<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000">
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top">
  
  
  <title>soar 启发规则汇总 &amp;&amp; 常见 MySQL 优化案例 | rovast</title>
  <meta name="description" content="摘自： https://github.com/XiaoMi/soar/blob/master/doc/heuristic.md 这是小米 soar 的默认启发规则汇总，也是 DBA 多年精华总结。熟读各个案例，对于一般的 MySQL 优化有很高的帮助。如果你不喜欢太理论的东西，或者没时间去深入，举一反三学习也未尝不可。   启发式规则建议建议使用 AS 关键字显示声明一个别名 Item:ALI.0">
<meta name="keywords" content="MySQL,soar">
<meta property="og:type" content="article">
<meta property="og:title" content="soar 启发规则汇总 &amp;&amp; 常见 MySQL 优化案例">
<meta property="og:url" content="https://rovast.github.io/2018/12/20/soar-heuristic-list/index.html">
<meta property="og:site_name" content="rovast">
<meta property="og:description" content="摘自： https://github.com/XiaoMi/soar/blob/master/doc/heuristic.md 这是小米 soar 的默认启发规则汇总，也是 DBA 多年精华总结。熟读各个案例，对于一般的 MySQL 优化有很高的帮助。如果你不喜欢太理论的东西，或者没时间去深入，举一反三学习也未尝不可。   启发式规则建议建议使用 AS 关键字显示声明一个别名 Item:ALI.0">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://rovast.github.io/2018/12/20/soar-heuristic-list/1.png">
<meta property="og:updated_time" content="2022-09-28T03:14:43.406Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="soar 启发规则汇总 &amp;&amp; 常见 MySQL 优化案例">
<meta name="twitter:description" content="摘自： https://github.com/XiaoMi/soar/blob/master/doc/heuristic.md 这是小米 soar 的默认启发规则汇总，也是 DBA 多年精华总结。熟读各个案例，对于一般的 MySQL 优化有很高的帮助。如果你不喜欢太理论的东西，或者没时间去深入，举一反三学习也未尝不可。   启发式规则建议建议使用 AS 关键字显示声明一个别名 Item:ALI.0">
<meta name="twitter:image" content="https://rovast.github.io/2018/12/20/soar-heuristic-list/1.png">
  <!-- Canonical links -->
  <link rel="canonical" href="https://rovast.github.io/2018/12/20/soar-heuristic-list/index.html">
  
    <link rel="alternate" href="/atom.xml" title="rovast" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.jpg" type="image/x-icon">
  
  <link rel="stylesheet" href="/css/style.css">
  
  
  
  
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.css">
  
</head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope="" itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/rovast" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">rovast</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">但行好事</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Nanjing, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索">
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech="">
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope="" itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/rovast" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope="" itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>Welcome to rovast's blog</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/WASM/">WASM</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/wiki/">wiki</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/云原生/">云原生</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/基础/">基础</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂项/">杂项</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/流程/">流程</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程/">编程</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/翻译/">翻译</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随想/">随想</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PHP/">PHP</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RFC/">RFC</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gnome/">gnome</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kill/">kill</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/laravel/">laravel</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/makefile/">makefile</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/">node</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/soar/">soar</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tinker/">tinker</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ubuntu/">ubuntu</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/">vue</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wiki/">wiki</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/云原生/">云原生</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/命令行/">命令行</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/截图/">截图</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/杂项/">杂项</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端/">移动端</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/管道/">管道</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/转载/">转载</a><span class="tag-list-count">4</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/Linux/" style="font-size: 14px;">Linux</a> <a href="/tags/MySQL/" style="font-size: 13.33px;">MySQL</a> <a href="/tags/PHP/" style="font-size: 13.67px;">PHP</a> <a href="/tags/RFC/" style="font-size: 13px;">RFC</a> <a href="/tags/docker/" style="font-size: 13.33px;">docker</a> <a href="/tags/git/" style="font-size: 13px;">git</a> <a href="/tags/gnome/" style="font-size: 13px;">gnome</a> <a href="/tags/kill/" style="font-size: 13px;">kill</a> <a href="/tags/laravel/" style="font-size: 13.33px;">laravel</a> <a href="/tags/linux/" style="font-size: 13px;">linux</a> <a href="/tags/makefile/" style="font-size: 13px;">makefile</a> <a href="/tags/nginx/" style="font-size: 13px;">nginx</a> <a href="/tags/node/" style="font-size: 13px;">node</a> <a href="/tags/php/" style="font-size: 13px;">php</a> <a href="/tags/soar/" style="font-size: 13.33px;">soar</a> <a href="/tags/tinker/" style="font-size: 13px;">tinker</a> <a href="/tags/ubuntu/" style="font-size: 13.33px;">ubuntu</a> <a href="/tags/vue/" style="font-size: 13px;">vue</a> <a href="/tags/wiki/" style="font-size: 13.33px;">wiki</a> <a href="/tags/云原生/" style="font-size: 13px;">云原生</a> <a href="/tags/命令行/" style="font-size: 13px;">命令行</a> <a href="/tags/截图/" style="font-size: 13px;">截图</a> <a href="/tags/数据结构与算法/" style="font-size: 13px;">数据结构与算法</a> <a href="/tags/杂项/" style="font-size: 13.33px;">杂项</a> <a href="/tags/移动端/" style="font-size: 13px;">移动端</a> <a href="/tags/管道/" style="font-size: 13px;">管道</a> <a href="/tags/设计模式/" style="font-size: 13px;">设计模式</a> <a href="/tags/转载/" style="font-size: 13.67px;">转载</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a><span class="archive-list-count">25</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2022/09/28/hello-world/" class="title">Hello World</a>
              </p>
              <p class="item-date">
                <time datetime="2022-09-28T03:14:43.390Z" itemprop="datePublished">2022-09-28</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2022/09/28/jia-ban/" class="title">(no title)</a>
              </p>
              <p class="item-date">
                <time datetime="2022-09-28T03:14:43.390Z" itemprop="datePublished">2022-09-28</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/WASM/">WASM</a>
              </p>
              <p class="item-title">
                <a href="/2022/09/28/wasmcloud-app-provider-read/" class="title">wasmcloud app provider 源码阅读</a>
              </p>
              <p class="item-date">
                <time datetime="2022-09-28T02:33:49.000Z" itemprop="datePublished">2022-09-28</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/WASM/">WASM</a>
              </p>
              <p class="item-title">
                <a href="/2022/09/23/wasmcloud-app-development/" class="title">wasmcloud app development</a>
              </p>
              <p class="item-date">
                <time datetime="2022-09-23T05:57:31.000Z" itemprop="datePublished">2022-09-23</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/WASM/">WASM</a>
              </p>
              <p class="item-title">
                <a href="/2022/09/19/wasmcloud-intro/" class="title">wasmcloud actor调度梳理</a>
              </p>
              <p class="item-date">
                <time datetime="2022-09-19T05:22:55.000Z" itemprop="datePublished">2022-09-19</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope="" itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#启发式规则建议"><span class="toc-number">1.</span> <span class="toc-text">启发式规则建议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#建议使用-AS-关键字显示声明一个别名"><span class="toc-number">1.1.</span> <span class="toc-text">建议使用 AS 关键字显示声明一个别名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不建议给列通配符’-‘设置别名"><span class="toc-number">1.2.</span> <span class="toc-text">不建议给列通配符’*‘设置别名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#别名不要与表或列的名字相同"><span class="toc-number">1.3.</span> <span class="toc-text">别名不要与表或列的名字相同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#修改表的默认字符集不会改表各个字段的字符集"><span class="toc-number">1.4.</span> <span class="toc-text">修改表的默认字符集不会改表各个字段的字符集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#同一张表的多条-ALTER-请求建议合为一条"><span class="toc-number">1.5.</span> <span class="toc-text">同一张表的多条 ALTER 请求建议合为一条</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#删除列为高危操作，操作前请注意检查业务逻辑是否还有依赖"><span class="toc-number">1.6.</span> <span class="toc-text">删除列为高危操作，操作前请注意检查业务逻辑是否还有依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#删除主键和外键为高危操作，操作前请与-DBA-确认影响"><span class="toc-number">1.7.</span> <span class="toc-text">删除主键和外键为高危操作，操作前请与 DBA 确认影响</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不建议使用前项通配符查找"><span class="toc-number">1.8.</span> <span class="toc-text">不建议使用前项通配符查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#没有通配符的-LIKE-查询"><span class="toc-number">1.9.</span> <span class="toc-text">没有通配符的 LIKE 查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参数比较包含隐式转换，无法使用索引"><span class="toc-number">1.10.</span> <span class="toc-text">参数比较包含隐式转换，无法使用索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IN-NULL-NOT-IN-NULL-永远非真"><span class="toc-number">1.11.</span> <span class="toc-text">IN (NULL)/NOT IN (NULL) 永远非真</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IN-要慎用，元素过多会导致全表扫描"><span class="toc-number">1.12.</span> <span class="toc-text">IN 要慎用，元素过多会导致全表扫描</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应尽量避免在-WHERE-子句中对字段进行-NULL-值判断"><span class="toc-number">1.13.</span> <span class="toc-text">应尽量避免在 WHERE 子句中对字段进行 NULL 值判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#避免使用模式匹配"><span class="toc-number">1.14.</span> <span class="toc-text">避免使用模式匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OR-查询索引列时请尽量使用-IN-谓词"><span class="toc-number">1.15.</span> <span class="toc-text">OR 查询索引列时请尽量使用 IN 谓词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#引号中的字符串开头或结尾包含空格"><span class="toc-number">1.16.</span> <span class="toc-text">引号中的字符串开头或结尾包含空格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不要使用-hint，如：sql-no-cache-force-index-ignore-key-straight-join等"><span class="toc-number">1.17.</span> <span class="toc-text">不要使用 hint，如：sql_no_cache, force index, ignore key, straight join等</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不要使用负向查询，如：NOT-IN-NOT-LIKE"><span class="toc-number">1.18.</span> <span class="toc-text">不要使用负向查询，如：NOT IN/NOT LIKE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一次性-INSERT-REPLACE-的数据过多"><span class="toc-number">1.19.</span> <span class="toc-text">一次性 INSERT/REPLACE 的数据过多</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最外层-SELECT-未指定-WHERE-条件"><span class="toc-number">1.20.</span> <span class="toc-text">最外层 SELECT 未指定 WHERE 条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不建议使用-ORDER-BY-RAND"><span class="toc-number">1.21.</span> <span class="toc-text">不建议使用 ORDER BY RAND()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不建议使用带-OFFSET-的LIMIT-查询"><span class="toc-number">1.22.</span> <span class="toc-text">不建议使用带 OFFSET 的LIMIT 查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不建议对常量进行-GROUP-BY"><span class="toc-number">1.23.</span> <span class="toc-text">不建议对常量进行 GROUP BY</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ORDER-BY-常数列没有任何意义"><span class="toc-number">1.24.</span> <span class="toc-text">ORDER BY 常数列没有任何意义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在不同的表中-GROUP-BY-或-ORDER-BY"><span class="toc-number">1.25.</span> <span class="toc-text">在不同的表中 GROUP BY 或 ORDER BY</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ORDER-BY-语句对多个不同条件使用不同方向的排序无法使用索引"><span class="toc-number">1.26.</span> <span class="toc-text">ORDER BY 语句对多个不同条件使用不同方向的排序无法使用索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#请为-GROUP-BY-显示添加-ORDER-BY-条件"><span class="toc-number">1.27.</span> <span class="toc-text">请为 GROUP BY 显示添加 ORDER BY 条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ORDER-BY-的条件为表达式"><span class="toc-number">1.28.</span> <span class="toc-text">ORDER BY 的条件为表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GROUP-BY-的条件为表达式"><span class="toc-number">1.29.</span> <span class="toc-text">GROUP BY 的条件为表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#建议为表添加注释"><span class="toc-number">1.30.</span> <span class="toc-text">建议为表添加注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#将复杂的裹脚布式查询分解成几个简单的查询"><span class="toc-number">1.31.</span> <span class="toc-text">将复杂的裹脚布式查询分解成几个简单的查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不建议使用-HAVING-子句"><span class="toc-number">1.32.</span> <span class="toc-text">不建议使用 HAVING 子句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#删除全表时建议使用-TRUNCATE-替代-DELETE"><span class="toc-number">1.33.</span> <span class="toc-text">删除全表时建议使用 TRUNCATE 替代 DELETE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UPDATE-未指定-WHERE-条件"><span class="toc-number">1.34.</span> <span class="toc-text">UPDATE 未指定 WHERE 条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不要-UPDATE-主键"><span class="toc-number">1.35.</span> <span class="toc-text">不要 UPDATE 主键</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不建议使用-SELECT-类型查询"><span class="toc-number">1.36.</span> <span class="toc-text">不建议使用 SELECT * 类型查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#INSERT-REPLACE-未指定列名"><span class="toc-number">1.37.</span> <span class="toc-text">INSERT/REPLACE 未指定列名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#建议修改自增-ID-为无符号类型"><span class="toc-number">1.38.</span> <span class="toc-text">建议修改自增 ID 为无符号类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#请为列添加默认值"><span class="toc-number">1.39.</span> <span class="toc-text">请为列添加默认值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#列未添加注释"><span class="toc-number">1.40.</span> <span class="toc-text">列未添加注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#表中包含有太多的列"><span class="toc-number">1.41.</span> <span class="toc-text">表中包含有太多的列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可使用-VARCHAR-代替-CHAR，-VARBINARY-代替-BINARY"><span class="toc-number">1.42.</span> <span class="toc-text">可使用 VARCHAR 代替 CHAR， VARBINARY 代替 BINARY</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#建议使用精确的数据类型"><span class="toc-number">1.43.</span> <span class="toc-text">建议使用精确的数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不建议使用-ENUM-数据类型"><span class="toc-number">1.44.</span> <span class="toc-text">不建议使用 ENUM 数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#当需要唯一约束时才使用-NULL，仅当列不能有缺失值时才使用-NOT-NULL"><span class="toc-number">1.45.</span> <span class="toc-text">当需要唯一约束时才使用 NULL，仅当列不能有缺失值时才使用 NOT NULL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BLOB-和-TEXT-类型的字段不可设置为-NULL"><span class="toc-number">1.46.</span> <span class="toc-text">BLOB 和 TEXT 类型的字段不可设置为 NULL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TIMESTAMP-类型未设置默认值"><span class="toc-number">1.47.</span> <span class="toc-text">TIMESTAMP 类型未设置默认值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为列指定了字符集"><span class="toc-number">1.48.</span> <span class="toc-text">为列指定了字符集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BLOB-类型的字段不可指定默认值"><span class="toc-number">1.49.</span> <span class="toc-text">BLOB 类型的字段不可指定默认值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#整型定义建议采用-INT-10-或-BIGINT-20"><span class="toc-number">1.50.</span> <span class="toc-text">整型定义建议采用 INT(10) 或 BIGINT(20)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VARCHAR-定义长度过长"><span class="toc-number">1.51.</span> <span class="toc-text">VARCHAR 定义长度过长</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#消除不必要的-DISTINCT-条件"><span class="toc-number">1.52.</span> <span class="toc-text">消除不必要的 DISTINCT 条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#COUNT-DISTINCT-多列时结果可能和你预想的不同"><span class="toc-number">1.53.</span> <span class="toc-text">COUNT(DISTINCT) 多列时结果可能和你预想的不同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DISTINCT-对有主键的表没有意义"><span class="toc-number">1.54.</span> <span class="toc-text">DISTINCT * 对有主键的表没有意义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#避免在-WHERE-条件中使用函数或其他运算符"><span class="toc-number">1.55.</span> <span class="toc-text">避免在 WHERE 条件中使用函数或其他运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指定了-WHERE-条件或非-MyISAM-引擎时使用-COUNT-操作性能不佳"><span class="toc-number">1.56.</span> <span class="toc-text">指定了 WHERE 条件或非 MyISAM 引擎时使用 COUNT(*) 操作性能不佳</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用了合并为可空列的字符串连接"><span class="toc-number">1.57.</span> <span class="toc-text">使用了合并为可空列的字符串连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不建议使用-SYSDATE-函数"><span class="toc-number">1.58.</span> <span class="toc-text">不建议使用 SYSDATE() 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不建议使用-COUNT-col-或-COUNT-常量"><span class="toc-number">1.59.</span> <span class="toc-text">不建议使用 COUNT(col) 或 COUNT(常量)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-SUM-COL-时需注意-NPE-问题"><span class="toc-number">1.60.</span> <span class="toc-text">使用 SUM(COL) 时需注意 NPE 问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不建议使用触发器"><span class="toc-number">1.61.</span> <span class="toc-text">不建议使用触发器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不建议使用存储过程"><span class="toc-number">1.62.</span> <span class="toc-text">不建议使用存储过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不建议使用自定义函数"><span class="toc-number">1.63.</span> <span class="toc-text">不建议使用自定义函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不建议对等值查询列使用-GROUP-BY"><span class="toc-number">1.64.</span> <span class="toc-text">不建议对等值查询列使用 GROUP BY</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JOIN-语句混用逗号和-ANSI-模式"><span class="toc-number">1.65.</span> <span class="toc-text">JOIN 语句混用逗号和 ANSI 模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#同一张表被连接两次"><span class="toc-number">1.66.</span> <span class="toc-text">同一张表被连接两次</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OUTER-JOIN-失效"><span class="toc-number">1.67.</span> <span class="toc-text">OUTER JOIN 失效</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不建议使用排它-JOIN"><span class="toc-number">1.68.</span> <span class="toc-text">不建议使用排它 JOIN</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#减少-JOIN-的数量"><span class="toc-number">1.69.</span> <span class="toc-text">减少 JOIN 的数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#将嵌套查询重写为-JOIN-通常会导致更高效的执行和更有效的优化"><span class="toc-number">1.70.</span> <span class="toc-text">将嵌套查询重写为 JOIN 通常会导致更高效的执行和更有效的优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不建议使用联表删除或更新"><span class="toc-number">1.71.</span> <span class="toc-text">不建议使用联表删除或更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不要使用跨数据库的-JOIN-查询"><span class="toc-number">1.72.</span> <span class="toc-text">不要使用跨数据库的 JOIN 查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#建议使用自增列作为主键，如使用联合自增主键时请将自增键作为第一列"><span class="toc-number">1.73.</span> <span class="toc-text">建议使用自增列作为主键，如使用联合自增主键时请将自增键作为第一列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#无主键或唯一键，无法在线变更表结构"><span class="toc-number">1.74.</span> <span class="toc-text">无主键或唯一键，无法在线变更表结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#避免外键等递归关系"><span class="toc-number">1.75.</span> <span class="toc-text">避免外键等递归关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#提醒：请将索引属性顺序与查询对齐"><span class="toc-number">1.76.</span> <span class="toc-text">提醒：请将索引属性顺序与查询对齐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#表建的索引过多"><span class="toc-number">1.77.</span> <span class="toc-text">表建的索引过多</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#主键中的列过多"><span class="toc-number">1.78.</span> <span class="toc-text">主键中的列过多</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#未指定主键或主键非-bigint"><span class="toc-number">1.79.</span> <span class="toc-text">未指定主键或主键非 bigint</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ORDER-BY-多个列但排序方向不同时可能无法使用索引"><span class="toc-number">1.80.</span> <span class="toc-text">ORDER BY 多个列但排序方向不同时可能无法使用索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#添加唯一索引前请注意检查数据唯一性"><span class="toc-number">1.81.</span> <span class="toc-text">添加唯一索引前请注意检查数据唯一性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#全文索引不是银弹"><span class="toc-number">1.82.</span> <span class="toc-text">全文索引不是银弹</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL-CALC-FOUND-ROWS-效率低下"><span class="toc-number">1.83.</span> <span class="toc-text">SQL_CALC_FOUND_ROWS 效率低下</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不建议使用-MySQL-关键字做列名或表名"><span class="toc-number">1.84.</span> <span class="toc-text">不建议使用 MySQL 关键字做列名或表名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不建议使用复数做列名或表名"><span class="toc-number">1.85.</span> <span class="toc-text">不建议使用复数做列名或表名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不建议使用使用多字节编码字符-中文-命名"><span class="toc-number">1.86.</span> <span class="toc-text">不建议使用使用多字节编码字符(中文)命名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#INSERT-INTO-xx-SELECT-加锁粒度较大请谨慎"><span class="toc-number">1.87.</span> <span class="toc-text">INSERT INTO xx SELECT 加锁粒度较大请谨慎</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#请慎用-INSERT-ON-DUPLICATE-KEY-UPDATE"><span class="toc-number">1.88.</span> <span class="toc-text">请慎用 INSERT ON DUPLICATE KEY UPDATE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用字符类型存储IP地址"><span class="toc-number">1.89.</span> <span class="toc-text">用字符类型存储IP地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#日期-时间未使用引号括起"><span class="toc-number">1.90.</span> <span class="toc-text">日期/时间未使用引号括起</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一列中存储一系列相关数据的集合"><span class="toc-number">1.91.</span> <span class="toc-text">一列中存储一系列相关数据的集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#请使用分号或已设定的-DELIMITER-结尾"><span class="toc-number">1.92.</span> <span class="toc-text">请使用分号或已设定的 DELIMITER 结尾</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#非确定性的-GROUP-BY"><span class="toc-number">1.93.</span> <span class="toc-text">非确定性的 GROUP BY</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#未使用-ORDER-BY-的-LIMIT-查询"><span class="toc-number">1.94.</span> <span class="toc-text">未使用 ORDER BY 的 LIMIT 查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UPDATE-DELETE-操作使用了-LIMIT-条件"><span class="toc-number">1.95.</span> <span class="toc-text">UPDATE/DELETE 操作使用了 LIMIT 条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UPDATE-DELETE-操作指定了-ORDER-BY-条件"><span class="toc-number">1.96.</span> <span class="toc-text">UPDATE/DELETE 操作指定了 ORDER BY 条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UPDATE-语句可能存在逻辑错误，导致数据损坏"><span class="toc-number">1.97.</span> <span class="toc-text">UPDATE 语句可能存在逻辑错误，导致数据损坏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#永远不真的比较条件"><span class="toc-number">1.98.</span> <span class="toc-text">永远不真的比较条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#永远为真的比较条件"><span class="toc-number">1.99.</span> <span class="toc-text">永远为真的比较条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不建议使用LOAD-DATA-SELECT-…-INTO-OUTFILE"><span class="toc-number">1.100.</span> <span class="toc-text">不建议使用LOAD DATA/SELECT … INTO OUTFILE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#请谨慎使用TRUNCATE操作"><span class="toc-number">1.101.</span> <span class="toc-text">请谨慎使用TRUNCATE操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不使用明文存储密码"><span class="toc-number">1.102.</span> <span class="toc-text">不使用明文存储密码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用DELETE-DROP-TRUNCATE等操作时注意备份"><span class="toc-number">1.103.</span> <span class="toc-text">使用DELETE/DROP/TRUNCATE等操作时注意备份</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#建议使用-datetime-替换-timestamp-类型"><span class="toc-number">1.104.</span> <span class="toc-text">建议使用 datetime 替换 timestamp 类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#缺少数据库必须字段-last-update-time-和-is-del"><span class="toc-number">1.105.</span> <span class="toc-text">缺少数据库必须字段 last_update_time 和 is_del</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#last-update-time-和-is-del-类型不对"><span class="toc-number">1.106.</span> <span class="toc-text">last_update_time 和 is_del 类型不对</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不建议使用大字段-TEXT-BLOB"><span class="toc-number">1.107.</span> <span class="toc-text">不建议使用大字段 TEXT BLOB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#整形建议使用-unsigned"><span class="toc-number">1.108.</span> <span class="toc-text">整形建议使用 unsigned</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#‘-’-运算符是非标准的"><span class="toc-number">1.109.</span> <span class="toc-text">‘!=’ 运算符是非标准的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#库名或表名点后建议不要加空格"><span class="toc-number">1.110.</span> <span class="toc-text">库名或表名点后建议不要加空格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#索引起名不规范"><span class="toc-number">1.111.</span> <span class="toc-text">索引起名不规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#起名时请不要使用字母、数字和下划线之外的字符"><span class="toc-number">1.112.</span> <span class="toc-text">起名时请不要使用字母、数字和下划线之外的字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-对子查询的优化效果不佳"><span class="toc-number">1.113.</span> <span class="toc-text">MySQL 对子查询的优化效果不佳</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如果您不在乎重复的话，建议使用-UNION-ALL-替代-UNION"><span class="toc-number">1.114.</span> <span class="toc-text">如果您不在乎重复的话，建议使用 UNION ALL 替代 UNION</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#考虑使用-EXISTS-而不是-DISTINCT-子查询"><span class="toc-number">1.115.</span> <span class="toc-text">考虑使用 EXISTS 而不是 DISTINCT 子查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#执行计划中嵌套连接深度过深"><span class="toc-number">1.116.</span> <span class="toc-text">执行计划中嵌套连接深度过深</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#子查询不支持LIMIT"><span class="toc-number">1.117.</span> <span class="toc-text">子查询不支持LIMIT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不建议在子查询中使用函数"><span class="toc-number">1.118.</span> <span class="toc-text">不建议在子查询中使用函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不建议使用分区表"><span class="toc-number">1.119.</span> <span class="toc-text">不建议使用分区表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#请为表选择合适的存储引擎"><span class="toc-number">1.120.</span> <span class="toc-text">请为表选择合适的存储引擎</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#以DUAL命名的表在数据库中有特殊含义"><span class="toc-number">1.121.</span> <span class="toc-text">以DUAL命名的表在数据库中有特殊含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#表的初始AUTO-INCREMENT值不为0"><span class="toc-number">1.122.</span> <span class="toc-text">表的初始AUTO_INCREMENT值不为0</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#请使用推荐的字符集"><span class="toc-number">1.123.</span> <span class="toc-text">请使用推荐的字符集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不建议使用视图"><span class="toc-number">1.124.</span> <span class="toc-text">不建议使用视图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不建议使用临时表"><span class="toc-number">1.125.</span> <span class="toc-text">不建议使用临时表</span></a></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-soar-heuristic-list" class="article article-type-post" itemscope="" itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      soar 启发规则汇总 &amp;&amp; 常见 MySQL 优化案例
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2018/12/20/soar-heuristic-list/" class="article-date">
	  <time datetime="2018-12-20T15:43:49.000Z" itemprop="datePublished">2018-12-20</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/MySQL/">MySQL</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/MySQL/">MySQL</a>, <a class="article-tag-link" href="/tags/soar/">soar</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


	<span class="article-read hidden-xs">
    	<i class="icon icon-eye-fill" aria-hidden="true"></i>
    	<span id="/2018/12/20/soar-heuristic-list/" class="leancloud_visitors" data-flag-title="soar 启发规则汇总 &amp;&amp; 常见 MySQL 优化案例">0</span>
    </span>

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2018/12/20/soar-heuristic-list/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 10.9k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 45(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <p>摘自： <a href="https://github.com/XiaoMi/soar/blob/master/doc/heuristic.md" target="_blank" rel="noopener">https://github.com/XiaoMi/soar/blob/master/doc/heuristic.md</a></p>
<p>这是小米 soar 的默认启发规则汇总，也是 DBA 多年精华总结。熟读各个案例，对于一般的 MySQL 优化有很高的帮助。<br>如果你不喜欢太理论的东西，或者没时间去深入，举一反三学习也未尝不可。</p>
<img src="/2018/12/20/soar-heuristic-list/1.png" title="soar运行流程">
<hr>
<h1 id="启发式规则建议"><a href="#启发式规则建议" class="headerlink" title="启发式规则建议"></a>启发式规则建议</h1><h2 id="建议使用-AS-关键字显示声明一个别名"><a href="#建议使用-AS-关键字显示声明一个别名" class="headerlink" title="建议使用 AS 关键字显示声明一个别名"></a>建议使用 AS 关键字显示声明一个别名</h2><ul>
<li><strong>Item</strong>:ALI.001</li>
<li><strong>Severity</strong>:L0</li>
<li><strong>Content</strong>:在列或表别名(如”tbl AS alias”)中, 明确使用 AS 关键字比隐含别名(如”tbl alias”)更易懂。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> tbl t1 <span class="keyword">where</span> <span class="keyword">id</span> &lt; <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<h2 id="不建议给列通配符’-‘设置别名"><a href="#不建议给列通配符’-‘设置别名" class="headerlink" title="不建议给列通配符’*‘设置别名"></a>不建议给列通配符’*‘设置别名</h2><ul>
<li><strong>Item</strong>:ALI.002</li>
<li><strong>Severity</strong>:L8</li>
<li><strong>Content</strong>:例: “SELECT tbl.* col1, col2”上面这条 SQL 给列通配符设置了别名，这样的SQL可能存在逻辑错误。您可能意在查询 col1, 但是代替它的是重命名的是 tbl 的最后一列。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> tbl.* <span class="keyword">as</span> c1,c2,c3 <span class="keyword">from</span> tbl <span class="keyword">where</span> <span class="keyword">id</span> &lt; <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<h2 id="别名不要与表或列的名字相同"><a href="#别名不要与表或列的名字相同" class="headerlink" title="别名不要与表或列的名字相同"></a>别名不要与表或列的名字相同</h2><ul>
<li><strong>Item</strong>:ALI.003</li>
<li><strong>Severity</strong>:L1</li>
<li><strong>Content</strong>:表或列的别名与其真实名称相同, 这样的别名会使得查询更难去分辨。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> tbl <span class="keyword">as</span> tbl <span class="keyword">where</span> <span class="keyword">id</span> &lt; <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<h2 id="修改表的默认字符集不会改表各个字段的字符集"><a href="#修改表的默认字符集不会改表各个字段的字符集" class="headerlink" title="修改表的默认字符集不会改表各个字段的字符集"></a>修改表的默认字符集不会改表各个字段的字符集</h2><ul>
<li><strong>Item</strong>:ALT.001</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:很多初学者会将 ALTER TABLE tbl_name [DEFAULT] CHARACTER SET ‘UTF8’ 误认为会修改所有字段的字符集，但实际上它只会影响后续新增的字段不会改表已有字段的字符集。如果想修改整张表所有字段的字符集建议使用 ALTER TABLE tbl_name CONVERT TO CHARACTER SET charset_name;</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">CONVERT</span> <span class="keyword">TO</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> charset_name;</span><br></pre></td></tr></table></figure>
<h2 id="同一张表的多条-ALTER-请求建议合为一条"><a href="#同一张表的多条-ALTER-请求建议合为一条" class="headerlink" title="同一张表的多条 ALTER 请求建议合为一条"></a>同一张表的多条 ALTER 请求建议合为一条</h2><ul>
<li><strong>Item</strong>:ALT.002</li>
<li><strong>Severity</strong>:L2</li>
<li><strong>Content</strong>:每次表结构变更对线上服务都会产生影响，即使是能够通过在线工具进行调整也请尽量通过合并 ALTER 请求的试减少操作次数。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> <span class="keyword">col</span> <span class="built_in">int</span>, <span class="keyword">ADD</span> <span class="keyword">INDEX</span> idx_col (<span class="string">`col`</span>);</span><br></pre></td></tr></table></figure>
<h2 id="删除列为高危操作，操作前请注意检查业务逻辑是否还有依赖"><a href="#删除列为高危操作，操作前请注意检查业务逻辑是否还有依赖" class="headerlink" title="删除列为高危操作，操作前请注意检查业务逻辑是否还有依赖"></a>删除列为高危操作，操作前请注意检查业务逻辑是否还有依赖</h2><ul>
<li><strong>Item</strong>:ALT.003</li>
<li><strong>Severity</strong>:L0</li>
<li><strong>Content</strong>:如业务逻辑依赖未完全消除，列被删除后可能导致数据无法写入或无法查询到已删除列数据导致程序异常的情况。这种情况下即使通过备份数据回滚也会丢失用户请求写入的数据。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> <span class="keyword">col</span>;</span><br></pre></td></tr></table></figure>
<h2 id="删除主键和外键为高危操作，操作前请与-DBA-确认影响"><a href="#删除主键和外键为高危操作，操作前请与-DBA-确认影响" class="headerlink" title="删除主键和外键为高危操作，操作前请与 DBA 确认影响"></a>删除主键和外键为高危操作，操作前请与 DBA 确认影响</h2><ul>
<li><strong>Item</strong>:ALT.004</li>
<li><strong>Severity</strong>:L0</li>
<li><strong>Content</strong>:主键和外键为关系型数据库中两种重要约束，删除已有约束会打破已有业务逻辑，操作前请业务开发与 DBA 确认影响，三思而行。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl <span class="keyword">DROP</span> PRIMARY <span class="keyword">KEY</span>;</span><br></pre></td></tr></table></figure>
<h2 id="不建议使用前项通配符查找"><a href="#不建议使用前项通配符查找" class="headerlink" title="不建议使用前项通配符查找"></a>不建议使用前项通配符查找</h2><ul>
<li><strong>Item</strong>:ARG.001</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:例如 “％foo”，查询参数有一个前项通配符的情况无法使用已有索引。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c1,c2,c3 <span class="keyword">from</span> tbl <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%foo'</span></span><br></pre></td></tr></table></figure>
<h2 id="没有通配符的-LIKE-查询"><a href="#没有通配符的-LIKE-查询" class="headerlink" title="没有通配符的 LIKE 查询"></a>没有通配符的 LIKE 查询</h2><ul>
<li><strong>Item</strong>:ARG.002</li>
<li><strong>Severity</strong>:L1</li>
<li><strong>Content</strong>:不包含通配符的 LIKE 查询可能存在逻辑错误，因为逻辑上它与等值查询相同。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c1,c2,c3 <span class="keyword">from</span> tbl <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'foo'</span></span><br></pre></td></tr></table></figure>
<h2 id="参数比较包含隐式转换，无法使用索引"><a href="#参数比较包含隐式转换，无法使用索引" class="headerlink" title="参数比较包含隐式转换，无法使用索引"></a>参数比较包含隐式转换，无法使用索引</h2><ul>
<li><strong>Item</strong>:ARG.003</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:隐式类型转换有无法命中索引的风险，在高并发、大数据量的情况下，命不中索引带来的后果非常严重。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> sakila.film <span class="keyword">WHERE</span> <span class="keyword">length</span> &gt;= <span class="string">'60'</span>;</span><br></pre></td></tr></table></figure>
<h2 id="IN-NULL-NOT-IN-NULL-永远非真"><a href="#IN-NULL-NOT-IN-NULL-永远非真" class="headerlink" title="IN (NULL)/NOT IN (NULL) 永远非真"></a>IN (NULL)/NOT IN (NULL) 永远非真</h2><ul>
<li><strong>Item</strong>:ARG.004</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:正确的作法是 col IN (‘val1’, ‘val2’, ‘val3’) OR col IS NULL</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tb <span class="keyword">WHERE</span> <span class="keyword">col</span> <span class="keyword">IN</span> (<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<h2 id="IN-要慎用，元素过多会导致全表扫描"><a href="#IN-要慎用，元素过多会导致全表扫描" class="headerlink" title="IN 要慎用，元素过多会导致全表扫描"></a>IN 要慎用，元素过多会导致全表扫描</h2><ul>
<li><strong>Item</strong>:ARG.005</li>
<li><strong>Severity</strong>:L1</li>
<li><strong>Content</strong>: 如：select id from t where num in(1,2,3)对于连续的数值，能用 BETWEEN 就不要用 IN 了：select id from t where num between 1 and 3。而当 IN 值过多时 MySQL 也可能会进入全表扫描导致性能急剧下降。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h2 id="应尽量避免在-WHERE-子句中对字段进行-NULL-值判断"><a href="#应尽量避免在-WHERE-子句中对字段进行-NULL-值判断" class="headerlink" title="应尽量避免在 WHERE 子句中对字段进行 NULL 值判断"></a>应尽量避免在 WHERE 子句中对字段进行 NULL 值判断</h2><ul>
<li><strong>Item</strong>:ARG.006</li>
<li><strong>Severity</strong>:L1</li>
<li><strong>Content</strong>:使用 IS NULL 或 IS NOT NULL 将可能导致引擎放弃使用索引而进行全表扫描，如：select id from t where num is null;可以在num上设置默认值0，确保表中 num 列没有 NULL 值，然后这样查询： select id from t where num=0;</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">is</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<h2 id="避免使用模式匹配"><a href="#避免使用模式匹配" class="headerlink" title="避免使用模式匹配"></a>避免使用模式匹配</h2><ul>
<li><strong>Item</strong>:ARG.007</li>
<li><strong>Severity</strong>:L3</li>
<li><strong>Content</strong>:性能问题是使用模式匹配操作符的最大缺点。使用 LIKE 或正则表达式进行模式匹配进行查询的另一个问题，是可能会返回意料之外的结果。最好的方案就是使用特殊的搜索引擎技术来替代 SQL，比如 Apache Lucene。另一个可选方案是将结果保存起来从而减少重复的搜索开销。如果一定要使用SQL，请考虑在 MySQL 中使用像 FULLTEXT 索引这样的第三方扩展。但更广泛地说，您不一定要使用SQL来解决所有问题。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c_id,c2,c3 <span class="keyword">from</span> tbl <span class="keyword">where</span> c2 <span class="keyword">like</span> <span class="string">'test%'</span></span><br></pre></td></tr></table></figure>
<h2 id="OR-查询索引列时请尽量使用-IN-谓词"><a href="#OR-查询索引列时请尽量使用-IN-谓词" class="headerlink" title="OR 查询索引列时请尽量使用 IN 谓词"></a>OR 查询索引列时请尽量使用 IN 谓词</h2><ul>
<li><strong>Item</strong>:ARG.008</li>
<li><strong>Severity</strong>:L1</li>
<li><strong>Content</strong>:IN-list 谓词可以用于索引检索，并且优化器可以对 IN-list 进行排序，以匹配索引的排序序列，从而获得更有效的检索。请注意，IN-list 必须只包含常量，或在查询块执行期间保持常量的值，例如外引用。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c1,c2,c3 <span class="keyword">FROM</span> tbl <span class="keyword">WHERE</span> c1 = <span class="number">14</span> <span class="keyword">OR</span> c1 = <span class="number">17</span></span><br></pre></td></tr></table></figure>
<h2 id="引号中的字符串开头或结尾包含空格"><a href="#引号中的字符串开头或结尾包含空格" class="headerlink" title="引号中的字符串开头或结尾包含空格"></a>引号中的字符串开头或结尾包含空格</h2><ul>
<li><strong>Item</strong>:ARG.009</li>
<li><strong>Severity</strong>:L1</li>
<li><strong>Content</strong>:如果 VARCHAR 列的前后存在空格将可能引起逻辑问题，如在 MySQL 5.5中 ‘a’ 和 ‘a ‘ 可能会在查询中被认为是相同的值。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">'abc '</span></span><br></pre></td></tr></table></figure>
<h2 id="不要使用-hint，如：sql-no-cache-force-index-ignore-key-straight-join等"><a href="#不要使用-hint，如：sql-no-cache-force-index-ignore-key-straight-join等" class="headerlink" title="不要使用 hint，如：sql_no_cache, force index, ignore key, straight join等"></a>不要使用 hint，如：sql_no_cache, force index, ignore key, straight join等</h2><ul>
<li><strong>Item</strong>:ARG.010</li>
<li><strong>Severity</strong>:L1</li>
<li><strong>Content</strong>:hint 是用来强制 SQL 按照某个执行计划来执行，但随着数据量变化我们无法保证自己当初的预判是正确的。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">USE</span> <span class="keyword">INDEX</span> (i1) <span class="keyword">ORDER</span> <span class="keyword">BY</span> a;</span><br></pre></td></tr></table></figure>
<h2 id="不要使用负向查询，如：NOT-IN-NOT-LIKE"><a href="#不要使用负向查询，如：NOT-IN-NOT-LIKE" class="headerlink" title="不要使用负向查询，如：NOT IN/NOT LIKE"></a>不要使用负向查询，如：NOT IN/NOT LIKE</h2><ul>
<li><strong>Item</strong>:ARG.011</li>
<li><strong>Severity</strong>:L3</li>
<li><strong>Content</strong>:请尽量不要使用负向查询，这将导致全表扫描，对查询性能影响较大。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">not</span> <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h2 id="一次性-INSERT-REPLACE-的数据过多"><a href="#一次性-INSERT-REPLACE-的数据过多" class="headerlink" title="一次性 INSERT/REPLACE 的数据过多"></a>一次性 INSERT/REPLACE 的数据过多</h2><ul>
<li><strong>Item</strong>:ARG.012</li>
<li><strong>Severity</strong>:L2</li>
<li><strong>Content</strong>:单条 INSERT/REPLACE 语句批量插入大量数据性能较差，甚至可能导致从库同步延迟。为了提升性能，减少批量写入数据对从库同步延时的影响，建议采用分批次插入的方法。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb (a) <span class="keyword">VALUES</span> (<span class="number">1</span>), (<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h2 id="最外层-SELECT-未指定-WHERE-条件"><a href="#最外层-SELECT-未指定-WHERE-条件" class="headerlink" title="最外层 SELECT 未指定 WHERE 条件"></a>最外层 SELECT 未指定 WHERE 条件</h2><ul>
<li><strong>Item</strong>:CLA.001</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:SELECT 语句没有 WHERE 子句，可能检查比预期更多的行(全表扫描)。对于 SELECT COUNT(*) 类型的请求如果不要求精度，建议使用 SHOW TABLE STATUS 或 EXPLAIN 替代。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> tbl</span><br></pre></td></tr></table></figure>
<h2 id="不建议使用-ORDER-BY-RAND"><a href="#不建议使用-ORDER-BY-RAND" class="headerlink" title="不建议使用 ORDER BY RAND()"></a>不建议使用 ORDER BY RAND()</h2><ul>
<li><strong>Item</strong>:CLA.002</li>
<li><strong>Severity</strong>:L3</li>
<li><strong>Content</strong>:ORDER BY RAND() 是从结果集中检索随机行的一种非常低效的方法，因为它会对整个结果进行排序并丢弃其大部分数据。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> <span class="keyword">id</span> &lt; <span class="number">1000</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">rand</span>(<span class="built_in">number</span>)</span><br></pre></td></tr></table></figure>
<h2 id="不建议使用带-OFFSET-的LIMIT-查询"><a href="#不建议使用带-OFFSET-的LIMIT-查询" class="headerlink" title="不建议使用带 OFFSET 的LIMIT 查询"></a>不建议使用带 OFFSET 的LIMIT 查询</h2><ul>
<li><strong>Item</strong>:CLA.003</li>
<li><strong>Severity</strong>:L2</li>
<li><strong>Content</strong>:使用 LIMIT 和 OFFSET 对结果集分页的复杂度是 O(n^2)，并且会随着数据增大而导致性能问题。采用“书签”扫描的方法实现分页效率更高。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c1,c2 <span class="keyword">from</span> tbl <span class="keyword">where</span> <span class="keyword">name</span>=xx <span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">number</span> <span class="keyword">limit</span> <span class="number">1</span> <span class="keyword">offset</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>
<h2 id="不建议对常量进行-GROUP-BY"><a href="#不建议对常量进行-GROUP-BY" class="headerlink" title="不建议对常量进行 GROUP BY"></a>不建议对常量进行 GROUP BY</h2><ul>
<li><strong>Item</strong>:CLA.004</li>
<li><strong>Severity</strong>:L2</li>
<li><strong>Content</strong>:GROUP BY 1 表示按第一列进行 GROUP BY。如果在 GROUP BY 子句中使用数字，而不是表达式或列名称，当查询列顺序改变时，可能会导致问题。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col1,col2 <span class="keyword">from</span> tbl <span class="keyword">group</span> <span class="keyword">by</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="ORDER-BY-常数列没有任何意义"><a href="#ORDER-BY-常数列没有任何意义" class="headerlink" title="ORDER BY 常数列没有任何意义"></a>ORDER BY 常数列没有任何意义</h2><ul>
<li><strong>Item</strong>:CLA.005</li>
<li><strong>Severity</strong>:L2</li>
<li><strong>Content</strong>:SQL 逻辑上可能存在错误; 最多只是一个无用的操作，不会更改查询结果。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span></span><br></pre></td></tr></table></figure>
<h2 id="在不同的表中-GROUP-BY-或-ORDER-BY"><a href="#在不同的表中-GROUP-BY-或-ORDER-BY" class="headerlink" title="在不同的表中 GROUP BY 或 ORDER BY"></a>在不同的表中 GROUP BY 或 ORDER BY</h2><ul>
<li><strong>Item</strong>:CLA.006</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:这将强制使用临时表和 filesort，可能产生巨大性能隐患，并且可能消耗大量内存和磁盘上的临时空间。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> tb1.col, tb2.col <span class="keyword">from</span> tb1, tb2 <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">group</span> <span class="keyword">by</span> tb1.col, tb2.col</span><br></pre></td></tr></table></figure>
<h2 id="ORDER-BY-语句对多个不同条件使用不同方向的排序无法使用索引"><a href="#ORDER-BY-语句对多个不同条件使用不同方向的排序无法使用索引" class="headerlink" title="ORDER BY 语句对多个不同条件使用不同方向的排序无法使用索引"></a>ORDER BY 语句对多个不同条件使用不同方向的排序无法使用索引</h2><ul>
<li><strong>Item</strong>:CLA.007</li>
<li><strong>Severity</strong>:L2</li>
<li><strong>Content</strong>:ORDER BY 子句中的所有表达式必须按统一的 ASC 或 DESC 方向排序，以便利用索引。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c1,c2,c3 <span class="keyword">from</span> t1 <span class="keyword">where</span> c1=<span class="string">'foo'</span> <span class="keyword">order</span> <span class="keyword">by</span> c2 <span class="keyword">desc</span>, c3 <span class="keyword">asc</span></span><br></pre></td></tr></table></figure>
<h2 id="请为-GROUP-BY-显示添加-ORDER-BY-条件"><a href="#请为-GROUP-BY-显示添加-ORDER-BY-条件" class="headerlink" title="请为 GROUP BY 显示添加 ORDER BY 条件"></a>请为 GROUP BY 显示添加 ORDER BY 条件</h2><ul>
<li><strong>Item</strong>:CLA.008</li>
<li><strong>Severity</strong>:L2</li>
<li><strong>Content</strong>:默认 MySQL 会对 ‘GROUP BY col1, col2, …’ 请求按如下顺序排序 ‘ORDER BY col1, col2, …’。如果 GROUP BY 语句不指定 ORDER BY 条件会导致无谓的排序产生，如果不需要排序建议添加 ‘ORDER BY NULL’。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c1,c2,c3 <span class="keyword">from</span> t1 <span class="keyword">where</span> c1=<span class="string">'foo'</span> <span class="keyword">group</span> <span class="keyword">by</span> c2</span><br></pre></td></tr></table></figure>
<h2 id="ORDER-BY-的条件为表达式"><a href="#ORDER-BY-的条件为表达式" class="headerlink" title="ORDER BY 的条件为表达式"></a>ORDER BY 的条件为表达式</h2><ul>
<li><strong>Item</strong>:CLA.009</li>
<li><strong>Severity</strong>:L2</li>
<li><strong>Content</strong>:当 ORDER BY 条件为表达式或函数时会使用到临时表，如果在未指定 WHERE 或 WHERE 条件返回的结果集较大时性能会很差。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> description <span class="keyword">from</span> film <span class="keyword">where</span> title =<span class="string">'ACADEMY DINOSAUR'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">length</span>-language_id;</span><br></pre></td></tr></table></figure>
<h2 id="GROUP-BY-的条件为表达式"><a href="#GROUP-BY-的条件为表达式" class="headerlink" title="GROUP BY 的条件为表达式"></a>GROUP BY 的条件为表达式</h2><ul>
<li><strong>Item</strong>:CLA.010</li>
<li><strong>Severity</strong>:L2</li>
<li><strong>Content</strong>:当 GROUP BY 条件为表达式或函数时会使用到临时表，如果在未指定 WHERE 或 WHERE 条件返回的结果集较大时性能会很差。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> description <span class="keyword">from</span> film <span class="keyword">where</span> title =<span class="string">'ACADEMY DINOSAUR'</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">length</span>-language_id;</span><br></pre></td></tr></table></figure>
<h2 id="建议为表添加注释"><a href="#建议为表添加注释" class="headerlink" title="建议为表添加注释"></a>建议为表添加注释</h2><ul>
<li><strong>Item</strong>:CLA.011</li>
<li><strong>Severity</strong>:L1</li>
<li><strong>Content</strong>:为表添加注释能够使得表的意义更明确，从而为日后的维护带来极大的便利。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`test1`</span> (<span class="string">`ID`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,<span class="string">`c1`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,PRIMARY <span class="keyword">KEY</span> (<span class="string">`ID`</span>)) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br></pre></td></tr></table></figure>
<h2 id="将复杂的裹脚布式查询分解成几个简单的查询"><a href="#将复杂的裹脚布式查询分解成几个简单的查询" class="headerlink" title="将复杂的裹脚布式查询分解成几个简单的查询"></a>将复杂的裹脚布式查询分解成几个简单的查询</h2><ul>
<li><strong>Item</strong>:CLA.012</li>
<li><strong>Severity</strong>:L2</li>
<li><strong>Content</strong>:SQL是一门极具表现力的语言，您可以在单个SQL查询或者单条语句中完成很多事情。但这并不意味着必须强制只使用一行代码，或者认为使用一行代码就搞定每个任务是个好主意。通过一个查询来获得所有结果的常见后果是得到了一个笛卡儿积。当查询中的两张表之间没有条件限制它们的关系时，就会发生这种情况。没有对应的限制而直接使用两张表进行联结查询，就会得到第一张表中的每一行和第二张表中的每一行的一个组合。每一个这样的组合就会成为结果集中的一行，最终您就会得到一个行数很多的结果集。重要的是要考虑这些查询很难编写、难以修改和难以调试。数据库查询请求的日益增加应该是预料之中的事。经理们想要更复杂的报告以及在用户界面上添加更多的字段。如果您的设计很复杂，并且是一个单一查询，要扩展它们就会很费时费力。不论对您还是项目来说，时间花在这些事情上面不值得。将复杂的意大利面条式查询分解成几个简单的查询。当您拆分一个复杂的SQL查询时，得到的结果可能是很多类似的查询，可能仅仅在数据类型上有所不同。编写所有的这些查询是很乏味的，因此，最好能够有个程序自动生成这些代码。SQL代码生成是一个很好的应用。尽管SQL支持用一行代码解决复杂的问题，但也别做不切实际的事情。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一条很长很长的 SQL，案例略。</span><br></pre></td></tr></table></figure>
<h2 id="不建议使用-HAVING-子句"><a href="#不建议使用-HAVING-子句" class="headerlink" title="不建议使用 HAVING 子句"></a>不建议使用 HAVING 子句</h2><ul>
<li><strong>Item</strong>:CLA.013</li>
<li><strong>Severity</strong>:L3</li>
<li><strong>Content</strong>:将查询的 HAVING 子句改写为 WHERE 中的查询条件，可以在查询处理期间使用索引。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.c_id,<span class="keyword">count</span>(s.c_id) <span class="keyword">FROM</span> s <span class="keyword">where</span> c = <span class="keyword">test</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> s.c_id <span class="keyword">HAVING</span> s.c_id &lt;&gt; <span class="string">'1660'</span> <span class="keyword">AND</span> s.c_id &lt;&gt; <span class="string">'2'</span> <span class="keyword">order</span> <span class="keyword">by</span> s.c_id</span><br></pre></td></tr></table></figure>
<h2 id="删除全表时建议使用-TRUNCATE-替代-DELETE"><a href="#删除全表时建议使用-TRUNCATE-替代-DELETE" class="headerlink" title="删除全表时建议使用 TRUNCATE 替代 DELETE"></a>删除全表时建议使用 TRUNCATE 替代 DELETE</h2><ul>
<li><strong>Item</strong>:CLA.014</li>
<li><strong>Severity</strong>:L2</li>
<li><strong>Content</strong>:删除全表时建议使用 TRUNCATE 替代 DELETE</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tbl</span><br></pre></td></tr></table></figure>
<h2 id="UPDATE-未指定-WHERE-条件"><a href="#UPDATE-未指定-WHERE-条件" class="headerlink" title="UPDATE 未指定 WHERE 条件"></a>UPDATE 未指定 WHERE 条件</h2><ul>
<li><strong>Item</strong>:CLA.015</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:UPDATE 不指定 WHERE 条件一般是致命的，请您三思后行</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> tbl <span class="keyword">set</span> <span class="keyword">col</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="不要-UPDATE-主键"><a href="#不要-UPDATE-主键" class="headerlink" title="不要 UPDATE 主键"></a>不要 UPDATE 主键</h2><ul>
<li><strong>Item</strong>:CLA.016</li>
<li><strong>Severity</strong>:L2</li>
<li><strong>Content</strong>:主键是数据表中记录的唯一标识符，不建议频繁更新主键列，这将影响元数据统计信息进而影响正常的查询。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> tbl <span class="keyword">set</span> <span class="keyword">col</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="不建议使用-SELECT-类型查询"><a href="#不建议使用-SELECT-类型查询" class="headerlink" title="不建议使用 SELECT * 类型查询"></a>不建议使用 SELECT * 类型查询</h2><ul>
<li><strong>Item</strong>:COL.001</li>
<li><strong>Severity</strong>:L1</li>
<li><strong>Content</strong>:当表结构变更时，使用 * 通配符选择所有列将导致查询的含义和行为会发生更改，可能导致查询返回更多的数据。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tbl <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="INSERT-REPLACE-未指定列名"><a href="#INSERT-REPLACE-未指定列名" class="headerlink" title="INSERT/REPLACE 未指定列名"></a>INSERT/REPLACE 未指定列名</h2><ul>
<li><strong>Item</strong>:COL.002</li>
<li><strong>Severity</strong>:L2</li>
<li><strong>Content</strong>:当表结构发生变更，如果 INSERT 或 REPLACE 请求不明确指定列名，请求的结果将会与预想的不同; 建议使用 “INSERT INTO tbl(col1，col2)VALUES …” 代替。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tbl <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'name'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="建议修改自增-ID-为无符号类型"><a href="#建议修改自增-ID-为无符号类型" class="headerlink" title="建议修改自增 ID 为无符号类型"></a>建议修改自增 ID 为无符号类型</h2><ul>
<li><strong>Item</strong>:COL.003</li>
<li><strong>Severity</strong>:L2</li>
<li><strong>Content</strong>:建议修改自增 ID 为无符号类型</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span>(<span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT)</span><br></pre></td></tr></table></figure>
<h2 id="请为列添加默认值"><a href="#请为列添加默认值" class="headerlink" title="请为列添加默认值"></a>请为列添加默认值</h2><ul>
<li><strong>Item</strong>:COL.004</li>
<li><strong>Severity</strong>:L1</li>
<li><strong>Content</strong>:请为列添加默认值，如果是 ALTER 操作，请不要忘记将原字段的默认值写上。字段无默认值，当表较大时无法在线变更表结构。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl (<span class="keyword">col</span> <span class="built_in">int</span>) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>
<h2 id="列未添加注释"><a href="#列未添加注释" class="headerlink" title="列未添加注释"></a>列未添加注释</h2><ul>
<li><strong>Item</strong>:COL.005</li>
<li><strong>Severity</strong>:L1</li>
<li><strong>Content</strong>:建议对表中每个列添加注释，来明确每个列在表中的含义及作用。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl (<span class="keyword">col</span> <span class="built_in">int</span>) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>
<h2 id="表中包含有太多的列"><a href="#表中包含有太多的列" class="headerlink" title="表中包含有太多的列"></a>表中包含有太多的列</h2><ul>
<li><strong>Item</strong>:COL.006</li>
<li><strong>Severity</strong>:L3</li>
<li><strong>Content</strong>:表中包含有太多的列</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl ( cols ....);</span><br></pre></td></tr></table></figure>
<h2 id="可使用-VARCHAR-代替-CHAR，-VARBINARY-代替-BINARY"><a href="#可使用-VARCHAR-代替-CHAR，-VARBINARY-代替-BINARY" class="headerlink" title="可使用 VARCHAR 代替 CHAR， VARBINARY 代替 BINARY"></a>可使用 VARCHAR 代替 CHAR， VARBINARY 代替 BINARY</h2><ul>
<li><strong>Item</strong>:COL.008</li>
<li><strong>Severity</strong>:L1</li>
<li><strong>Content</strong>:为首先变长字段存储空间小，可以节省存储空间。其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(<span class="keyword">id</span> <span class="built_in">int</span>,<span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">20</span>),last_time <span class="built_in">date</span>)</span><br></pre></td></tr></table></figure>
<h2 id="建议使用精确的数据类型"><a href="#建议使用精确的数据类型" class="headerlink" title="建议使用精确的数据类型"></a>建议使用精确的数据类型</h2><ul>
<li><strong>Item</strong>:COL.009</li>
<li><strong>Severity</strong>:L2</li>
<li><strong>Content</strong>:实际上，任何使用 FLOAT, REAL 或 DOUBLE PRECISION 数据类型的设计都有可能是反模式。大多数应用程序使用的浮点数的取值范围并不需要达到IEEE 754标准所定义的最大/最小区间。在计算总量时，非精确浮点数所积累的影响是严重的。使用 SQL 中的 NUMERIC 或 DECIMAL 类型来代替 FLOAT 及其类似的数据类型进行固定精度的小数存储。这些数据类型精确地根据您定义这一列时指定的精度来存储数据。尽可能不要使用浮点数。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab2 (p_id  <span class="built_in">BIGINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,a_id  <span class="built_in">BIGINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,hours <span class="built_in">float</span> <span class="keyword">not</span> <span class="literal">null</span>,PRIMARY <span class="keyword">KEY</span> (p_id, a_id))</span><br></pre></td></tr></table></figure>
<h2 id="不建议使用-ENUM-数据类型"><a href="#不建议使用-ENUM-数据类型" class="headerlink" title="不建议使用 ENUM 数据类型"></a>不建议使用 ENUM 数据类型</h2><ul>
<li><strong>Item</strong>:COL.010</li>
<li><strong>Severity</strong>:L2</li>
<li><strong>Content</strong>:ENUM 定义了列中值的类型，使用字符串表示 ENUM 里的值时，实际存储在列中的数据是这些值在定义时的序数。因此，这列的数据是字节对齐的，当您进行一次排序查询时，结果是按照实际存储的序数值排序的，而不是按字符串值的字母顺序排序的。这可能不是您所希望的。没有什么语法支持从 ENUM 或者 check 约束中添加或删除一个值；您只能使用一个新的集合重新定义这一列。如果您打算废弃一个选项，您可能会为历史数据而烦恼。作为一种策略，改变元数据——也就是说，改变表和列的定义——应该是不常见的，并且要注意测试和质量保证。有一个更好的解决方案来约束一列中的可选值:创建一张检查表，每一行包含一个允许在列中出现的候选值；然后在引用新表的旧表上声明一个外键约束。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tab1(<span class="keyword">status</span> ENUM(<span class="string">'new'</span>,<span class="string">'in progress'</span>,<span class="string">'fixed'</span>))</span><br></pre></td></tr></table></figure>
<h2 id="当需要唯一约束时才使用-NULL，仅当列不能有缺失值时才使用-NOT-NULL"><a href="#当需要唯一约束时才使用-NULL，仅当列不能有缺失值时才使用-NOT-NULL" class="headerlink" title="当需要唯一约束时才使用 NULL，仅当列不能有缺失值时才使用 NOT NULL"></a>当需要唯一约束时才使用 NULL，仅当列不能有缺失值时才使用 NOT NULL</h2><ul>
<li><strong>Item</strong>:COL.011</li>
<li><strong>Severity</strong>:L0</li>
<li><strong>Content</strong>:NULL 和0是不同的，10乘以 NULL 还是 NULL。NULL 和空字符串是不一样的。将一个字符串和标准 SQL 中的 NULL 联合起来的结果还是 NULL。NULL 和 FALSE 也是不同的。AND、OR 和 NOT 这三个布尔操作如果涉及 NULL，其结果也让很多人感到困惑。当您将一列声明为 NOT NULL 时，也就是说这列中的每一个值都必须存在且是有意义的。使用 NULL 来表示任意类型不存在的空值。 当您将一列声明为 NOT NULL 时，也就是说这列中的每一个值都必须存在且是有意义的。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c1,c2,c3 <span class="keyword">from</span> tbl <span class="keyword">where</span> c4 <span class="keyword">is</span> <span class="literal">null</span> <span class="keyword">or</span> c4 &lt;&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="BLOB-和-TEXT-类型的字段不可设置为-NULL"><a href="#BLOB-和-TEXT-类型的字段不可设置为-NULL" class="headerlink" title="BLOB 和 TEXT 类型的字段不可设置为 NULL"></a>BLOB 和 TEXT 类型的字段不可设置为 NULL</h2><ul>
<li><strong>Item</strong>:COL.012</li>
<li><strong>Severity</strong>:L5</li>
<li><strong>Content</strong>:BLOB 和 TEXT 类型的字段不可设置为 NULL</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tbl`</span> ( <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT, <span class="string">`c`</span> longblob, PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>));</span><br></pre></td></tr></table></figure>
<h2 id="TIMESTAMP-类型未设置默认值"><a href="#TIMESTAMP-类型未设置默认值" class="headerlink" title="TIMESTAMP 类型未设置默认值"></a>TIMESTAMP 类型未设置默认值</h2><ul>
<li><strong>Item</strong>:COL.013</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:TIMESTAMP 类型未设置默认值</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl( <span class="string">`id`</span> <span class="built_in">bigint</span> <span class="keyword">not</span> <span class="literal">null</span>, <span class="string">`create_time`</span> <span class="built_in">timestamp</span>);</span><br></pre></td></tr></table></figure>
<h2 id="为列指定了字符集"><a href="#为列指定了字符集" class="headerlink" title="为列指定了字符集"></a>为列指定了字符集</h2><ul>
<li><strong>Item</strong>:COL.014</li>
<li><strong>Severity</strong>:L5</li>
<li><strong>Content</strong>:建议列与表使用同一个字符集，不要单独指定列的字符集。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tb2`</span> ( <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>, <span class="string">`col`</span> <span class="built_in">char</span>(<span class="number">10</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure>
<h2 id="BLOB-类型的字段不可指定默认值"><a href="#BLOB-类型的字段不可指定默认值" class="headerlink" title="BLOB 类型的字段不可指定默认值"></a>BLOB 类型的字段不可指定默认值</h2><ul>
<li><strong>Item</strong>:COL.015</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:BLOB 类型的字段不可指定默认值</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tbl`</span> ( <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT, <span class="string">`c`</span> <span class="built_in">blob</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>, PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>));</span><br></pre></td></tr></table></figure>
<h2 id="整型定义建议采用-INT-10-或-BIGINT-20"><a href="#整型定义建议采用-INT-10-或-BIGINT-20" class="headerlink" title="整型定义建议采用 INT(10) 或 BIGINT(20)"></a>整型定义建议采用 INT(10) 或 BIGINT(20)</h2><ul>
<li><strong>Item</strong>:COL.016</li>
<li><strong>Severity</strong>:L1</li>
<li><strong>Content</strong>:INT(M) 在 integer 数据类型中，M 表示最大显示宽度。 在 INT(M) 中，M 的值跟 INT(M) 所占多少存储空间并无任何关系。 INT(3)、INT(4)、INT(8) 在磁盘上都是占用 4 bytes 的存储空间。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab (a <span class="built_in">INT</span>(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<h2 id="VARCHAR-定义长度过长"><a href="#VARCHAR-定义长度过长" class="headerlink" title="VARCHAR 定义长度过长"></a>VARCHAR 定义长度过长</h2><ul>
<li><strong>Item</strong>:COL.017</li>
<li><strong>Severity</strong>:L2</li>
<li><strong>Content</strong>:varchar 是可变长字符串，不预先分配存储空间，长度不要超过255，如果存储长度过长 MySQL 将定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab (a <span class="built_in">varchar</span>(<span class="number">3500</span>));</span><br></pre></td></tr></table></figure>
<h2 id="消除不必要的-DISTINCT-条件"><a href="#消除不必要的-DISTINCT-条件" class="headerlink" title="消除不必要的 DISTINCT 条件"></a>消除不必要的 DISTINCT 条件</h2><ul>
<li><strong>Item</strong>:DIS.001</li>
<li><strong>Severity</strong>:L1</li>
<li><strong>Content</strong>:太多DISTINCT条件是复杂的裹脚布式查询的症状。考虑将复杂查询分解成许多简单的查询，并减少DISTINCT条件的数量。如果主键列是列的结果集的一部分，则DISTINCT条件可能没有影响。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> c.c_id,<span class="keyword">count</span>(<span class="keyword">DISTINCT</span> c.c_name),<span class="keyword">count</span>(<span class="keyword">DISTINCT</span> c.c_e),<span class="keyword">count</span>(<span class="keyword">DISTINCT</span> c.c_n),<span class="keyword">count</span>(<span class="keyword">DISTINCT</span> c.c_me),c.c_d <span class="keyword">FROM</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> <span class="keyword">id</span>, <span class="keyword">name</span> <span class="keyword">from</span> B) <span class="keyword">as</span> e <span class="keyword">WHERE</span> e.country_id = c.country_id</span><br></pre></td></tr></table></figure>
<h2 id="COUNT-DISTINCT-多列时结果可能和你预想的不同"><a href="#COUNT-DISTINCT-多列时结果可能和你预想的不同" class="headerlink" title="COUNT(DISTINCT) 多列时结果可能和你预想的不同"></a>COUNT(DISTINCT) 多列时结果可能和你预想的不同</h2><ul>
<li><strong>Item</strong>:DIS.002</li>
<li><strong>Severity</strong>:L3</li>
<li><strong>Content</strong>:COUNT(DISTINCT col) 计算该列除NULL之外的不重复行数，注意 COUNT(DISTINCT col, col2) 如果其中一列全为 NULL 那么即使另一列有不同的值，也返回0。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">col</span>, col2) <span class="keyword">FROM</span> tbl;</span><br></pre></td></tr></table></figure>
<h2 id="DISTINCT-对有主键的表没有意义"><a href="#DISTINCT-对有主键的表没有意义" class="headerlink" title="DISTINCT * 对有主键的表没有意义"></a>DISTINCT * 对有主键的表没有意义</h2><ul>
<li><strong>Item</strong>:DIS.003</li>
<li><strong>Severity</strong>:L3</li>
<li><strong>Content</strong>:当表已经有主键时，对所有列进行 DISTINCT 的输出结果与不进行 DISTINCT 操作的结果相同，请不要画蛇添足。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> * <span class="keyword">FROM</span> film;</span><br></pre></td></tr></table></figure>
<h2 id="避免在-WHERE-条件中使用函数或其他运算符"><a href="#避免在-WHERE-条件中使用函数或其他运算符" class="headerlink" title="避免在 WHERE 条件中使用函数或其他运算符"></a>避免在 WHERE 条件中使用函数或其他运算符</h2><ul>
<li><strong>Item</strong>:FUN.001</li>
<li><strong>Severity</strong>:L2</li>
<li><strong>Content</strong>:虽然在 SQL 中使用函数可以简化很多复杂的查询，但使用了函数的查询无法利用表中已经建立的索引，该查询将会是全表扫描，性能较差。通常建议将列名写在比较运算符左侧，将查询过滤条件放在比较运算符右侧。也不建议在查询比较条件两侧书写多余的括号，这会对阅读产生比较大的困扰。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">substring</span>(<span class="keyword">name</span>,<span class="number">1</span>,<span class="number">3</span>)=<span class="string">'abc'</span></span><br></pre></td></tr></table></figure>
<h2 id="指定了-WHERE-条件或非-MyISAM-引擎时使用-COUNT-操作性能不佳"><a href="#指定了-WHERE-条件或非-MyISAM-引擎时使用-COUNT-操作性能不佳" class="headerlink" title="指定了 WHERE 条件或非 MyISAM 引擎时使用 COUNT(*) 操作性能不佳"></a>指定了 WHERE 条件或非 MyISAM 引擎时使用 COUNT(*) 操作性能不佳</h2><ul>
<li><strong>Item</strong>:FUN.002</li>
<li><strong>Severity</strong>:L1</li>
<li><strong>Content</strong>:COUNT(*) 的作用是统计表行数，COUNT(COL) 的作用是统计指定列非 NULL 的行数。MyISAM 表对于 COUNT(*) 统计全表行数进行了特殊的优化，通常情况下非常快。但对于非 MyISAM 表或指定了某些 WHERE 条件，COUNT(*) 操作需要扫描大量的行才能获取精确的结果，性能也因此不佳。有时候某些业务场景并不需要完全精确的 COUNT 值，此时可以用近似值来代替。EXPLAIN 出来的优化器估算的行数就是一个不错的近似值，执行 EXPLAIN 并不需要真正去执行查询，所以成本很低。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c3, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> accounts <span class="keyword">FROM</span> tab <span class="keyword">where</span> c2 &lt; <span class="number">10000</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> c3 <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">num</span></span><br></pre></td></tr></table></figure>
<h2 id="使用了合并为可空列的字符串连接"><a href="#使用了合并为可空列的字符串连接" class="headerlink" title="使用了合并为可空列的字符串连接"></a>使用了合并为可空列的字符串连接</h2><ul>
<li><strong>Item</strong>:FUN.003</li>
<li><strong>Severity</strong>:L3</li>
<li><strong>Content</strong>:在一些查询请求中，您需要强制让某一列或者某个表达式返回非 NULL 的值，从而让查询逻辑变得更简单，担忧不想将这个值存下来。使用 COALESCE() 函数来构造连接的表达式，这样即使是空值列也不会使整表达式变为 NULL。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c1 || <span class="keyword">coalesce</span>(<span class="string">' '</span> || c2 || <span class="string">' '</span>, <span class="string">' '</span>) || c3 <span class="keyword">as</span> c <span class="keyword">from</span> tbl</span><br></pre></td></tr></table></figure>
<h2 id="不建议使用-SYSDATE-函数"><a href="#不建议使用-SYSDATE-函数" class="headerlink" title="不建议使用 SYSDATE() 函数"></a>不建议使用 SYSDATE() 函数</h2><ul>
<li><strong>Item</strong>:FUN.004</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:SYSDATE() 函数可能导致主从数据不一致，请使用 NOW() 函数替代 SYSDATE()。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SYSDATE</span>();</span><br></pre></td></tr></table></figure>
<h2 id="不建议使用-COUNT-col-或-COUNT-常量"><a href="#不建议使用-COUNT-col-或-COUNT-常量" class="headerlink" title="不建议使用 COUNT(col) 或 COUNT(常量)"></a>不建议使用 COUNT(col) 或 COUNT(常量)</h2><ul>
<li><strong>Item</strong>:FUN.005</li>
<li><strong>Severity</strong>:L1</li>
<li><strong>Content</strong>:不要使用 COUNT(col) 或 COUNT(常量) 来替代 COUNT(*), COUNT(*) 是 SQL92 定义的标准统计行数的方法，跟数据无关，跟 NULL 和非 NULL 也无关。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> tbl;</span><br></pre></td></tr></table></figure>
<h2 id="使用-SUM-COL-时需注意-NPE-问题"><a href="#使用-SUM-COL-时需注意-NPE-问题" class="headerlink" title="使用 SUM(COL) 时需注意 NPE 问题"></a>使用 SUM(COL) 时需注意 NPE 问题</h2><ul>
<li><strong>Item</strong>:FUN.006</li>
<li><strong>Severity</strong>:L1</li>
<li><strong>Content</strong>:当某一列的值全是 NULL 时，COUNT(COL) 的返回结果为0,但 SUM(COL) 的返回结果为 NULL，因此使用 SUM() 时需注意 NPE 问题。可以使用如下方式来避免 SUM 的 NPE 问题: SELECT IF(ISNULL(SUM(COL)), 0, SUM(COL)) FROM tbl</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(<span class="keyword">COL</span>) <span class="keyword">FROM</span> tbl;</span><br></pre></td></tr></table></figure>
<h2 id="不建议使用触发器"><a href="#不建议使用触发器" class="headerlink" title="不建议使用触发器"></a>不建议使用触发器</h2><ul>
<li><strong>Item</strong>:FUN.007</li>
<li><strong>Severity</strong>:L1</li>
<li><strong>Content</strong>:触发器的执行没有反馈和日志，隐藏了实际的执行步骤，当数据库出现问题是，不能通过慢日志分析触发器的具体执行情况，不易发现问题。在MySQL中，触发器不能临时关闭或打开，在数据迁移或数据恢复等场景下，需要临时drop触发器，可能影响到生产环境。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> t1 <span class="keyword">AFTER</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> <span class="keyword">work</span> <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="built_in">time</span> <span class="keyword">VALUES</span>(<span class="keyword">NOW</span>());</span><br></pre></td></tr></table></figure>
<h2 id="不建议使用存储过程"><a href="#不建议使用存储过程" class="headerlink" title="不建议使用存储过程"></a>不建议使用存储过程</h2><ul>
<li><strong>Item</strong>:FUN.008</li>
<li><strong>Severity</strong>:L1</li>
<li><strong>Content</strong>:存储过程无版本控制，配合业务的存储过程升级很难做到业务无感知。存储过程在拓展和移植上也存在问题。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> simpleproc (<span class="keyword">OUT</span> param1 <span class="built_in">INT</span>);</span><br></pre></td></tr></table></figure>
<h2 id="不建议使用自定义函数"><a href="#不建议使用自定义函数" class="headerlink" title="不建议使用自定义函数"></a>不建议使用自定义函数</h2><ul>
<li><strong>Item</strong>:FUN.009</li>
<li><strong>Severity</strong>:L1</li>
<li><strong>Content</strong>:不建议使用自定义函数</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> hello (s <span class="built_in">CHAR</span>(<span class="number">20</span>));</span><br></pre></td></tr></table></figure>
<h2 id="不建议对等值查询列使用-GROUP-BY"><a href="#不建议对等值查询列使用-GROUP-BY" class="headerlink" title="不建议对等值查询列使用 GROUP BY"></a>不建议对等值查询列使用 GROUP BY</h2><ul>
<li><strong>Item</strong>:GRP.001</li>
<li><strong>Severity</strong>:L2</li>
<li><strong>Content</strong>:GROUP BY 中的列在前面的 WHERE 条件中使用了等值查询，对这样的列进行 GROUP BY 意义不大。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> film_id, title <span class="keyword">from</span> film <span class="keyword">where</span> release_year=<span class="string">'2006'</span> <span class="keyword">group</span> <span class="keyword">by</span> release_year</span><br></pre></td></tr></table></figure>
<h2 id="JOIN-语句混用逗号和-ANSI-模式"><a href="#JOIN-语句混用逗号和-ANSI-模式" class="headerlink" title="JOIN 语句混用逗号和 ANSI 模式"></a>JOIN 语句混用逗号和 ANSI 模式</h2><ul>
<li><strong>Item</strong>:JOI.001</li>
<li><strong>Severity</strong>:L2</li>
<li><strong>Content</strong>:表连接的时候混用逗号和 ANSI JOIN 不便于人类理解，并且MySQL不同版本的表连接行为和优先级均有所不同，当 MySQL 版本变化后可能会引入错误。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c1,c2,c3 <span class="keyword">from</span> t1,t2 <span class="keyword">join</span> t3 <span class="keyword">on</span> t1.c1=t2.c1,t1.c3=t3,c1 <span class="keyword">where</span> <span class="keyword">id</span>&gt;<span class="number">1000</span></span><br></pre></td></tr></table></figure>
<h2 id="同一张表被连接两次"><a href="#同一张表被连接两次" class="headerlink" title="同一张表被连接两次"></a>同一张表被连接两次</h2><ul>
<li><strong>Item</strong>:JOI.002</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:相同的表在 FROM 子句中至少出现两次，可以简化为对该表的单次访问。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> tb1.col <span class="keyword">from</span> (tb1, tb2) <span class="keyword">join</span> tb2 <span class="keyword">on</span> tb1.id=tb.id <span class="keyword">where</span> tb1.id=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="OUTER-JOIN-失效"><a href="#OUTER-JOIN-失效" class="headerlink" title="OUTER JOIN 失效"></a>OUTER JOIN 失效</h2><ul>
<li><strong>Item</strong>:JOI.003</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:由于 WHERE 条件错误使得 OUTER JOIN 的外部表无数据返回，这会将查询隐式转换为 INNER JOIN 。如：select c from L left join R using(c) where L.a=5 and R.b=10。这种 SQL 逻辑上可能存在错误或程序员对 OUTER JOIN 如何工作存在误解，因为 LEFT/RIGHT JOIN 是 LEFT/RIGHT OUTER JOIN 的缩写。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c1,c2,c3 <span class="keyword">from</span> t1 <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> t2 <span class="keyword">using</span>(c1) <span class="keyword">where</span> t1.c2=<span class="number">2</span> <span class="keyword">and</span> t2.c3=<span class="number">4</span></span><br></pre></td></tr></table></figure>
<h2 id="不建议使用排它-JOIN"><a href="#不建议使用排它-JOIN" class="headerlink" title="不建议使用排它 JOIN"></a>不建议使用排它 JOIN</h2><ul>
<li><strong>Item</strong>:JOI.004</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:只在右侧表为 NULL 的带 WHERE 子句的 LEFT OUTER JOIN 语句，有可能是在WHERE子句中使用错误的列，如：“… FROM l LEFT OUTER JOIN r ON l.l = r.r WHERE r.z IS NULL”，这个查询正确的逻辑可能是 WHERE r.r IS NULL。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c1,c2,c3 <span class="keyword">from</span> t1 <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> t2 <span class="keyword">on</span> t1.c1=t2.c1 <span class="keyword">where</span> t2.c2 <span class="keyword">is</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<h2 id="减少-JOIN-的数量"><a href="#减少-JOIN-的数量" class="headerlink" title="减少 JOIN 的数量"></a>减少 JOIN 的数量</h2><ul>
<li><strong>Item</strong>:JOI.005</li>
<li><strong>Severity</strong>:L2</li>
<li><strong>Content</strong>:太多的 JOIN 是复杂的裹脚布式查询的症状。考虑将复杂查询分解成许多简单的查询，并减少 JOIN 的数量。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> bp1.p_id, b1.d_d <span class="keyword">as</span> l, b1.b_id <span class="keyword">from</span> b1 <span class="keyword">join</span> bp1 <span class="keyword">on</span> (b1.b_id = bp1.b_id) <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> (b1 <span class="keyword">as</span> b2 <span class="keyword">join</span> bp2 <span class="keyword">on</span> (b2.b_id = bp2.b_id)) <span class="keyword">on</span> (bp1.p_id = bp2.p_id ) <span class="keyword">join</span> bp21 <span class="keyword">on</span> (b1.b_id = bp1.b_id) <span class="keyword">join</span> bp31 <span class="keyword">on</span> (b1.b_id = bp1.b_id) <span class="keyword">join</span> bp41 <span class="keyword">on</span> (b1.b_id = bp1.b_id) <span class="keyword">where</span> b2.b_id = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="将嵌套查询重写为-JOIN-通常会导致更高效的执行和更有效的优化"><a href="#将嵌套查询重写为-JOIN-通常会导致更高效的执行和更有效的优化" class="headerlink" title="将嵌套查询重写为 JOIN 通常会导致更高效的执行和更有效的优化"></a>将嵌套查询重写为 JOIN 通常会导致更高效的执行和更有效的优化</h2><ul>
<li><strong>Item</strong>:JOI.006</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:一般来说，非嵌套子查询总是用于关联子查询，最多是来自FROM子句中的一个表，这些子查询用于 ANY, ALL 和 EXISTS 的谓词。如果可以根据查询语义决定子查询最多返回一个行，那么一个不相关的子查询或来自FROM子句中的多个表的子查询就被压平了。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s,p,d <span class="keyword">FROM</span> tbl <span class="keyword">WHERE</span> p.p_id = (<span class="keyword">SELECT</span> s.p_id <span class="keyword">FROM</span> tbl <span class="keyword">WHERE</span> s.c_id = <span class="number">100996</span> <span class="keyword">AND</span> s.q = <span class="number">1</span> )</span><br></pre></td></tr></table></figure>
<h2 id="不建议使用联表删除或更新"><a href="#不建议使用联表删除或更新" class="headerlink" title="不建议使用联表删除或更新"></a>不建议使用联表删除或更新</h2><ul>
<li><strong>Item</strong>:JOI.007</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:当需要同时删除或更新多张表时建议使用简单语句，一条 SQL 只删除或更新一张表，尽量不要将多张表的操作在同一条语句。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">users</span> u <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> hobby h <span class="keyword">ON</span> u.id = h.uid <span class="keyword">SET</span> u.name = <span class="string">'pianoboy'</span> <span class="keyword">WHERE</span> h.hobby = <span class="string">'piano'</span>;</span><br></pre></td></tr></table></figure>
<h2 id="不要使用跨数据库的-JOIN-查询"><a href="#不要使用跨数据库的-JOIN-查询" class="headerlink" title="不要使用跨数据库的 JOIN 查询"></a>不要使用跨数据库的 JOIN 查询</h2><ul>
<li><strong>Item</strong>:JOI.008</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:一般来说，跨数据库的 JOIN 查询意味着查询语句跨越了两个不同的子系统，这可能意味着系统耦合度过高或库表结构设计不合理。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s,p,d <span class="keyword">FROM</span> tbl <span class="keyword">WHERE</span> p.p_id = (<span class="keyword">SELECT</span> s.p_id <span class="keyword">FROM</span> tbl <span class="keyword">WHERE</span> s.c_id = <span class="number">100996</span> <span class="keyword">AND</span> s.q = <span class="number">1</span> )</span><br></pre></td></tr></table></figure>
<h2 id="建议使用自增列作为主键，如使用联合自增主键时请将自增键作为第一列"><a href="#建议使用自增列作为主键，如使用联合自增主键时请将自增键作为第一列" class="headerlink" title="建议使用自增列作为主键，如使用联合自增主键时请将自增键作为第一列"></a>建议使用自增列作为主键，如使用联合自增主键时请将自增键作为第一列</h2><ul>
<li><strong>Item</strong>:KEY.001</li>
<li><strong>Severity</strong>:L2</li>
<li><strong>Content</strong>:建议使用自增列作为主键，如使用联合自增主键时请将自增键作为第一列</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span>(<span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>))</span><br></pre></td></tr></table></figure>
<h2 id="无主键或唯一键，无法在线变更表结构"><a href="#无主键或唯一键，无法在线变更表结构" class="headerlink" title="无主键或唯一键，无法在线变更表结构"></a>无主键或唯一键，无法在线变更表结构</h2><ul>
<li><strong>Item</strong>:KEY.002</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:无主键或唯一键，无法在线变更表结构</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span>(<span class="keyword">col</span> <span class="built_in">varchar</span>(<span class="number">5000</span>))</span><br></pre></td></tr></table></figure>
<h2 id="避免外键等递归关系"><a href="#避免外键等递归关系" class="headerlink" title="避免外键等递归关系"></a>避免外键等递归关系</h2><ul>
<li><strong>Item</strong>:KEY.003</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:存在递归关系的数据很常见，数据常会像树或者以层级方式组织。然而，创建一个外键约束来强制执行同一表中两列之间的关系，会导致笨拙的查询。树的每一层对应着另一个连接。您将需要发出递归查询，以获得节点的所有后代或所有祖先。解决方案是构造一个附加的闭包表。它记录了树中所有节点间的关系，而不仅仅是那些具有直接的父子关系。您也可以比较不同层次的数据设计：闭包表，路径枚举，嵌套集。然后根据应用程序的需要选择一个。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab2 (p_id  <span class="built_in">BIGINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,a_id  <span class="built_in">BIGINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,PRIMARY <span class="keyword">KEY</span> (p_id, a_id),<span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (p_id) <span class="keyword">REFERENCES</span> tab1(p_id),<span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (a_id) <span class="keyword">REFERENCES</span> tab3(a_id))</span><br></pre></td></tr></table></figure>
<h2 id="提醒：请将索引属性顺序与查询对齐"><a href="#提醒：请将索引属性顺序与查询对齐" class="headerlink" title="提醒：请将索引属性顺序与查询对齐"></a>提醒：请将索引属性顺序与查询对齐</h2><ul>
<li><strong>Item</strong>:KEY.004</li>
<li><strong>Severity</strong>:L0</li>
<li><strong>Content</strong>:如果为列创建复合索引，请确保查询属性与索引属性的顺序相同，以便DBMS在处理查询时使用索引。如果查询和索引属性订单没有对齐，那么DBMS可能无法在查询处理期间使用索引。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx1 <span class="keyword">on</span> tbl (last_name,first_name)</span><br></pre></td></tr></table></figure>
<h2 id="表建的索引过多"><a href="#表建的索引过多" class="headerlink" title="表建的索引过多"></a>表建的索引过多</h2><ul>
<li><strong>Item</strong>:KEY.005</li>
<li><strong>Severity</strong>:L2</li>
<li><strong>Content</strong>:表建的索引过多</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl ( a <span class="built_in">int</span>, b <span class="built_in">int</span>, c <span class="built_in">int</span>, <span class="keyword">KEY</span> idx_a (<span class="string">`a`</span>),<span class="keyword">KEY</span> idx_b(<span class="string">`b`</span>),<span class="keyword">KEY</span> idx_c(<span class="string">`c`</span>));</span><br></pre></td></tr></table></figure>
<h2 id="主键中的列过多"><a href="#主键中的列过多" class="headerlink" title="主键中的列过多"></a>主键中的列过多</h2><ul>
<li><strong>Item</strong>:KEY.006</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:主键中的列过多</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl ( a <span class="built_in">int</span>, b <span class="built_in">int</span>, c <span class="built_in">int</span>, PRIMARY <span class="keyword">KEY</span>(<span class="string">`a`</span>,<span class="string">`b`</span>,<span class="string">`c`</span>));</span><br></pre></td></tr></table></figure>
<h2 id="未指定主键或主键非-bigint"><a href="#未指定主键或主键非-bigint" class="headerlink" title="未指定主键或主键非 bigint"></a>未指定主键或主键非 bigint</h2><ul>
<li><strong>Item</strong>:KEY.007</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:未指定主键或主键非 bigint，建议将主键设置为 bigint unsigned。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl (a <span class="built_in">bigint</span>);</span><br></pre></td></tr></table></figure>
<h2 id="ORDER-BY-多个列但排序方向不同时可能无法使用索引"><a href="#ORDER-BY-多个列但排序方向不同时可能无法使用索引" class="headerlink" title="ORDER BY 多个列但排序方向不同时可能无法使用索引"></a>ORDER BY 多个列但排序方向不同时可能无法使用索引</h2><ul>
<li><strong>Item</strong>:KEY.008</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:在 MySQL 8.0之前当 ORDER BY 多个列指定的排序方向不同时将无法使用已经建立的索引。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl <span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">DESC</span>, b <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>
<h2 id="添加唯一索引前请注意检查数据唯一性"><a href="#添加唯一索引前请注意检查数据唯一性" class="headerlink" title="添加唯一索引前请注意检查数据唯一性"></a>添加唯一索引前请注意检查数据唯一性</h2><ul>
<li><strong>Item</strong>:KEY.009</li>
<li><strong>Severity</strong>:L0</li>
<li><strong>Content</strong>:请提前检查添加唯一索引列的数据唯一性，如果数据不唯一在线表结构调整时将有可能自动将重复列删除，这有可能导致数据丢失。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> part_of_name <span class="keyword">ON</span> customer (<span class="keyword">name</span>(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>
<h2 id="全文索引不是银弹"><a href="#全文索引不是银弹" class="headerlink" title="全文索引不是银弹"></a>全文索引不是银弹</h2><ul>
<li><strong>Item</strong>:KEY.010</li>
<li><strong>Severity</strong>:L0</li>
<li><strong>Content</strong>:全文索引主要用于解决模糊查询的性能问题，但需要控制好查询的频率和并发度。同时注意调整 ft_min_word_len, ft_max_word_len, ngram_token_size 等参数。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tb`</span> ( <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT, <span class="string">`ip`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>, PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>), FULLTEXT <span class="keyword">KEY</span> <span class="string">`ip`</span> (<span class="string">`ip`</span>) ) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>
<h2 id="SQL-CALC-FOUND-ROWS-效率低下"><a href="#SQL-CALC-FOUND-ROWS-效率低下" class="headerlink" title="SQL_CALC_FOUND_ROWS 效率低下"></a>SQL_CALC_FOUND_ROWS 效率低下</h2><ul>
<li><strong>Item</strong>:KWR.001</li>
<li><strong>Severity</strong>:L2</li>
<li><strong>Content</strong>:因为 SQL_CALC_FOUND_ROWS 不能很好地扩展，所以可能导致性能问题; 建议业务使用其他策略来替代 SQL_CALC_FOUND_ROWS 提供的计数功能，比如：分页结果展示等。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">SQL_CALC_FOUND_ROWS</span> <span class="keyword">col</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> <span class="keyword">id</span>&gt;<span class="number">1000</span></span><br></pre></td></tr></table></figure>
<h2 id="不建议使用-MySQL-关键字做列名或表名"><a href="#不建议使用-MySQL-关键字做列名或表名" class="headerlink" title="不建议使用 MySQL 关键字做列名或表名"></a>不建议使用 MySQL 关键字做列名或表名</h2><ul>
<li><strong>Item</strong>:KWR.002</li>
<li><strong>Severity</strong>:L2</li>
<li><strong>Content</strong>:当使用关键字做为列名或表名时程序需要对列名和表名进行转义，如果疏忽被将导致请求无法执行。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl ( <span class="string">`select`</span> <span class="built_in">int</span> )</span><br></pre></td></tr></table></figure>
<h2 id="不建议使用复数做列名或表名"><a href="#不建议使用复数做列名或表名" class="headerlink" title="不建议使用复数做列名或表名"></a>不建议使用复数做列名或表名</h2><ul>
<li><strong>Item</strong>:KWR.003</li>
<li><strong>Severity</strong>:L1</li>
<li><strong>Content</strong>:表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合表达习惯。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl ( <span class="string">`books`</span> <span class="built_in">int</span> )</span><br></pre></td></tr></table></figure>
<h2 id="不建议使用使用多字节编码字符-中文-命名"><a href="#不建议使用使用多字节编码字符-中文-命名" class="headerlink" title="不建议使用使用多字节编码字符(中文)命名"></a>不建议使用使用多字节编码字符(中文)命名</h2><ul>
<li><strong>Item</strong>:KWR.004</li>
<li><strong>Severity</strong>:L1</li>
<li><strong>Content</strong>:为库、表、列、别名命名时建议使用英文，数字，下划线等字符，不建议使用中文或其他多字节编码字符。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">col</span> <span class="keyword">as</span> 列 <span class="keyword">from</span> tb</span><br></pre></td></tr></table></figure>
<h2 id="INSERT-INTO-xx-SELECT-加锁粒度较大请谨慎"><a href="#INSERT-INTO-xx-SELECT-加锁粒度较大请谨慎" class="headerlink" title="INSERT INTO xx SELECT 加锁粒度较大请谨慎"></a>INSERT INTO xx SELECT 加锁粒度较大请谨慎</h2><ul>
<li><strong>Item</strong>:LCK.001</li>
<li><strong>Severity</strong>:L3</li>
<li><strong>Content</strong>:INSERT INTO xx SELECT 加锁粒度较大请谨慎</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl2;</span><br></pre></td></tr></table></figure>
<h2 id="请慎用-INSERT-ON-DUPLICATE-KEY-UPDATE"><a href="#请慎用-INSERT-ON-DUPLICATE-KEY-UPDATE" class="headerlink" title="请慎用 INSERT ON DUPLICATE KEY UPDATE"></a>请慎用 INSERT ON DUPLICATE KEY UPDATE</h2><ul>
<li><strong>Item</strong>:LCK.002</li>
<li><strong>Severity</strong>:L3</li>
<li><strong>Content</strong>:当主键为自增键时使用 INSERT ON DUPLICATE KEY UPDATE 可能会导致主键出现大量不连续快速增长，导致主键快速溢出无法继续写入。极端情况下还有可能导致主从数据不一致。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1(a,b,c) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="keyword">ON</span> <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span> <span class="keyword">UPDATE</span> c=c+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h2 id="用字符类型存储IP地址"><a href="#用字符类型存储IP地址" class="headerlink" title="用字符类型存储IP地址"></a>用字符类型存储IP地址</h2><ul>
<li><strong>Item</strong>:LIT.001</li>
<li><strong>Severity</strong>:L2</li>
<li><strong>Content</strong>:字符串字面上看起来像IP地址，但不是 INET_ATON() 的参数，表示数据被存储为字符而不是整数。将IP地址存储为整数更为有效。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tbl (IP,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="string">'10.20.306.122'</span>,<span class="string">'test'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="日期-时间未使用引号括起"><a href="#日期-时间未使用引号括起" class="headerlink" title="日期/时间未使用引号括起"></a>日期/时间未使用引号括起</h2><ul>
<li><strong>Item</strong>:LIT.002</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:诸如“WHERE col &lt;2010-02-12”之类的查询是有效的SQL，但可能是一个错误，因为它将被解释为“WHERE col &lt;1996”; 日期/时间文字应该加引号。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col1,col2 <span class="keyword">from</span> tbl <span class="keyword">where</span> <span class="built_in">time</span> &lt; <span class="number">2018</span><span class="number">-01</span><span class="number">-10</span></span><br></pre></td></tr></table></figure>
<h2 id="一列中存储一系列相关数据的集合"><a href="#一列中存储一系列相关数据的集合" class="headerlink" title="一列中存储一系列相关数据的集合"></a>一列中存储一系列相关数据的集合</h2><ul>
<li><strong>Item</strong>:LIT.003</li>
<li><strong>Severity</strong>:L3</li>
<li><strong>Content</strong>:将 ID 存储为一个列表，作为 VARCHAR/TEXT 列，这样能导致性能和数据完整性问题。查询这样的列需要使用模式匹配的表达式。使用逗号分隔的列表来做多表联结查询定位一行数据是极不优雅和耗时的。这将使验证 ID 更加困难。考虑一下，列表最多支持存放多少数据呢？将 ID 存储在一张单独的表中，代替使用多值属性，从而每个单独的属性值都可以占据一行。这样交叉表实现了两张表之间的多对多关系。这将更好地简化查询，也更有效地验证ID。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c1,c2,c3,c4 <span class="keyword">from</span> tab1 <span class="keyword">where</span> col_id REGEXP <span class="string">'[[:&lt;:]]12[[:&gt;:]]'</span></span><br></pre></td></tr></table></figure>
<h2 id="请使用分号或已设定的-DELIMITER-结尾"><a href="#请使用分号或已设定的-DELIMITER-结尾" class="headerlink" title="请使用分号或已设定的 DELIMITER 结尾"></a>请使用分号或已设定的 DELIMITER 结尾</h2><ul>
<li><strong>Item</strong>:LIT.004</li>
<li><strong>Severity</strong>:L1</li>
<li><strong>Content</strong>:USE database, SHOW DATABASES 等命令也需要使用使用分号或已设定的 DELIMITER 结尾。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> db</span><br></pre></td></tr></table></figure>
<h2 id="非确定性的-GROUP-BY"><a href="#非确定性的-GROUP-BY" class="headerlink" title="非确定性的 GROUP BY"></a>非确定性的 GROUP BY</h2><ul>
<li><strong>Item</strong>:RES.001</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:SQL返回的列既不在聚合函数中也不是 GROUP BY 表达式的列中，因此这些值的结果将是非确定性的。如：select a, b, c from tbl where foo=”bar” group by a，该 SQL 返回的结果就是不确定的。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c1,c2,c3 <span class="keyword">from</span> t1 <span class="keyword">where</span> c2=<span class="string">'foo'</span> <span class="keyword">group</span> <span class="keyword">by</span> c2</span><br></pre></td></tr></table></figure>
<h2 id="未使用-ORDER-BY-的-LIMIT-查询"><a href="#未使用-ORDER-BY-的-LIMIT-查询" class="headerlink" title="未使用 ORDER BY 的 LIMIT 查询"></a>未使用 ORDER BY 的 LIMIT 查询</h2><ul>
<li><strong>Item</strong>:RES.002</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:没有 ORDER BY 的 LIMIT 会导致非确定性的结果，这取决于查询执行计划。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col1,col2 <span class="keyword">from</span> tbl <span class="keyword">where</span> <span class="keyword">name</span>=xx <span class="keyword">limit</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h2 id="UPDATE-DELETE-操作使用了-LIMIT-条件"><a href="#UPDATE-DELETE-操作使用了-LIMIT-条件" class="headerlink" title="UPDATE/DELETE 操作使用了 LIMIT 条件"></a>UPDATE/DELETE 操作使用了 LIMIT 条件</h2><ul>
<li><strong>Item</strong>:RES.003</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:UPDATE/DELETE 操作使用 LIMIT 条件和不添加 WHERE 条件一样危险，它可将会导致主从数据不一致或从库同步中断。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> film <span class="keyword">SET</span> <span class="keyword">length</span> = <span class="number">120</span> <span class="keyword">WHERE</span> title = <span class="string">'abc'</span> <span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h2 id="UPDATE-DELETE-操作指定了-ORDER-BY-条件"><a href="#UPDATE-DELETE-操作指定了-ORDER-BY-条件" class="headerlink" title="UPDATE/DELETE 操作指定了 ORDER BY 条件"></a>UPDATE/DELETE 操作指定了 ORDER BY 条件</h2><ul>
<li><strong>Item</strong>:RES.004</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:UPDATE/DELETE 操作不要指定 ORDER BY 条件。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> film <span class="keyword">SET</span> <span class="keyword">length</span> = <span class="number">120</span> <span class="keyword">WHERE</span> title = <span class="string">'abc'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> title</span><br></pre></td></tr></table></figure>
<h2 id="UPDATE-语句可能存在逻辑错误，导致数据损坏"><a href="#UPDATE-语句可能存在逻辑错误，导致数据损坏" class="headerlink" title="UPDATE 语句可能存在逻辑错误，导致数据损坏"></a>UPDATE 语句可能存在逻辑错误，导致数据损坏</h2><ul>
<li><strong>Item</strong>:RES.005</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:在一条 UPDATE 语句中，如果要更新多个字段，字段间不能使用 AND ，而应该用逗号分隔。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> tbl <span class="keyword">set</span> <span class="keyword">col</span> = <span class="number">1</span> <span class="keyword">and</span> cl = <span class="number">2</span> <span class="keyword">where</span> <span class="keyword">col</span>=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<h2 id="永远不真的比较条件"><a href="#永远不真的比较条件" class="headerlink" title="永远不真的比较条件"></a>永远不真的比较条件</h2><ul>
<li><strong>Item</strong>:RES.006</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:查询条件永远非真，如果该条件出现在 where 中可能导致查询无匹配到的结果。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tbl <span class="keyword">where</span> <span class="number">1</span> != <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h2 id="永远为真的比较条件"><a href="#永远为真的比较条件" class="headerlink" title="永远为真的比较条件"></a>永远为真的比较条件</h2><ul>
<li><strong>Item</strong>:RES.007</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:查询条件永远为真，可能导致 WHERE 条件失效进行全表查询。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tbl <span class="keyword">where</span> <span class="number">1</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h2 id="不建议使用LOAD-DATA-SELECT-…-INTO-OUTFILE"><a href="#不建议使用LOAD-DATA-SELECT-…-INTO-OUTFILE" class="headerlink" title="不建议使用LOAD DATA/SELECT … INTO OUTFILE"></a>不建议使用LOAD DATA/SELECT … INTO OUTFILE</h2><ul>
<li><strong>Item</strong>:RES.008</li>
<li><strong>Severity</strong>:L2</li>
<li><strong>Content</strong>:SELECT INTO OUTFILE 需要授予 FILE 权限，这通过会引入安全问题。LOAD DATA 虽然可以提高数据导入速度，但同时也可能导致从库同步延迟过大。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">INFILE</span> <span class="string">'data.txt'</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> db2.my_table;</span><br></pre></td></tr></table></figure>
<h2 id="请谨慎使用TRUNCATE操作"><a href="#请谨慎使用TRUNCATE操作" class="headerlink" title="请谨慎使用TRUNCATE操作"></a>请谨慎使用TRUNCATE操作</h2><ul>
<li><strong>Item</strong>:SEC.001</li>
<li><strong>Severity</strong>:L0</li>
<li><strong>Content</strong>:一般来说想清空一张表最快速的做法就是使用TRUNCATE TABLE tbl_name;语句。但TRUNCATE操作也并非是毫无代价的，TRUNCATE TABLE无法返回被删除的准确行数，如果需要返回被删除的行数建议使用DELETE语法。TRUNCATE 操作还会重置 AUTO_INCREMENT，如果不想重置该值建议使用 DELETE FROM tbl_name WHERE 1;替代。TRUNCATE 操作会对数据字典添加源数据锁(MDL)，当一次需要 TRUNCATE 很多表时会影响整个实例的所有请求，因此如果要 TRUNCATE 多个表建议用 DROP+CREATE 的方式以减少锁时长。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> tbl_name</span><br></pre></td></tr></table></figure>
<h2 id="不使用明文存储密码"><a href="#不使用明文存储密码" class="headerlink" title="不使用明文存储密码"></a>不使用明文存储密码</h2><ul>
<li><strong>Item</strong>:SEC.002</li>
<li><strong>Severity</strong>:L0</li>
<li><strong>Content</strong>:使用明文存储密码或者使用明文在网络上传递密码都是不安全的。如果攻击者能够截获您用来插入密码的SQL语句，他们就能直接读到密码。另外，将用户输入的字符串以明文的形式插入到纯SQL语句中，也会让攻击者发现它。如果您能够读取密码，黑客也可以。解决方案是使用单向哈希函数对原始密码进行加密编码。哈希是指将输入字符串转化成另一个新的、不可识别的字符串的函数。对密码加密表达式加点随机串来防御“字典攻击”。不要将明文密码输入到SQL查询语句中。在应用程序代码中计算哈希串，只在SQL查询中使用哈希串。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span>(<span class="keyword">id</span> <span class="built_in">int</span>,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,<span class="keyword">password</span> <span class="built_in">varchar</span>(<span class="number">200</span>)<span class="keyword">not</span> <span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<h2 id="使用DELETE-DROP-TRUNCATE等操作时注意备份"><a href="#使用DELETE-DROP-TRUNCATE等操作时注意备份" class="headerlink" title="使用DELETE/DROP/TRUNCATE等操作时注意备份"></a>使用DELETE/DROP/TRUNCATE等操作时注意备份</h2><ul>
<li><strong>Item</strong>:SEC.003</li>
<li><strong>Severity</strong>:L0</li>
<li><strong>Content</strong>:在执行高危操作之前对数据进行备份是十分有必要的。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">col</span> = <span class="string">'condition'</span></span><br></pre></td></tr></table></figure>
<h2 id="建议使用-datetime-替换-timestamp-类型"><a href="#建议使用-datetime-替换-timestamp-类型" class="headerlink" title="建议使用 datetime 替换 timestamp 类型"></a>建议使用 datetime 替换 timestamp 类型</h2><ul>
<li><strong>Item</strong>:SKEY.005</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:建议使用 datetime 替换 timestamp 类型，且默认值设置为 1970-01-01 00:00:00。 datetime 类型能保存大范围的值，从1001年到9999年，且与时区无关。使用8个字节的存储空间（比 timestamp 多出4字节）</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl (a datetime);</span><br></pre></td></tr></table></figure>
<h2 id="缺少数据库必须字段-last-update-time-和-is-del"><a href="#缺少数据库必须字段-last-update-time-和-is-del" class="headerlink" title="缺少数据库必须字段 last_update_time 和 is_del"></a>缺少数据库必须字段 last_update_time 和 is_del</h2><ul>
<li><strong>Item</strong>:SKEY.006</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:数据库必须字段 （`last_update_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT ‘最后更新时间’; `is_del` TINYINT (1) UNSIGNED NOT NULL DEFAULT ‘0’ COMMENT ‘是否删除 0：未删除 1：已删除’）</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl （<span class="string">`last_update_time`</span> <span class="built_in">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'最后更新时间'</span>; `is_del` TINYINT (1) UNSIGNED NOT NULL DEFAULT '0' <span class="keyword">COMMENT</span> <span class="string">'是否删除 0：未删除 1：已删除'</span>）;</span><br></pre></td></tr></table></figure>
<h2 id="last-update-time-和-is-del-类型不对"><a href="#last-update-time-和-is-del-类型不对" class="headerlink" title="last_update_time 和 is_del 类型不对"></a>last_update_time 和 is_del 类型不对</h2><ul>
<li><strong>Item</strong>:SKEY.006a</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:数据库必须字段 （`last_update_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT ‘最后更新时间’; `is_del` TINYINT (1) UNSIGNED NOT NULL DEFAULT ‘0’ COMMENT ‘是否删除 0：未删除 1：已删除’）</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl （<span class="string">`last_update_time`</span> <span class="built_in">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'最后更新时间'</span>; `is_del` TINYINT (1) UNSIGNED NOT NULL DEFAULT '0' <span class="keyword">COMMENT</span> <span class="string">'是否删除 0：未删除 1：已删除'</span>）;</span><br></pre></td></tr></table></figure>
<h2 id="不建议使用大字段-TEXT-BLOB"><a href="#不建议使用大字段-TEXT-BLOB" class="headerlink" title="不建议使用大字段 TEXT BLOB"></a>不建议使用大字段 TEXT BLOB</h2><ul>
<li><strong>Item</strong>:SKEY.010</li>
<li><strong>Severity</strong>:L1</li>
<li><strong>Content</strong>:BLOB 和 TEXT 都是为存储很大的数据而设计的字符串数据类型，且性能开销较大，请检查是否有必要使用</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl （a <span class="built_in">TEXT</span>）;</span><br></pre></td></tr></table></figure>
<h2 id="整形建议使用-unsigned"><a href="#整形建议使用-unsigned" class="headerlink" title="整形建议使用 unsigned"></a>整形建议使用 unsigned</h2><ul>
<li><strong>Item</strong>:SKEY.011</li>
<li><strong>Severity</strong>:L1</li>
<li><strong>Content</strong>:请检查整形是否有负数场景，如无特殊场景，建议使用 unsigned</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl （a <span class="built_in">int</span> <span class="keyword">unsigned</span>）;</span><br></pre></td></tr></table></figure>
<h2 id="‘-’-运算符是非标准的"><a href="#‘-’-运算符是非标准的" class="headerlink" title="‘!=’ 运算符是非标准的"></a>‘!=’ 运算符是非标准的</h2><ul>
<li><strong>Item</strong>:STA.001</li>
<li><strong>Severity</strong>:L0</li>
<li><strong>Content</strong>:”&lt;&gt;”才是标准SQL中的不等于运算符。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col1,col2 <span class="keyword">from</span> tbl <span class="keyword">where</span> <span class="keyword">type</span>!=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="库名或表名点后建议不要加空格"><a href="#库名或表名点后建议不要加空格" class="headerlink" title="库名或表名点后建议不要加空格"></a>库名或表名点后建议不要加空格</h2><ul>
<li><strong>Item</strong>:STA.002</li>
<li><strong>Severity</strong>:L1</li>
<li><strong>Content</strong>:当使用 db.table 或 table.column 格式访问表或字段时，请不要在点号后面添加空格，虽然这样语法正确。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">col</span> <span class="keyword">from</span> sakila. film</span><br></pre></td></tr></table></figure>
<h2 id="索引起名不规范"><a href="#索引起名不规范" class="headerlink" title="索引起名不规范"></a>索引起名不规范</h2><ul>
<li><strong>Item</strong>:STA.003</li>
<li><strong>Severity</strong>:L1</li>
<li><strong>Content</strong>:建议普通二级索引以idx_为前缀，唯一索引以uniq_为前缀。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">col</span> <span class="keyword">from</span> <span class="keyword">now</span> <span class="keyword">where</span> <span class="keyword">type</span>!=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="起名时请不要使用字母、数字和下划线之外的字符"><a href="#起名时请不要使用字母、数字和下划线之外的字符" class="headerlink" title="起名时请不要使用字母、数字和下划线之外的字符"></a>起名时请不要使用字母、数字和下划线之外的字符</h2><ul>
<li><strong>Item</strong>:STA.004</li>
<li><strong>Severity</strong>:L1</li>
<li><strong>Content</strong>:以字母或下划线开头，名字只允许使用字母、数字和下划线。请统一大小写，不要使用驼峰命名法。不要在名字中出现连续下划线’__‘，这样很难辨认。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">` abc`</span> (a <span class="built_in">int</span>);</span><br></pre></td></tr></table></figure>
<h2 id="MySQL-对子查询的优化效果不佳"><a href="#MySQL-对子查询的优化效果不佳" class="headerlink" title="MySQL 对子查询的优化效果不佳"></a>MySQL 对子查询的优化效果不佳</h2><ul>
<li><strong>Item</strong>:SUB.001</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:MySQL 将外部查询中的每一行作为依赖子查询执行子查询。 这是导致严重性能问题的常见原因。这可能会在 MySQL 5.6 版本中得到改善, 但对于5.1及更早版本, 建议将该类查询分别重写为 JOIN 或 LEFT OUTER JOIN。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col1,col2,col3 <span class="keyword">from</span> table1 <span class="keyword">where</span> col2 <span class="keyword">in</span>(<span class="keyword">select</span> <span class="keyword">col</span> <span class="keyword">from</span> table2)</span><br></pre></td></tr></table></figure>
<h2 id="如果您不在乎重复的话，建议使用-UNION-ALL-替代-UNION"><a href="#如果您不在乎重复的话，建议使用-UNION-ALL-替代-UNION" class="headerlink" title="如果您不在乎重复的话，建议使用 UNION ALL 替代 UNION"></a>如果您不在乎重复的话，建议使用 UNION ALL 替代 UNION</h2><ul>
<li><strong>Item</strong>:SUB.002</li>
<li><strong>Severity</strong>:L2</li>
<li><strong>Content</strong>:与去除重复的UNION不同，UNION ALL允许重复元组。如果您不关心重复元组，那么使用UNION ALL将是一个更快的选项。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> teacher_id <span class="keyword">as</span> <span class="keyword">id</span>,people_name <span class="keyword">as</span> <span class="keyword">name</span> <span class="keyword">from</span> t1,t2 <span class="keyword">where</span> t1.teacher_id=t2.people_id <span class="keyword">union</span> <span class="keyword">select</span> student_id <span class="keyword">as</span> <span class="keyword">id</span>,people_name <span class="keyword">as</span> <span class="keyword">name</span> <span class="keyword">from</span> t1,t2 <span class="keyword">where</span> t1.student_id=t2.people_id</span><br></pre></td></tr></table></figure>
<h2 id="考虑使用-EXISTS-而不是-DISTINCT-子查询"><a href="#考虑使用-EXISTS-而不是-DISTINCT-子查询" class="headerlink" title="考虑使用 EXISTS 而不是 DISTINCT 子查询"></a>考虑使用 EXISTS 而不是 DISTINCT 子查询</h2><ul>
<li><strong>Item</strong>:SUB.003</li>
<li><strong>Severity</strong>:L3</li>
<li><strong>Content</strong>:DISTINCT 关键字在对元组排序后删除重复。相反，考虑使用一个带有 EXISTS 关键字的子查询，您可以避免返回整个表。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> c.c_id, c.c_name <span class="keyword">FROM</span> c,e <span class="keyword">WHERE</span> e.c_id = c.c_id</span><br></pre></td></tr></table></figure>
<h2 id="执行计划中嵌套连接深度过深"><a href="#执行计划中嵌套连接深度过深" class="headerlink" title="执行计划中嵌套连接深度过深"></a>执行计划中嵌套连接深度过深</h2><ul>
<li><strong>Item</strong>:SUB.004</li>
<li><strong>Severity</strong>:L3</li>
<li><strong>Content</strong>:MySQL对子查询的优化效果不佳,MySQL将外部查询中的每一行作为依赖子查询执行子查询。 这是导致严重性能问题的常见原因。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> tb <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> tb))</span><br></pre></td></tr></table></figure>
<h2 id="子查询不支持LIMIT"><a href="#子查询不支持LIMIT" class="headerlink" title="子查询不支持LIMIT"></a>子查询不支持LIMIT</h2><ul>
<li><strong>Item</strong>:SUB.005</li>
<li><strong>Severity</strong>:L8</li>
<li><strong>Content</strong>:当前 MySQL 版本不支持在子查询中进行 ‘LIMIT &amp; IN/ALL/ANY/SOME’。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> staff <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">NAME</span> <span class="keyword">FROM</span> customer <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">name</span> <span class="keyword">LIMIT</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="不建议在子查询中使用函数"><a href="#不建议在子查询中使用函数" class="headerlink" title="不建议在子查询中使用函数"></a>不建议在子查询中使用函数</h2><ul>
<li><strong>Item</strong>:SUB.006</li>
<li><strong>Severity</strong>:L2</li>
<li><strong>Content</strong>:MySQL将外部查询中的每一行作为依赖子查询执行子查询，如果在子查询中使用函数，即使是semi-join也很难进行高效的查询。可以将子查询重写为OUTER JOIN语句并用连接条件对数据进行过滤。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> staff <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">max</span>(<span class="keyword">NAME</span>) <span class="keyword">FROM</span> customer)</span><br></pre></td></tr></table></figure>
<h2 id="不建议使用分区表"><a href="#不建议使用分区表" class="headerlink" title="不建议使用分区表"></a>不建议使用分区表</h2><ul>
<li><strong>Item</strong>:TBL.001</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:不建议使用分区表</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> trb3(<span class="keyword">id</span> <span class="built_in">INT</span>, <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>), purchased <span class="built_in">DATE</span>) <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(<span class="keyword">YEAR</span>(purchased)) (<span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">1990</span>), <span class="keyword">PARTITION</span> p1 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">1995</span>), <span class="keyword">PARTITION</span> p2 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2000</span>), <span class="keyword">PARTITION</span> p3 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2005</span>) );</span><br></pre></td></tr></table></figure>
<h2 id="请为表选择合适的存储引擎"><a href="#请为表选择合适的存储引擎" class="headerlink" title="请为表选择合适的存储引擎"></a>请为表选择合适的存储引擎</h2><ul>
<li><strong>Item</strong>:TBL.002</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:建表或修改表的存储引擎时建议使用推荐的存储引擎，如：innodb</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span>(<span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT)</span><br></pre></td></tr></table></figure>
<h2 id="以DUAL命名的表在数据库中有特殊含义"><a href="#以DUAL命名的表在数据库中有特殊含义" class="headerlink" title="以DUAL命名的表在数据库中有特殊含义"></a>以DUAL命名的表在数据库中有特殊含义</h2><ul>
<li><strong>Item</strong>:TBL.003</li>
<li><strong>Severity</strong>:L8</li>
<li><strong>Content</strong>:DUAL表为虚拟表，不需要创建即可使用，也不建议服务以DUAL命名表。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> dual(<span class="keyword">id</span> <span class="built_in">int</span>, primary <span class="keyword">key</span> (<span class="keyword">id</span>));</span><br></pre></td></tr></table></figure>
<h2 id="表的初始AUTO-INCREMENT值不为0"><a href="#表的初始AUTO-INCREMENT值不为0" class="headerlink" title="表的初始AUTO_INCREMENT值不为0"></a>表的初始AUTO_INCREMENT值不为0</h2><ul>
<li><strong>Item</strong>:TBL.004</li>
<li><strong>Severity</strong>:L2</li>
<li><strong>Content</strong>:AUTO_INCREMENT不为0会导致数据空洞。</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl (a <span class="built_in">int</span>) AUTO_INCREMENT = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h2 id="请使用推荐的字符集"><a href="#请使用推荐的字符集" class="headerlink" title="请使用推荐的字符集"></a>请使用推荐的字符集</h2><ul>
<li><strong>Item</strong>:TBL.005</li>
<li><strong>Severity</strong>:L4</li>
<li><strong>Content</strong>:表字符集只允许设置为utf8mb4</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl (a <span class="built_in">int</span>) <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = latin1;</span><br></pre></td></tr></table></figure>
<h2 id="不建议使用视图"><a href="#不建议使用视图" class="headerlink" title="不建议使用视图"></a>不建议使用视图</h2><ul>
<li><strong>Item</strong>:TBL.006</li>
<li><strong>Severity</strong>:L1</li>
<li><strong>Content</strong>:不建议使用视图</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v_today (today) <span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="keyword">CURRENT_DATE</span>;</span><br></pre></td></tr></table></figure>
<h2 id="不建议使用临时表"><a href="#不建议使用临时表" class="headerlink" title="不建议使用临时表"></a>不建议使用临时表</h2><ul>
<li><strong>Item</strong>:TBL.007</li>
<li><strong>Severity</strong>:L1</li>
<li><strong>Content</strong>:不建议使用临时表</li>
<li><strong>Case</strong>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TEMPORARY</span> <span class="keyword">TABLE</span> <span class="string">`work`</span> (<span class="string">`time`</span> <span class="built_in">time</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://rovast.github.io/2018/12/20/soar-heuristic-list/" title="soar 启发规则汇总 &amp;&amp; 常见 MySQL 优化案例" target="_blank" rel="external">https://rovast.github.io/2018/12/20/soar-heuristic-list/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/rovast" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/rovast" target="_blank"><span class="text-dark">rovast</span><small class="ml-1x">但行好事</small></a></h3>
        <div>该用户很懒，没有介绍自己。</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
           
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom="">
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2018/12/21/useful-docker-links/" title="useful-docker-links"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2018/12/20/optimize-mysql-with-soar/" title="使用 soar 优化 MySQL"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope="" itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/rovast" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>
<script src="/js/plugin.min.js"></script>
<script src="/js/application.js"></script>

    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>





   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<!-- custom analytics part create by xiamo -->
<script defer src="https://cdn1.lncld.net/static/js/av-min-1.2.1.js"></script>
<script defer>
AV.init({
  appId: '2xvr0rI4HA5Vn1CcgtMPxMac-gzGzoHsz',
  appKey: 'F2QrebTLqLwYwoJVJucLOjvX'
});

function showTime(Counter) {
	var query = new AV.Query(Counter);
		var visitors= $('.leancloud_visitors');
		query.greaterThanOrEqualTo("time", 0);		
		query.find({
			success: function(results) {
				if (results.length == 0) {				
					return;
				}
				var data = results;
				visitors.each(function(){
					var url = $(this).attr('id').trim();					
					for (var i = 0; i < data.length; i++) {
						var object = data[i];
						var content = object.get('time');
						var _url = object.get('url')
						if(url == _url){
							$(this).text(content);
						}
					}
				})
				
			},
			error: function(object, error) {
				console.log("Error: " + error.code + " " + error.message);
			}
		});
}

function addCount(Counter) {
	var Counter = AV.Object.extend("Counter");
	url = $(".leancloud_visitors").attr('id').trim();
	title = $(".leancloud_visitors").attr('data-flag-title').trim();
	var query = new AV.Query(Counter);
	query.equalTo("url", url);
	query.find({
		success: function(results) {
			if (results.length > 0) {
				var counter = results[0];
				counter.fetchWhenSave(true);
				counter.increment("time");
				counter.save(null, {
					success: function(counter) {
						var content = counter.get('time');
						$(document.getElementById(url)).text(content);
					},
					error: function(counter, error) {
						console.log('Failed to save Visitor num, with error message: ' + error.message);
					}
				});
			} else {
				var newcounter = new Counter();
				newcounter.set("title", title);
				newcounter.set("url", url);
				newcounter.set("time", 1);
				newcounter.save(null, {
					success: function(newcounter) {
					    console.log("newcounter.get('time')="+newcounter.get('time'));
						var content = newcounter.get('time');
						$(document.getElementById(url)).text(content);
					},
					error: function(newcounter, error) {
						console.log('Failed to create');
					}
				});
			}
		},
		error: function(error) {
			console.log('Error:' + error.code + " " + error.message);
		}
	});
}
$(function() {
	var Counter = AV.Object.extend("Counter");
	if ($('.leancloud_visitors').length == 1) {
		addCount(Counter);
	} else {
		showTime(Counter);
	}
}); 
</script>



   
    
  <!-- <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"> -->
  <script src="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script>
  <script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'd09c04a01484da542af7',
    clientSecret: '378cbbec6959681baa751421c508b75e3755b27c',
    repo: 'rovast.github.io',
    owner: 'rovast',
    admin: ['rovast'],
    id: md5(location.pathname),
    distractionFreeMode: true
  })
  gitalk.render('comments')
  </script>

      








<!-- Cloudflare Web Analytics -->
<script defer src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{"token": "772d8ac6c6e34909aabd01d173940c88"}"></script>
<!-- End Cloudflare Web Analytics -->

</body>
</html>