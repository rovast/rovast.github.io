var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField = (obj, key, value2) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
  return value2;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value2) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
};
var __privateSet = (obj, member, value2, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value2) : member.set(obj, value2);
  return value2;
};
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value2) {
    __privateSet(obj, member, value2, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var _head, _tail, _size;
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  var f = n.default;
  if (typeof f == "function") {
    var a = function() {
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else
    a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var isPlainObj = (value2) => {
  if (Object.prototype.toString.call(value2) !== "[object Object]") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value2);
  return prototype === null || prototype === Object.prototype;
};
const isOptionObject = isPlainObj;
const { hasOwnProperty: hasOwnProperty$1 } = Object.prototype;
const { propertyIsEnumerable } = Object;
const defineProperty = (object, name2, value2) => Object.defineProperty(object, name2, {
  value: value2,
  writable: true,
  enumerable: true,
  configurable: true
});
const globalThis$1 = commonjsGlobal;
const defaultMergeOptions = {
  concatArrays: false,
  ignoreUndefined: false
};
const getEnumerableOwnPropertyKeys = (value2) => {
  const keys = [];
  for (const key in value2) {
    if (hasOwnProperty$1.call(value2, key)) {
      keys.push(key);
    }
  }
  if (Object.getOwnPropertySymbols) {
    const symbols = Object.getOwnPropertySymbols(value2);
    for (const symbol2 of symbols) {
      if (propertyIsEnumerable.call(value2, symbol2)) {
        keys.push(symbol2);
      }
    }
  }
  return keys;
};
function clone(value2) {
  if (Array.isArray(value2)) {
    return cloneArray(value2);
  }
  if (isOptionObject(value2)) {
    return cloneOptionObject(value2);
  }
  return value2;
}
function cloneArray(array) {
  const result = array.slice(0, 0);
  getEnumerableOwnPropertyKeys(array).forEach((key) => {
    defineProperty(result, key, clone(array[key]));
  });
  return result;
}
function cloneOptionObject(object) {
  const result = Object.getPrototypeOf(object) === null ? /* @__PURE__ */ Object.create(null) : {};
  getEnumerableOwnPropertyKeys(object).forEach((key) => {
    defineProperty(result, key, clone(object[key]));
  });
  return result;
}
const mergeKeys = (merged, source2, keys, config2) => {
  keys.forEach((key) => {
    if (typeof source2[key] === "undefined" && config2.ignoreUndefined) {
      return;
    }
    if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
      defineProperty(merged, key, merge$3(merged[key], source2[key], config2));
    } else {
      defineProperty(merged, key, clone(source2[key]));
    }
  });
  return merged;
};
const concatArrays = (merged, source2, config2) => {
  let result = merged.slice(0, 0);
  let resultIndex = 0;
  [merged, source2].forEach((array) => {
    const indices = [];
    for (let k = 0; k < array.length; k++) {
      if (!hasOwnProperty$1.call(array, k)) {
        continue;
      }
      indices.push(String(k));
      if (array === merged) {
        defineProperty(result, resultIndex++, array[k]);
      } else {
        defineProperty(result, resultIndex++, clone(array[k]));
      }
    }
    result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter((key) => !indices.includes(key)), config2);
  });
  return result;
};
function merge$3(merged, source2, config2) {
  if (config2.concatArrays && Array.isArray(merged) && Array.isArray(source2)) {
    return concatArrays(merged, source2, config2);
  }
  if (!isOptionObject(source2) || !isOptionObject(merged)) {
    return clone(source2);
  }
  return mergeKeys(merged, source2, getEnumerableOwnPropertyKeys(source2), config2);
}
var mergeOptions$g = function(...options) {
  const config2 = merge$3(clone(defaultMergeOptions), this !== globalThis$1 && this || {}, defaultMergeOptions);
  let merged = { _: {} };
  for (const option of options) {
    if (option === void 0) {
      continue;
    }
    if (!isOptionObject(option)) {
      throw new TypeError("`" + option + "` is not an Option Object");
    }
    merged = merge$3(merged, { _: option }, config2);
  }
  return merged._;
};
const mergeOptions$f = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: mergeOptions$g
}, Symbol.toStringTag, { value: "Module" }));
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
function isElectron$2() {
  if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
    return true;
  }
  if (typeof process !== "undefined" && typeof process.versions === "object" && !!process.versions.electron) {
    return true;
  }
  if (typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent.indexOf("Electron") >= 0) {
    return true;
  }
  return false;
}
var isElectron_1 = isElectron$2;
const isElectron$1 = isElectron_1;
const IS_ENV_WITH_DOM = typeof window === "object" && typeof document === "object" && document.nodeType === 9;
const IS_ELECTRON = isElectron$1();
const IS_BROWSER = IS_ENV_WITH_DOM && !IS_ELECTRON;
const IS_ELECTRON_MAIN = IS_ELECTRON && !IS_ENV_WITH_DOM;
const IS_ELECTRON_RENDERER = IS_ELECTRON && IS_ENV_WITH_DOM;
const IS_NODE = typeof commonjsRequire === "function" && typeof process !== "undefined" && typeof process.release !== "undefined" && process.release.name === "node" && !IS_ELECTRON;
const IS_WEBWORKER = typeof importScripts === "function" && typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
const IS_TEST = typeof process !== "undefined" && typeof process.env !== "undefined" && false;
const IS_REACT_NATIVE = typeof navigator !== "undefined" && navigator.product === "ReactNative";
var env = {
  isTest: IS_TEST,
  isElectron: IS_ELECTRON,
  isElectronMain: IS_ELECTRON_MAIN,
  isElectronRenderer: IS_ELECTRON_RENDERER,
  isNode: IS_NODE,
  isBrowser: IS_BROWSER,
  isWebWorker: IS_WEBWORKER,
  isEnvWithDom: IS_ENV_WITH_DOM,
  isReactNative: IS_REACT_NATIVE
};
var browser$5 = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs)
    return ms;
  hasRequiredMs = 1;
  var s2 = 1e3;
  var m = s2 * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse2(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s2) {
      return Math.round(ms2 / s2) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s2) {
      return plural(ms2, msAbs, s2, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name2) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name2 + (isPlural ? "s" : "");
  }
  return ms;
}
function setup(env2) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce2;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = requireMs();
  createDebug.destroy = destroy;
  Object.keys(env2).forEach((key) => {
    createDebug[key] = env2[key];
  });
  createDebug.names = [];
  createDebug.skips = [];
  createDebug.formatters = {};
  function selectColor(namespace2) {
    let hash2 = 0;
    for (let i2 = 0; i2 < namespace2.length; i2++) {
      hash2 = (hash2 << 5) - hash2 + namespace2.charCodeAt(i2);
      hash2 |= 0;
    }
    return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
  }
  createDebug.selectColor = selectColor;
  function createDebug(namespace2) {
    let prevTime;
    let enableOverride = null;
    let namespacesCache;
    let enabledCache;
    function debug2(...args) {
      if (!debug2.enabled) {
        return;
      }
      const self2 = debug2;
      const curr = Number(new Date());
      const ms2 = curr - (prevTime || curr);
      self2.diff = ms2;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);
      if (typeof args[0] !== "string") {
        args.unshift("%O");
      }
      let index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
        if (match === "%%") {
          return "%";
        }
        index++;
        const formatter = createDebug.formatters[format2];
        if (typeof formatter === "function") {
          const val = args[index];
          match = formatter.call(self2, val);
          args.splice(index, 1);
          index--;
        }
        return match;
      });
      createDebug.formatArgs.call(self2, args);
      const logFn = self2.log || createDebug.log;
      logFn.apply(self2, args);
    }
    debug2.namespace = namespace2;
    debug2.useColors = createDebug.useColors();
    debug2.color = createDebug.selectColor(namespace2);
    debug2.extend = extend;
    debug2.destroy = createDebug.destroy;
    Object.defineProperty(debug2, "enabled", {
      enumerable: true,
      configurable: false,
      get: () => {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace2);
        }
        return enabledCache;
      },
      set: (v) => {
        enableOverride = v;
      }
    });
    if (typeof createDebug.init === "function") {
      createDebug.init(debug2);
    }
    return debug2;
  }
  function extend(namespace2, delimiter) {
    const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace2);
    newDebug.log = this.log;
    return newDebug;
  }
  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    let i2;
    const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    const len2 = split.length;
    for (i2 = 0; i2 < len2; i2++) {
      if (!split[i2]) {
        continue;
      }
      namespaces = split[i2].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
      } else {
        createDebug.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    const namespaces = [
      ...createDebug.names.map(toNamespace),
      ...createDebug.skips.map(toNamespace).map((namespace2) => "-" + namespace2)
    ].join(",");
    createDebug.enable("");
    return namespaces;
  }
  function enabled(name2) {
    if (name2[name2.length - 1] === "*") {
      return true;
    }
    let i2;
    let len2;
    for (i2 = 0, len2 = createDebug.skips.length; i2 < len2; i2++) {
      if (createDebug.skips[i2].test(name2)) {
        return false;
      }
    }
    for (i2 = 0, len2 = createDebug.names.length; i2 < len2; i2++) {
      if (createDebug.names[i2].test(name2)) {
        return true;
      }
    }
    return false;
  }
  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function coerce2(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }
    return val;
  }
  function destroy() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  createDebug.enable(createDebug.load());
  return createDebug;
}
var common$2 = setup;
(function(module, exports) {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {
  });
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error2) {
    }
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug");
    } catch (error2) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = {}.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error2) {
    }
  }
  module.exports = common$2(exports);
  const { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error2) {
      return "[UnexpectedJSONParseError]: " + error2.message;
    }
  };
})(browser$5, browser$5.exports);
const debug = browser$5.exports;
function base$2(ALPHABET, name2) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x = ALPHABET.charAt(i2);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode3(source2) {
    if (source2 instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source2)) {
      source2 = new Uint8Array(source2.buffer, source2.byteOffset, source2.byteLength);
    } else if (Array.isArray(source2)) {
      source2 = Uint8Array.from(source2);
    }
    if (!(source2 instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source2.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length3 = 0;
    var pbegin = 0;
    var pend = source2.length;
    while (pbegin !== pend && source2[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size2 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size2);
    while (pbegin !== pend) {
      var carry = source2[pbegin];
      var i3 = 0;
      for (var it1 = size2 - 1; (carry !== 0 || i3 < length3) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length3 = i3;
      pbegin++;
    }
    var it2 = size2 - length3;
    while (it2 !== size2 && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size2; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source2) {
    if (typeof source2 !== "string") {
      throw new TypeError("Expected String");
    }
    if (source2.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source2[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length3 = 0;
    while (source2[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size2 = (source2.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size2);
    while (source2[psz]) {
      var carry = BASE_MAP[source2.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size2 - 1; (carry !== 0 || i3 < length3) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length3 = i3;
      psz++;
    }
    if (source2[psz] === " ") {
      return;
    }
    var it4 = size2 - length3;
    while (it4 !== size2 && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size2 - it4));
    var j2 = zeroes;
    while (it4 !== size2) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode3(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name2} character`);
  }
  return {
    encode: encode3,
    decodeUnsafe,
    decode: decode3
  };
}
var src$5 = base$2;
var _brrp__multiformats_scope_baseX$1 = src$5;
const empty$1 = new Uint8Array(0);
const fromHex = (hex) => {
  const hexes2 = hex.match(/../g);
  return hexes2 ? new Uint8Array(hexes2.map((b2) => parseInt(b2, 16))) : empty$1;
};
const equals$3 = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
const coerce$1 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
const fromString$5 = (str) => new TextEncoder().encode(str);
const toString$7 = (b2) => new TextDecoder().decode(b2);
class Encoder$3 {
  constructor(name2, prefix, baseEncode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
}
class Decoder$3 {
  constructor(name2, prefix, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or$2(this, decoder);
  }
}
class ComposedDecoder$1 {
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or$2(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
}
const or$2 = (left, right) => new ComposedDecoder$1({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
class Codec$1 {
  constructor(name2, prefix, baseEncode, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder$3(name2, prefix, baseEncode);
    this.decoder = new Decoder$3(name2, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
}
const from$4 = ({ name: name2, prefix, encode: encode3, decode: decode3 }) => new Codec$1(name2, prefix, encode3, decode3);
const baseX$1 = ({ prefix, name: name2, alphabet: alphabet2 }) => {
  const { encode: encode3, decode: decode3 } = _brrp__multiformats_scope_baseX$1(alphabet2, name2);
  return from$4({
    prefix,
    name: name2,
    encode: encode3,
    decode: (text) => coerce$1(decode3(text))
  });
};
const decode$m = (string2, alphabet2, bitsPerChar, name2) => {
  const codes2 = {};
  for (let i2 = 0; i2 < alphabet2.length; ++i2) {
    codes2[alphabet2[i2]] = i2;
  }
  let end2 = string2.length;
  while (string2[end2 - 1] === "=") {
    --end2;
  }
  const out = new Uint8Array(end2 * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end2; ++i2) {
    const value2 = codes2[string2[i2]];
    if (value2 === void 0) {
      throw new SyntaxError(`Non-${name2} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value2;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer2 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || 255 & buffer2 << 8 - bits2) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
const encode$q = (data, alphabet2, bitsPerChar) => {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet2[mask & buffer2 >> bits2];
    }
  }
  if (bits2) {
    out += alphabet2[mask & buffer2 << bitsPerChar - bits2];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
const rfc4648$1 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
  return from$4({
    prefix,
    name: name2,
    encode(input) {
      return encode$q(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode$m(input, alphabet2, bitsPerChar, name2);
    }
  });
};
const base58btc$1 = baseX$1({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
const base58flickr$1 = baseX$1({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});
const base58$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc: base58btc$1,
  base58flickr: base58flickr$1
}, Symbol.toStringTag, { value: "Module" }));
const base32$2 = rfc4648$1({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
const base32upper$1 = rfc4648$1({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
const base32pad$1 = rfc4648$1({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
const base32padupper$1 = rfc4648$1({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
const base32hex$1 = rfc4648$1({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
const base32hexupper$1 = rfc4648$1({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
const base32hexpad$1 = rfc4648$1({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
const base32hexpadupper$1 = rfc4648$1({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
const base32z$1 = rfc4648$1({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});
const base32$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32: base32$2,
  base32upper: base32upper$1,
  base32pad: base32pad$1,
  base32padupper: base32padupper$1,
  base32hex: base32hex$1,
  base32hexupper: base32hexupper$1,
  base32hexpad: base32hexpad$1,
  base32hexpadupper: base32hexpadupper$1,
  base32z: base32z$1
}, Symbol.toStringTag, { value: "Module" }));
const base64$4 = rfc4648$1({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
const base64pad$1 = rfc4648$1({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
const base64url$1 = rfc4648$1({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
const base64urlpad$1 = rfc4648$1({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});
const base64$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: base64$4,
  base64pad: base64pad$1,
  base64url: base64url$1,
  base64urlpad: base64urlpad$1
}, Symbol.toStringTag, { value: "Module" }));
debug.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc$1.baseEncode(v);
};
debug.formatters.t = (v) => {
  return v == null ? "undefined" : base32$2.baseEncode(v);
};
debug.formatters.m = (v) => {
  return v == null ? "undefined" : base64$4.baseEncode(v);
};
debug.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
debug.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
debug.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
function logger$1(name2) {
  return Object.assign(debug(name2), {
    error: debug(`${name2}:error`),
    trace: debug(`${name2}:trace`)
  });
}
function assign$1(obj, props) {
  for (const key in props) {
    Object.defineProperty(obj, key, {
      value: props[key],
      enumerable: true,
      configurable: true
    });
  }
  return obj;
}
function createError(err2, code2, props) {
  if (!err2 || typeof err2 === "string") {
    throw new TypeError("Please pass an Error to err-code");
  }
  if (!props) {
    props = {};
  }
  if (typeof code2 === "object") {
    props = code2;
    code2 = "";
  }
  if (code2) {
    props.code = code2;
  }
  try {
    return assign$1(err2, props);
  } catch (_) {
    props.message = err2.message;
    props.stack = err2.stack;
    const ErrClass = function() {
    };
    ErrClass.prototype = Object.create(Object.getPrototypeOf(err2));
    const output = assign$1(new ErrClass(), props);
    return output;
  }
}
var errCode = createError;
var minimal$3 = { exports: {} };
var indexMinimal$1 = {};
var minimal$2 = {};
var aspromise = asPromise;
function asPromise(fn, ctx) {
  var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
  while (index < arguments.length)
    params[offset++] = arguments[index++];
  return new Promise(function executor(resolve2, reject) {
    params[offset] = function callback(err2) {
      if (pending) {
        pending = false;
        if (err2)
          reject(err2);
        else {
          var params2 = new Array(arguments.length - 1), offset2 = 0;
          while (offset2 < params2.length)
            params2[offset2++] = arguments[offset2];
          resolve2.apply(null, params2);
        }
      }
    };
    try {
      fn.apply(ctx || null, params);
    } catch (err2) {
      if (pending) {
        pending = false;
        reject(err2);
      }
    }
  });
}
var base64$3 = {};
(function(exports) {
  var base642 = exports;
  base642.length = function length3(string2) {
    var p = string2.length;
    if (!p)
      return 0;
    var n = 0;
    while (--p % 4 > 1 && string2.charAt(p) === "=")
      ++n;
    return Math.ceil(string2.length * 3) / 4 - n;
  };
  var b64 = new Array(64);
  var s64 = new Array(123);
  for (var i2 = 0; i2 < 64; )
    s64[b64[i2] = i2 < 26 ? i2 + 65 : i2 < 52 ? i2 + 71 : i2 < 62 ? i2 - 4 : i2 - 59 | 43] = i2++;
  base642.encode = function encode3(buffer2, start, end2) {
    var parts2 = null, chunk = [];
    var i3 = 0, j = 0, t;
    while (start < end2) {
      var b2 = buffer2[start++];
      switch (j) {
        case 0:
          chunk[i3++] = b64[b2 >> 2];
          t = (b2 & 3) << 4;
          j = 1;
          break;
        case 1:
          chunk[i3++] = b64[t | b2 >> 4];
          t = (b2 & 15) << 2;
          j = 2;
          break;
        case 2:
          chunk[i3++] = b64[t | b2 >> 6];
          chunk[i3++] = b64[b2 & 63];
          j = 0;
          break;
      }
      if (i3 > 8191) {
        (parts2 || (parts2 = [])).push(String.fromCharCode.apply(String, chunk));
        i3 = 0;
      }
    }
    if (j) {
      chunk[i3++] = b64[t];
      chunk[i3++] = 61;
      if (j === 1)
        chunk[i3++] = 61;
    }
    if (parts2) {
      if (i3)
        parts2.push(String.fromCharCode.apply(String, chunk.slice(0, i3)));
      return parts2.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i3));
  };
  var invalidEncoding = "invalid encoding";
  base642.decode = function decode3(string2, buffer2, offset) {
    var start = offset;
    var j = 0, t;
    for (var i3 = 0; i3 < string2.length; ) {
      var c = string2.charCodeAt(i3++);
      if (c === 61 && j > 1)
        break;
      if ((c = s64[c]) === void 0)
        throw Error(invalidEncoding);
      switch (j) {
        case 0:
          t = c;
          j = 1;
          break;
        case 1:
          buffer2[offset++] = t << 2 | (c & 48) >> 4;
          t = c;
          j = 2;
          break;
        case 2:
          buffer2[offset++] = (t & 15) << 4 | (c & 60) >> 2;
          t = c;
          j = 3;
          break;
        case 3:
          buffer2[offset++] = (t & 3) << 6 | c;
          j = 0;
          break;
      }
    }
    if (j === 1)
      throw Error(invalidEncoding);
    return offset - start;
  };
  base642.test = function test(string2) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string2);
  };
})(base64$3);
var eventemitter = EventEmitter$5;
function EventEmitter$5() {
  this._listeners = {};
}
EventEmitter$5.prototype.on = function on2(evt, fn, ctx) {
  (this._listeners[evt] || (this._listeners[evt] = [])).push({
    fn,
    ctx: ctx || this
  });
  return this;
};
EventEmitter$5.prototype.off = function off(evt, fn) {
  if (evt === void 0)
    this._listeners = {};
  else {
    if (fn === void 0)
      this._listeners[evt] = [];
    else {
      var listeners2 = this._listeners[evt];
      for (var i2 = 0; i2 < listeners2.length; )
        if (listeners2[i2].fn === fn)
          listeners2.splice(i2, 1);
        else
          ++i2;
    }
  }
  return this;
};
EventEmitter$5.prototype.emit = function emit(evt) {
  var listeners2 = this._listeners[evt];
  if (listeners2) {
    var args = [], i2 = 1;
    for (; i2 < arguments.length; )
      args.push(arguments[i2++]);
    for (i2 = 0; i2 < listeners2.length; )
      listeners2[i2].fn.apply(listeners2[i2++].ctx, args);
  }
  return this;
};
var float = factory(factory);
function factory(exports) {
  if (typeof Float32Array !== "undefined")
    (function() {
      var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
      function writeFloat_f32_cpy(val, buf2, pos) {
        f32[0] = val;
        buf2[pos] = f8b[0];
        buf2[pos + 1] = f8b[1];
        buf2[pos + 2] = f8b[2];
        buf2[pos + 3] = f8b[3];
      }
      function writeFloat_f32_rev(val, buf2, pos) {
        f32[0] = val;
        buf2[pos] = f8b[3];
        buf2[pos + 1] = f8b[2];
        buf2[pos + 2] = f8b[1];
        buf2[pos + 3] = f8b[0];
      }
      exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
      exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
      function readFloat_f32_cpy(buf2, pos) {
        f8b[0] = buf2[pos];
        f8b[1] = buf2[pos + 1];
        f8b[2] = buf2[pos + 2];
        f8b[3] = buf2[pos + 3];
        return f32[0];
      }
      function readFloat_f32_rev(buf2, pos) {
        f8b[3] = buf2[pos];
        f8b[2] = buf2[pos + 1];
        f8b[1] = buf2[pos + 2];
        f8b[0] = buf2[pos + 3];
        return f32[0];
      }
      exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
      exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
    })();
  else
    (function() {
      function writeFloat_ieee754(writeUint, val, buf2, pos) {
        var sign2 = val < 0 ? 1 : 0;
        if (sign2)
          val = -val;
        if (val === 0)
          writeUint(1 / val > 0 ? 0 : 2147483648, buf2, pos);
        else if (isNaN(val))
          writeUint(2143289344, buf2, pos);
        else if (val > 34028234663852886e22)
          writeUint((sign2 << 31 | 2139095040) >>> 0, buf2, pos);
        else if (val < 11754943508222875e-54)
          writeUint((sign2 << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf2, pos);
        else {
          var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
          writeUint((sign2 << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf2, pos);
        }
      }
      exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE$1);
      exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE$1);
      function readFloat_ieee754(readUint, buf2, pos) {
        var uint = readUint(buf2, pos), sign2 = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
        return exponent === 255 ? mantissa ? NaN : sign2 * Infinity : exponent === 0 ? sign2 * 1401298464324817e-60 * mantissa : sign2 * Math.pow(2, exponent - 150) * (mantissa + 8388608);
      }
      exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE$1);
      exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE$1);
    })();
  if (typeof Float64Array !== "undefined")
    (function() {
      var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
      function writeDouble_f64_cpy(val, buf2, pos) {
        f64[0] = val;
        buf2[pos] = f8b[0];
        buf2[pos + 1] = f8b[1];
        buf2[pos + 2] = f8b[2];
        buf2[pos + 3] = f8b[3];
        buf2[pos + 4] = f8b[4];
        buf2[pos + 5] = f8b[5];
        buf2[pos + 6] = f8b[6];
        buf2[pos + 7] = f8b[7];
      }
      function writeDouble_f64_rev(val, buf2, pos) {
        f64[0] = val;
        buf2[pos] = f8b[7];
        buf2[pos + 1] = f8b[6];
        buf2[pos + 2] = f8b[5];
        buf2[pos + 3] = f8b[4];
        buf2[pos + 4] = f8b[3];
        buf2[pos + 5] = f8b[2];
        buf2[pos + 6] = f8b[1];
        buf2[pos + 7] = f8b[0];
      }
      exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
      exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
      function readDouble_f64_cpy(buf2, pos) {
        f8b[0] = buf2[pos];
        f8b[1] = buf2[pos + 1];
        f8b[2] = buf2[pos + 2];
        f8b[3] = buf2[pos + 3];
        f8b[4] = buf2[pos + 4];
        f8b[5] = buf2[pos + 5];
        f8b[6] = buf2[pos + 6];
        f8b[7] = buf2[pos + 7];
        return f64[0];
      }
      function readDouble_f64_rev(buf2, pos) {
        f8b[7] = buf2[pos];
        f8b[6] = buf2[pos + 1];
        f8b[5] = buf2[pos + 2];
        f8b[4] = buf2[pos + 3];
        f8b[3] = buf2[pos + 4];
        f8b[2] = buf2[pos + 5];
        f8b[1] = buf2[pos + 6];
        f8b[0] = buf2[pos + 7];
        return f64[0];
      }
      exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
      exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
    })();
  else
    (function() {
      function writeDouble_ieee754(writeUint, off0, off1, val, buf2, pos) {
        var sign2 = val < 0 ? 1 : 0;
        if (sign2)
          val = -val;
        if (val === 0) {
          writeUint(0, buf2, pos + off0);
          writeUint(1 / val > 0 ? 0 : 2147483648, buf2, pos + off1);
        } else if (isNaN(val)) {
          writeUint(0, buf2, pos + off0);
          writeUint(2146959360, buf2, pos + off1);
        } else if (val > 17976931348623157e292) {
          writeUint(0, buf2, pos + off0);
          writeUint((sign2 << 31 | 2146435072) >>> 0, buf2, pos + off1);
        } else {
          var mantissa;
          if (val < 22250738585072014e-324) {
            mantissa = val / 5e-324;
            writeUint(mantissa >>> 0, buf2, pos + off0);
            writeUint((sign2 << 31 | mantissa / 4294967296) >>> 0, buf2, pos + off1);
          } else {
            var exponent = Math.floor(Math.log(val) / Math.LN2);
            if (exponent === 1024)
              exponent = 1023;
            mantissa = val * Math.pow(2, -exponent);
            writeUint(mantissa * 4503599627370496 >>> 0, buf2, pos + off0);
            writeUint((sign2 << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf2, pos + off1);
          }
        }
      }
      exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE$1, 0, 4);
      exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE$1, 4, 0);
      function readDouble_ieee754(readUint, off0, off1, buf2, pos) {
        var lo = readUint(buf2, pos + off0), hi = readUint(buf2, pos + off1);
        var sign2 = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
        return exponent === 2047 ? mantissa ? NaN : sign2 * Infinity : exponent === 0 ? sign2 * 5e-324 * mantissa : sign2 * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
      }
      exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE$1, 0, 4);
      exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE$1, 4, 0);
    })();
  return exports;
}
function writeUintLE$1(val, buf2, pos) {
  buf2[pos] = val & 255;
  buf2[pos + 1] = val >>> 8 & 255;
  buf2[pos + 2] = val >>> 16 & 255;
  buf2[pos + 3] = val >>> 24;
}
function writeUintBE$1(val, buf2, pos) {
  buf2[pos] = val >>> 24;
  buf2[pos + 1] = val >>> 16 & 255;
  buf2[pos + 2] = val >>> 8 & 255;
  buf2[pos + 3] = val & 255;
}
function readUintLE$1(buf2, pos) {
  return (buf2[pos] | buf2[pos + 1] << 8 | buf2[pos + 2] << 16 | buf2[pos + 3] << 24) >>> 0;
}
function readUintBE$1(buf2, pos) {
  return (buf2[pos] << 24 | buf2[pos + 1] << 16 | buf2[pos + 2] << 8 | buf2[pos + 3]) >>> 0;
}
var inquire_1 = inquire;
function inquire(moduleName) {
  try {
    var mod = eval("quire".replace(/^/, "re"))(moduleName);
    if (mod && (mod.length || Object.keys(mod).length))
      return mod;
  } catch (e) {
  }
  return null;
}
var utf8$2 = {};
(function(exports) {
  var utf82 = exports;
  utf82.length = function utf8_length(string2) {
    var len2 = 0, c = 0;
    for (var i2 = 0; i2 < string2.length; ++i2) {
      c = string2.charCodeAt(i2);
      if (c < 128)
        len2 += 1;
      else if (c < 2048)
        len2 += 2;
      else if ((c & 64512) === 55296 && (string2.charCodeAt(i2 + 1) & 64512) === 56320) {
        ++i2;
        len2 += 4;
      } else
        len2 += 3;
    }
    return len2;
  };
  utf82.read = function utf8_read(buffer2, start, end2) {
    var len2 = end2 - start;
    if (len2 < 1)
      return "";
    var parts2 = null, chunk = [], i2 = 0, t;
    while (start < end2) {
      t = buffer2[start++];
      if (t < 128)
        chunk[i2++] = t;
      else if (t > 191 && t < 224)
        chunk[i2++] = (t & 31) << 6 | buffer2[start++] & 63;
      else if (t > 239 && t < 365) {
        t = ((t & 7) << 18 | (buffer2[start++] & 63) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63) - 65536;
        chunk[i2++] = 55296 + (t >> 10);
        chunk[i2++] = 56320 + (t & 1023);
      } else
        chunk[i2++] = (t & 15) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63;
      if (i2 > 8191) {
        (parts2 || (parts2 = [])).push(String.fromCharCode.apply(String, chunk));
        i2 = 0;
      }
    }
    if (parts2) {
      if (i2)
        parts2.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
      return parts2.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i2));
  };
  utf82.write = function utf8_write(string2, buffer2, offset) {
    var start = offset, c1, c2;
    for (var i2 = 0; i2 < string2.length; ++i2) {
      c1 = string2.charCodeAt(i2);
      if (c1 < 128) {
        buffer2[offset++] = c1;
      } else if (c1 < 2048) {
        buffer2[offset++] = c1 >> 6 | 192;
        buffer2[offset++] = c1 & 63 | 128;
      } else if ((c1 & 64512) === 55296 && ((c2 = string2.charCodeAt(i2 + 1)) & 64512) === 56320) {
        c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
        ++i2;
        buffer2[offset++] = c1 >> 18 | 240;
        buffer2[offset++] = c1 >> 12 & 63 | 128;
        buffer2[offset++] = c1 >> 6 & 63 | 128;
        buffer2[offset++] = c1 & 63 | 128;
      } else {
        buffer2[offset++] = c1 >> 12 | 224;
        buffer2[offset++] = c1 >> 6 & 63 | 128;
        buffer2[offset++] = c1 & 63 | 128;
      }
    }
    return offset - start;
  };
})(utf8$2);
var pool_1 = pool;
function pool(alloc3, slice2, size2) {
  var SIZE = size2 || 8192;
  var MAX = SIZE >>> 1;
  var slab = null;
  var offset = SIZE;
  return function pool_alloc(size3) {
    if (size3 < 1 || size3 > MAX)
      return alloc3(size3);
    if (offset + size3 > SIZE) {
      slab = alloc3(SIZE);
      offset = 0;
    }
    var buf2 = slice2.call(slab, offset, offset += size3);
    if (offset & 7)
      offset = (offset | 7) + 1;
    return buf2;
  };
}
var longbits$1;
var hasRequiredLongbits$1;
function requireLongbits$1() {
  if (hasRequiredLongbits$1)
    return longbits$1;
  hasRequiredLongbits$1 = 1;
  longbits$1 = LongBits2;
  var util2 = requireMinimal$2();
  function LongBits2(lo, hi) {
    this.lo = lo >>> 0;
    this.hi = hi >>> 0;
  }
  var zero2 = LongBits2.zero = new LongBits2(0, 0);
  zero2.toNumber = function() {
    return 0;
  };
  zero2.zzEncode = zero2.zzDecode = function() {
    return this;
  };
  zero2.length = function() {
    return 1;
  };
  var zeroHash = LongBits2.zeroHash = "\0\0\0\0\0\0\0\0";
  LongBits2.fromNumber = function fromNumber(value2) {
    if (value2 === 0)
      return zero2;
    var sign2 = value2 < 0;
    if (sign2)
      value2 = -value2;
    var lo = value2 >>> 0, hi = (value2 - lo) / 4294967296 >>> 0;
    if (sign2) {
      hi = ~hi >>> 0;
      lo = ~lo >>> 0;
      if (++lo > 4294967295) {
        lo = 0;
        if (++hi > 4294967295)
          hi = 0;
      }
    }
    return new LongBits2(lo, hi);
  };
  LongBits2.from = function from2(value2) {
    if (typeof value2 === "number")
      return LongBits2.fromNumber(value2);
    if (util2.isString(value2)) {
      if (util2.Long)
        value2 = util2.Long.fromString(value2);
      else
        return LongBits2.fromNumber(parseInt(value2, 10));
    }
    return value2.low || value2.high ? new LongBits2(value2.low >>> 0, value2.high >>> 0) : zero2;
  };
  LongBits2.prototype.toNumber = function toNumber(unsigned2) {
    if (!unsigned2 && this.hi >>> 31) {
      var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
      if (!lo)
        hi = hi + 1 >>> 0;
      return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  };
  LongBits2.prototype.toLong = function toLong(unsigned2) {
    return util2.Long ? new util2.Long(this.lo | 0, this.hi | 0, Boolean(unsigned2)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned2) };
  };
  var charCodeAt = String.prototype.charCodeAt;
  LongBits2.fromHash = function fromHash(hash2) {
    if (hash2 === zeroHash)
      return zero2;
    return new LongBits2(
      (charCodeAt.call(hash2, 0) | charCodeAt.call(hash2, 1) << 8 | charCodeAt.call(hash2, 2) << 16 | charCodeAt.call(hash2, 3) << 24) >>> 0,
      (charCodeAt.call(hash2, 4) | charCodeAt.call(hash2, 5) << 8 | charCodeAt.call(hash2, 6) << 16 | charCodeAt.call(hash2, 7) << 24) >>> 0
    );
  };
  LongBits2.prototype.toHash = function toHash() {
    return String.fromCharCode(
      this.lo & 255,
      this.lo >>> 8 & 255,
      this.lo >>> 16 & 255,
      this.lo >>> 24,
      this.hi & 255,
      this.hi >>> 8 & 255,
      this.hi >>> 16 & 255,
      this.hi >>> 24
    );
  };
  LongBits2.prototype.zzEncode = function zzEncode() {
    var mask = this.hi >> 31;
    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo = (this.lo << 1 ^ mask) >>> 0;
    return this;
  };
  LongBits2.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi = (this.hi >>> 1 ^ mask) >>> 0;
    return this;
  };
  LongBits2.prototype.length = function length3() {
    var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
  };
  return longbits$1;
}
var hasRequiredMinimal$2;
function requireMinimal$2() {
  if (hasRequiredMinimal$2)
    return minimal$2;
  hasRequiredMinimal$2 = 1;
  (function(exports) {
    var util2 = exports;
    util2.asPromise = aspromise;
    util2.base64 = base64$3;
    util2.EventEmitter = eventemitter;
    util2.float = float;
    util2.inquire = inquire_1;
    util2.utf8 = utf8$2;
    util2.pool = pool_1;
    util2.LongBits = requireLongbits$1();
    util2.isNode = Boolean(typeof globalThis !== "undefined" && globalThis && globalThis.process && globalThis.process.versions && globalThis.process.versions.node);
    util2.global = util2.isNode && globalThis || typeof window !== "undefined" && window || typeof self !== "undefined" && self || commonjsGlobal;
    util2.emptyArray = Object.freeze ? Object.freeze([]) : [];
    util2.emptyObject = Object.freeze ? Object.freeze({}) : {};
    util2.isInteger = Number.isInteger || function isInteger(value2) {
      return typeof value2 === "number" && isFinite(value2) && Math.floor(value2) === value2;
    };
    util2.isString = function isString2(value2) {
      return typeof value2 === "string" || value2 instanceof String;
    };
    util2.isObject = function isObject(value2) {
      return value2 && typeof value2 === "object";
    };
    util2.isset = util2.isSet = function isSet(obj, prop) {
      var value2 = obj[prop];
      if (value2 != null && obj.hasOwnProperty(prop))
        return typeof value2 !== "object" || (Array.isArray(value2) ? value2.length : Object.keys(value2).length) > 0;
      return false;
    };
    util2.Buffer = function() {
      try {
        var Buffer2 = util2.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : null;
      } catch (e) {
        return null;
      }
    }();
    util2._Buffer_from = null;
    util2._Buffer_allocUnsafe = null;
    util2.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util2.Buffer ? util2._Buffer_allocUnsafe(sizeOrArray) : new util2.Array(sizeOrArray) : util2.Buffer ? util2._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util2.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util2.Long = util2.global.dcodeIO && util2.global.dcodeIO.Long || util2.global.Long || util2.inquire("long");
    util2.key2Re = /^true|false|0|1$/;
    util2.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util2.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util2.longToHash = function longToHash(value2) {
      return value2 ? util2.LongBits.from(value2).toHash() : util2.LongBits.zeroHash;
    };
    util2.longFromHash = function longFromHash(hash2, unsigned2) {
      var bits2 = util2.LongBits.fromHash(hash2);
      if (util2.Long)
        return util2.Long.fromBits(bits2.lo, bits2.hi, unsigned2);
      return bits2.toNumber(Boolean(unsigned2));
    };
    function merge2(dst, src2, ifNotSet) {
      for (var keys = Object.keys(src2), i2 = 0; i2 < keys.length; ++i2)
        if (dst[keys[i2]] === void 0 || !ifNotSet)
          dst[keys[i2]] = src2[keys[i2]];
      return dst;
    }
    util2.merge = merge2;
    util2.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name2) {
      function CustomError(message2, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message2, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message2;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge2(this, properties);
      }
      CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get() {
            return name2;
          },
          set: void 0,
          enumerable: false,
          configurable: true
        },
        toString: {
          value() {
            return this.name + ": " + this.message;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      return CustomError;
    }
    util2.newError = newError;
    util2.ProtocolError = newError("ProtocolError");
    util2.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i2 = 0; i2 < fieldNames.length; ++i2)
        fieldMap[fieldNames[i2]] = 1;
      return function() {
        for (var keys = Object.keys(this), i3 = keys.length - 1; i3 > -1; --i3)
          if (fieldMap[keys[i3]] === 1 && this[keys[i3]] !== void 0 && this[keys[i3]] !== null)
            return keys[i3];
      };
    };
    util2.oneOfSetter = function setOneOf(fieldNames) {
      return function(name2) {
        for (var i2 = 0; i2 < fieldNames.length; ++i2)
          if (fieldNames[i2] !== name2)
            delete this[fieldNames[i2]];
      };
    };
    util2.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util2._configure = function() {
      var Buffer2 = util2.Buffer;
      if (!Buffer2) {
        util2._Buffer_from = util2._Buffer_allocUnsafe = null;
        return;
      }
      util2._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || function Buffer_from(value2, encoding2) {
        return new Buffer2(value2, encoding2);
      };
      util2._Buffer_allocUnsafe = Buffer2.allocUnsafe || function Buffer_allocUnsafe(size2) {
        return new Buffer2(size2);
      };
    };
  })(minimal$2);
  return minimal$2;
}
var writer$2 = Writer$1;
var util$7 = requireMinimal$2();
var BufferWriter$1;
var LongBits$2 = util$7.LongBits, base64$2 = util$7.base64, utf8$1 = util$7.utf8;
function Op(fn, len2, val) {
  this.fn = fn;
  this.len = len2;
  this.next = void 0;
  this.val = val;
}
function noop$6() {
}
function State(writer2) {
  this.head = writer2.head;
  this.tail = writer2.tail;
  this.len = writer2.len;
  this.next = writer2.states;
}
function Writer$1() {
  this.len = 0;
  this.head = new Op(noop$6, 0, 0);
  this.tail = this.head;
  this.states = null;
}
var create$a = function create2() {
  return util$7.Buffer ? function create_buffer_setup() {
    return (Writer$1.create = function create_buffer() {
      return new BufferWriter$1();
    })();
  } : function create_array3() {
    return new Writer$1();
  };
};
Writer$1.create = create$a();
Writer$1.alloc = function alloc2(size2) {
  return new util$7.Array(size2);
};
if (util$7.Array !== Array)
  Writer$1.alloc = util$7.pool(Writer$1.alloc, util$7.Array.prototype.subarray);
Writer$1.prototype._push = function push(fn, len2, val) {
  this.tail = this.tail.next = new Op(fn, len2, val);
  this.len += len2;
  return this;
};
function writeByte(val, buf2, pos) {
  buf2[pos] = val & 255;
}
function writeVarint32(val, buf2, pos) {
  while (val > 127) {
    buf2[pos++] = val & 127 | 128;
    val >>>= 7;
  }
  buf2[pos] = val;
}
function VarintOp(len2, val) {
  this.len = len2;
  this.next = void 0;
  this.val = val;
}
VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;
Writer$1.prototype.uint32 = function write_uint32(value2) {
  this.len += (this.tail = this.tail.next = new VarintOp(
    (value2 = value2 >>> 0) < 128 ? 1 : value2 < 16384 ? 2 : value2 < 2097152 ? 3 : value2 < 268435456 ? 4 : 5,
    value2
  )).len;
  return this;
};
Writer$1.prototype.int32 = function write_int32(value2) {
  return value2 < 0 ? this._push(writeVarint64, 10, LongBits$2.fromNumber(value2)) : this.uint32(value2);
};
Writer$1.prototype.sint32 = function write_sint32(value2) {
  return this.uint32((value2 << 1 ^ value2 >> 31) >>> 0);
};
function writeVarint64(val, buf2, pos) {
  while (val.hi) {
    buf2[pos++] = val.lo & 127 | 128;
    val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
    val.hi >>>= 7;
  }
  while (val.lo > 127) {
    buf2[pos++] = val.lo & 127 | 128;
    val.lo = val.lo >>> 7;
  }
  buf2[pos++] = val.lo;
}
Writer$1.prototype.uint64 = function write_uint64(value2) {
  var bits2 = LongBits$2.from(value2);
  return this._push(writeVarint64, bits2.length(), bits2);
};
Writer$1.prototype.int64 = Writer$1.prototype.uint64;
Writer$1.prototype.sint64 = function write_sint64(value2) {
  var bits2 = LongBits$2.from(value2).zzEncode();
  return this._push(writeVarint64, bits2.length(), bits2);
};
Writer$1.prototype.bool = function write_bool(value2) {
  return this._push(writeByte, 1, value2 ? 1 : 0);
};
function writeFixed32(val, buf2, pos) {
  buf2[pos] = val & 255;
  buf2[pos + 1] = val >>> 8 & 255;
  buf2[pos + 2] = val >>> 16 & 255;
  buf2[pos + 3] = val >>> 24;
}
Writer$1.prototype.fixed32 = function write_fixed32(value2) {
  return this._push(writeFixed32, 4, value2 >>> 0);
};
Writer$1.prototype.sfixed32 = Writer$1.prototype.fixed32;
Writer$1.prototype.fixed64 = function write_fixed64(value2) {
  var bits2 = LongBits$2.from(value2);
  return this._push(writeFixed32, 4, bits2.lo)._push(writeFixed32, 4, bits2.hi);
};
Writer$1.prototype.sfixed64 = Writer$1.prototype.fixed64;
Writer$1.prototype.float = function write_float(value2) {
  return this._push(util$7.float.writeFloatLE, 4, value2);
};
Writer$1.prototype.double = function write_double(value2) {
  return this._push(util$7.float.writeDoubleLE, 8, value2);
};
var writeBytes = util$7.Array.prototype.set ? function writeBytes_set(val, buf2, pos) {
  buf2.set(val, pos);
} : function writeBytes_for(val, buf2, pos) {
  for (var i2 = 0; i2 < val.length; ++i2)
    buf2[pos + i2] = val[i2];
};
Writer$1.prototype.bytes = function write_bytes(value2) {
  var len2 = value2.length >>> 0;
  if (!len2)
    return this._push(writeByte, 1, 0);
  if (util$7.isString(value2)) {
    var buf2 = Writer$1.alloc(len2 = base64$2.length(value2));
    base64$2.decode(value2, buf2, 0);
    value2 = buf2;
  }
  return this.uint32(len2)._push(writeBytes, len2, value2);
};
Writer$1.prototype.string = function write_string(value2) {
  var len2 = utf8$1.length(value2);
  return len2 ? this.uint32(len2)._push(utf8$1.write, len2, value2) : this._push(writeByte, 1, 0);
};
Writer$1.prototype.fork = function fork() {
  this.states = new State(this);
  this.head = this.tail = new Op(noop$6, 0, 0);
  this.len = 0;
  return this;
};
Writer$1.prototype.reset = function reset() {
  if (this.states) {
    this.head = this.states.head;
    this.tail = this.states.tail;
    this.len = this.states.len;
    this.states = this.states.next;
  } else {
    this.head = this.tail = new Op(noop$6, 0, 0);
    this.len = 0;
  }
  return this;
};
Writer$1.prototype.ldelim = function ldelim() {
  var head = this.head, tail = this.tail, len2 = this.len;
  this.reset().uint32(len2);
  if (len2) {
    this.tail.next = head.next;
    this.tail = tail;
    this.len += len2;
  }
  return this;
};
Writer$1.prototype.finish = function finish() {
  var head = this.head.next, buf2 = this.constructor.alloc(this.len), pos = 0;
  while (head) {
    head.fn(head.val, buf2, pos);
    pos += head.len;
    head = head.next;
  }
  return buf2;
};
Writer$1._configure = function(BufferWriter_) {
  BufferWriter$1 = BufferWriter_;
  Writer$1.create = create$a();
  BufferWriter$1._configure();
};
var writer_buffer$1 = BufferWriter;
var Writer = writer$2;
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
var util$6 = requireMinimal$2();
function BufferWriter() {
  Writer.call(this);
}
BufferWriter._configure = function() {
  BufferWriter.alloc = util$6._Buffer_allocUnsafe;
  BufferWriter.writeBytesBuffer = util$6.Buffer && util$6.Buffer.prototype instanceof Uint8Array && util$6.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf2, pos) {
    buf2.set(val, pos);
  } : function writeBytesBuffer_copy(val, buf2, pos) {
    if (val.copy)
      val.copy(buf2, pos, 0, val.length);
    else
      for (var i2 = 0; i2 < val.length; )
        buf2[pos++] = val[i2++];
  };
};
BufferWriter.prototype.bytes = function write_bytes_buffer(value2) {
  if (util$6.isString(value2))
    value2 = util$6._Buffer_from(value2, "base64");
  var len2 = value2.length >>> 0;
  this.uint32(len2);
  if (len2)
    this._push(BufferWriter.writeBytesBuffer, len2, value2);
  return this;
};
function writeStringBuffer(val, buf2, pos) {
  if (val.length < 40)
    util$6.utf8.write(val, buf2, pos);
  else if (buf2.utf8Write)
    buf2.utf8Write(val, pos);
  else
    buf2.write(val, pos);
}
BufferWriter.prototype.string = function write_string_buffer(value2) {
  var len2 = util$6.Buffer.byteLength(value2);
  this.uint32(len2);
  if (len2)
    this._push(writeStringBuffer, len2, value2);
  return this;
};
BufferWriter._configure();
var reader$3 = Reader$1;
var util$5 = requireMinimal$2();
var BufferReader$1;
var LongBits$1 = util$5.LongBits, utf8 = util$5.utf8;
function indexOutOfRange(reader2, writeLength) {
  return RangeError("index out of range: " + reader2.pos + " + " + (writeLength || 1) + " > " + reader2.len);
}
function Reader$1(buffer2) {
  this.buf = buffer2;
  this.pos = 0;
  this.len = buffer2.length;
}
var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer2) {
  if (buffer2 instanceof Uint8Array || Array.isArray(buffer2))
    return new Reader$1(buffer2);
  throw Error("illegal buffer");
} : function create_array2(buffer2) {
  if (Array.isArray(buffer2))
    return new Reader$1(buffer2);
  throw Error("illegal buffer");
};
var create$9 = function create3() {
  return util$5.Buffer ? function create_buffer_setup(buffer2) {
    return (Reader$1.create = function create_buffer(buffer3) {
      return util$5.Buffer.isBuffer(buffer3) ? new BufferReader$1(buffer3) : create_array(buffer3);
    })(buffer2);
  } : create_array;
};
Reader$1.create = create$9();
Reader$1.prototype._slice = util$5.Array.prototype.subarray || util$5.Array.prototype.slice;
Reader$1.prototype.uint32 = function read_uint32_setup() {
  var value2 = 4294967295;
  return function read_uint32() {
    value2 = (this.buf[this.pos] & 127) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value2;
    value2 = (value2 | (this.buf[this.pos] & 127) << 7) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value2;
    value2 = (value2 | (this.buf[this.pos] & 127) << 14) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value2;
    value2 = (value2 | (this.buf[this.pos] & 127) << 21) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value2;
    value2 = (value2 | (this.buf[this.pos] & 15) << 28) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value2;
    if ((this.pos += 5) > this.len) {
      this.pos = this.len;
      throw indexOutOfRange(this, 10);
    }
    return value2;
  };
}();
Reader$1.prototype.int32 = function read_int32() {
  return this.uint32() | 0;
};
Reader$1.prototype.sint32 = function read_sint32() {
  var value2 = this.uint32();
  return value2 >>> 1 ^ -(value2 & 1) | 0;
};
function readLongVarint() {
  var bits2 = new LongBits$1(0, 0);
  var i2 = 0;
  if (this.len - this.pos > 4) {
    for (; i2 < 4; ++i2) {
      bits2.lo = (bits2.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits2;
    }
    bits2.lo = (bits2.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
    bits2.hi = (bits2.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
    if (this.buf[this.pos++] < 128)
      return bits2;
    i2 = 0;
  } else {
    for (; i2 < 3; ++i2) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      bits2.lo = (bits2.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits2;
    }
    bits2.lo = (bits2.lo | (this.buf[this.pos++] & 127) << i2 * 7) >>> 0;
    return bits2;
  }
  if (this.len - this.pos > 4) {
    for (; i2 < 5; ++i2) {
      bits2.hi = (bits2.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits2;
    }
  } else {
    for (; i2 < 5; ++i2) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      bits2.hi = (bits2.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits2;
    }
  }
  throw Error("invalid varint encoding");
}
Reader$1.prototype.bool = function read_bool() {
  return this.uint32() !== 0;
};
function readFixed32_end(buf2, end2) {
  return (buf2[end2 - 4] | buf2[end2 - 3] << 8 | buf2[end2 - 2] << 16 | buf2[end2 - 1] << 24) >>> 0;
}
Reader$1.prototype.fixed32 = function read_fixed32() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4);
};
Reader$1.prototype.sfixed32 = function read_sfixed32() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4) | 0;
};
function readFixed64() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 8);
  return new LongBits$1(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}
Reader$1.prototype.float = function read_float() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  var value2 = util$5.float.readFloatLE(this.buf, this.pos);
  this.pos += 4;
  return value2;
};
Reader$1.prototype.double = function read_double() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 4);
  var value2 = util$5.float.readDoubleLE(this.buf, this.pos);
  this.pos += 8;
  return value2;
};
Reader$1.prototype.bytes = function read_bytes() {
  var length3 = this.uint32(), start = this.pos, end2 = this.pos + length3;
  if (end2 > this.len)
    throw indexOutOfRange(this, length3);
  this.pos += length3;
  if (Array.isArray(this.buf))
    return this.buf.slice(start, end2);
  return start === end2 ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end2);
};
Reader$1.prototype.string = function read_string() {
  var bytes2 = this.bytes();
  return utf8.read(bytes2, 0, bytes2.length);
};
Reader$1.prototype.skip = function skip(length3) {
  if (typeof length3 === "number") {
    if (this.pos + length3 > this.len)
      throw indexOutOfRange(this, length3);
    this.pos += length3;
  } else {
    do {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
    } while (this.buf[this.pos++] & 128);
  }
  return this;
};
Reader$1.prototype.skipType = function(wireType) {
  switch (wireType) {
    case 0:
      this.skip();
      break;
    case 1:
      this.skip(8);
      break;
    case 2:
      this.skip(this.uint32());
      break;
    case 3:
      while ((wireType = this.uint32() & 7) !== 4) {
        this.skipType(wireType);
      }
      break;
    case 5:
      this.skip(4);
      break;
    default:
      throw Error("invalid wire type " + wireType + " at offset " + this.pos);
  }
  return this;
};
Reader$1._configure = function(BufferReader_) {
  BufferReader$1 = BufferReader_;
  Reader$1.create = create$9();
  BufferReader$1._configure();
  var fn = util$5.Long ? "toLong" : "toNumber";
  util$5.merge(Reader$1.prototype, {
    int64: function read_int64() {
      return readLongVarint.call(this)[fn](false);
    },
    uint64: function read_uint64() {
      return readLongVarint.call(this)[fn](true);
    },
    sint64: function read_sint64() {
      return readLongVarint.call(this).zzDecode()[fn](false);
    },
    fixed64: function read_fixed64() {
      return readFixed64.call(this)[fn](true);
    },
    sfixed64: function read_sfixed64() {
      return readFixed64.call(this)[fn](false);
    }
  });
};
var reader_buffer$1 = BufferReader;
var Reader = reader$3;
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
var util$4 = requireMinimal$2();
function BufferReader(buffer2) {
  Reader.call(this, buffer2);
}
BufferReader._configure = function() {
  if (util$4.Buffer)
    BufferReader.prototype._slice = util$4.Buffer.prototype.slice;
};
BufferReader.prototype.string = function read_string_buffer() {
  var len2 = this.uint32();
  return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len2, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len2, this.len));
};
BufferReader._configure();
var rpc$2 = {};
var service$1 = Service$1;
var util$3 = requireMinimal$2();
(Service$1.prototype = Object.create(util$3.EventEmitter.prototype)).constructor = Service$1;
function Service$1(rpcImpl, requestDelimited, responseDelimited) {
  if (typeof rpcImpl !== "function")
    throw TypeError("rpcImpl must be a function");
  util$3.EventEmitter.call(this);
  this.rpcImpl = rpcImpl;
  this.requestDelimited = Boolean(requestDelimited);
  this.responseDelimited = Boolean(responseDelimited);
}
Service$1.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request2, callback) {
  if (!request2)
    throw TypeError("request must be specified");
  var self2 = this;
  if (!callback)
    return util$3.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request2);
  if (!self2.rpcImpl) {
    setTimeout(function() {
      callback(Error("already ended"));
    }, 0);
    return void 0;
  }
  try {
    return self2.rpcImpl(
      method,
      requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request2).finish(),
      function rpcCallback(err2, response) {
        if (err2) {
          self2.emit("error", err2, method);
          return callback(err2);
        }
        if (response === null) {
          self2.end(true);
          return void 0;
        }
        if (!(response instanceof responseCtor)) {
          try {
            response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
          } catch (err3) {
            self2.emit("error", err3, method);
            return callback(err3);
          }
        }
        self2.emit("data", response, method);
        return callback(null, response);
      }
    );
  } catch (err2) {
    self2.emit("error", err2, method);
    setTimeout(function() {
      callback(err2);
    }, 0);
    return void 0;
  }
};
Service$1.prototype.end = function end(endedByRPC) {
  if (this.rpcImpl) {
    if (!endedByRPC)
      this.rpcImpl(null, null, null);
    this.rpcImpl = null;
    this.emit("end").off();
  }
  return this;
};
(function(exports) {
  var rpc2 = exports;
  rpc2.Service = service$1;
})(rpc$2);
var roots$1 = {};
(function(exports) {
  var protobuf = exports;
  protobuf.build = "minimal";
  protobuf.Writer = writer$2;
  protobuf.BufferWriter = writer_buffer$1;
  protobuf.Reader = reader$3;
  protobuf.BufferReader = reader_buffer$1;
  protobuf.util = requireMinimal$2();
  protobuf.rpc = rpc$2;
  protobuf.roots = roots$1;
  protobuf.configure = configure2;
  function configure2() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
  }
  configure2();
})(indexMinimal$1);
(function(module) {
  module.exports = indexMinimal$1;
})(minimal$3);
const $protobuf = /* @__PURE__ */ getDefaultExportFromCjs(minimal$3.exports);
const $Reader$7 = $protobuf.Reader, $Writer$7 = $protobuf.Writer, $util$6 = $protobuf.util;
const $root$7 = $protobuf.roots["ipfs-unixfs"] || ($protobuf.roots["ipfs-unixfs"] = {});
const Data = $root$7.Data = (() => {
  function Data2(p) {
    this.blocksizes = [];
    if (p) {
      for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
        if (p[ks[i2]] != null)
          this[ks[i2]] = p[ks[i2]];
    }
  }
  Data2.prototype.Type = 0;
  Data2.prototype.Data = $util$6.newBuffer([]);
  Data2.prototype.filesize = $util$6.Long ? $util$6.Long.fromBits(0, 0, true) : 0;
  Data2.prototype.blocksizes = $util$6.emptyArray;
  Data2.prototype.hashType = $util$6.Long ? $util$6.Long.fromBits(0, 0, true) : 0;
  Data2.prototype.fanout = $util$6.Long ? $util$6.Long.fromBits(0, 0, true) : 0;
  Data2.prototype.mode = 0;
  Data2.prototype.mtime = null;
  Data2.encode = function encode3(m, w) {
    if (!w)
      w = $Writer$7.create();
    w.uint32(8).int32(m.Type);
    if (m.Data != null && Object.hasOwnProperty.call(m, "Data"))
      w.uint32(18).bytes(m.Data);
    if (m.filesize != null && Object.hasOwnProperty.call(m, "filesize"))
      w.uint32(24).uint64(m.filesize);
    if (m.blocksizes != null && m.blocksizes.length) {
      for (var i2 = 0; i2 < m.blocksizes.length; ++i2)
        w.uint32(32).uint64(m.blocksizes[i2]);
    }
    if (m.hashType != null && Object.hasOwnProperty.call(m, "hashType"))
      w.uint32(40).uint64(m.hashType);
    if (m.fanout != null && Object.hasOwnProperty.call(m, "fanout"))
      w.uint32(48).uint64(m.fanout);
    if (m.mode != null && Object.hasOwnProperty.call(m, "mode"))
      w.uint32(56).uint32(m.mode);
    if (m.mtime != null && Object.hasOwnProperty.call(m, "mtime"))
      $root$7.UnixTime.encode(m.mtime, w.uint32(66).fork()).ldelim();
    return w;
  };
  Data2.decode = function decode3(r, l) {
    if (!(r instanceof $Reader$7))
      r = $Reader$7.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root$7.Data();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.Type = r.int32();
          break;
        case 2:
          m.Data = r.bytes();
          break;
        case 3:
          m.filesize = r.uint64();
          break;
        case 4:
          if (!(m.blocksizes && m.blocksizes.length))
            m.blocksizes = [];
          if ((t & 7) === 2) {
            var c2 = r.uint32() + r.pos;
            while (r.pos < c2)
              m.blocksizes.push(r.uint64());
          } else
            m.blocksizes.push(r.uint64());
          break;
        case 5:
          m.hashType = r.uint64();
          break;
        case 6:
          m.fanout = r.uint64();
          break;
        case 7:
          m.mode = r.uint32();
          break;
        case 8:
          m.mtime = $root$7.UnixTime.decode(r, r.uint32());
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    if (!m.hasOwnProperty("Type"))
      throw $util$6.ProtocolError("missing required 'Type'", { instance: m });
    return m;
  };
  Data2.fromObject = function fromObject(d) {
    if (d instanceof $root$7.Data)
      return d;
    var m = new $root$7.Data();
    switch (d.Type) {
      case "Raw":
      case 0:
        m.Type = 0;
        break;
      case "Directory":
      case 1:
        m.Type = 1;
        break;
      case "File":
      case 2:
        m.Type = 2;
        break;
      case "Metadata":
      case 3:
        m.Type = 3;
        break;
      case "Symlink":
      case 4:
        m.Type = 4;
        break;
      case "HAMTShard":
      case 5:
        m.Type = 5;
        break;
    }
    if (d.Data != null) {
      if (typeof d.Data === "string")
        $util$6.base64.decode(d.Data, m.Data = $util$6.newBuffer($util$6.base64.length(d.Data)), 0);
      else if (d.Data.length)
        m.Data = d.Data;
    }
    if (d.filesize != null) {
      if ($util$6.Long)
        (m.filesize = $util$6.Long.fromValue(d.filesize)).unsigned = true;
      else if (typeof d.filesize === "string")
        m.filesize = parseInt(d.filesize, 10);
      else if (typeof d.filesize === "number")
        m.filesize = d.filesize;
      else if (typeof d.filesize === "object")
        m.filesize = new $util$6.LongBits(d.filesize.low >>> 0, d.filesize.high >>> 0).toNumber(true);
    }
    if (d.blocksizes) {
      if (!Array.isArray(d.blocksizes))
        throw TypeError(".Data.blocksizes: array expected");
      m.blocksizes = [];
      for (var i2 = 0; i2 < d.blocksizes.length; ++i2) {
        if ($util$6.Long)
          (m.blocksizes[i2] = $util$6.Long.fromValue(d.blocksizes[i2])).unsigned = true;
        else if (typeof d.blocksizes[i2] === "string")
          m.blocksizes[i2] = parseInt(d.blocksizes[i2], 10);
        else if (typeof d.blocksizes[i2] === "number")
          m.blocksizes[i2] = d.blocksizes[i2];
        else if (typeof d.blocksizes[i2] === "object")
          m.blocksizes[i2] = new $util$6.LongBits(d.blocksizes[i2].low >>> 0, d.blocksizes[i2].high >>> 0).toNumber(true);
      }
    }
    if (d.hashType != null) {
      if ($util$6.Long)
        (m.hashType = $util$6.Long.fromValue(d.hashType)).unsigned = true;
      else if (typeof d.hashType === "string")
        m.hashType = parseInt(d.hashType, 10);
      else if (typeof d.hashType === "number")
        m.hashType = d.hashType;
      else if (typeof d.hashType === "object")
        m.hashType = new $util$6.LongBits(d.hashType.low >>> 0, d.hashType.high >>> 0).toNumber(true);
    }
    if (d.fanout != null) {
      if ($util$6.Long)
        (m.fanout = $util$6.Long.fromValue(d.fanout)).unsigned = true;
      else if (typeof d.fanout === "string")
        m.fanout = parseInt(d.fanout, 10);
      else if (typeof d.fanout === "number")
        m.fanout = d.fanout;
      else if (typeof d.fanout === "object")
        m.fanout = new $util$6.LongBits(d.fanout.low >>> 0, d.fanout.high >>> 0).toNumber(true);
    }
    if (d.mode != null) {
      m.mode = d.mode >>> 0;
    }
    if (d.mtime != null) {
      if (typeof d.mtime !== "object")
        throw TypeError(".Data.mtime: object expected");
      m.mtime = $root$7.UnixTime.fromObject(d.mtime);
    }
    return m;
  };
  Data2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.blocksizes = [];
    }
    if (o.defaults) {
      d.Type = o.enums === String ? "Raw" : 0;
      if (o.bytes === String)
        d.Data = "";
      else {
        d.Data = [];
        if (o.bytes !== Array)
          d.Data = $util$6.newBuffer(d.Data);
      }
      if ($util$6.Long) {
        var n = new $util$6.Long(0, 0, true);
        d.filesize = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.filesize = o.longs === String ? "0" : 0;
      if ($util$6.Long) {
        var n = new $util$6.Long(0, 0, true);
        d.hashType = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.hashType = o.longs === String ? "0" : 0;
      if ($util$6.Long) {
        var n = new $util$6.Long(0, 0, true);
        d.fanout = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.fanout = o.longs === String ? "0" : 0;
      d.mode = 0;
      d.mtime = null;
    }
    if (m.Type != null && m.hasOwnProperty("Type")) {
      d.Type = o.enums === String ? $root$7.Data.DataType[m.Type] : m.Type;
    }
    if (m.Data != null && m.hasOwnProperty("Data")) {
      d.Data = o.bytes === String ? $util$6.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;
    }
    if (m.filesize != null && m.hasOwnProperty("filesize")) {
      if (typeof m.filesize === "number")
        d.filesize = o.longs === String ? String(m.filesize) : m.filesize;
      else
        d.filesize = o.longs === String ? $util$6.Long.prototype.toString.call(m.filesize) : o.longs === Number ? new $util$6.LongBits(m.filesize.low >>> 0, m.filesize.high >>> 0).toNumber(true) : m.filesize;
    }
    if (m.blocksizes && m.blocksizes.length) {
      d.blocksizes = [];
      for (var j = 0; j < m.blocksizes.length; ++j) {
        if (typeof m.blocksizes[j] === "number")
          d.blocksizes[j] = o.longs === String ? String(m.blocksizes[j]) : m.blocksizes[j];
        else
          d.blocksizes[j] = o.longs === String ? $util$6.Long.prototype.toString.call(m.blocksizes[j]) : o.longs === Number ? new $util$6.LongBits(m.blocksizes[j].low >>> 0, m.blocksizes[j].high >>> 0).toNumber(true) : m.blocksizes[j];
      }
    }
    if (m.hashType != null && m.hasOwnProperty("hashType")) {
      if (typeof m.hashType === "number")
        d.hashType = o.longs === String ? String(m.hashType) : m.hashType;
      else
        d.hashType = o.longs === String ? $util$6.Long.prototype.toString.call(m.hashType) : o.longs === Number ? new $util$6.LongBits(m.hashType.low >>> 0, m.hashType.high >>> 0).toNumber(true) : m.hashType;
    }
    if (m.fanout != null && m.hasOwnProperty("fanout")) {
      if (typeof m.fanout === "number")
        d.fanout = o.longs === String ? String(m.fanout) : m.fanout;
      else
        d.fanout = o.longs === String ? $util$6.Long.prototype.toString.call(m.fanout) : o.longs === Number ? new $util$6.LongBits(m.fanout.low >>> 0, m.fanout.high >>> 0).toNumber(true) : m.fanout;
    }
    if (m.mode != null && m.hasOwnProperty("mode")) {
      d.mode = m.mode;
    }
    if (m.mtime != null && m.hasOwnProperty("mtime")) {
      d.mtime = $root$7.UnixTime.toObject(m.mtime, o);
    }
    return d;
  };
  Data2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };
  Data2.DataType = function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "Raw"] = 0;
    values[valuesById[1] = "Directory"] = 1;
    values[valuesById[2] = "File"] = 2;
    values[valuesById[3] = "Metadata"] = 3;
    values[valuesById[4] = "Symlink"] = 4;
    values[valuesById[5] = "HAMTShard"] = 5;
    return values;
  }();
  return Data2;
})();
$root$7.UnixTime = (() => {
  function UnixTime(p) {
    if (p) {
      for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
        if (p[ks[i2]] != null)
          this[ks[i2]] = p[ks[i2]];
    }
  }
  UnixTime.prototype.Seconds = $util$6.Long ? $util$6.Long.fromBits(0, 0, false) : 0;
  UnixTime.prototype.FractionalNanoseconds = 0;
  UnixTime.encode = function encode3(m, w) {
    if (!w)
      w = $Writer$7.create();
    w.uint32(8).int64(m.Seconds);
    if (m.FractionalNanoseconds != null && Object.hasOwnProperty.call(m, "FractionalNanoseconds"))
      w.uint32(21).fixed32(m.FractionalNanoseconds);
    return w;
  };
  UnixTime.decode = function decode3(r, l) {
    if (!(r instanceof $Reader$7))
      r = $Reader$7.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root$7.UnixTime();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.Seconds = r.int64();
          break;
        case 2:
          m.FractionalNanoseconds = r.fixed32();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    if (!m.hasOwnProperty("Seconds"))
      throw $util$6.ProtocolError("missing required 'Seconds'", { instance: m });
    return m;
  };
  UnixTime.fromObject = function fromObject(d) {
    if (d instanceof $root$7.UnixTime)
      return d;
    var m = new $root$7.UnixTime();
    if (d.Seconds != null) {
      if ($util$6.Long)
        (m.Seconds = $util$6.Long.fromValue(d.Seconds)).unsigned = false;
      else if (typeof d.Seconds === "string")
        m.Seconds = parseInt(d.Seconds, 10);
      else if (typeof d.Seconds === "number")
        m.Seconds = d.Seconds;
      else if (typeof d.Seconds === "object")
        m.Seconds = new $util$6.LongBits(d.Seconds.low >>> 0, d.Seconds.high >>> 0).toNumber();
    }
    if (d.FractionalNanoseconds != null) {
      m.FractionalNanoseconds = d.FractionalNanoseconds >>> 0;
    }
    return m;
  };
  UnixTime.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      if ($util$6.Long) {
        var n = new $util$6.Long(0, 0, false);
        d.Seconds = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.Seconds = o.longs === String ? "0" : 0;
      d.FractionalNanoseconds = 0;
    }
    if (m.Seconds != null && m.hasOwnProperty("Seconds")) {
      if (typeof m.Seconds === "number")
        d.Seconds = o.longs === String ? String(m.Seconds) : m.Seconds;
      else
        d.Seconds = o.longs === String ? $util$6.Long.prototype.toString.call(m.Seconds) : o.longs === Number ? new $util$6.LongBits(m.Seconds.low >>> 0, m.Seconds.high >>> 0).toNumber() : m.Seconds;
    }
    if (m.FractionalNanoseconds != null && m.hasOwnProperty("FractionalNanoseconds")) {
      d.FractionalNanoseconds = m.FractionalNanoseconds;
    }
    return d;
  };
  UnixTime.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };
  return UnixTime;
})();
$root$7.Metadata = (() => {
  function Metadata2(p) {
    if (p) {
      for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
        if (p[ks[i2]] != null)
          this[ks[i2]] = p[ks[i2]];
    }
  }
  Metadata2.prototype.MimeType = "";
  Metadata2.encode = function encode3(m, w) {
    if (!w)
      w = $Writer$7.create();
    if (m.MimeType != null && Object.hasOwnProperty.call(m, "MimeType"))
      w.uint32(10).string(m.MimeType);
    return w;
  };
  Metadata2.decode = function decode3(r, l) {
    if (!(r instanceof $Reader$7))
      r = $Reader$7.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root$7.Metadata();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.MimeType = r.string();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Metadata2.fromObject = function fromObject(d) {
    if (d instanceof $root$7.Metadata)
      return d;
    var m = new $root$7.Metadata();
    if (d.MimeType != null) {
      m.MimeType = String(d.MimeType);
    }
    return m;
  };
  Metadata2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      d.MimeType = "";
    }
    if (m.MimeType != null && m.hasOwnProperty("MimeType")) {
      d.MimeType = m.MimeType;
    }
    return d;
  };
  Metadata2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };
  return Metadata2;
})();
const PBData = Data;
const types = [
  "raw",
  "directory",
  "file",
  "metadata",
  "symlink",
  "hamt-sharded-directory"
];
const dirTypes = [
  "directory",
  "hamt-sharded-directory"
];
const DEFAULT_FILE_MODE = parseInt("0644", 8);
const DEFAULT_DIRECTORY_MODE = parseInt("0755", 8);
function parseMode(mode) {
  if (mode == null) {
    return void 0;
  }
  if (typeof mode === "number") {
    return mode & 4095;
  }
  mode = mode.toString();
  if (mode.substring(0, 1) === "0") {
    return parseInt(mode, 8) & 4095;
  }
  return parseInt(mode, 10) & 4095;
}
function parseMtime$1(input) {
  if (input == null) {
    return void 0;
  }
  let mtime;
  if (input.secs != null) {
    mtime = {
      secs: input.secs,
      nsecs: input.nsecs
    };
  }
  if (input.Seconds != null) {
    mtime = {
      secs: input.Seconds,
      nsecs: input.FractionalNanoseconds
    };
  }
  if (Array.isArray(input)) {
    mtime = {
      secs: input[0],
      nsecs: input[1]
    };
  }
  if (input instanceof Date) {
    const ms2 = input.getTime();
    const secs = Math.floor(ms2 / 1e3);
    mtime = {
      secs,
      nsecs: (ms2 - secs * 1e3) * 1e3
    };
  }
  if (!Object.prototype.hasOwnProperty.call(mtime, "secs")) {
    return void 0;
  }
  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
    throw errCode(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS");
  }
  return mtime;
}
class UnixFS {
  static unmarshal(marshaled) {
    const message2 = PBData.decode(marshaled);
    const decoded = PBData.toObject(message2, {
      defaults: false,
      arrays: true,
      longs: Number,
      objects: false
    });
    const data = new UnixFS({
      type: types[decoded.Type],
      data: decoded.Data,
      blockSizes: decoded.blocksizes,
      mode: decoded.mode,
      mtime: decoded.mtime ? {
        secs: decoded.mtime.Seconds,
        nsecs: decoded.mtime.FractionalNanoseconds
      } : void 0
    });
    data._originalMode = decoded.mode || 0;
    return data;
  }
  constructor(options = {
    type: "file"
  }) {
    const {
      type,
      data,
      blockSizes,
      hashType,
      fanout,
      mtime,
      mode
    } = options;
    if (type && !types.includes(type)) {
      throw errCode(new Error("Type: " + type + " is not valid"), "ERR_INVALID_TYPE");
    }
    this.type = type || "file";
    this.data = data;
    this.hashType = hashType;
    this.fanout = fanout;
    this.blockSizes = blockSizes || [];
    this._originalMode = 0;
    this.mode = parseMode(mode);
    if (mtime) {
      this.mtime = parseMtime$1(mtime);
      if (this.mtime && !this.mtime.nsecs) {
        this.mtime.nsecs = 0;
      }
    }
  }
  set mode(mode) {
    this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE;
    const parsedMode = parseMode(mode);
    if (parsedMode !== void 0) {
      this._mode = parsedMode;
    }
  }
  get mode() {
    return this._mode;
  }
  isDirectory() {
    return Boolean(this.type && dirTypes.includes(this.type));
  }
  addBlockSize(size2) {
    this.blockSizes.push(size2);
  }
  removeBlockSize(index) {
    this.blockSizes.splice(index, 1);
  }
  fileSize() {
    if (this.isDirectory()) {
      return 0;
    }
    let sum = 0;
    this.blockSizes.forEach((size2) => {
      sum += size2;
    });
    if (this.data) {
      sum += this.data.length;
    }
    return sum;
  }
  marshal() {
    let type;
    switch (this.type) {
      case "raw":
        type = PBData.DataType.Raw;
        break;
      case "directory":
        type = PBData.DataType.Directory;
        break;
      case "file":
        type = PBData.DataType.File;
        break;
      case "metadata":
        type = PBData.DataType.Metadata;
        break;
      case "symlink":
        type = PBData.DataType.Symlink;
        break;
      case "hamt-sharded-directory":
        type = PBData.DataType.HAMTShard;
        break;
      default:
        throw errCode(new Error("Type: " + type + " is not valid"), "ERR_INVALID_TYPE");
    }
    let data = this.data;
    if (!this.data || !this.data.length) {
      data = void 0;
    }
    let mode;
    if (this.mode != null) {
      mode = this._originalMode & 4294963200 | (parseMode(this.mode) || 0);
      if (mode === DEFAULT_FILE_MODE && !this.isDirectory()) {
        mode = void 0;
      }
      if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {
        mode = void 0;
      }
    }
    let mtime;
    if (this.mtime != null) {
      const parsed = parseMtime$1(this.mtime);
      if (parsed) {
        mtime = {
          Seconds: parsed.secs,
          FractionalNanoseconds: parsed.nsecs
        };
        if (mtime.FractionalNanoseconds === 0) {
          delete mtime.FractionalNanoseconds;
        }
      }
    }
    const pbData = {
      Type: type,
      Data: data,
      filesize: this.isDirectory() ? void 0 : this.fileSize(),
      blocksizes: this.blockSizes,
      hashType: this.hashType,
      fanout: this.fanout,
      mode,
      mtime
    };
    return PBData.encode(pbData).finish();
  }
}
var encode_1$3 = encode$p;
var MSB$6 = 128, REST$6 = 127, MSBALL$3 = ~REST$6, INT$3 = Math.pow(2, 31);
function encode$p(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT$3) {
    out[offset++] = num & 255 | MSB$6;
    num /= 128;
  }
  while (num & MSBALL$3) {
    out[offset++] = num & 255 | MSB$6;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode$p.bytes = offset - oldOffset + 1;
  return out;
}
var decode$l = read$4;
var MSB$1$2 = 128, REST$1$2 = 127;
function read$4(buf2, offset) {
  var res = 0, offset = offset || 0, shift2 = 0, counter2 = offset, b2, l = buf2.length;
  do {
    if (counter2 >= l) {
      read$4.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b2 = buf2[counter2++];
    res += shift2 < 28 ? (b2 & REST$1$2) << shift2 : (b2 & REST$1$2) * Math.pow(2, shift2);
    shift2 += 7;
  } while (b2 >= MSB$1$2);
  read$4.bytes = counter2 - offset;
  return res;
}
var N1$4 = Math.pow(2, 7);
var N2$4 = Math.pow(2, 14);
var N3$4 = Math.pow(2, 21);
var N4$4 = Math.pow(2, 28);
var N5$4 = Math.pow(2, 35);
var N6$4 = Math.pow(2, 42);
var N7$4 = Math.pow(2, 49);
var N8$4 = Math.pow(2, 56);
var N9$4 = Math.pow(2, 63);
var length$5 = function(value2) {
  return value2 < N1$4 ? 1 : value2 < N2$4 ? 2 : value2 < N3$4 ? 3 : value2 < N4$4 ? 4 : value2 < N5$4 ? 5 : value2 < N6$4 ? 6 : value2 < N7$4 ? 7 : value2 < N8$4 ? 8 : value2 < N9$4 ? 9 : 10;
};
var varint$4 = {
  encode: encode_1$3,
  decode: decode$l,
  encodingLength: length$5
};
var _brrp_varint$1 = varint$4;
const decode$k = (data, offset = 0) => {
  const code2 = _brrp_varint$1.decode(data, offset);
  return [code2, _brrp_varint$1.decode.bytes];
};
const encodeTo$1 = (int2, target, offset = 0) => {
  _brrp_varint$1.encode(int2, target, offset);
  return target;
};
const encodingLength$1 = (int2) => {
  return _brrp_varint$1.encodingLength(int2);
};
const create$8 = (code2, digest2) => {
  const size2 = digest2.byteLength;
  const sizeOffset = encodingLength$1(code2);
  const digestOffset = sizeOffset + encodingLength$1(size2);
  const bytes2 = new Uint8Array(digestOffset + size2);
  encodeTo$1(code2, bytes2, 0);
  encodeTo$1(size2, bytes2, sizeOffset);
  bytes2.set(digest2, digestOffset);
  return new Digest$1(code2, size2, digest2, bytes2);
};
const decode$j = (multihash) => {
  const bytes2 = coerce$1(multihash);
  const [code2, sizeOffset] = decode$k(bytes2);
  const [size2, digestOffset] = decode$k(bytes2.subarray(sizeOffset));
  const digest2 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest2.byteLength !== size2) {
    throw new Error("Incorrect length");
  }
  return new Digest$1(code2, size2, digest2, bytes2);
};
const equals$2 = (a, b2) => {
  if (a === b2) {
    return true;
  } else {
    const data = b2;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals$3(a.bytes, data.bytes);
  }
};
class Digest$1 {
  constructor(code2, size2, digest2, bytes2) {
    this.code = code2;
    this.size = size2;
    this.digest = digest2;
    this.bytes = bytes2;
  }
}
const format$4 = (link, base3) => {
  const { bytes: bytes2, version: version2 } = link;
  switch (version2) {
    case 0:
      return toStringV0(
        bytes2,
        baseCache(link),
        base3 || base58btc$1.encoder
      );
    default:
      return toStringV1(
        bytes2,
        baseCache(link),
        base3 || base32$2.encoder
      );
  }
};
const cache$3 = /* @__PURE__ */ new WeakMap();
const baseCache = (cid) => {
  const baseCache2 = cache$3.get(cid);
  if (baseCache2 == null) {
    const baseCache3 = /* @__PURE__ */ new Map();
    cache$3.set(cid, baseCache3);
    return baseCache3;
  }
  return baseCache2;
};
class CID {
  constructor(version2, code2, multihash, bytes2) {
    this.code = code2;
    this.version = version2;
    this.multihash = multihash;
    this.bytes = bytes2;
    this["/"] = bytes2;
  }
  get asCID() {
    return this;
  }
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code2, multihash } = this;
        if (code2 !== DAG_PB_CODE) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID.createV0(
          multihash
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code2, digest: digest2 } = this.multihash;
        const multihash = create$8(code2, digest2);
        return CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  equals(other) {
    return CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals$2(self2.multihash, unknown.multihash);
  }
  toString(base3) {
    return format$4(this, base3);
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value2 = input;
    if (value2 instanceof CID) {
      return value2;
    } else if (value2["/"] != null && value2["/"] === value2.bytes || value2.asCID === value2) {
      const { version: version2, code: code2, multihash, bytes: bytes2 } = value2;
      return new CID(
        version2,
        code2,
        multihash,
        bytes2 || encodeCID$1(version2, code2, multihash.bytes)
      );
    } else if (value2[cidSymbol] === true) {
      const { version: version2, multihash, code: code2 } = value2;
      const digest2 = decode$j(multihash);
      return CID.create(version2, code2, digest2);
    } else {
      return null;
    }
  }
  static create(version2, code2, digest2) {
    if (typeof code2 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest2.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version2) {
      case 0: {
        if (code2 !== DAG_PB_CODE) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`
          );
        } else {
          return new CID(version2, code2, digest2, digest2.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID$1(version2, code2, digest2.bytes);
        return new CID(version2, code2, digest2, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest2) {
    return CID.create(0, DAG_PB_CODE, digest2);
  }
  static createV1(code2, digest2) {
    return CID.create(1, code2, digest2);
  }
  static decode(bytes2) {
    const [cid, remainder] = CID.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes2) {
    const specs = CID.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce$1(
      bytes2.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest2 = new Digest$1(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? CID.createV0(digest2) : CID.createV1(specs.codec, digest2);
    return [cid, bytes2.subarray(specs.size)];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length3] = decode$k(initialBytes.subarray(offset));
      offset += length3;
      return i2;
    };
    let version2 = next();
    let codec = DAG_PB_CODE;
    if (version2 === 18) {
      version2 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version2 !== 0 && version2 !== 1) {
      throw new RangeError(`Invalid CID version ${version2}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size2 = offset + digestSize;
    const multihashSize = size2 - prefixSize;
    return { version: version2, codec, multihashCode, digestSize, multihashSize, size: size2 };
  }
  static parse(source2, base3) {
    const [prefix, bytes2] = parseCIDtoBytes(source2, base3);
    const cid = CID.decode(bytes2);
    baseCache(cid).set(prefix, source2);
    return cid;
  }
}
const parseCIDtoBytes = (source2, base3) => {
  switch (source2[0]) {
    case "Q": {
      const decoder = base3 || base58btc$1;
      return [
        base58btc$1.prefix,
        decoder.decode(`${base58btc$1.prefix}${source2}`)
      ];
    }
    case base58btc$1.prefix: {
      const decoder = base3 || base58btc$1;
      return [base58btc$1.prefix, decoder.decode(source2)];
    }
    case base32$2.prefix: {
      const decoder = base3 || base32$2;
      return [base32$2.prefix, decoder.decode(source2)];
    }
    default: {
      if (base3 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [source2[0], base3.decode(source2)];
    }
  }
};
const toStringV0 = (bytes2, cache2, base3) => {
  const { prefix } = base3;
  if (prefix !== base58btc$1.prefix) {
    throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
  }
  const cid = cache2.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes2).slice(1);
    cache2.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
const toStringV1 = (bytes2, cache2, base3) => {
  const { prefix } = base3;
  const cid = cache2.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes2);
    cache2.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
const DAG_PB_CODE = 112;
const SHA_256_CODE = 18;
const encodeCID$1 = (version2, code2, multihash) => {
  const codeOffset = encodingLength$1(version2);
  const hashOffset = codeOffset + encodingLength$1(code2);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo$1(version2, bytes2, 0);
  encodeTo$1(code2, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
const cidSymbol = Symbol.for("@ipld/js-cid/CID");
const textDecoder$3 = new TextDecoder();
function decodeVarint(bytes2, offset) {
  let v = 0;
  for (let shift2 = 0; ; shift2 += 7) {
    if (shift2 >= 64) {
      throw new Error("protobuf: varint overflow");
    }
    if (offset >= bytes2.length) {
      throw new Error("protobuf: unexpected end of data");
    }
    const b2 = bytes2[offset++];
    v += shift2 < 28 ? (b2 & 127) << shift2 : (b2 & 127) * 2 ** shift2;
    if (b2 < 128) {
      break;
    }
  }
  return [v, offset];
}
function decodeBytes(bytes2, offset) {
  let byteLen;
  [byteLen, offset] = decodeVarint(bytes2, offset);
  const postOffset = offset + byteLen;
  if (byteLen < 0 || postOffset < 0) {
    throw new Error("protobuf: invalid length");
  }
  if (postOffset > bytes2.length) {
    throw new Error("protobuf: unexpected end of data");
  }
  return [bytes2.subarray(offset, postOffset), postOffset];
}
function decodeKey(bytes2, index) {
  let wire;
  [wire, index] = decodeVarint(bytes2, index);
  return [wire & 7, wire >> 3, index];
}
function decodeLink(bytes2) {
  const link = {};
  const l = bytes2.length;
  let index = 0;
  while (index < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index] = decodeKey(bytes2, index);
    if (fieldNum === 1) {
      if (link.Hash) {
        throw new Error("protobuf: (PBLink) duplicate Hash section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`);
      }
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");
      }
      [link.Hash, index] = decodeBytes(bytes2, index);
    } else if (fieldNum === 2) {
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Name section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`);
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");
      }
      let byts;
      [byts, index] = decodeBytes(bytes2, index);
      link.Name = textDecoder$3.decode(byts);
    } else if (fieldNum === 3) {
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Tsize section");
      }
      if (wireType !== 0) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`);
      }
      [link.Tsize, index] = decodeVarint(bytes2, index);
    } else {
      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`);
    }
  }
  if (index > l) {
    throw new Error("protobuf: (PBLink) unexpected end of data");
  }
  return link;
}
function decodeNode(bytes2) {
  const l = bytes2.length;
  let index = 0;
  let links2;
  let linksBeforeData = false;
  let data;
  while (index < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index] = decodeKey(bytes2, index);
    if (wireType !== 2) {
      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`);
    }
    if (fieldNum === 1) {
      if (data) {
        throw new Error("protobuf: (PBNode) duplicate Data section");
      }
      [data, index] = decodeBytes(bytes2, index);
      if (links2) {
        linksBeforeData = true;
      }
    } else if (fieldNum === 2) {
      if (linksBeforeData) {
        throw new Error("protobuf: (PBNode) duplicate Links section");
      } else if (!links2) {
        links2 = [];
      }
      let byts;
      [byts, index] = decodeBytes(bytes2, index);
      links2.push(decodeLink(byts));
    } else {
      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`);
    }
  }
  if (index > l) {
    throw new Error("protobuf: (PBNode) unexpected end of data");
  }
  const node2 = {};
  if (data) {
    node2.Data = data;
  }
  node2.Links = links2 || [];
  return node2;
}
const textEncoder$5 = new TextEncoder();
const maxInt32 = 2 ** 32;
const maxUInt32 = 2 ** 31;
function encodeLink(link, bytes2) {
  let i2 = bytes2.length;
  if (typeof link.Tsize === "number") {
    if (link.Tsize < 0) {
      throw new Error("Tsize cannot be negative");
    }
    if (!Number.isSafeInteger(link.Tsize)) {
      throw new Error("Tsize too large for encoding");
    }
    i2 = encodeVarint(bytes2, i2, link.Tsize) - 1;
    bytes2[i2] = 24;
  }
  if (typeof link.Name === "string") {
    const nameBytes = textEncoder$5.encode(link.Name);
    i2 -= nameBytes.length;
    bytes2.set(nameBytes, i2);
    i2 = encodeVarint(bytes2, i2, nameBytes.length) - 1;
    bytes2[i2] = 18;
  }
  if (link.Hash) {
    i2 -= link.Hash.length;
    bytes2.set(link.Hash, i2);
    i2 = encodeVarint(bytes2, i2, link.Hash.length) - 1;
    bytes2[i2] = 10;
  }
  return bytes2.length - i2;
}
function encodeNode(node2) {
  const size2 = sizeNode(node2);
  const bytes2 = new Uint8Array(size2);
  let i2 = size2;
  if (node2.Data) {
    i2 -= node2.Data.length;
    bytes2.set(node2.Data, i2);
    i2 = encodeVarint(bytes2, i2, node2.Data.length) - 1;
    bytes2[i2] = 10;
  }
  if (node2.Links) {
    for (let index = node2.Links.length - 1; index >= 0; index--) {
      const size3 = encodeLink(node2.Links[index], bytes2.subarray(0, i2));
      i2 -= size3;
      i2 = encodeVarint(bytes2, i2, size3) - 1;
      bytes2[i2] = 18;
    }
  }
  return bytes2;
}
function sizeLink(link) {
  let n = 0;
  if (link.Hash) {
    const l = link.Hash.length;
    n += 1 + l + sov(l);
  }
  if (typeof link.Name === "string") {
    const l = textEncoder$5.encode(link.Name).length;
    n += 1 + l + sov(l);
  }
  if (typeof link.Tsize === "number") {
    n += 1 + sov(link.Tsize);
  }
  return n;
}
function sizeNode(node2) {
  let n = 0;
  if (node2.Data) {
    const l = node2.Data.length;
    n += 1 + l + sov(l);
  }
  if (node2.Links) {
    for (const link of node2.Links) {
      const l = sizeLink(link);
      n += 1 + l + sov(l);
    }
  }
  return n;
}
function encodeVarint(bytes2, offset, v) {
  offset -= sov(v);
  const base3 = offset;
  while (v >= maxUInt32) {
    bytes2[offset++] = v & 127 | 128;
    v /= 128;
  }
  while (v >= 128) {
    bytes2[offset++] = v & 127 | 128;
    v >>>= 7;
  }
  bytes2[offset] = v;
  return base3;
}
function sov(x) {
  if (x % 2 === 0) {
    x++;
  }
  return Math.floor((len64(x) + 6) / 7);
}
function len64(x) {
  let n = 0;
  if (x >= maxInt32) {
    x = Math.floor(x / maxInt32);
    n = 32;
  }
  if (x >= 1 << 16) {
    x >>>= 16;
    n += 16;
  }
  if (x >= 1 << 8) {
    x >>>= 8;
    n += 8;
  }
  return n + len8tab[x];
}
const len8tab = [
  0,
  1,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8
];
const pbNodeProperties = ["Data", "Links"];
const pbLinkProperties = ["Hash", "Name", "Tsize"];
const textEncoder$4 = new TextEncoder();
function linkComparator(a, b2) {
  if (a === b2) {
    return 0;
  }
  const abuf = a.Name ? textEncoder$4.encode(a.Name) : [];
  const bbuf = b2.Name ? textEncoder$4.encode(b2.Name) : [];
  let x = abuf.length;
  let y = bbuf.length;
  for (let i2 = 0, len2 = Math.min(x, y); i2 < len2; ++i2) {
    if (abuf[i2] !== bbuf[i2]) {
      x = abuf[i2];
      y = bbuf[i2];
      break;
    }
  }
  return x < y ? -1 : y < x ? 1 : 0;
}
function hasOnlyProperties(node2, properties) {
  return !Object.keys(node2).some((p) => !properties.includes(p));
}
function asLink(link) {
  if (typeof link.asCID === "object") {
    const Hash = CID.asCID(link);
    if (!Hash) {
      throw new TypeError("Invalid DAG-PB form");
    }
    return { Hash };
  }
  if (typeof link !== "object" || Array.isArray(link)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbl = {};
  if (link.Hash) {
    let cid = CID.asCID(link.Hash);
    try {
      if (!cid) {
        if (typeof link.Hash === "string") {
          cid = CID.parse(link.Hash);
        } else if (link.Hash instanceof Uint8Array) {
          cid = CID.decode(link.Hash);
        }
      }
    } catch (e) {
      throw new TypeError(`Invalid DAG-PB form: ${e.message}`);
    }
    if (cid) {
      pbl.Hash = cid;
    }
  }
  if (!pbl.Hash) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (typeof link.Name === "string") {
    pbl.Name = link.Name;
  }
  if (typeof link.Tsize === "number") {
    pbl.Tsize = link.Tsize;
  }
  return pbl;
}
function prepare(node2) {
  if (node2 instanceof Uint8Array || typeof node2 === "string") {
    node2 = { Data: node2 };
  }
  if (typeof node2 !== "object" || Array.isArray(node2)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbn = {};
  if (node2.Data !== void 0) {
    if (typeof node2.Data === "string") {
      pbn.Data = textEncoder$4.encode(node2.Data);
    } else if (node2.Data instanceof Uint8Array) {
      pbn.Data = node2.Data;
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  }
  if (node2.Links !== void 0) {
    if (Array.isArray(node2.Links)) {
      pbn.Links = node2.Links.map(asLink);
      pbn.Links.sort(linkComparator);
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  } else {
    pbn.Links = [];
  }
  return pbn;
}
function validate$1(node2) {
  if (!node2 || typeof node2 !== "object" || Array.isArray(node2)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (!hasOnlyProperties(node2, pbNodeProperties)) {
    throw new TypeError("Invalid DAG-PB form (extraneous properties)");
  }
  if (node2.Data !== void 0 && !(node2.Data instanceof Uint8Array)) {
    throw new TypeError("Invalid DAG-PB form (Data must be a Uint8Array)");
  }
  if (!Array.isArray(node2.Links)) {
    throw new TypeError("Invalid DAG-PB form (Links must be an array)");
  }
  for (let i2 = 0; i2 < node2.Links.length; i2++) {
    const link = node2.Links[i2];
    if (!link || typeof link !== "object" || Array.isArray(link)) {
      throw new TypeError("Invalid DAG-PB form (bad link object)");
    }
    if (!hasOnlyProperties(link, pbLinkProperties)) {
      throw new TypeError("Invalid DAG-PB form (extraneous properties on link object)");
    }
    if (!link.Hash) {
      throw new TypeError("Invalid DAG-PB form (link must have a Hash)");
    }
    if (link.Hash.asCID !== link.Hash) {
      throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");
    }
    if (link.Name !== void 0 && typeof link.Name !== "string") {
      throw new TypeError("Invalid DAG-PB form (link Name must be a string)");
    }
    if (link.Tsize !== void 0 && (typeof link.Tsize !== "number" || link.Tsize % 1 !== 0)) {
      throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");
    }
    if (i2 > 0 && linkComparator(link, node2.Links[i2 - 1]) === -1) {
      throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)");
    }
  }
}
function createNode$2(data, links2 = []) {
  return prepare({ Data: data, Links: links2 });
}
function createLink(name2, size2, cid) {
  return asLink({ Hash: cid, Name: name2, Tsize: size2 });
}
const name$8 = "dag-pb";
const code$8 = 112;
function encode$o(node2) {
  validate$1(node2);
  const pbn = {};
  if (node2.Links) {
    pbn.Links = node2.Links.map((l) => {
      const link = {};
      if (l.Hash) {
        link.Hash = l.Hash.bytes;
      }
      if (l.Name !== void 0) {
        link.Name = l.Name;
      }
      if (l.Tsize !== void 0) {
        link.Tsize = l.Tsize;
      }
      return link;
    });
  }
  if (node2.Data) {
    pbn.Data = node2.Data;
  }
  return encodeNode(pbn);
}
function decode$i(bytes2) {
  const pbn = decodeNode(bytes2);
  const node2 = {};
  if (pbn.Data) {
    node2.Data = pbn.Data;
  }
  if (pbn.Links) {
    node2.Links = pbn.Links.map((l) => {
      const link = {};
      try {
        link.Hash = CID.decode(l.Hash);
      } catch (e) {
      }
      if (!link.Hash) {
        throw new Error("Invalid Hash field found in link, expected CID");
      }
      if (l.Name !== void 0) {
        link.Name = l.Name;
      }
      if (l.Tsize !== void 0) {
        link.Tsize = l.Tsize;
      }
      return link;
    });
  }
  return node2;
}
const dagPB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  name: name$8,
  code: code$8,
  encode: encode$o,
  decode: decode$i,
  prepare,
  validate: validate$1,
  createNode: createNode$2,
  createLink
}, Symbol.toStringTag, { value: "Module" }));
const typeofs = [
  "string",
  "number",
  "bigint",
  "symbol"
];
const objectTypeNames = [
  "Function",
  "Generator",
  "AsyncGenerator",
  "GeneratorFunction",
  "AsyncGeneratorFunction",
  "AsyncFunction",
  "Observable",
  "Array",
  "Buffer",
  "Object",
  "RegExp",
  "Date",
  "Error",
  "Map",
  "Set",
  "WeakMap",
  "WeakSet",
  "ArrayBuffer",
  "SharedArrayBuffer",
  "DataView",
  "Promise",
  "URL",
  "HTMLElement",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Uint16Array",
  "Int32Array",
  "Uint32Array",
  "Float32Array",
  "Float64Array",
  "BigInt64Array",
  "BigUint64Array"
];
function is(value2) {
  if (value2 === null) {
    return "null";
  }
  if (value2 === void 0) {
    return "undefined";
  }
  if (value2 === true || value2 === false) {
    return "boolean";
  }
  const typeOf2 = typeof value2;
  if (typeofs.includes(typeOf2)) {
    return typeOf2;
  }
  if (typeOf2 === "function") {
    return "Function";
  }
  if (Array.isArray(value2)) {
    return "Array";
  }
  if (isBuffer$1(value2)) {
    return "Buffer";
  }
  const objectType = getObjectType(value2);
  if (objectType) {
    return objectType;
  }
  return "Object";
}
function isBuffer$1(value2) {
  return value2 && value2.constructor && value2.constructor.isBuffer && value2.constructor.isBuffer.call(null, value2);
}
function getObjectType(value2) {
  const objectTypeName = Object.prototype.toString.call(value2).slice(8, -1);
  if (objectTypeNames.includes(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}
class Type {
  constructor(major, name2, terminal) {
    this.major = major;
    this.majorEncoded = major << 5;
    this.name = name2;
    this.terminal = terminal;
  }
  toString() {
    return `Type[${this.major}].${this.name}`;
  }
  compare(typ) {
    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
  }
}
Type.uint = new Type(0, "uint", true);
Type.negint = new Type(1, "negint", true);
Type.bytes = new Type(2, "bytes", true);
Type.string = new Type(3, "string", true);
Type.array = new Type(4, "array", false);
Type.map = new Type(5, "map", false);
Type.tag = new Type(6, "tag", false);
Type.float = new Type(7, "float", true);
Type.false = new Type(7, "false", true);
Type.true = new Type(7, "true", true);
Type.null = new Type(7, "null", true);
Type.undefined = new Type(7, "undefined", true);
Type.break = new Type(7, "break", true);
class Token {
  constructor(type, value2, encodedLength) {
    this.type = type;
    this.value = value2;
    this.encodedLength = encodedLength;
    this.encodedBytes = void 0;
    this.byteValue = void 0;
  }
  toString() {
    return `Token[${this.type}].${this.value}`;
  }
}
const useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === "function";
const textDecoder$2 = new TextDecoder();
const textEncoder$3 = new TextEncoder();
function isBuffer(buf2) {
  return useBuffer && globalThis.Buffer.isBuffer(buf2);
}
function asU8A(buf2) {
  if (!(buf2 instanceof Uint8Array)) {
    return Uint8Array.from(buf2);
  }
  return isBuffer(buf2) ? new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength) : buf2;
}
const toString$6 = useBuffer ? (bytes2, start, end2) => {
  return end2 - start > 64 ? globalThis.Buffer.from(bytes2.subarray(start, end2)).toString("utf8") : utf8Slice(bytes2, start, end2);
} : (bytes2, start, end2) => {
  return end2 - start > 64 ? textDecoder$2.decode(bytes2.subarray(start, end2)) : utf8Slice(bytes2, start, end2);
};
const fromString$4 = useBuffer ? (string2) => {
  return string2.length > 64 ? globalThis.Buffer.from(string2) : utf8ToBytes(string2);
} : (string2) => {
  return string2.length > 64 ? textEncoder$3.encode(string2) : utf8ToBytes(string2);
};
const fromArray = (arr) => {
  return Uint8Array.from(arr);
};
const slice = useBuffer ? (bytes2, start, end2) => {
  if (isBuffer(bytes2)) {
    return new Uint8Array(bytes2.subarray(start, end2));
  }
  return bytes2.slice(start, end2);
} : (bytes2, start, end2) => {
  return bytes2.slice(start, end2);
};
const concat$2 = useBuffer ? (chunks, length3) => {
  chunks = chunks.map((c) => c instanceof Uint8Array ? c : globalThis.Buffer.from(c));
  return asU8A(globalThis.Buffer.concat(chunks, length3));
} : (chunks, length3) => {
  const out = new Uint8Array(length3);
  let off2 = 0;
  for (let b2 of chunks) {
    if (off2 + b2.length > out.length) {
      b2 = b2.subarray(0, out.length - off2);
    }
    out.set(b2, off2);
    off2 += b2.length;
  }
  return out;
};
const alloc$1 = useBuffer ? (size2) => {
  return globalThis.Buffer.allocUnsafe(size2);
} : (size2) => {
  return new Uint8Array(size2);
};
function compare$2(b1, b2) {
  if (isBuffer(b1) && isBuffer(b2)) {
    return b1.compare(b2);
  }
  for (let i2 = 0; i2 < b1.length; i2++) {
    if (b1[i2] === b2[i2]) {
      continue;
    }
    return b1[i2] < b2[i2] ? -1 : 1;
  }
  return 0;
}
function utf8ToBytes(string2, units = Infinity) {
  let codePoint;
  const length3 = string2.length;
  let leadSurrogate = null;
  const bytes2 = [];
  for (let i2 = 0; i2 < length3; ++i2) {
    codePoint = string2.charCodeAt(i2);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          continue;
        } else if (i2 + 1 === length3) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes2.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes2.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes2.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes2.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes2.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes2.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes2;
}
function utf8Slice(buf2, offset, end2) {
  const res = [];
  while (offset < end2) {
    const firstByte = buf2[offset];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (offset + bytesPerSequence <= end2) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf2[offset + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          fourthByte = buf2[offset + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    offset += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
const MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  const len2 = codePoints.length;
  if (len2 <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i2 = 0;
  while (i2 < len2) {
    res += String.fromCharCode.apply(String, codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
const defaultChunkSize = 256;
class Bl {
  constructor(chunkSize = defaultChunkSize) {
    this.chunkSize = chunkSize;
    this.cursor = 0;
    this.maxCursor = -1;
    this.chunks = [];
    this._initReuseChunk = null;
  }
  reset() {
    this.cursor = 0;
    this.maxCursor = -1;
    if (this.chunks.length) {
      this.chunks = [];
    }
    if (this._initReuseChunk !== null) {
      this.chunks.push(this._initReuseChunk);
      this.maxCursor = this._initReuseChunk.length - 1;
    }
  }
  push(bytes2) {
    let topChunk = this.chunks[this.chunks.length - 1];
    const newMax = this.cursor + bytes2.length;
    if (newMax <= this.maxCursor + 1) {
      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
      topChunk.set(bytes2, chunkPos);
    } else {
      if (topChunk) {
        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
        if (chunkPos < topChunk.length) {
          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
          this.maxCursor = this.cursor - 1;
        }
      }
      if (bytes2.length < 64 && bytes2.length < this.chunkSize) {
        topChunk = alloc$1(this.chunkSize);
        this.chunks.push(topChunk);
        this.maxCursor += topChunk.length;
        if (this._initReuseChunk === null) {
          this._initReuseChunk = topChunk;
        }
        topChunk.set(bytes2, 0);
      } else {
        this.chunks.push(bytes2);
        this.maxCursor += bytes2.length;
      }
    }
    this.cursor += bytes2.length;
  }
  toBytes(reset2 = false) {
    let byts;
    if (this.chunks.length === 1) {
      const chunk = this.chunks[0];
      if (reset2 && this.cursor > chunk.length / 2) {
        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
        this._initReuseChunk = null;
        this.chunks = [];
      } else {
        byts = slice(chunk, 0, this.cursor);
      }
    } else {
      byts = concat$2(this.chunks, this.cursor);
    }
    if (reset2) {
      this.reset();
    }
    return byts;
  }
}
const decodeErrPrefix = "CBOR decode error:";
const encodeErrPrefix = "CBOR encode error:";
function assertEnoughData(data, pos, need) {
  if (data.length - pos < need) {
    throw new Error(`${decodeErrPrefix} not enough data for type`);
  }
}
const uintBoundaries = [
  24,
  256,
  65536,
  4294967296,
  BigInt("18446744073709551616")
];
function readUint8(data, offset, options) {
  assertEnoughData(data, offset, 1);
  const value2 = data[offset];
  if (options.strict === true && value2 < uintBoundaries[0]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value2;
}
function readUint16(data, offset, options) {
  assertEnoughData(data, offset, 2);
  const value2 = data[offset] << 8 | data[offset + 1];
  if (options.strict === true && value2 < uintBoundaries[1]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value2;
}
function readUint32(data, offset, options) {
  assertEnoughData(data, offset, 4);
  const value2 = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  if (options.strict === true && value2 < uintBoundaries[2]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value2;
}
function readUint64(data, offset, options) {
  assertEnoughData(data, offset, 8);
  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
  const value2 = (BigInt(hi) << BigInt(32)) + BigInt(lo);
  if (options.strict === true && value2 < uintBoundaries[3]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  if (value2 <= Number.MAX_SAFE_INTEGER) {
    return Number(value2);
  }
  if (options.allowBigInt === true) {
    return value2;
  }
  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
}
function decodeUint8(data, pos, _minor, options) {
  return new Token(Type.uint, readUint8(data, pos + 1, options), 2);
}
function decodeUint16(data, pos, _minor, options) {
  return new Token(Type.uint, readUint16(data, pos + 1, options), 3);
}
function decodeUint32(data, pos, _minor, options) {
  return new Token(Type.uint, readUint32(data, pos + 1, options), 5);
}
function decodeUint64(data, pos, _minor, options) {
  return new Token(Type.uint, readUint64(data, pos + 1, options), 9);
}
function encodeUint(buf2, token) {
  return encodeUintValue(buf2, 0, token.value);
}
function encodeUintValue(buf2, major, uint) {
  if (uint < uintBoundaries[0]) {
    const nuint = Number(uint);
    buf2.push([major | nuint]);
  } else if (uint < uintBoundaries[1]) {
    const nuint = Number(uint);
    buf2.push([
      major | 24,
      nuint
    ]);
  } else if (uint < uintBoundaries[2]) {
    const nuint = Number(uint);
    buf2.push([
      major | 25,
      nuint >>> 8,
      nuint & 255
    ]);
  } else if (uint < uintBoundaries[3]) {
    const nuint = Number(uint);
    buf2.push([
      major | 26,
      nuint >>> 24 & 255,
      nuint >>> 16 & 255,
      nuint >>> 8 & 255,
      nuint & 255
    ]);
  } else {
    const buint = BigInt(uint);
    if (buint < uintBoundaries[4]) {
      const set2 = [
        major | 27,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      let lo = Number(buint & BigInt(4294967295));
      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
      set2[8] = lo & 255;
      lo = lo >> 8;
      set2[7] = lo & 255;
      lo = lo >> 8;
      set2[6] = lo & 255;
      lo = lo >> 8;
      set2[5] = lo & 255;
      set2[4] = hi & 255;
      hi = hi >> 8;
      set2[3] = hi & 255;
      hi = hi >> 8;
      set2[2] = hi & 255;
      hi = hi >> 8;
      set2[1] = hi & 255;
      buf2.push(set2);
    } else {
      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
    }
  }
}
encodeUint.encodedSize = function encodedSize(token) {
  return encodeUintValue.encodedSize(token.value);
};
encodeUintValue.encodedSize = function encodedSize2(uint) {
  if (uint < uintBoundaries[0]) {
    return 1;
  }
  if (uint < uintBoundaries[1]) {
    return 2;
  }
  if (uint < uintBoundaries[2]) {
    return 3;
  }
  if (uint < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeUint.compareTokens = function compareTokens(tok1, tok2) {
  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;
};
function decodeNegint8(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint8(data, pos + 1, options), 2);
}
function decodeNegint16(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint16(data, pos + 1, options), 3);
}
function decodeNegint32(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint32(data, pos + 1, options), 5);
}
const neg1b = BigInt(-1);
const pos1b = BigInt(1);
function decodeNegint64(data, pos, _minor, options) {
  const int2 = readUint64(data, pos + 1, options);
  if (typeof int2 !== "bigint") {
    const value2 = -1 - int2;
    if (value2 >= Number.MIN_SAFE_INTEGER) {
      return new Token(Type.negint, value2, 9);
    }
  }
  if (options.allowBigInt !== true) {
    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
  }
  return new Token(Type.negint, neg1b - BigInt(int2), 9);
}
function encodeNegint(buf2, token) {
  const negint = token.value;
  const unsigned2 = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  encodeUintValue(buf2, token.type.majorEncoded, unsigned2);
}
encodeNegint.encodedSize = function encodedSize3(token) {
  const negint = token.value;
  const unsigned2 = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  if (unsigned2 < uintBoundaries[0]) {
    return 1;
  }
  if (unsigned2 < uintBoundaries[1]) {
    return 2;
  }
  if (unsigned2 < uintBoundaries[2]) {
    return 3;
  }
  if (unsigned2 < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeNegint.compareTokens = function compareTokens2(tok1, tok2) {
  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : 0;
};
function toToken$3(data, pos, prefix, length3) {
  assertEnoughData(data, pos, prefix + length3);
  const buf2 = slice(data, pos + prefix, pos + prefix + length3);
  return new Token(Type.bytes, buf2, prefix + length3);
}
function decodeBytesCompact(data, pos, minor, _options) {
  return toToken$3(data, pos, 1, minor);
}
function decodeBytes8(data, pos, _minor, options) {
  return toToken$3(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeBytes16(data, pos, _minor, options) {
  return toToken$3(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeBytes32(data, pos, _minor, options) {
  return toToken$3(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeBytes64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
  }
  return toToken$3(data, pos, 9, l);
}
function tokenBytes(token) {
  if (token.encodedBytes === void 0) {
    token.encodedBytes = token.type === Type.string ? fromString$4(token.value) : token.value;
  }
  return token.encodedBytes;
}
function encodeBytes(buf2, token) {
  const bytes2 = tokenBytes(token);
  encodeUintValue(buf2, token.type.majorEncoded, bytes2.length);
  buf2.push(bytes2);
}
encodeBytes.encodedSize = function encodedSize4(token) {
  const bytes2 = tokenBytes(token);
  return encodeUintValue.encodedSize(bytes2.length) + bytes2.length;
};
encodeBytes.compareTokens = function compareTokens3(tok1, tok2) {
  return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
};
function compareBytes(b1, b2) {
  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare$2(b1, b2);
}
function toToken$2(data, pos, prefix, length3, options) {
  const totLength = prefix + length3;
  assertEnoughData(data, pos, totLength);
  const tok = new Token(Type.string, toString$6(data, pos + prefix, pos + totLength), totLength);
  if (options.retainStringBytes === true) {
    tok.byteValue = slice(data, pos + prefix, pos + totLength);
  }
  return tok;
}
function decodeStringCompact(data, pos, minor, options) {
  return toToken$2(data, pos, 1, minor, options);
}
function decodeString8(data, pos, _minor, options) {
  return toToken$2(data, pos, 2, readUint8(data, pos + 1, options), options);
}
function decodeString16(data, pos, _minor, options) {
  return toToken$2(data, pos, 3, readUint16(data, pos + 1, options), options);
}
function decodeString32(data, pos, _minor, options) {
  return toToken$2(data, pos, 5, readUint32(data, pos + 1, options), options);
}
function decodeString64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
  }
  return toToken$2(data, pos, 9, l, options);
}
const encodeString = encodeBytes;
function toToken$1(_data, _pos, prefix, length3) {
  return new Token(Type.array, length3, prefix);
}
function decodeArrayCompact(data, pos, minor, _options) {
  return toToken$1(data, pos, 1, minor);
}
function decodeArray8(data, pos, _minor, options) {
  return toToken$1(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeArray16(data, pos, _minor, options) {
  return toToken$1(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeArray32(data, pos, _minor, options) {
  return toToken$1(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeArray64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
  }
  return toToken$1(data, pos, 9, l);
}
function decodeArrayIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken$1(data, pos, 1, Infinity);
}
function encodeArray(buf2, token) {
  encodeUintValue(buf2, Type.array.majorEncoded, token.value);
}
encodeArray.compareTokens = encodeUint.compareTokens;
encodeArray.encodedSize = function encodedSize5(token) {
  return encodeUintValue.encodedSize(token.value);
};
function toToken(_data, _pos, prefix, length3) {
  return new Token(Type.map, length3, prefix);
}
function decodeMapCompact(data, pos, minor, _options) {
  return toToken(data, pos, 1, minor);
}
function decodeMap8(data, pos, _minor, options) {
  return toToken(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeMap16(data, pos, _minor, options) {
  return toToken(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeMap32(data, pos, _minor, options) {
  return toToken(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeMap64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
  }
  return toToken(data, pos, 9, l);
}
function decodeMapIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken(data, pos, 1, Infinity);
}
function encodeMap(buf2, token) {
  encodeUintValue(buf2, Type.map.majorEncoded, token.value);
}
encodeMap.compareTokens = encodeUint.compareTokens;
encodeMap.encodedSize = function encodedSize6(token) {
  return encodeUintValue.encodedSize(token.value);
};
function decodeTagCompact(_data, _pos, minor, _options) {
  return new Token(Type.tag, minor, 1);
}
function decodeTag8(data, pos, _minor, options) {
  return new Token(Type.tag, readUint8(data, pos + 1, options), 2);
}
function decodeTag16(data, pos, _minor, options) {
  return new Token(Type.tag, readUint16(data, pos + 1, options), 3);
}
function decodeTag32(data, pos, _minor, options) {
  return new Token(Type.tag, readUint32(data, pos + 1, options), 5);
}
function decodeTag64(data, pos, _minor, options) {
  return new Token(Type.tag, readUint64(data, pos + 1, options), 9);
}
function encodeTag(buf2, token) {
  encodeUintValue(buf2, Type.tag.majorEncoded, token.value);
}
encodeTag.compareTokens = encodeUint.compareTokens;
encodeTag.encodedSize = function encodedSize7(token) {
  return encodeUintValue.encodedSize(token.value);
};
const MINOR_FALSE = 20;
const MINOR_TRUE = 21;
const MINOR_NULL = 22;
const MINOR_UNDEFINED = 23;
function decodeUndefined(_data, _pos, _minor, options) {
  if (options.allowUndefined === false) {
    throw new Error(`${decodeErrPrefix} undefined values are not supported`);
  } else if (options.coerceUndefinedToNull === true) {
    return new Token(Type.null, null, 1);
  }
  return new Token(Type.undefined, void 0, 1);
}
function decodeBreak(_data, _pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return new Token(Type.break, void 0, 1);
}
function createToken(value2, bytes2, options) {
  if (options) {
    if (options.allowNaN === false && Number.isNaN(value2)) {
      throw new Error(`${decodeErrPrefix} NaN values are not supported`);
    }
    if (options.allowInfinity === false && (value2 === Infinity || value2 === -Infinity)) {
      throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
    }
  }
  return new Token(Type.float, value2, bytes2);
}
function decodeFloat16(data, pos, _minor, options) {
  return createToken(readFloat16(data, pos + 1), 3, options);
}
function decodeFloat32(data, pos, _minor, options) {
  return createToken(readFloat32(data, pos + 1), 5, options);
}
function decodeFloat64(data, pos, _minor, options) {
  return createToken(readFloat64(data, pos + 1), 9, options);
}
function encodeFloat(buf2, token, options) {
  const float2 = token.value;
  if (float2 === false) {
    buf2.push([Type.float.majorEncoded | MINOR_FALSE]);
  } else if (float2 === true) {
    buf2.push([Type.float.majorEncoded | MINOR_TRUE]);
  } else if (float2 === null) {
    buf2.push([Type.float.majorEncoded | MINOR_NULL]);
  } else if (float2 === void 0) {
    buf2.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
  } else {
    let decoded;
    let success = false;
    if (!options || options.float64 !== true) {
      encodeFloat16(float2);
      decoded = readFloat16(ui8a, 1);
      if (float2 === decoded || Number.isNaN(float2)) {
        ui8a[0] = 249;
        buf2.push(ui8a.slice(0, 3));
        success = true;
      } else {
        encodeFloat32(float2);
        decoded = readFloat32(ui8a, 1);
        if (float2 === decoded) {
          ui8a[0] = 250;
          buf2.push(ui8a.slice(0, 5));
          success = true;
        }
      }
    }
    if (!success) {
      encodeFloat64(float2);
      decoded = readFloat64(ui8a, 1);
      ui8a[0] = 251;
      buf2.push(ui8a.slice(0, 9));
    }
  }
}
encodeFloat.encodedSize = function encodedSize8(token, options) {
  const float2 = token.value;
  if (float2 === false || float2 === true || float2 === null || float2 === void 0) {
    return 1;
  }
  if (!options || options.float64 !== true) {
    encodeFloat16(float2);
    let decoded = readFloat16(ui8a, 1);
    if (float2 === decoded || Number.isNaN(float2)) {
      return 3;
    }
    encodeFloat32(float2);
    decoded = readFloat32(ui8a, 1);
    if (float2 === decoded) {
      return 5;
    }
  }
  return 9;
};
const buffer$1 = new ArrayBuffer(9);
const dataView = new DataView(buffer$1, 1);
const ui8a = new Uint8Array(buffer$1, 0);
function encodeFloat16(inp) {
  if (inp === Infinity) {
    dataView.setUint16(0, 31744, false);
  } else if (inp === -Infinity) {
    dataView.setUint16(0, 64512, false);
  } else if (Number.isNaN(inp)) {
    dataView.setUint16(0, 32256, false);
  } else {
    dataView.setFloat32(0, inp);
    const valu32 = dataView.getUint32(0);
    const exponent = (valu32 & 2139095040) >> 23;
    const mantissa = valu32 & 8388607;
    if (exponent === 255) {
      dataView.setUint16(0, 31744, false);
    } else if (exponent === 0) {
      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
    } else {
      const logicalExponent = exponent - 127;
      if (logicalExponent < -24) {
        dataView.setUint16(0, 0);
      } else if (logicalExponent < -14) {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | 1 << 24 + logicalExponent, false);
      } else {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
      }
    }
  }
}
function readFloat16(ui8a2, pos) {
  if (ui8a2.length - pos < 2) {
    throw new Error(`${decodeErrPrefix} not enough data for float16`);
  }
  const half = (ui8a2[pos] << 8) + ui8a2[pos + 1];
  if (half === 31744) {
    return Infinity;
  }
  if (half === 64512) {
    return -Infinity;
  }
  if (half === 32256) {
    return NaN;
  }
  const exp = half >> 10 & 31;
  const mant = half & 1023;
  let val;
  if (exp === 0) {
    val = mant * 2 ** -24;
  } else if (exp !== 31) {
    val = (mant + 1024) * 2 ** (exp - 25);
  } else {
    val = mant === 0 ? Infinity : NaN;
  }
  return half & 32768 ? -val : val;
}
function encodeFloat32(inp) {
  dataView.setFloat32(0, inp, false);
}
function readFloat32(ui8a2, pos) {
  if (ui8a2.length - pos < 4) {
    throw new Error(`${decodeErrPrefix} not enough data for float32`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 4).getFloat32(0, false);
}
function encodeFloat64(inp) {
  dataView.setFloat64(0, inp, false);
}
function readFloat64(ui8a2, pos) {
  if (ui8a2.length - pos < 8) {
    throw new Error(`${decodeErrPrefix} not enough data for float64`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 8).getFloat64(0, false);
}
encodeFloat.compareTokens = encodeUint.compareTokens;
function invalidMinor(data, pos, minor) {
  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
}
function errorer(msg) {
  return () => {
    throw new Error(`${decodeErrPrefix} ${msg}`);
  };
}
const jump = [];
for (let i2 = 0; i2 <= 23; i2++) {
  jump[i2] = invalidMinor;
}
jump[24] = decodeUint8;
jump[25] = decodeUint16;
jump[26] = decodeUint32;
jump[27] = decodeUint64;
jump[28] = invalidMinor;
jump[29] = invalidMinor;
jump[30] = invalidMinor;
jump[31] = invalidMinor;
for (let i2 = 32; i2 <= 55; i2++) {
  jump[i2] = invalidMinor;
}
jump[56] = decodeNegint8;
jump[57] = decodeNegint16;
jump[58] = decodeNegint32;
jump[59] = decodeNegint64;
jump[60] = invalidMinor;
jump[61] = invalidMinor;
jump[62] = invalidMinor;
jump[63] = invalidMinor;
for (let i2 = 64; i2 <= 87; i2++) {
  jump[i2] = decodeBytesCompact;
}
jump[88] = decodeBytes8;
jump[89] = decodeBytes16;
jump[90] = decodeBytes32;
jump[91] = decodeBytes64;
jump[92] = invalidMinor;
jump[93] = invalidMinor;
jump[94] = invalidMinor;
jump[95] = errorer("indefinite length bytes/strings are not supported");
for (let i2 = 96; i2 <= 119; i2++) {
  jump[i2] = decodeStringCompact;
}
jump[120] = decodeString8;
jump[121] = decodeString16;
jump[122] = decodeString32;
jump[123] = decodeString64;
jump[124] = invalidMinor;
jump[125] = invalidMinor;
jump[126] = invalidMinor;
jump[127] = errorer("indefinite length bytes/strings are not supported");
for (let i2 = 128; i2 <= 151; i2++) {
  jump[i2] = decodeArrayCompact;
}
jump[152] = decodeArray8;
jump[153] = decodeArray16;
jump[154] = decodeArray32;
jump[155] = decodeArray64;
jump[156] = invalidMinor;
jump[157] = invalidMinor;
jump[158] = invalidMinor;
jump[159] = decodeArrayIndefinite;
for (let i2 = 160; i2 <= 183; i2++) {
  jump[i2] = decodeMapCompact;
}
jump[184] = decodeMap8;
jump[185] = decodeMap16;
jump[186] = decodeMap32;
jump[187] = decodeMap64;
jump[188] = invalidMinor;
jump[189] = invalidMinor;
jump[190] = invalidMinor;
jump[191] = decodeMapIndefinite;
for (let i2 = 192; i2 <= 215; i2++) {
  jump[i2] = decodeTagCompact;
}
jump[216] = decodeTag8;
jump[217] = decodeTag16;
jump[218] = decodeTag32;
jump[219] = decodeTag64;
jump[220] = invalidMinor;
jump[221] = invalidMinor;
jump[222] = invalidMinor;
jump[223] = invalidMinor;
for (let i2 = 224; i2 <= 243; i2++) {
  jump[i2] = errorer("simple values are not supported");
}
jump[244] = invalidMinor;
jump[245] = invalidMinor;
jump[246] = invalidMinor;
jump[247] = decodeUndefined;
jump[248] = errorer("simple values are not supported");
jump[249] = decodeFloat16;
jump[250] = decodeFloat32;
jump[251] = decodeFloat64;
jump[252] = invalidMinor;
jump[253] = invalidMinor;
jump[254] = invalidMinor;
jump[255] = decodeBreak;
const quick = [];
for (let i2 = 0; i2 < 24; i2++) {
  quick[i2] = new Token(Type.uint, i2, 1);
}
for (let i2 = -1; i2 >= -24; i2--) {
  quick[31 - i2] = new Token(Type.negint, i2, 1);
}
quick[64] = new Token(Type.bytes, new Uint8Array(0), 1);
quick[96] = new Token(Type.string, "", 1);
quick[128] = new Token(Type.array, 0, 1);
quick[160] = new Token(Type.map, 0, 1);
quick[244] = new Token(Type.false, false, 1);
quick[245] = new Token(Type.true, true, 1);
quick[246] = new Token(Type.null, null, 1);
function quickEncodeToken(token) {
  switch (token.type) {
    case Type.false:
      return fromArray([244]);
    case Type.true:
      return fromArray([245]);
    case Type.null:
      return fromArray([246]);
    case Type.bytes:
      if (!token.value.length) {
        return fromArray([64]);
      }
      return;
    case Type.string:
      if (token.value === "") {
        return fromArray([96]);
      }
      return;
    case Type.array:
      if (token.value === 0) {
        return fromArray([128]);
      }
      return;
    case Type.map:
      if (token.value === 0) {
        return fromArray([160]);
      }
      return;
    case Type.uint:
      if (token.value < 24) {
        return fromArray([Number(token.value)]);
      }
      return;
    case Type.negint:
      if (token.value >= -24) {
        return fromArray([31 - Number(token.value)]);
      }
  }
}
const defaultEncodeOptions$1 = {
  float64: false,
  mapSorter: mapSorter$1,
  quickEncodeToken
};
function makeCborEncoders() {
  const encoders = [];
  encoders[Type.uint.major] = encodeUint;
  encoders[Type.negint.major] = encodeNegint;
  encoders[Type.bytes.major] = encodeBytes;
  encoders[Type.string.major] = encodeString;
  encoders[Type.array.major] = encodeArray;
  encoders[Type.map.major] = encodeMap;
  encoders[Type.tag.major] = encodeTag;
  encoders[Type.float.major] = encodeFloat;
  return encoders;
}
const cborEncoders = makeCborEncoders();
const buf = new Bl();
class Ref {
  constructor(obj, parent2) {
    this.obj = obj;
    this.parent = parent2;
  }
  includes(obj) {
    let p = this;
    do {
      if (p.obj === obj) {
        return true;
      }
    } while (p = p.parent);
    return false;
  }
  static createCheck(stack, obj) {
    if (stack && stack.includes(obj)) {
      throw new Error(`${encodeErrPrefix} object contains circular references`);
    }
    return new Ref(obj, stack);
  }
}
const simpleTokens = {
  null: new Token(Type.null, null),
  undefined: new Token(Type.undefined, void 0),
  true: new Token(Type.true, true),
  false: new Token(Type.false, false),
  emptyArray: new Token(Type.array, 0),
  emptyMap: new Token(Type.map, 0)
};
const typeEncoders = {
  number(obj, _typ, _options, _refStack) {
    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
      return new Token(Type.float, obj);
    } else if (obj >= 0) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  bigint(obj, _typ, _options, _refStack) {
    if (obj >= BigInt(0)) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  Uint8Array(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, obj);
  },
  string(obj, _typ, _options, _refStack) {
    return new Token(Type.string, obj);
  },
  boolean(obj, _typ, _options, _refStack) {
    return obj ? simpleTokens.true : simpleTokens.false;
  },
  null(_obj, _typ, _options, _refStack) {
    return simpleTokens.null;
  },
  undefined(_obj, _typ, _options, _refStack) {
    return simpleTokens.undefined;
  },
  ArrayBuffer(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj));
  },
  DataView(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
  },
  Array(obj, _typ, options, refStack) {
    if (!obj.length) {
      if (options.addBreakTokens === true) {
        return [
          simpleTokens.emptyArray,
          new Token(Type.break)
        ];
      }
      return simpleTokens.emptyArray;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i2 = 0;
    for (const e of obj) {
      entries[i2++] = objectToTokens(e, options, refStack);
    }
    if (options.addBreakTokens) {
      return [
        new Token(Type.array, obj.length),
        entries,
        new Token(Type.break)
      ];
    }
    return [
      new Token(Type.array, obj.length),
      entries
    ];
  },
  Object(obj, typ, options, refStack) {
    const isMap = typ !== "Object";
    const keys = isMap ? obj.keys() : Object.keys(obj);
    const length3 = isMap ? obj.size : keys.length;
    if (!length3) {
      if (options.addBreakTokens === true) {
        return [
          simpleTokens.emptyMap,
          new Token(Type.break)
        ];
      }
      return simpleTokens.emptyMap;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i2 = 0;
    for (const key of keys) {
      entries[i2++] = [
        objectToTokens(key, options, refStack),
        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)
      ];
    }
    sortMapEntries(entries, options);
    if (options.addBreakTokens) {
      return [
        new Token(Type.map, length3),
        entries,
        new Token(Type.break)
      ];
    }
    return [
      new Token(Type.map, length3),
      entries
    ];
  }
};
typeEncoders.Map = typeEncoders.Object;
typeEncoders.Buffer = typeEncoders.Uint8Array;
for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
  typeEncoders[`${typ}Array`] = typeEncoders.DataView;
}
function objectToTokens(obj, options = {}, refStack) {
  const typ = is(obj);
  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];
  if (typeof customTypeEncoder === "function") {
    const tokens = customTypeEncoder(obj, typ, options, refStack);
    if (tokens != null) {
      return tokens;
    }
  }
  const typeEncoder = typeEncoders[typ];
  if (!typeEncoder) {
    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);
  }
  return typeEncoder(obj, typ, options, refStack);
}
function sortMapEntries(entries, options) {
  if (options.mapSorter) {
    entries.sort(options.mapSorter);
  }
}
function mapSorter$1(e1, e2) {
  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
  if (keyToken1.type !== keyToken2.type) {
    return keyToken1.type.compare(keyToken2.type);
  }
  const major = keyToken1.type.major;
  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);
  if (tcmp === 0) {
    console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
  }
  return tcmp;
}
function tokensToEncoded(buf2, tokens, encoders, options) {
  if (Array.isArray(tokens)) {
    for (const token of tokens) {
      tokensToEncoded(buf2, token, encoders, options);
    }
  } else {
    encoders[tokens.type.major](buf2, tokens, options);
  }
}
function encodeCustom(data, encoders, options) {
  const tokens = objectToTokens(data, options);
  if (!Array.isArray(tokens) && options.quickEncodeToken) {
    const quickBytes = options.quickEncodeToken(tokens);
    if (quickBytes) {
      return quickBytes;
    }
    const encoder2 = encoders[tokens.type.major];
    if (encoder2.encodedSize) {
      const size2 = encoder2.encodedSize(tokens, options);
      const buf2 = new Bl(size2);
      encoder2(buf2, tokens, options);
      if (buf2.chunks.length !== 1) {
        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
      }
      return asU8A(buf2.chunks[0]);
    }
  }
  buf.reset();
  tokensToEncoded(buf, tokens, encoders, options);
  return buf.toBytes(true);
}
function encode$n(data, options) {
  options = Object.assign({}, defaultEncodeOptions$1, options);
  return encodeCustom(data, cborEncoders, options);
}
const defaultDecodeOptions = {
  strict: false,
  allowIndefinite: true,
  allowUndefined: true,
  allowBigInt: true
};
class Tokeniser {
  constructor(data, options = {}) {
    this.pos = 0;
    this.data = data;
    this.options = options;
  }
  done() {
    return this.pos >= this.data.length;
  }
  next() {
    const byt = this.data[this.pos];
    let token = quick[byt];
    if (token === void 0) {
      const decoder = jump[byt];
      if (!decoder) {
        throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
      }
      const minor = byt & 31;
      token = decoder(this.data, this.pos, minor, this.options);
    }
    this.pos += token.encodedLength;
    return token;
  }
}
const DONE$1 = Symbol.for("DONE");
const BREAK = Symbol.for("BREAK");
function tokenToArray(token, tokeniser, options) {
  const arr = [];
  for (let i2 = 0; i2 < token.value; i2++) {
    const value2 = tokensToObject(tokeniser, options);
    if (value2 === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);
    }
    if (value2 === DONE$1) {
      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i2}, expected ${token.value})`);
    }
    arr[i2] = value2;
  }
  return arr;
}
function tokenToMap(token, tokeniser, options) {
  const useMaps = options.useMaps === true;
  const obj = useMaps ? void 0 : {};
  const m = useMaps ? /* @__PURE__ */ new Map() : void 0;
  for (let i2 = 0; i2 < token.value; i2++) {
    const key = tokensToObject(tokeniser, options);
    if (key === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);
    }
    if (key === DONE$1) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i2} [no key], expected ${token.value})`);
    }
    if (useMaps !== true && typeof key !== "string") {
      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`);
    }
    const value2 = tokensToObject(tokeniser, options);
    if (value2 === DONE$1) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i2} [no value], expected ${token.value})`);
    }
    if (useMaps) {
      m.set(key, value2);
    } else {
      obj[key] = value2;
    }
  }
  return useMaps ? m : obj;
}
function tokensToObject(tokeniser, options) {
  if (tokeniser.done()) {
    return DONE$1;
  }
  const token = tokeniser.next();
  if (token.type === Type.break) {
    return BREAK;
  }
  if (token.type.terminal) {
    return token.value;
  }
  if (token.type === Type.array) {
    return tokenToArray(token, tokeniser, options);
  }
  if (token.type === Type.map) {
    return tokenToMap(token, tokeniser, options);
  }
  if (token.type === Type.tag) {
    if (options.tags && typeof options.tags[token.value] === "function") {
      const tagged = tokensToObject(tokeniser, options);
      return options.tags[token.value](tagged);
    }
    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`);
  }
  throw new Error("unsupported");
}
function decode$h(data, options) {
  if (!(data instanceof Uint8Array)) {
    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);
  }
  options = Object.assign({}, defaultDecodeOptions, options);
  const tokeniser = options.tokenizer || new Tokeniser(data, options);
  const decoded = tokensToObject(tokeniser, options);
  if (decoded === DONE$1) {
    throw new Error(`${decodeErrPrefix} did not find any content to decode`);
  }
  if (decoded === BREAK) {
    throw new Error(`${decodeErrPrefix} got unexpected break`);
  }
  if (!tokeniser.done()) {
    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);
  }
  return decoded;
}
const CID_CBOR_TAG = 42;
function cidEncoder$1(obj) {
  if (obj.asCID !== obj && obj["/"] !== obj.bytes) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes2 = new Uint8Array(cid.bytes.byteLength + 1);
  bytes2.set(cid.bytes, 1);
  return [
    new Token(Type.tag, CID_CBOR_TAG),
    new Token(Type.bytes, bytes2)
  ];
}
function undefinedEncoder$1() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder$1(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
const encodeOptions$1 = {
  float64: true,
  typeEncoders: {
    Object: cidEncoder$1,
    undefined: undefinedEncoder$1,
    number: numberEncoder$1
  }
};
function cidDecoder(bytes2) {
  if (bytes2[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID.decode(bytes2.subarray(1));
}
const decodeOptions$1 = {
  allowIndefinite: false,
  coerceUndefinedToNull: true,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  strict: true,
  useMaps: false,
  tags: []
};
decodeOptions$1.tags[CID_CBOR_TAG] = cidDecoder;
const name$7 = "dag-cbor";
const code$7 = 113;
const encode$m = (node2) => encode$n(node2, encodeOptions$1);
const decode$g = (data) => decode$h(data, decodeOptions$1);
const dagCBOR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  name: name$7,
  code: code$7,
  encode: encode$m,
  decode: decode$g
}, Symbol.toStringTag, { value: "Module" }));
const from$3 = ({ name: name2, code: code2, encode: encode3 }) => new Hasher$1(name2, code2, encode3);
class Hasher$1 {
  constructor(name2, code2, encode3) {
    this.name = name2;
    this.code = code2;
    this.encode = encode3;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create$8(this.code, result) : result.then((digest2) => create$8(this.code, digest2));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
}
class JSONEncoder extends Array {
  constructor() {
    super();
    this.inRecursive = [];
  }
  prefix(buf2) {
    const recurs = this.inRecursive[this.inRecursive.length - 1];
    if (recurs) {
      if (recurs.type === Type.array) {
        recurs.elements++;
        if (recurs.elements !== 1) {
          buf2.push([44]);
        }
      }
      if (recurs.type === Type.map) {
        recurs.elements++;
        if (recurs.elements !== 1) {
          if (recurs.elements % 2 === 1) {
            buf2.push([44]);
          } else {
            buf2.push([58]);
          }
        }
      }
    }
  }
  [Type.uint.major](buf2, token) {
    this.prefix(buf2);
    const is2 = String(token.value);
    const isa = [];
    for (let i2 = 0; i2 < is2.length; i2++) {
      isa[i2] = is2.charCodeAt(i2);
    }
    buf2.push(isa);
  }
  [Type.negint.major](buf2, token) {
    this[Type.uint.major](buf2, token);
  }
  [Type.bytes.major](_buf, _token) {
    throw new Error(`${encodeErrPrefix} unsupported type: Uint8Array`);
  }
  [Type.string.major](buf2, token) {
    this.prefix(buf2);
    const byts = fromString$4(JSON.stringify(token.value));
    buf2.push(byts.length > 32 ? asU8A(byts) : byts);
  }
  [Type.array.major](buf2, _token) {
    this.prefix(buf2);
    this.inRecursive.push({
      type: Type.array,
      elements: 0
    });
    buf2.push([91]);
  }
  [Type.map.major](buf2, _token) {
    this.prefix(buf2);
    this.inRecursive.push({
      type: Type.map,
      elements: 0
    });
    buf2.push([123]);
  }
  [Type.tag.major](_buf, _token) {
  }
  [Type.float.major](buf2, token) {
    if (token.type.name === "break") {
      const recurs = this.inRecursive.pop();
      if (recurs) {
        if (recurs.type === Type.array) {
          buf2.push([93]);
        } else if (recurs.type === Type.map) {
          buf2.push([125]);
        } else {
          throw new Error("Unexpected recursive type; this should not happen!");
        }
        return;
      }
      throw new Error("Unexpected break; this should not happen!");
    }
    if (token.value === void 0) {
      throw new Error(`${encodeErrPrefix} unsupported type: undefined`);
    }
    this.prefix(buf2);
    if (token.type.name === "true") {
      buf2.push([
        116,
        114,
        117,
        101
      ]);
      return;
    } else if (token.type.name === "false") {
      buf2.push([
        102,
        97,
        108,
        115,
        101
      ]);
      return;
    } else if (token.type.name === "null") {
      buf2.push([
        110,
        117,
        108,
        108
      ]);
      return;
    }
    const is2 = String(token.value);
    const isa = [];
    let dp = false;
    for (let i2 = 0; i2 < is2.length; i2++) {
      isa[i2] = is2.charCodeAt(i2);
      if (!dp && (isa[i2] === 46 || isa[i2] === 101 || isa[i2] === 69)) {
        dp = true;
      }
    }
    if (!dp) {
      isa.push(46);
      isa.push(48);
    }
    buf2.push(isa);
  }
}
function mapSorter(e1, e2) {
  if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {
    throw new Error(`${encodeErrPrefix} complex map keys are not supported`);
  }
  const keyToken1 = e1[0];
  const keyToken2 = e2[0];
  if (keyToken1.type !== Type.string || keyToken2.type !== Type.string) {
    throw new Error(`${encodeErrPrefix} non-string map keys are not supported`);
  }
  if (keyToken1 < keyToken2) {
    return -1;
  }
  if (keyToken1 > keyToken2) {
    return 1;
  }
  throw new Error(`${encodeErrPrefix} unexpected duplicate map keys, this is not supported`);
}
const defaultEncodeOptions = {
  addBreakTokens: true,
  mapSorter
};
function encode$l(data, options) {
  options = Object.assign({}, defaultEncodeOptions, options);
  return encodeCustom(data, new JSONEncoder(), options);
}
class Tokenizer {
  constructor(data, options = {}) {
    this.pos = 0;
    this.data = data;
    this.options = options;
    this.modeStack = ["value"];
    this.lastToken = "";
  }
  done() {
    return this.pos >= this.data.length;
  }
  ch() {
    return this.data[this.pos];
  }
  currentMode() {
    return this.modeStack[this.modeStack.length - 1];
  }
  skipWhitespace() {
    let c = this.ch();
    while (c === 32 || c === 9 || c === 13 || c === 10) {
      c = this.data[++this.pos];
    }
  }
  expect(str) {
    if (this.data.length - this.pos < str.length) {
      throw new Error(`${decodeErrPrefix} unexpected end of input at position ${this.pos}`);
    }
    for (let i2 = 0; i2 < str.length; i2++) {
      if (this.data[this.pos++] !== str[i2]) {
        throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}, expected to find '${String.fromCharCode(...str)}'`);
      }
    }
  }
  parseNumber() {
    const startPos = this.pos;
    let negative = false;
    let float2 = false;
    const swallow = (chars2) => {
      while (!this.done()) {
        const ch = this.ch();
        if (chars2.includes(ch)) {
          this.pos++;
        } else {
          break;
        }
      }
    };
    if (this.ch() === 45) {
      negative = true;
      this.pos++;
    }
    if (this.ch() === 48) {
      this.pos++;
      if (this.ch() === 46) {
        this.pos++;
        float2 = true;
      } else {
        return new Token(Type.uint, 0, this.pos - startPos);
      }
    }
    swallow([
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57
    ]);
    if (negative && this.pos === startPos + 1) {
      throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}`);
    }
    if (!this.done() && this.ch() === 46) {
      if (float2) {
        throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}`);
      }
      float2 = true;
      this.pos++;
      swallow([
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57
      ]);
    }
    if (!this.done() && (this.ch() === 101 || this.ch() === 69)) {
      float2 = true;
      this.pos++;
      if (!this.done() && (this.ch() === 43 || this.ch() === 45)) {
        this.pos++;
      }
      swallow([
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57
      ]);
    }
    const numStr = String.fromCharCode.apply(null, this.data.subarray(startPos, this.pos));
    const num = parseFloat(numStr);
    if (float2) {
      return new Token(Type.float, num, this.pos - startPos);
    }
    if (this.options.allowBigInt !== true || Number.isSafeInteger(num)) {
      return new Token(num >= 0 ? Type.uint : Type.negint, num, this.pos - startPos);
    }
    return new Token(num >= 0 ? Type.uint : Type.negint, BigInt(numStr), this.pos - startPos);
  }
  parseString() {
    if (this.ch() !== 34) {
      throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}; this shouldn't happen`);
    }
    this.pos++;
    for (let i2 = this.pos, l = 0; i2 < this.data.length && l < 65536; i2++, l++) {
      const ch = this.data[i2];
      if (ch === 92 || ch < 32 || ch >= 128) {
        break;
      }
      if (ch === 34) {
        const str = String.fromCharCode.apply(null, this.data.subarray(this.pos, i2));
        this.pos = i2 + 1;
        return new Token(Type.string, str, l);
      }
    }
    const startPos = this.pos;
    const chars2 = [];
    const readu4 = () => {
      if (this.pos + 4 >= this.data.length) {
        throw new Error(`${decodeErrPrefix} unexpected end of unicode escape sequence at position ${this.pos}`);
      }
      let u4 = 0;
      for (let i2 = 0; i2 < 4; i2++) {
        let ch = this.ch();
        if (ch >= 48 && ch <= 57) {
          ch -= 48;
        } else if (ch >= 97 && ch <= 102) {
          ch = ch - 97 + 10;
        } else if (ch >= 65 && ch <= 70) {
          ch = ch - 65 + 10;
        } else {
          throw new Error(`${decodeErrPrefix} unexpected unicode escape character at position ${this.pos}`);
        }
        u4 = u4 * 16 + ch;
        this.pos++;
      }
      return u4;
    };
    const readUtf8Char = () => {
      const firstByte = this.ch();
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (this.pos + bytesPerSequence > this.data.length) {
        throw new Error(`${decodeErrPrefix} unexpected unicode sequence at position ${this.pos}`);
      }
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = this.data[this.pos + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = this.data[this.pos + 1];
          thirdByte = this.data[this.pos + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = this.data[this.pos + 1];
          thirdByte = this.data[this.pos + 2];
          fourthByte = this.data[this.pos + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        chars2.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      chars2.push(codePoint);
      this.pos += bytesPerSequence;
    };
    while (!this.done()) {
      const ch = this.ch();
      let ch1;
      switch (ch) {
        case 92:
          this.pos++;
          if (this.done()) {
            throw new Error(`${decodeErrPrefix} unexpected string termination at position ${this.pos}`);
          }
          ch1 = this.ch();
          this.pos++;
          switch (ch1) {
            case 34:
            case 39:
            case 92:
            case 47:
              chars2.push(ch1);
              break;
            case 98:
              chars2.push(8);
              break;
            case 116:
              chars2.push(9);
              break;
            case 110:
              chars2.push(10);
              break;
            case 102:
              chars2.push(12);
              break;
            case 114:
              chars2.push(13);
              break;
            case 117:
              chars2.push(readu4());
              break;
            default:
              throw new Error(`${decodeErrPrefix} unexpected string escape character at position ${this.pos}`);
          }
          break;
        case 34:
          this.pos++;
          return new Token(Type.string, decodeCodePointsArray(chars2), this.pos - startPos);
        default:
          if (ch < 32) {
            throw new Error(`${decodeErrPrefix} invalid control character at position ${this.pos}`);
          } else if (ch < 128) {
            chars2.push(ch);
            this.pos++;
          } else {
            readUtf8Char();
          }
      }
    }
    throw new Error(`${decodeErrPrefix} unexpected end of string at position ${this.pos}`);
  }
  parseValue() {
    switch (this.ch()) {
      case 123:
        this.modeStack.push("obj-start");
        this.pos++;
        return new Token(Type.map, Infinity, 1);
      case 91:
        this.modeStack.push("array-start");
        this.pos++;
        return new Token(Type.array, Infinity, 1);
      case 34: {
        return this.parseString();
      }
      case 110:
        this.expect([
          110,
          117,
          108,
          108
        ]);
        return new Token(Type.null, null, 4);
      case 102:
        this.expect([
          102,
          97,
          108,
          115,
          101
        ]);
        return new Token(Type.false, false, 5);
      case 116:
        this.expect([
          116,
          114,
          117,
          101
        ]);
        return new Token(Type.true, true, 4);
      case 45:
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return this.parseNumber();
      default:
        throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}`);
    }
  }
  next() {
    this.skipWhitespace();
    switch (this.currentMode()) {
      case "value":
        this.modeStack.pop();
        return this.parseValue();
      case "array-value": {
        this.modeStack.pop();
        if (this.ch() === 93) {
          this.pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        if (this.ch() !== 44) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`);
        }
        this.pos++;
        this.modeStack.push("array-value");
        this.skipWhitespace();
        return this.parseValue();
      }
      case "array-start": {
        this.modeStack.pop();
        if (this.ch() === 93) {
          this.pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        this.modeStack.push("array-value");
        this.skipWhitespace();
        return this.parseValue();
      }
      case "obj-key":
        if (this.ch() === 125) {
          this.modeStack.pop();
          this.pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        if (this.ch() !== 44) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`);
        }
        this.pos++;
        this.skipWhitespace();
      case "obj-start": {
        this.modeStack.pop();
        if (this.ch() === 125) {
          this.pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        const token = this.parseString();
        this.skipWhitespace();
        if (this.ch() !== 58) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`);
        }
        this.pos++;
        this.modeStack.push("obj-value");
        return token;
      }
      case "obj-value": {
        this.modeStack.pop();
        this.modeStack.push("obj-key");
        this.skipWhitespace();
        return this.parseValue();
      }
      default:
        throw new Error(`${decodeErrPrefix} unexpected parse state at position ${this.pos}; this shouldn't happen`);
    }
  }
}
function decode$f(data, options) {
  options = Object.assign({ tokenizer: new Tokenizer(data, options) }, options);
  return decode$h(data, options);
}
function cidEncoder(obj) {
  if (obj.asCID !== obj && obj["/"] !== obj.bytes) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const cidString = cid.toString();
  return [
    new Token(Type.map, Infinity, 1),
    new Token(Type.string, "/", 1),
    new Token(Type.string, cidString, cidString.length),
    new Token(Type.break, void 0, 1)
  ];
}
function bytesEncoder(bytes2) {
  const bytesString = base64$4.encode(bytes2).slice(1);
  return [
    new Token(Type.map, Infinity, 1),
    new Token(Type.string, "/", 1),
    new Token(Type.map, Infinity, 1),
    new Token(Type.string, "bytes", 5),
    new Token(Type.string, bytesString, bytesString.length),
    new Token(Type.break, void 0, 1),
    new Token(Type.break, void 0, 1)
  ];
}
function undefinedEncoder() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
const encodeOptions = {
  typeEncoders: {
    Object: cidEncoder,
    Uint8Array: bytesEncoder,
    Buffer: bytesEncoder,
    undefined: undefinedEncoder,
    number: numberEncoder
  }
};
class DagJsonTokenizer extends Tokenizer {
  constructor(data, options) {
    super(data, options);
    this.tokenBuffer = [];
  }
  done() {
    return this.tokenBuffer.length === 0 && super.done();
  }
  _next() {
    if (this.tokenBuffer.length > 0) {
      return this.tokenBuffer.pop();
    }
    return super.next();
  }
  next() {
    const token = this._next();
    if (token.type === Type.map) {
      const keyToken = this._next();
      if (keyToken.type === Type.string && keyToken.value === "/") {
        const valueToken = this._next();
        if (valueToken.type === Type.string) {
          const breakToken = this._next();
          if (breakToken.type !== Type.break) {
            throw new Error("Invalid encoded CID form");
          }
          this.tokenBuffer.push(valueToken);
          return new Token(Type.tag, 42, 0);
        }
        if (valueToken.type === Type.map) {
          const innerKeyToken = this._next();
          if (innerKeyToken.type === Type.string && innerKeyToken.value === "bytes") {
            const innerValueToken = this._next();
            if (innerValueToken.type === Type.string) {
              for (let i2 = 0; i2 < 2; i2++) {
                const breakToken = this._next();
                if (breakToken.type !== Type.break) {
                  throw new Error("Invalid encoded Bytes form");
                }
              }
              const bytes2 = base64$4.decode(`m${innerValueToken.value}`);
              return new Token(Type.bytes, bytes2, innerValueToken.value.length);
            }
            this.tokenBuffer.push(innerValueToken);
          }
          this.tokenBuffer.push(innerKeyToken);
        }
        this.tokenBuffer.push(valueToken);
      }
      this.tokenBuffer.push(keyToken);
    }
    return token;
  }
}
const decodeOptions = {
  allowIndefinite: false,
  allowUndefined: false,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  strict: true,
  useMaps: false,
  tags: []
};
decodeOptions.tags[42] = CID.parse;
const name$6 = "dag-json";
const code$6 = 297;
const encode$k = (node2) => encode$l(node2, encodeOptions);
const decode$e = (data) => {
  const options = Object.assign(decodeOptions, { tokenizer: new DagJsonTokenizer(data, decodeOptions) });
  return decode$f(data, options);
};
const dagJSON = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  name: name$6,
  code: code$6,
  encode: encode$k,
  decode: decode$e
}, Symbol.toStringTag, { value: "Module" }));
function toBase64url(b2) {
  return base64url$1.encode(b2).slice(1);
}
function fromBase64url(s2) {
  return base64url$1.decode(`u${s2}`);
}
function fromSplit$1(split) {
  const [protectedHeader, payload, signature] = split;
  return {
    payload,
    signatures: [{ protected: protectedHeader, signature }],
    link: CID.decode(fromBase64url(payload))
  };
}
function encodeSignature(signature) {
  const encoded = {
    signature: fromBase64url(signature.signature)
  };
  if (signature.header)
    encoded.header = signature.header;
  if (signature.protected)
    encoded.protected = fromBase64url(signature.protected);
  return encoded;
}
function encode$j(jws) {
  const payload = fromBase64url(jws.payload);
  try {
    CID.decode(payload);
  } catch (e) {
    throw new Error("Not a valid DagJWS");
  }
  return {
    payload,
    signatures: jws.signatures.map(encodeSignature)
  };
}
function decodeSignature(encoded) {
  const sign2 = {
    signature: toBase64url(encoded.signature)
  };
  if (encoded.header)
    sign2.header = encoded.header;
  if (encoded.protected)
    sign2.protected = toBase64url(encoded.protected);
  return sign2;
}
function decode$d(encoded) {
  const decoded = {
    payload: toBase64url(encoded.payload),
    signatures: encoded.signatures.map(decodeSignature)
  };
  decoded.link = CID.decode(new Uint8Array(encoded.payload));
  return decoded;
}
function fromSplit(split) {
  const [protectedHeader, encrypted_key, iv, ciphertext, tag] = split;
  const jwe = {
    ciphertext,
    iv,
    protected: protectedHeader,
    tag
  };
  if (encrypted_key)
    jwe.recipients = [{ encrypted_key }];
  return jwe;
}
function encodeRecipient(recipient) {
  const encRec = {};
  if (recipient.encrypted_key)
    encRec.encrypted_key = fromBase64url(recipient.encrypted_key);
  if (recipient.header)
    encRec.header = recipient.header;
  return encRec;
}
function encode$i(jwe) {
  const encJwe = {
    ciphertext: fromBase64url(jwe.ciphertext),
    protected: fromBase64url(jwe.protected),
    iv: fromBase64url(jwe.iv),
    tag: fromBase64url(jwe.tag)
  };
  if (jwe.aad)
    encJwe.aad = fromBase64url(jwe.aad);
  if (jwe.recipients)
    encJwe.recipients = jwe.recipients.map(encodeRecipient);
  if (jwe.unprotected)
    encJwe.unprotected = jwe.unprotected;
  return encJwe;
}
function decodeRecipient(encoded) {
  const recipient = {};
  if (encoded.encrypted_key)
    recipient.encrypted_key = toBase64url(encoded.encrypted_key);
  if (encoded.header)
    recipient.header = encoded.header;
  return recipient;
}
function decode$c(encoded) {
  const jwe = {
    ciphertext: toBase64url(encoded.ciphertext),
    protected: toBase64url(encoded.protected),
    iv: toBase64url(encoded.iv),
    tag: toBase64url(encoded.tag)
  };
  if (encoded.aad)
    jwe.aad = toBase64url(encoded.aad);
  if (encoded.recipients)
    jwe.recipients = encoded.recipients.map(decodeRecipient);
  if (encoded.unprotected)
    jwe.unprotected = encoded.unprotected;
  return jwe;
}
const name$5 = "dag-jose";
const code$5 = 133;
function isDagJWS(jose) {
  return "payload" in jose && typeof jose.payload === "string" && "signatures" in jose && Array.isArray(jose.signatures);
}
function isEncodedJWS(jose) {
  return "payload" in jose && jose.payload instanceof Uint8Array && "signatures" in jose && Array.isArray(jose.signatures);
}
function isEncodedJWE(jose) {
  return "ciphertext" in jose && jose.ciphertext instanceof Uint8Array && "iv" in jose && jose.iv instanceof Uint8Array && "protected" in jose && jose.protected instanceof Uint8Array && "tag" in jose && jose.tag instanceof Uint8Array;
}
function isDagJWE(jose) {
  return "ciphertext" in jose && typeof jose.ciphertext === "string" && "iv" in jose && typeof jose.iv === "string" && "protected" in jose && typeof jose.protected === "string" && "tag" in jose && typeof jose.tag === "string";
}
function toGeneral(jose) {
  if (typeof jose === "string") {
    const split = jose.split(".");
    if (split.length === 3) {
      return fromSplit$1(split);
    } else if (split.length === 5) {
      return fromSplit(split);
    }
    throw new Error("Not a valid JOSE string");
  }
  if (isDagJWS(jose) || isDagJWE(jose)) {
    return jose;
  }
  throw new Error("Not a valid unencoded JOSE object");
}
function encode$h(obj) {
  if (typeof obj === "string") {
    obj = toGeneral(obj);
  }
  let encodedJose;
  if (isDagJWS(obj)) {
    encodedJose = encode$j(obj);
  } else if (isDagJWE(obj)) {
    encodedJose = encode$i(obj);
  } else {
    throw new Error("Not a valid JOSE object");
  }
  return new Uint8Array(encode$m(encodedJose));
}
function decode$b(data) {
  let encoded;
  try {
    encoded = decode$g(data);
  } catch (e) {
    throw new Error("Not a valid DAG-JOSE object");
  }
  if (isEncodedJWS(encoded)) {
    return decode$d(encoded);
  } else if (isEncodedJWE(encoded)) {
    return decode$c(encoded);
  } else {
    throw new Error("Not a valid DAG-JOSE object");
  }
}
const dagJOSE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  name: name$5,
  code: code$5,
  toGeneral,
  encode: encode$h,
  decode: decode$b
}, Symbol.toStringTag, { value: "Module" }));
const code$4 = 0;
const name$4 = "identity";
const encode$g = coerce$1;
const digest$1 = (input) => create$8(code$4, encode$g(input));
const identity$5 = { code: code$4, name: name$4, encode: encode$g, digest: digest$1 };
const identity$6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: identity$5
}, Symbol.toStringTag, { value: "Module" }));
const identity$4 = from$4({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString$7(buf2),
  decode: (str) => fromString$5(str)
});
const identityBase$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: identity$4
}, Symbol.toStringTag, { value: "Module" }));
const base2$2 = rfc4648$1({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});
const base2$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2: base2$2
}, Symbol.toStringTag, { value: "Module" }));
const base8$2 = rfc4648$1({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});
const base8$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8: base8$2
}, Symbol.toStringTag, { value: "Module" }));
const base10$2 = baseX$1({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});
const base10$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10: base10$2
}, Symbol.toStringTag, { value: "Module" }));
const base16$2 = rfc4648$1({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
const base16upper$1 = rfc4648$1({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});
const base16$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16: base16$2,
  base16upper: base16upper$1
}, Symbol.toStringTag, { value: "Module" }));
const base36$2 = baseX$1({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
const base36upper$1 = baseX$1({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});
const base36$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36: base36$2,
  base36upper: base36upper$1
}, Symbol.toStringTag, { value: "Module" }));
const alphabet$2 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
const alphabetBytesToChars$1 = alphabet$2.reduce((p, c, i2) => {
  p[i2] = c;
  return p;
}, []);
const alphabetCharsToBytes$1 = alphabet$2.reduce((p, c, i2) => {
  p[c.codePointAt(0)] = i2;
  return p;
}, []);
function encode$f(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars$1[c];
    return p;
  }, "");
}
function decode$a(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes$1[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
const base256emoji$2 = from$4({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode$f,
  decode: decode$a
});
const base256emoji$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji: base256emoji$2
}, Symbol.toStringTag, { value: "Module" }));
const sha$1 = (name2) => async (data) => new Uint8Array(await crypto.subtle.digest(name2, data));
const sha256$3 = from$3({
  name: "sha2-256",
  code: 18,
  encode: sha$1("SHA-256")
});
const sha512$2 = from$3({
  name: "sha2-512",
  code: 19,
  encode: sha$1("SHA-512")
});
const sha2$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  sha256: sha256$3,
  sha512: sha512$2
}, Symbol.toStringTag, { value: "Module" }));
const name$3 = "raw";
const code$3 = 85;
const encode$e = (node2) => coerce$1(node2);
const decode$9 = (data) => coerce$1(data);
const raw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  name: name$3,
  code: code$3,
  encode: encode$e,
  decode: decode$9
}, Symbol.toStringTag, { value: "Module" }));
const textEncoder$2 = new TextEncoder();
const textDecoder$1 = new TextDecoder();
const name$2 = "json";
const code$2 = 512;
const encode$d = (node2) => textEncoder$2.encode(JSON.stringify(node2));
const decode$8 = (data) => JSON.parse(textDecoder$1.decode(data));
const json = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  name: name$2,
  code: code$2,
  encode: encode$d,
  decode: decode$8
}, Symbol.toStringTag, { value: "Module" }));
const bases$1 = { ...identityBase$1, ...base2$3, ...base8$3, ...base10$3, ...base16$3, ...base32$3, ...base36$3, ...base58$1, ...base64$5, ...base256emoji$3 };
const hashes = { ...sha2$1, ...identity$6 };
const codecs = { raw, json };
function initAssets() {
}
class NotInitializedError extends Error {
  constructor(message2 = "not initialized") {
    super(message2);
    this.name = "NotInitializedError";
    this.code = NotInitializedError.code;
  }
}
NotInitializedError.code = "ERR_NOT_INITIALIZED";
class AlreadyInitializingError extends Error {
  constructor(message2 = "cannot initialize an initializing node") {
    super(message2);
    this.name = "AlreadyInitializingError";
    this.code = AlreadyInitializedError.code;
  }
}
AlreadyInitializingError.code = "ERR_ALREADY_INITIALIZING";
class AlreadyInitializedError extends Error {
  constructor(message2 = "cannot re-initialize an initialized node") {
    super(message2);
    this.name = "AlreadyInitializedError";
    this.code = AlreadyInitializedError.code;
  }
}
AlreadyInitializedError.code = "ERR_ALREADY_INITIALIZED";
class NotStartedError extends Error {
  constructor(message2 = "not started") {
    super(message2);
    this.name = "NotStartedError";
    this.code = NotStartedError.code;
  }
}
NotStartedError.code = "ERR_NOT_STARTED";
class AlreadyStartingError extends Error {
  constructor(message2 = "cannot start, already startin") {
    super(message2);
    this.name = "AlreadyStartingError";
    this.code = AlreadyStartingError.code;
  }
}
AlreadyStartingError.code = "ERR_ALREADY_STARTING";
class AlreadyStartedError extends Error {
  constructor(message2 = "cannot start, already started") {
    super(message2);
    this.name = "AlreadyStartedError";
    this.code = AlreadyStartedError.code;
  }
}
AlreadyStartedError.code = "ERR_ALREADY_STARTED";
class NotEnabledError extends Error {
  constructor(message2 = "not enabled") {
    super(message2);
    this.name = "NotEnabledError";
    this.code = NotEnabledError.code;
  }
}
NotEnabledError.code = "ERR_NOT_ENABLED";
function asUint8Array$1(buf2) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
  }
  return buf2;
}
function alloc(size2 = 0) {
  if (globalThis.Buffer?.alloc != null) {
    return asUint8Array$1(globalThis.Buffer.alloc(size2));
  }
  return new Uint8Array(size2);
}
function allocUnsafe$4(size2 = 0) {
  if (globalThis.Buffer?.allocUnsafe != null) {
    return asUint8Array$1(globalThis.Buffer.allocUnsafe(size2));
  }
  return new Uint8Array(size2);
}
function createCodec$2(name2, prefix, encode3, decode3) {
  return {
    name: name2,
    prefix,
    encoder: {
      name: name2,
      prefix,
      encode: encode3
    },
    decoder: {
      decode: decode3
    }
  };
}
const string$1 = createCodec$2("utf8", "u", (buf2) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf2);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
const ascii$1 = createCodec$2("ascii", "a", (buf2) => {
  let string2 = "a";
  for (let i2 = 0; i2 < buf2.length; i2++) {
    string2 += String.fromCharCode(buf2[i2]);
  }
  return string2;
}, (str) => {
  str = str.substring(1);
  const buf2 = allocUnsafe$4(str.length);
  for (let i2 = 0; i2 < str.length; i2++) {
    buf2[i2] = str.charCodeAt(i2);
  }
  return buf2;
});
const BASES$1 = {
  utf8: string$1,
  "utf-8": string$1,
  hex: bases$1.base16,
  latin1: ascii$1,
  ascii: ascii$1,
  binary: ascii$1,
  ...bases$1
};
function fromString$3(string2, encoding2 = "utf8") {
  const base3 = BASES$1[encoding2];
  if (base3 == null) {
    throw new Error(`Unsupported encoding "${encoding2}"`);
  }
  if ((encoding2 === "utf8" || encoding2 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array$1(globalThis.Buffer.from(string2, "utf-8"));
  }
  return base3.decoder.decode(`${base3.prefix}${string2}`);
}
var timeBrowser = function getTime2() {
  return Date.now();
};
const getTime = timeBrowser;
class Retimer {
  constructor(callback, timeout2, args) {
    const that = this;
    this._started = getTime();
    this._rescheduled = 0;
    this._scheduled = timeout2;
    this._args = args;
    this._triggered = false;
    this._timerWrapper = () => {
      if (that._rescheduled > 0) {
        that._scheduled = that._rescheduled - (getTime() - that._started);
        that._schedule(that._scheduled);
      } else {
        that._triggered = true;
        callback.apply(null, that._args);
      }
    };
    this._timer = setTimeout(this._timerWrapper, timeout2);
  }
  reschedule(timeout2) {
    if (!timeout2) {
      timeout2 = this._scheduled;
    }
    const now = getTime();
    if (now + timeout2 - (this._started + this._scheduled) < 0) {
      clearTimeout(this._timer);
      this._schedule(timeout2);
    } else if (!this._triggered) {
      this._started = now;
      this._rescheduled = timeout2;
    } else {
      this._schedule(timeout2);
    }
  }
  _schedule(timeout2) {
    this._triggered = false;
    this._started = getTime();
    this._rescheduled = 0;
    this._scheduled = timeout2;
    this._timer = setTimeout(this._timerWrapper, timeout2);
  }
  clear() {
    clearTimeout(this._timer);
  }
}
function retimer$1() {
  if (typeof arguments[0] !== "function") {
    throw new Error("callback needed");
  }
  if (typeof arguments[1] !== "number") {
    throw new Error("timeout needed");
  }
  let args;
  if (arguments.length > 0) {
    args = new Array(arguments.length - 2);
    for (var i2 = 0; i2 < args.length; i2++) {
      args[i2] = arguments[i2 + 2];
    }
  }
  return new Retimer(arguments[0], arguments[1], args);
}
var retimer_1 = retimer$1;
const { AbortController: AbortController$1 } = globalThis;
const retimer = retimer_1;
class TimeoutController extends AbortController$1 {
  constructor(ms2) {
    super();
    this._ms = ms2;
    this._timer = retimer(() => this.abort(), ms2);
    Object.setPrototypeOf(this, TimeoutController.prototype);
  }
  abort() {
    this._timer.clear();
    return super.abort();
  }
  clear() {
    this._timer.clear();
  }
  reset() {
    this._timer.clear();
    this._timer = retimer(() => this.abort(), this._ms);
  }
}
var timeoutAbortController = {
  TimeoutController
};
class Parser {
  constructor() {
    __publicField(this, "index", 0);
    __publicField(this, "input", "");
  }
  new(input) {
    this.index = 0;
    this.input = input;
    return this;
  }
  readAtomically(fn) {
    const index = this.index;
    const result = fn();
    if (result === void 0) {
      this.index = index;
    }
    return result;
  }
  parseWith(fn) {
    const result = fn();
    if (this.index !== this.input.length) {
      return void 0;
    }
    return result;
  }
  peekChar() {
    if (this.index >= this.input.length) {
      return void 0;
    }
    return this.input[this.index];
  }
  readChar() {
    if (this.index >= this.input.length) {
      return void 0;
    }
    return this.input[this.index++];
  }
  readGivenChar(target) {
    return this.readAtomically(() => {
      const char = this.readChar();
      if (char !== target) {
        return void 0;
      }
      return char;
    });
  }
  readSeparator(sep, index, inner) {
    return this.readAtomically(() => {
      if (index > 0) {
        if (this.readGivenChar(sep) === void 0) {
          return void 0;
        }
      }
      return inner();
    });
  }
  readNumber(radix, maxDigits, allowZeroPrefix, maxBytes) {
    return this.readAtomically(() => {
      let result = 0;
      let digitCount = 0;
      const leadingChar = this.peekChar();
      if (leadingChar === void 0) {
        return void 0;
      }
      const hasLeadingZero = leadingChar === "0";
      const maxValue = 2 ** (8 * maxBytes) - 1;
      while (true) {
        const digit = this.readAtomically(() => {
          const char = this.readChar();
          if (char === void 0) {
            return void 0;
          }
          const num = Number.parseInt(char, radix);
          if (Number.isNaN(num)) {
            return void 0;
          }
          return num;
        });
        if (digit === void 0) {
          break;
        }
        result *= radix;
        result += digit;
        if (result > maxValue) {
          return void 0;
        }
        digitCount += 1;
        if (maxDigits !== void 0) {
          if (digitCount > maxDigits) {
            return void 0;
          }
        }
      }
      if (digitCount === 0) {
        return void 0;
      } else if (!allowZeroPrefix && hasLeadingZero && digitCount > 1) {
        return void 0;
      } else {
        return result;
      }
    });
  }
  readIPv4Addr() {
    return this.readAtomically(() => {
      const out = new Uint8Array(4);
      for (let i2 = 0; i2 < out.length; i2++) {
        const ix = this.readSeparator(".", i2, () => this.readNumber(10, 3, false, 1));
        if (ix === void 0) {
          return void 0;
        }
        out[i2] = ix;
      }
      return out;
    });
  }
  readIPv6Addr() {
    const readGroups = (groups) => {
      for (let i2 = 0; i2 < groups.length / 2; i2++) {
        const ix = i2 * 2;
        if (i2 < groups.length - 3) {
          const ipv4 = this.readSeparator(":", i2, () => this.readIPv4Addr());
          if (ipv4 !== void 0) {
            groups[ix] = ipv4[0];
            groups[ix + 1] = ipv4[1];
            groups[ix + 2] = ipv4[2];
            groups[ix + 3] = ipv4[3];
            return [ix + 4, true];
          }
        }
        const group = this.readSeparator(":", i2, () => this.readNumber(16, 4, true, 2));
        if (group === void 0) {
          return [ix, false];
        }
        groups[ix] = group >> 8;
        groups[ix + 1] = group & 255;
      }
      return [groups.length, false];
    };
    return this.readAtomically(() => {
      const head = new Uint8Array(16);
      const [headSize, headIp4] = readGroups(head);
      if (headSize === 16) {
        return head;
      }
      if (headIp4) {
        return void 0;
      }
      if (this.readGivenChar(":") === void 0) {
        return void 0;
      }
      if (this.readGivenChar(":") === void 0) {
        return void 0;
      }
      const tail = new Uint8Array(14);
      const limit = 16 - (headSize + 2);
      const [tailSize] = readGroups(tail.subarray(0, limit));
      head.set(tail.subarray(0, tailSize), 16 - tailSize);
      return head;
    });
  }
  readIPAddr() {
    return this.readIPv4Addr() ?? this.readIPv6Addr();
  }
}
const MAX_IPV6_LENGTH = 45;
const MAX_IPV4_LENGTH = 15;
const parser$1 = new Parser();
function parseIPv4(input) {
  if (input.length > MAX_IPV4_LENGTH) {
    return void 0;
  }
  return parser$1.new(input).parseWith(() => parser$1.readIPv4Addr());
}
function parseIPv6(input) {
  if (input.length > MAX_IPV6_LENGTH) {
    return void 0;
  }
  return parser$1.new(input).parseWith(() => parser$1.readIPv6Addr());
}
function parseIP(input) {
  if (input.length > MAX_IPV6_LENGTH) {
    return void 0;
  }
  return parser$1.new(input).parseWith(() => parser$1.readIPAddr());
}
function isIPv4(input) {
  return Boolean(parseIPv4(input));
}
function isIPv6(input) {
  return Boolean(parseIPv6(input));
}
function isIP(input) {
  return Boolean(parseIP(input));
}
function toString$5(array, encoding2 = "utf8") {
  const base3 = BASES$1[encoding2];
  if (base3 == null) {
    throw new Error(`Unsupported encoding "${encoding2}"`);
  }
  if ((encoding2 === "utf8" || encoding2 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base3.encoder.encode(array).substring(1);
}
const isV4 = isIPv4;
const isV6 = isIPv6;
const toBytes$1 = function(ip2) {
  let offset = 0;
  ip2 = ip2.toString().trim();
  if (isV4(ip2)) {
    const bytes2 = new Uint8Array(offset + 4);
    ip2.split(/\./g).forEach((byte) => {
      bytes2[offset++] = parseInt(byte, 10) & 255;
    });
    return bytes2;
  }
  if (isV6(ip2)) {
    const sections = ip2.split(":", 8);
    let i2;
    for (i2 = 0; i2 < sections.length; i2++) {
      const isv4 = isV4(sections[i2]);
      let v4Buffer;
      if (isv4) {
        v4Buffer = toBytes$1(sections[i2]);
        sections[i2] = toString$5(v4Buffer.slice(0, 2), "base16");
      }
      if (v4Buffer != null && ++i2 < 8) {
        sections.splice(i2, 0, toString$5(v4Buffer.slice(2, 4), "base16"));
      }
    }
    if (sections[0] === "") {
      while (sections.length < 8)
        sections.unshift("0");
    } else if (sections[sections.length - 1] === "") {
      while (sections.length < 8)
        sections.push("0");
    } else if (sections.length < 8) {
      for (i2 = 0; i2 < sections.length && sections[i2] !== ""; i2++)
        ;
      const argv = [i2, 1];
      for (i2 = 9 - sections.length; i2 > 0; i2--) {
        argv.push("0");
      }
      sections.splice.apply(sections, argv);
    }
    const bytes2 = new Uint8Array(offset + 16);
    for (i2 = 0; i2 < sections.length; i2++) {
      const word2 = parseInt(sections[i2], 16);
      bytes2[offset++] = word2 >> 8 & 255;
      bytes2[offset++] = word2 & 255;
    }
    return bytes2;
  }
  throw new Error("invalid ip address");
};
const toString$4 = function(buf2, offset = 0, length3) {
  offset = ~~offset;
  length3 = length3 ?? buf2.length - offset;
  const view = new DataView(buf2.buffer);
  if (length3 === 4) {
    const result = [];
    for (let i2 = 0; i2 < length3; i2++) {
      result.push(buf2[offset + i2]);
    }
    return result.join(".");
  }
  if (length3 === 16) {
    const result = [];
    for (let i2 = 0; i2 < length3; i2 += 2) {
      result.push(view.getUint16(offset + i2).toString(16));
    }
    return result.join(":").replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3").replace(/:{3,4}/, "::");
  }
  return "";
};
const V = -1;
const names = {};
const codes$3 = {};
const table = [
  [4, 32, "ip4"],
  [6, 16, "tcp"],
  [33, 16, "dccp"],
  [41, 128, "ip6"],
  [42, V, "ip6zone"],
  [53, V, "dns", true],
  [54, V, "dns4", true],
  [55, V, "dns6", true],
  [56, V, "dnsaddr", true],
  [132, 16, "sctp"],
  [273, 16, "udp"],
  [275, 0, "p2p-webrtc-star"],
  [276, 0, "p2p-webrtc-direct"],
  [277, 0, "p2p-stardust"],
  [280, 0, "webrtc"],
  [290, 0, "p2p-circuit"],
  [301, 0, "udt"],
  [302, 0, "utp"],
  [400, V, "unix", false, true],
  [421, V, "ipfs"],
  [421, V, "p2p"],
  [443, 0, "https"],
  [444, 96, "onion"],
  [445, 296, "onion3"],
  [446, V, "garlic64"],
  [460, 0, "quic"],
  [465, 0, "webtransport"],
  [466, V, "certhash"],
  [477, 0, "ws"],
  [478, 0, "wss"],
  [479, 0, "p2p-websocket-star"],
  [480, 0, "http"],
  [777, V, "memory"]
];
table.forEach((row) => {
  const proto = createProtocol(...row);
  codes$3[proto.code] = proto;
  names[proto.name] = proto;
});
function createProtocol(code2, size2, name2, resolvable, path2) {
  return {
    code: code2,
    size: size2,
    name: name2,
    resolvable: Boolean(resolvable),
    path: Boolean(path2)
  };
}
function getProtocol(proto) {
  if (typeof proto === "number") {
    if (codes$3[proto] != null) {
      return codes$3[proto];
    }
    throw new Error(`no protocol with code: ${proto}`);
  } else if (typeof proto === "string") {
    if (names[proto] != null) {
      return names[proto];
    }
    throw new Error(`no protocol with name: ${proto}`);
  }
  throw new Error(`invalid protocol id type: ${typeof proto}`);
}
var encode_1$2 = encode$c;
var MSB$5 = 128, REST$5 = 127, MSBALL$2 = ~REST$5, INT$2 = Math.pow(2, 31);
function encode$c(num, out, offset) {
  if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
    encode$c.bytes = 0;
    throw new RangeError("Could not encode varint");
  }
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT$2) {
    out[offset++] = num & 255 | MSB$5;
    num /= 128;
  }
  while (num & MSBALL$2) {
    out[offset++] = num & 255 | MSB$5;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode$c.bytes = offset - oldOffset + 1;
  return out;
}
var decode$7 = read$3;
var MSB$4 = 128, REST$4 = 127;
function read$3(buf2, offset) {
  var res = 0, offset = offset || 0, shift2 = 0, counter2 = offset, b2, l = buf2.length;
  do {
    if (counter2 >= l || shift2 > 49) {
      read$3.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b2 = buf2[counter2++];
    res += shift2 < 28 ? (b2 & REST$4) << shift2 : (b2 & REST$4) * Math.pow(2, shift2);
    shift2 += 7;
  } while (b2 >= MSB$4);
  read$3.bytes = counter2 - offset;
  return res;
}
var N1$3 = Math.pow(2, 7);
var N2$3 = Math.pow(2, 14);
var N3$3 = Math.pow(2, 21);
var N4$3 = Math.pow(2, 28);
var N5$3 = Math.pow(2, 35);
var N6$3 = Math.pow(2, 42);
var N7$3 = Math.pow(2, 49);
var N8$3 = Math.pow(2, 56);
var N9$3 = Math.pow(2, 63);
var length$4 = function(value2) {
  return value2 < N1$3 ? 1 : value2 < N2$3 ? 2 : value2 < N3$3 ? 3 : value2 < N4$3 ? 4 : value2 < N5$3 ? 5 : value2 < N6$3 ? 6 : value2 < N7$3 ? 7 : value2 < N8$3 ? 8 : value2 < N9$3 ? 9 : 10;
};
var varint$3 = {
  encode: encode_1$2,
  decode: decode$7,
  encodingLength: length$4
};
function concat$1(arrays, length3) {
  if (length3 == null) {
    length3 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe$4(length3);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array$1(output);
}
function convertToString$1(proto, buf2) {
  const protocol2 = getProtocol(proto);
  switch (protocol2.code) {
    case 4:
    case 41:
      return bytes2ip(buf2);
    case 6:
    case 273:
    case 33:
    case 132:
      return bytes2port(buf2).toString();
    case 53:
    case 54:
    case 55:
    case 56:
    case 400:
    case 777:
      return bytes2str(buf2);
    case 421:
      return bytes2mh(buf2);
    case 444:
      return bytes2onion(buf2);
    case 445:
      return bytes2onion(buf2);
    case 466:
      return bytes2mb(buf2);
    default:
      return toString$5(buf2, "base16");
  }
}
function convertToBytes(proto, str) {
  const protocol2 = getProtocol(proto);
  switch (protocol2.code) {
    case 4:
      return ip2bytes(str);
    case 41:
      return ip2bytes(str);
    case 6:
    case 273:
    case 33:
    case 132:
      return port2bytes(parseInt(str, 10));
    case 53:
    case 54:
    case 55:
    case 56:
    case 400:
    case 777:
      return str2bytes(str);
    case 421:
      return mh2bytes(str);
    case 444:
      return onion2bytes(str);
    case 445:
      return onion32bytes(str);
    case 466:
      return mb2bytes(str);
    default:
      return fromString$3(str, "base16");
  }
}
const decoders = Object.values(bases$1).map((c) => c.decoder);
const anybaseDecoder = function() {
  let acc = decoders[0].or(decoders[1]);
  decoders.slice(2).forEach((d) => acc = acc.or(d));
  return acc;
}();
function ip2bytes(ipString) {
  if (!isIP(ipString)) {
    throw new Error("invalid ip address");
  }
  return toBytes$1(ipString);
}
function bytes2ip(ipBuff) {
  const ipString = toString$4(ipBuff, 0, ipBuff.length);
  if (ipString == null) {
    throw new Error("ipBuff is required");
  }
  if (!isIP(ipString)) {
    throw new Error("invalid ip address");
  }
  return ipString;
}
function port2bytes(port) {
  const buf2 = new ArrayBuffer(2);
  const view = new DataView(buf2);
  view.setUint16(0, port);
  return new Uint8Array(buf2);
}
function bytes2port(buf2) {
  const view = new DataView(buf2.buffer);
  return view.getUint16(buf2.byteOffset);
}
function str2bytes(str) {
  const buf2 = fromString$3(str);
  const size2 = Uint8Array.from(varint$3.encode(buf2.length));
  return concat$1([size2, buf2], size2.length + buf2.length);
}
function bytes2str(buf2) {
  const size2 = varint$3.decode(buf2);
  buf2 = buf2.slice(varint$3.decode.bytes);
  if (buf2.length !== size2) {
    throw new Error("inconsistent lengths");
  }
  return toString$5(buf2);
}
function mh2bytes(hash2) {
  let mh;
  if (hash2[0] === "Q" || hash2[0] === "1") {
    mh = decode$j(base58btc$1.decode(`z${hash2}`)).bytes;
  } else {
    mh = CID.parse(hash2).multihash.bytes;
  }
  const size2 = Uint8Array.from(varint$3.encode(mh.length));
  return concat$1([size2, mh], size2.length + mh.length);
}
function mb2bytes(mbstr) {
  const mb = anybaseDecoder.decode(mbstr);
  const size2 = Uint8Array.from(varint$3.encode(mb.length));
  return concat$1([size2, mb], size2.length + mb.length);
}
function bytes2mb(buf2) {
  const size2 = varint$3.decode(buf2);
  const hash2 = buf2.slice(varint$3.decode.bytes);
  if (hash2.length !== size2) {
    throw new Error("inconsistent lengths");
  }
  return "u" + toString$5(hash2, "base64url");
}
function bytes2mh(buf2) {
  const size2 = varint$3.decode(buf2);
  const address = buf2.slice(varint$3.decode.bytes);
  if (address.length !== size2) {
    throw new Error("inconsistent lengths");
  }
  return toString$5(address, "base58btc");
}
function onion2bytes(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 16) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);
  }
  const buf2 = base32$2.decode("b" + addr[0]);
  const port = parseInt(addr[1], 10);
  if (port < 1 || port > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes(port);
  return concat$1([buf2, portBuf], buf2.length + portBuf.length);
}
function onion32bytes(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 56) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);
  }
  const buf2 = base32$2.decode(`b${addr[0]}`);
  const port = parseInt(addr[1], 10);
  if (port < 1 || port > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes(port);
  return concat$1([buf2, portBuf], buf2.length + portBuf.length);
}
function bytes2onion(buf2) {
  const addrBytes = buf2.slice(0, buf2.length - 2);
  const portBytes = buf2.slice(buf2.length - 2);
  const addr = toString$5(addrBytes, "base32");
  const port = bytes2port(portBytes);
  return `${addr}:${port}`;
}
function stringToStringTuples(str) {
  const tuples = [];
  const parts2 = str.split("/").slice(1);
  if (parts2.length === 1 && parts2[0] === "") {
    return [];
  }
  for (let p = 0; p < parts2.length; p++) {
    const part = parts2[p];
    const proto = getProtocol(part);
    if (proto.size === 0) {
      tuples.push([part]);
      continue;
    }
    p++;
    if (p >= parts2.length) {
      throw ParseError("invalid address: " + str);
    }
    if (proto.path === true) {
      tuples.push([
        part,
        cleanPath(parts2.slice(p).join("/"))
      ]);
      break;
    }
    tuples.push([part, parts2[p]]);
  }
  return tuples;
}
function stringTuplesToString(tuples) {
  const parts2 = [];
  tuples.map((tup) => {
    const proto = protoFromTuple(tup);
    parts2.push(proto.name);
    if (tup.length > 1 && tup[1] != null) {
      parts2.push(tup[1]);
    }
    return null;
  });
  return cleanPath(parts2.join("/"));
}
function stringTuplesToTuples(tuples) {
  return tuples.map((tup) => {
    if (!Array.isArray(tup)) {
      tup = [tup];
    }
    const proto = protoFromTuple(tup);
    if (tup.length > 1) {
      return [proto.code, convertToBytes(proto.code, tup[1])];
    }
    return [proto.code];
  });
}
function tuplesToStringTuples(tuples) {
  return tuples.map((tup) => {
    const proto = protoFromTuple(tup);
    if (tup[1] != null) {
      return [proto.code, convertToString$1(proto.code, tup[1])];
    }
    return [proto.code];
  });
}
function tuplesToBytes(tuples) {
  return fromBytes$1(concat$1(tuples.map((tup) => {
    const proto = protoFromTuple(tup);
    let buf2 = Uint8Array.from(varint$3.encode(proto.code));
    if (tup.length > 1 && tup[1] != null) {
      buf2 = concat$1([buf2, tup[1]]);
    }
    return buf2;
  })));
}
function sizeForAddr(p, addr) {
  if (p.size > 0) {
    return p.size / 8;
  } else if (p.size === 0) {
    return 0;
  } else {
    const size2 = varint$3.decode(addr);
    return size2 + (varint$3.decode.bytes ?? 0);
  }
}
function bytesToTuples(buf2) {
  const tuples = [];
  let i2 = 0;
  while (i2 < buf2.length) {
    const code2 = varint$3.decode(buf2, i2);
    const n = varint$3.decode.bytes ?? 0;
    const p = getProtocol(code2);
    const size2 = sizeForAddr(p, buf2.slice(i2 + n));
    if (size2 === 0) {
      tuples.push([code2]);
      i2 += n;
      continue;
    }
    const addr = buf2.slice(i2 + n, i2 + n + size2);
    i2 += size2 + n;
    if (i2 > buf2.length) {
      throw ParseError("Invalid address Uint8Array: " + toString$5(buf2, "base16"));
    }
    tuples.push([code2, addr]);
  }
  return tuples;
}
function bytesToString(buf2) {
  const a = bytesToTuples(buf2);
  const b2 = tuplesToStringTuples(a);
  return stringTuplesToString(b2);
}
function stringToBytes(str) {
  str = cleanPath(str);
  const a = stringToStringTuples(str);
  const b2 = stringTuplesToTuples(a);
  return tuplesToBytes(b2);
}
function fromString$2(str) {
  return stringToBytes(str);
}
function fromBytes$1(buf2) {
  const err2 = validateBytes(buf2);
  if (err2 != null) {
    throw err2;
  }
  return Uint8Array.from(buf2);
}
function validateBytes(buf2) {
  try {
    bytesToTuples(buf2);
  } catch (err2) {
    return err2;
  }
}
function cleanPath(str) {
  return "/" + str.trim().split("/").filter((a) => a).join("/");
}
function ParseError(str) {
  return new Error("Error parsing address: " + str);
}
function protoFromTuple(tup) {
  const proto = getProtocol(tup[0]);
  return proto;
}
function equals$1(a, b2) {
  if (a === b2) {
    return true;
  }
  if (a.byteLength !== b2.byteLength) {
    return false;
  }
  for (let i2 = 0; i2 < a.byteLength; i2++) {
    if (a[i2] !== b2[i2]) {
      return false;
    }
  }
  return true;
}
var __classPrivateFieldGet$3 = globalThis && globalThis.__classPrivateFieldGet || function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$1 = globalThis && globalThis.__classPrivateFieldSet || function(receiver, state, value2, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var _DefaultMultiaddr_string, _DefaultMultiaddr_tuples, _DefaultMultiaddr_stringTuples, _a;
const inspect$1 = Symbol.for("nodejs.util.inspect.custom");
const DNS_CODES = [
  getProtocol("dns").code,
  getProtocol("dns4").code,
  getProtocol("dns6").code,
  getProtocol("dnsaddr").code
];
const P2P_CODES = [
  getProtocol("p2p").code,
  getProtocol("ipfs").code
];
const resolvers$1 = /* @__PURE__ */ new Map();
const symbol$5 = Symbol.for("@multiformats/js-multiaddr/multiaddr");
function fromNodeAddress(addr, transport) {
  if (addr == null) {
    throw new Error("requires node address object");
  }
  if (transport == null) {
    throw new Error("requires transport protocol");
  }
  let ip2;
  switch (addr.family) {
    case 4:
      ip2 = "ip4";
      break;
    case 6:
      ip2 = "ip6";
      break;
    default:
      throw Error("Invalid addr family, should be 4 or 6.");
  }
  return new DefaultMultiaddr("/" + [ip2, addr.address, transport, addr.port].join("/"));
}
function isName(addr) {
  if (!isMultiaddr(addr)) {
    return false;
  }
  return addr.protos().some((proto) => proto.resolvable);
}
function isMultiaddr(value2) {
  return Boolean(value2?.[symbol$5]);
}
class DefaultMultiaddr {
  constructor(addr) {
    _DefaultMultiaddr_string.set(this, void 0);
    _DefaultMultiaddr_tuples.set(this, void 0);
    _DefaultMultiaddr_stringTuples.set(this, void 0);
    this[_a] = true;
    if (addr == null) {
      addr = "";
    }
    if (addr instanceof Uint8Array) {
      this.bytes = fromBytes$1(addr);
    } else if (typeof addr === "string") {
      if (addr.length > 0 && addr.charAt(0) !== "/") {
        throw new Error(`multiaddr "${addr}" must start with a "/"`);
      }
      this.bytes = fromString$2(addr);
    } else if (isMultiaddr(addr)) {
      this.bytes = fromBytes$1(addr.bytes);
    } else {
      throw new Error("addr must be a string, Buffer, or another Multiaddr");
    }
  }
  toString() {
    if (__classPrivateFieldGet$3(this, _DefaultMultiaddr_string, "f") == null) {
      __classPrivateFieldSet$1(this, _DefaultMultiaddr_string, bytesToString(this.bytes), "f");
    }
    return __classPrivateFieldGet$3(this, _DefaultMultiaddr_string, "f");
  }
  toJSON() {
    return this.toString();
  }
  toOptions() {
    const codes2 = this.protoCodes();
    const parts2 = this.toString().split("/").slice(1);
    let transport;
    let port;
    if (parts2.length > 2) {
      if (DNS_CODES.includes(codes2[0]) && P2P_CODES.includes(codes2[1])) {
        transport = getProtocol("tcp").name;
        port = 443;
      } else {
        transport = getProtocol(parts2[2]).name;
        port = parseInt(parts2[3]);
      }
    } else if (DNS_CODES.includes(codes2[0])) {
      transport = getProtocol("tcp").name;
      port = 443;
    } else {
      throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');
    }
    const opts = {
      family: codes2[0] === 41 || codes2[0] === 55 ? 6 : 4,
      host: parts2[1],
      transport,
      port
    };
    return opts;
  }
  protos() {
    return this.protoCodes().map((code2) => Object.assign({}, getProtocol(code2)));
  }
  protoCodes() {
    const codes2 = [];
    const buf2 = this.bytes;
    let i2 = 0;
    while (i2 < buf2.length) {
      const code2 = varint$3.decode(buf2, i2);
      const n = varint$3.decode.bytes ?? 0;
      const p = getProtocol(code2);
      const size2 = sizeForAddr(p, buf2.slice(i2 + n));
      i2 += size2 + n;
      codes2.push(code2);
    }
    return codes2;
  }
  protoNames() {
    return this.protos().map((proto) => proto.name);
  }
  tuples() {
    if (__classPrivateFieldGet$3(this, _DefaultMultiaddr_tuples, "f") == null) {
      __classPrivateFieldSet$1(this, _DefaultMultiaddr_tuples, bytesToTuples(this.bytes), "f");
    }
    return __classPrivateFieldGet$3(this, _DefaultMultiaddr_tuples, "f");
  }
  stringTuples() {
    if (__classPrivateFieldGet$3(this, _DefaultMultiaddr_stringTuples, "f") == null) {
      __classPrivateFieldSet$1(this, _DefaultMultiaddr_stringTuples, tuplesToStringTuples(this.tuples()), "f");
    }
    return __classPrivateFieldGet$3(this, _DefaultMultiaddr_stringTuples, "f");
  }
  encapsulate(addr) {
    addr = new DefaultMultiaddr(addr);
    return new DefaultMultiaddr(this.toString() + addr.toString());
  }
  decapsulate(addr) {
    const addrString = addr.toString();
    const s2 = this.toString();
    const i2 = s2.lastIndexOf(addrString);
    if (i2 < 0) {
      throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);
    }
    return new DefaultMultiaddr(s2.slice(0, i2));
  }
  decapsulateCode(code2) {
    const tuples = this.tuples();
    for (let i2 = tuples.length - 1; i2 >= 0; i2--) {
      if (tuples[i2][0] === code2) {
        return new DefaultMultiaddr(tuplesToBytes(tuples.slice(0, i2)));
      }
    }
    return this;
  }
  getPeerId() {
    try {
      const tuples = this.stringTuples().filter((tuple2) => {
        if (tuple2[0] === names.ipfs.code) {
          return true;
        }
        return false;
      });
      const tuple = tuples.pop();
      if (tuple?.[1] != null) {
        const peerIdStr = tuple[1];
        if (peerIdStr[0] === "Q" || peerIdStr[0] === "1") {
          return toString$5(base58btc$1.decode(`z${peerIdStr}`), "base58btc");
        }
        return toString$5(CID.parse(peerIdStr).multihash.bytes, "base58btc");
      }
      return null;
    } catch (e) {
      return null;
    }
  }
  getPath() {
    let path2 = null;
    try {
      path2 = this.stringTuples().filter((tuple) => {
        const proto = getProtocol(tuple[0]);
        if (proto.path === true) {
          return true;
        }
        return false;
      })[0][1];
      if (path2 == null) {
        path2 = null;
      }
    } catch {
      path2 = null;
    }
    return path2;
  }
  equals(addr) {
    return equals$1(this.bytes, addr.bytes);
  }
  async resolve(options) {
    const resolvableProto = this.protos().find((p) => p.resolvable);
    if (resolvableProto == null) {
      return [this];
    }
    const resolver = resolvers$1.get(resolvableProto.name);
    if (resolver == null) {
      throw errCode(new Error(`no available resolver for ${resolvableProto.name}`), "ERR_NO_AVAILABLE_RESOLVER");
    }
    const addresses = await resolver(this, options);
    return addresses.map((a) => new DefaultMultiaddr(a));
  }
  nodeAddress() {
    const options = this.toOptions();
    if (options.transport !== "tcp" && options.transport !== "udp") {
      throw new Error(`multiaddr must have a valid format - no protocol with name: "${options.transport}". Must have a valid transport protocol: "{tcp, udp}"`);
    }
    return {
      family: options.family,
      address: options.host,
      port: options.port
    };
  }
  isThinWaistAddress(addr) {
    const protos = (addr ?? this).protos();
    if (protos.length !== 2) {
      return false;
    }
    if (protos[0].code !== 4 && protos[0].code !== 41) {
      return false;
    }
    if (protos[1].code !== 6 && protos[1].code !== 273) {
      return false;
    }
    return true;
  }
  [(_DefaultMultiaddr_string = /* @__PURE__ */ new WeakMap(), _DefaultMultiaddr_tuples = /* @__PURE__ */ new WeakMap(), _DefaultMultiaddr_stringTuples = /* @__PURE__ */ new WeakMap(), _a = symbol$5, inspect$1)]() {
    return `Multiaddr(${bytesToString(this.bytes)})`;
  }
}
function multiaddr(addr) {
  return new DefaultMultiaddr(addr);
}
const DNS4 = base$1("dns4");
const DNS6 = base$1("dns6");
const DNSADDR = base$1("dnsaddr");
const DNS = or$1(base$1("dns"), DNSADDR, DNS4, DNS6);
const IP = or$1(base$1("ip4"), base$1("ip6"));
const TCP = or$1(and(IP, base$1("tcp")), and(DNS, base$1("tcp")));
const UDP = and(IP, base$1("udp"));
const UTP = and(UDP, base$1("utp"));
const QUIC = and(UDP, base$1("quic"));
const WebSockets$1 = or$1(and(TCP, base$1("ws")), and(DNS, base$1("ws")));
const WebSocketsSecure = or$1(and(TCP, base$1("wss")), and(DNS, base$1("wss")));
const HTTP$1 = or$1(and(TCP, base$1("http")), and(IP, base$1("http")), and(DNS, base$1("http")));
const HTTPS = or$1(and(TCP, base$1("https")), and(IP, base$1("https")), and(DNS, base$1("https")));
const WebRTCStar$1 = or$1(and(WebSockets$1, base$1("p2p-webrtc-star"), base$1("p2p")), and(WebSocketsSecure, base$1("p2p-webrtc-star"), base$1("p2p")), and(WebSockets$1, base$1("p2p-webrtc-star")), and(WebSocketsSecure, base$1("p2p-webrtc-star")));
const WebRTCDirect = or$1(and(HTTP$1, base$1("p2p-webrtc-direct"), base$1("p2p")), and(HTTPS, base$1("p2p-webrtc-direct"), base$1("p2p")), and(HTTP$1, base$1("p2p-webrtc-direct")), and(HTTPS, base$1("p2p-webrtc-direct")));
const Reliable = or$1(WebSockets$1, WebSocketsSecure, HTTP$1, HTTPS, WebRTCStar$1, WebRTCDirect, TCP, UTP, QUIC, DNS);
const _P2P = or$1(and(Reliable, base$1("p2p")), WebRTCStar$1, WebRTCDirect, base$1("p2p"));
const _Circuit = or$1(and(_P2P, base$1("p2p-circuit"), _P2P), and(_P2P, base$1("p2p-circuit")), and(base$1("p2p-circuit"), _P2P), and(Reliable, base$1("p2p-circuit")), and(base$1("p2p-circuit"), Reliable), base$1("p2p-circuit"));
const CircuitRecursive = () => or$1(and(_Circuit, CircuitRecursive), _Circuit);
const Circuit$1 = CircuitRecursive();
const P2P = or$1(and(Circuit$1, _P2P, Circuit$1), and(_P2P, Circuit$1), and(Circuit$1, _P2P), Circuit$1, _P2P);
const IPFS$1 = P2P;
function makeMatchesFunction(partialMatch) {
  function matches(a) {
    let ma;
    try {
      ma = multiaddr(a);
    } catch (err2) {
      return false;
    }
    const out = partialMatch(ma.protoNames());
    if (out === null) {
      return false;
    }
    if (out === true || out === false) {
      return out;
    }
    return out.length === 0;
  }
  return matches;
}
function and(...args) {
  function partialMatch(a) {
    if (a.length < args.length) {
      return null;
    }
    let out = a;
    args.some((arg) => {
      out = typeof arg === "function" ? arg().partialMatch(a) : arg.partialMatch(a);
      if (Array.isArray(out)) {
        a = out;
      }
      if (out === null) {
        return true;
      }
      return false;
    });
    return out;
  }
  return {
    toString: function() {
      return "{ " + args.join(" ") + " }";
    },
    input: args,
    matches: makeMatchesFunction(partialMatch),
    partialMatch
  };
}
function or$1(...args) {
  function partialMatch(a) {
    let out = null;
    args.some((arg) => {
      const res = typeof arg === "function" ? arg().partialMatch(a) : arg.partialMatch(a);
      if (res != null) {
        out = res;
        return true;
      }
      return false;
    });
    return out;
  }
  const result = {
    toString: function() {
      return "{ " + args.join(" ") + " }";
    },
    input: args,
    matches: makeMatchesFunction(partialMatch),
    partialMatch
  };
  return result;
}
function base$1(n) {
  const name2 = n;
  function matches(a) {
    let ma;
    try {
      ma = multiaddr(a);
    } catch (err2) {
      return false;
    }
    const pnames = ma.protoNames();
    if (pnames.length === 1 && pnames[0] === name2) {
      return true;
    }
    return false;
  }
  function partialMatch(protos) {
    if (protos.length === 0) {
      return null;
    }
    if (protos[0] === name2) {
      return protos.slice(1);
    }
    return null;
  }
  return {
    toString: function() {
      return name2;
    },
    matches,
    partialMatch
  };
}
const isReactNative$2 = typeof navigator !== "undefined" && navigator.product === "ReactNative";
function getDefaultBase() {
  if (isReactNative$2) {
    return "http://localhost";
  }
  if (!self.location) {
    return "";
  }
  return self.location.protocol + "//" + self.location.host;
}
const URL$2 = self.URL;
const defaultBase$1 = getDefaultBase();
class URLWithLegacySupport$2 {
  constructor(url2 = "", base3 = defaultBase$1) {
    this.super = new URL$2(url2, base3);
    this.path = this.pathname + this.search;
    this.auth = this.username && this.password ? this.username + ":" + this.password : null;
    this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null;
  }
  get hash() {
    return this.super.hash;
  }
  get host() {
    return this.super.host;
  }
  get hostname() {
    return this.super.hostname;
  }
  get href() {
    return this.super.href;
  }
  get origin() {
    return this.super.origin;
  }
  get password() {
    return this.super.password;
  }
  get pathname() {
    return this.super.pathname;
  }
  get port() {
    return this.super.port;
  }
  get protocol() {
    return this.super.protocol;
  }
  get search() {
    return this.super.search;
  }
  get searchParams() {
    return this.super.searchParams;
  }
  get username() {
    return this.super.username;
  }
  set hash(hash2) {
    this.super.hash = hash2;
  }
  set host(host) {
    this.super.host = host;
  }
  set hostname(hostname) {
    this.super.hostname = hostname;
  }
  set href(href) {
    this.super.href = href;
  }
  set password(password) {
    this.super.password = password;
  }
  set pathname(pathname) {
    this.super.pathname = pathname;
  }
  set port(port) {
    this.super.port = port;
  }
  set protocol(protocol2) {
    this.super.protocol = protocol2;
  }
  set search(search) {
    this.super.search = search;
  }
  set username(username) {
    this.super.username = username;
  }
  static createObjectURL(o) {
    return URL$2.createObjectURL(o);
  }
  static revokeObjectURL(o) {
    URL$2.revokeObjectURL(o);
  }
  toJSON() {
    return this.super.toJSON();
  }
  toString() {
    return this.super.toString();
  }
  format() {
    return this.toString();
  }
}
function format$3(obj) {
  if (typeof obj === "string") {
    const url2 = new URL$2(obj);
    return url2.toString();
  }
  if (!(obj instanceof URL$2)) {
    const userPass = obj.username && obj.password ? `${obj.username}:${obj.password}@` : "";
    const auth = obj.auth ? obj.auth + "@" : "";
    const port = obj.port ? ":" + obj.port : "";
    const protocol2 = obj.protocol ? obj.protocol + "//" : "";
    const host = obj.host || "";
    const hostname = obj.hostname || "";
    const search = obj.search || (obj.query ? "?" + obj.query : "");
    const hash2 = obj.hash || "";
    const pathname = obj.pathname || "";
    const path2 = obj.path || pathname + search;
    return `${protocol2}${userPass || auth}${host || hostname + port}${path2}${hash2}`;
  }
}
var urlBrowser = {
  URLWithLegacySupport: URLWithLegacySupport$2,
  URLSearchParams: self.URLSearchParams,
  defaultBase: defaultBase$1,
  format: format$3
};
const { URLWithLegacySupport: URLWithLegacySupport$1, format: format$2 } = urlBrowser;
var relative$1 = (url2, location2 = {}, protocolMap = {}, defaultProtocol) => {
  let protocol2 = location2.protocol ? location2.protocol.replace(":", "") : "http";
  protocol2 = (protocolMap[protocol2] || defaultProtocol || protocol2) + ":";
  let urlParsed;
  try {
    urlParsed = new URLWithLegacySupport$1(url2);
  } catch (err2) {
    urlParsed = {};
  }
  const base3 = Object.assign({}, location2, {
    protocol: protocol2 || urlParsed.protocol,
    host: location2.host || urlParsed.host
  });
  return new URLWithLegacySupport$1(url2, format$2(base3)).toString();
};
const {
  URLWithLegacySupport,
  format: format$1,
  URLSearchParams: URLSearchParams$2,
  defaultBase
} = urlBrowser;
const relative = relative$1;
var isoUrl = {
  URL: URLWithLegacySupport,
  URLSearchParams: URLSearchParams$2,
  format: format$1,
  relative,
  defaultBase
};
const pathPattern = /^\/(ip[fn]s)\/([^/?#]+)/;
const defaultProtocolMatch = 1;
const defaultHashMath = 2;
const subdomainGatewayPattern = /^https?:\/\/([^/]+)\.(ip[fn]s)\.[^/?]+/;
const fqdnWithTld = /^(([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])\.)+([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/;
function isCID(hash2) {
  try {
    if (isString(hash2)) {
      return Boolean(CID.parse(hash2));
    }
    if (hash2 instanceof Uint8Array) {
      return Boolean(CID.decode(hash2));
    }
    return Boolean(CID.asCID(hash2));
  } catch {
    return false;
  }
}
function isIpfs(input, pattern, protocolMatch = defaultProtocolMatch, hashMatch = defaultHashMath) {
  const formatted = convertToString(input);
  if (formatted === false) {
    return false;
  }
  const match = formatted.match(pattern);
  if (match == null) {
    return false;
  }
  if (match[protocolMatch] !== "ipfs") {
    return false;
  }
  let hash2 = match[hashMatch];
  if (hash2 != null && pattern === subdomainGatewayPattern) {
    hash2 = hash2.toLowerCase();
  }
  return isCID(hash2);
}
function isIpns(input, pattern, protocolMatch = defaultProtocolMatch, hashMatch = defaultHashMath) {
  const formatted = convertToString(input);
  if (formatted === false) {
    return false;
  }
  const match = formatted.match(pattern);
  if (match == null) {
    return false;
  }
  if (match[protocolMatch] !== "ipns") {
    return false;
  }
  let ipnsId = match[hashMatch];
  if (ipnsId != null && pattern === subdomainGatewayPattern) {
    ipnsId = ipnsId.toLowerCase();
    if (isCID(ipnsId))
      return true;
    try {
      if (!ipnsId.includes(".") && ipnsId.includes("-")) {
        ipnsId = ipnsId.replace(/--/g, "@").replace(/-/g, ".").replace(/@/g, "-");
      }
      const { hostname } = new isoUrl.URL(`http://${ipnsId}`);
      return fqdnWithTld.test(hostname);
    } catch (e) {
      return false;
    }
  }
  return true;
}
function isString(input) {
  return typeof input === "string";
}
function convertToString(input) {
  if (input instanceof Uint8Array) {
    return toString$5(input, "base58btc");
  }
  if (isString(input)) {
    return input;
  }
  return false;
}
const path = (path2) => isIpfs(path2, pathPattern) || isIpns(path2, pathPattern);
const ipfsPath$1 = (path2) => isIpfs(path2, pathPattern);
const ipnsPath = (path2) => isIpns(path2, pathPattern);
let nanoid = (size2 = 21) => crypto.getRandomValues(new Uint8Array(size2)).reduce((id, byte) => {
  byte &= 63;
  if (byte < 36) {
    id += byte.toString(36);
  } else if (byte < 62) {
    id += (byte - 26).toString(36).toUpperCase();
  } else if (byte > 62) {
    id += "-";
  } else {
    id += "_";
  }
  return id;
}, "");
const pathSepS = "/";
const pathSepB = new TextEncoder().encode(pathSepS);
const pathSep = pathSepB[0];
class Key {
  constructor(s2, clean) {
    if (typeof s2 === "string") {
      this._buf = fromString$3(s2);
    } else if (s2 instanceof Uint8Array) {
      this._buf = s2;
    } else {
      throw new Error("Invalid key, should be String of Uint8Array");
    }
    if (clean == null) {
      clean = true;
    }
    if (clean) {
      this.clean();
    }
    if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {
      throw new Error("Invalid key");
    }
  }
  toString(encoding2 = "utf8") {
    return toString$5(this._buf, encoding2);
  }
  uint8Array() {
    return this._buf;
  }
  get [Symbol.toStringTag]() {
    return `Key(${this.toString()})`;
  }
  static withNamespaces(list) {
    return new Key(list.join(pathSepS));
  }
  static random() {
    return new Key(nanoid().replace(/-/g, ""));
  }
  static asKey(other) {
    if (other instanceof Uint8Array || typeof other === "string") {
      return new Key(other);
    }
    if (typeof other.uint8Array === "function") {
      return new Key(other.uint8Array());
    }
    return null;
  }
  clean() {
    if (this._buf == null || this._buf.byteLength === 0) {
      this._buf = pathSepB;
    }
    if (this._buf[0] !== pathSep) {
      const bytes2 = new Uint8Array(this._buf.byteLength + 1);
      bytes2.fill(pathSep, 0, 1);
      bytes2.set(this._buf, 1);
      this._buf = bytes2;
    }
    while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {
      this._buf = this._buf.subarray(0, -1);
    }
  }
  less(key) {
    const list1 = this.list();
    const list2 = key.list();
    for (let i2 = 0; i2 < list1.length; i2++) {
      if (list2.length < i2 + 1) {
        return false;
      }
      const c1 = list1[i2];
      const c2 = list2[i2];
      if (c1 < c2) {
        return true;
      } else if (c1 > c2) {
        return false;
      }
    }
    return list1.length < list2.length;
  }
  reverse() {
    return Key.withNamespaces(this.list().slice().reverse());
  }
  namespaces() {
    return this.list();
  }
  baseNamespace() {
    const ns = this.namespaces();
    return ns[ns.length - 1];
  }
  list() {
    return this.toString().split(pathSepS).slice(1);
  }
  type() {
    return namespaceType(this.baseNamespace());
  }
  name() {
    return namespaceValue(this.baseNamespace());
  }
  instance(s2) {
    return new Key(this.toString() + ":" + s2);
  }
  path() {
    let p = this.parent().toString();
    if (!p.endsWith(pathSepS)) {
      p += pathSepS;
    }
    p += this.type();
    return new Key(p);
  }
  parent() {
    const list = this.list();
    if (list.length === 1) {
      return new Key(pathSepS);
    }
    return new Key(list.slice(0, -1).join(pathSepS));
  }
  child(key) {
    if (this.toString() === pathSepS) {
      return key;
    } else if (key.toString() === pathSepS) {
      return this;
    }
    return new Key(this.toString() + key.toString(), false);
  }
  isAncestorOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return other.toString().startsWith(this.toString());
  }
  isDecendantOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return this.toString().startsWith(other.toString());
  }
  isTopLevel() {
    return this.list().length === 1;
  }
  concat(...keys) {
    return Key.withNamespaces([...this.namespaces(), ...flatten(keys.map((key) => key.namespaces()))]);
  }
}
function namespaceType(ns) {
  const parts2 = ns.split(":");
  if (parts2.length < 2) {
    return "";
  }
  return parts2.slice(0, -1).join(":");
}
function namespaceValue(ns) {
  const parts2 = ns.split(":");
  return parts2[parts2.length - 1];
}
function flatten(arr) {
  return [].concat(...arr);
}
var anySignal$2 = { exports: {} };
function anySignal$1(signals) {
  const controller = new globalThis.AbortController();
  function onAbort() {
    controller.abort();
    for (const signal of signals) {
      if (!signal || !signal.removeEventListener)
        continue;
      signal.removeEventListener("abort", onAbort);
    }
  }
  for (const signal of signals) {
    if (!signal || !signal.addEventListener)
      continue;
    if (signal.aborted) {
      onAbort();
      break;
    }
    signal.addEventListener("abort", onAbort);
  }
  return controller.signal;
}
anySignal$2.exports = anySignal$1;
var anySignal_2 = anySignal$2.exports.anySignal = anySignal$1;
let durationRE = /(-?(?:\d+\.?\d*|\d*\.?\d+)(?:e[-+]?\d+)?)\s*([\p{L}]*)/uig;
parse$3.nanosecond = parse$3.ns = 1 / 1e6;
parse$3["\xB5s"] = parse$3["\u03BCs"] = parse$3.us = parse$3.microsecond = 1 / 1e3;
parse$3.millisecond = parse$3.ms = parse$3[""] = 1;
parse$3.second = parse$3.sec = parse$3.s = parse$3.ms * 1e3;
parse$3.minute = parse$3.min = parse$3.m = parse$3.s * 60;
parse$3.hour = parse$3.hr = parse$3.h = parse$3.m * 60;
parse$3.day = parse$3.d = parse$3.h * 24;
parse$3.week = parse$3.wk = parse$3.w = parse$3.d * 7;
parse$3.month = parse$3.b = parse$3.d * (365.25 / 12);
parse$3.year = parse$3.yr = parse$3.y = parse$3.d * 365.25;
function parse$3(str = "", format2 = "ms") {
  var result = null;
  str = (str + "").replace(/(\d)[,_](\d)/g, "$1$2");
  str.replace(durationRE, function(_, n, units) {
    units = unitRatio(units);
    if (units)
      result = (result || 0) + parseFloat(n, 10) * units;
  });
  return result && result / (unitRatio(format2) || 1);
}
function unitRatio(str) {
  return parse$3[str] || parse$3[str.toLowerCase().replace(/s$/, "")];
}
class TimeoutError$5 extends Error {
  constructor(message2 = "request timed out") {
    super(message2);
    this.name = "TimeoutError";
    this.code = TimeoutError$5.code;
  }
}
TimeoutError$5.code = "ERR_TIMEOUT";
function withTimeoutOption(fn, optionsArgIndex) {
  return (...args) => {
    const options = args[optionsArgIndex == null ? args.length - 1 : optionsArgIndex];
    if (!options || !options.timeout)
      return fn(...args);
    const timeout2 = typeof options.timeout === "string" ? parse$3(options.timeout) : options.timeout;
    const controller = new timeoutAbortController.TimeoutController(timeout2);
    options.signal = anySignal_2([options.signal, controller.signal]);
    const fnRes = fn(...args);
    const timeoutPromise = new Promise((_resolve, reject) => {
      controller.signal.addEventListener("abort", () => {
        reject(new TimeoutError$5());
      });
    });
    const start = Date.now();
    const maybeThrowTimeoutError = () => {
      if (controller.signal.aborted) {
        throw new TimeoutError$5();
      }
      const timeTaken = Date.now() - start;
      if (timeTaken > timeout2) {
        controller.abort();
        throw new TimeoutError$5();
      }
    };
    if (fnRes[Symbol.asyncIterator]) {
      return async function* () {
        const it = fnRes[Symbol.asyncIterator]();
        try {
          while (true) {
            const { value: value2, done } = await Promise.race([it.next(), timeoutPromise]);
            if (done) {
              break;
            }
            maybeThrowTimeoutError();
            yield value2;
          }
        } catch (err2) {
          maybeThrowTimeoutError();
          throw err2;
        } finally {
          controller.clear();
          if (it.return) {
            it.return();
          }
        }
      }();
    }
    return (async () => {
      try {
        const res = await Promise.race([fnRes, timeoutPromise]);
        maybeThrowTimeoutError();
        return res;
      } catch (err2) {
        maybeThrowTimeoutError();
        throw err2;
      } finally {
        controller.clear();
      }
    })();
  };
}
const IPFS_PREFIX$1 = "/ipfs/";
function toCidAndPath(string2) {
  if (string2 instanceof Uint8Array) {
    try {
      string2 = CID.decode(string2);
    } catch (err2) {
      throw errCode(err2, "ERR_INVALID_CID");
    }
  }
  let cid = CID.asCID(string2);
  if (cid) {
    return {
      cid,
      path: void 0
    };
  }
  string2 = string2.toString();
  if (string2.startsWith(IPFS_PREFIX$1)) {
    string2 = string2.substring(IPFS_PREFIX$1.length);
  }
  const parts2 = string2.split("/");
  let path2;
  try {
    cid = CID.parse(parts2.shift() || "");
  } catch (err2) {
    throw errCode(err2, "ERR_INVALID_CID");
  }
  if (parts2.length) {
    path2 = `/${parts2.join("/")}`;
  }
  return {
    cid,
    path: path2
  };
}
const ERR_BAD_PATH = "ERR_BAD_PATH";
const OFFLINE_ERROR = "This command must be run in online mode. Try running 'ipfs daemon' first.";
const MFS_ROOT_KEY$2 = new Key("/local/filesroot");
const MFS_MAX_CHUNK_SIZE = 262144;
const normalizePath = (pathStr) => {
  const cid = CID.asCID(pathStr);
  if (cid) {
    return `/ipfs/${pathStr}`;
  }
  const str = pathStr.toString();
  try {
    return `/ipfs/${CID.parse(str)}`;
  } catch {
  }
  if (path(str)) {
    return str;
  } else {
    throw errCode(new Error(`invalid path: ${pathStr}`), ERR_BAD_PATH);
  }
};
const normalizeCidPath = (path2) => {
  if (path2 instanceof Uint8Array) {
    return CID.decode(path2).toString();
  }
  path2 = path2.toString();
  if (path2.indexOf("/ipfs/") === 0) {
    path2 = path2.substring("/ipfs/".length);
  }
  if (path2.charAt(path2.length - 1) === "/") {
    path2 = path2.substring(0, path2.length - 1);
  }
  return path2;
};
const resolvePath$1 = async function(repo, codecs2, ipfsPath2, options = {}) {
  const {
    cid,
    path: path2
  } = toCidAndPath(ipfsPath2);
  if (path2) {
    options.path = path2;
  }
  let lastCid = cid;
  let lastRemainderPath = options.path || "";
  if (lastRemainderPath.startsWith("/")) {
    lastRemainderPath = lastRemainderPath.substring(1);
  }
  if (options.path) {
    try {
      for await (const { value: value2, remainderPath } of resolve$5(cid, options.path, codecs2, repo, {
        signal: options.signal
      })) {
        if (!CID.asCID(value2)) {
          break;
        }
        lastRemainderPath = remainderPath;
        lastCid = value2;
      }
    } catch (err2) {
      if (err2.message.startsWith("Object has no property")) {
        err2.message = `no link named "${lastRemainderPath.split("/")[0]}" under ${lastCid}`;
        err2.code = "ERR_NO_LINK";
      }
      throw err2;
    }
  }
  return {
    cid: lastCid,
    remainderPath: lastRemainderPath || ""
  };
};
const mapFile = (file) => {
  if (file.type !== "file" && file.type !== "directory" && file.type !== "raw") {
    throw new Error(`Unknown node type '${file.type}'`);
  }
  const output = {
    cid: file.cid,
    path: file.path,
    name: file.name,
    size: file.size,
    type: "file"
  };
  if (file.type === "directory") {
    output.type = "dir";
  }
  if (file.type === "file") {
    output.size = file.unixfs.fileSize();
  }
  if (file.type === "file" || file.type === "directory") {
    output.mode = file.unixfs.mode;
    if (file.unixfs.mtime !== void 0) {
      output.mtime = file.unixfs.mtime;
    }
  }
  return output;
};
const withTimeout = withTimeoutOption(
  async (promise2, _options) => await promise2
);
const resolve$5 = async function* (cid, path2, codecs2, repo, options) {
  const load = async (cid2) => {
    const codec = await codecs2.getCodec(cid2.code);
    const block = await repo.blocks.get(cid2, options);
    return codec.decode(block);
  };
  const parts2 = path2.split("/").filter(Boolean);
  let value2 = await load(cid);
  let lastCid = cid;
  while (parts2.length) {
    const key = parts2.shift();
    if (!key) {
      throw errCode(new Error(`Could not resolve path "${path2}"`), "ERR_INVALID_PATH");
    }
    if (cid.code === code$8 && Array.isArray(value2.Links)) {
      const link = value2.Links.find((l) => l.Name === key);
      if (link) {
        yield {
          value: link.Hash,
          remainderPath: parts2.join("/")
        };
        value2 = await load(link.Hash);
        lastCid = link.Hash;
        continue;
      }
    }
    if (Object.prototype.hasOwnProperty.call(value2, key)) {
      value2 = value2[key];
      yield {
        value: value2,
        remainderPath: parts2.join("/")
      };
    } else {
      throw errCode(new Error(`no link named "${key}" under ${lastCid}`), "ERR_NO_LINK");
    }
    if (CID.asCID(value2)) {
      lastCid = value2;
      value2 = await load(value2);
    }
  }
  yield {
    value: value2,
    remainderPath: ""
  };
};
class Service {
  static create({ start, stop: stop2 }) {
    return new Service(start, stop2);
  }
  static async start(service2, options) {
    const { state, activate } = service2;
    switch (state.status) {
      case "stopped": {
        try {
          const promise2 = activate(options);
          service2.state = { status: "starting", ready: promise2 };
          const result = await promise2;
          service2.state = { status: "started", value: result };
          return result;
        } catch (error2) {
          service2.state = { status: "stopped" };
          throw error2;
        }
      }
      case "starting": {
        throw new AlreadyStartingError();
      }
      case "started": {
        throw new AlreadyStartedError();
      }
      case "stopping": {
        await state.ready;
        return await Service.start(service2, options);
      }
      default: {
        return Service.panic(service2);
      }
    }
  }
  static async stop(service2) {
    const { state, deactivate } = service2;
    switch (state.status) {
      case "stopped": {
        break;
      }
      case "starting": {
        try {
          await state.ready;
        } catch (_) {
        }
        return await Service.stop(service2);
      }
      case "stopping": {
        return await state.ready;
      }
      case "started": {
        if (deactivate) {
          await deactivate(state.value);
        }
        service2.state = { status: "stopped" };
        break;
      }
      default: {
        Service.panic(state);
      }
    }
  }
  static try({ state }) {
    switch (state.status) {
      case "started":
        return state.value;
      default:
        return null;
    }
  }
  static async use({ state }, options) {
    switch (state.status) {
      case "started":
        return state.value;
      case "starting":
        return await withTimeout(state.ready, options);
      default:
        throw new NotStartedError();
    }
  }
  static panic({ state }) {
    const status = JSON.stringify({ status: state.status });
    throw RangeError(`Service in invalid state ${status}, should never happen if you see this please report a bug`);
  }
  constructor(activate, deactivate) {
    this.activate = activate;
    this.deactivate = deactivate;
    this.state = { status: "stopped" };
  }
  async use(options) {
    return await Service.use(this, options);
  }
  try() {
    return Service.try(this);
  }
}
function createStart$1({ network, preload: preload2, peerId, keychain, repo, ipns, mfsPreload, print, hashers, options }) {
  const start = async () => {
    const { libp2p } = await Service.start(network, {
      peerId,
      repo,
      print,
      hashers,
      options
    });
    await Promise.all([
      ipns.startOnline({ keychain, libp2p, peerId, repo }),
      preload2.start(),
      mfsPreload.start()
    ]);
  };
  return start;
}
function createStop$1({ network, preload: preload2, ipns, repo, mfsPreload }) {
  const stop2 = async () => {
    await Promise.all([
      preload2.stop(),
      ipns.stop(),
      mfsPreload.stop()
    ]);
    await Service.stop(network);
    await repo.close();
  };
  return stop2;
}
var hashlru = function(max) {
  if (!max)
    throw Error("hashlru must have a max value, of type number, greater than 0");
  var size2 = 0, cache2 = /* @__PURE__ */ Object.create(null), _cache = /* @__PURE__ */ Object.create(null);
  function update(key, value2) {
    cache2[key] = value2;
    size2++;
    if (size2 >= max) {
      size2 = 0;
      _cache = cache2;
      cache2 = /* @__PURE__ */ Object.create(null);
    }
  }
  return {
    has: function(key) {
      return cache2[key] !== void 0 || _cache[key] !== void 0;
    },
    remove: function(key) {
      if (cache2[key] !== void 0)
        cache2[key] = void 0;
      if (_cache[key] !== void 0)
        _cache[key] = void 0;
    },
    get: function(key) {
      var v = cache2[key];
      if (v !== void 0)
        return v;
      if ((v = _cache[key]) !== void 0) {
        update(key, v);
        return v;
      }
    },
    set: function(key, value2) {
      if (cache2[key] !== void 0)
        cache2[key] = value2;
      else
        update(key, value2);
    },
    clear: function() {
      cache2 = /* @__PURE__ */ Object.create(null);
      _cache = /* @__PURE__ */ Object.create(null);
    }
  };
};
class TLRU$1 {
  constructor(maxSize) {
    this.lru = hashlru(maxSize);
  }
  get(key) {
    const value2 = this.lru.get(key);
    if (value2) {
      if (value2.expire && value2.expire < Date.now()) {
        this.lru.remove(key);
        return void 0;
      }
      return value2.value;
    }
    return void 0;
  }
  set(key, value2, ttl2) {
    this.lru.set(key, { value: value2, expire: Date.now() + ttl2 });
  }
  has(key) {
    const value2 = this.get(key);
    if (value2) {
      return true;
    }
    return false;
  }
  remove(key) {
    this.lru.remove(key);
  }
  clear() {
    this.lru.clear();
  }
}
var eventemitter3 = { exports: {} };
(function(module) {
  var has = Object.prototype.hasOwnProperty, prefix = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  function EE(fn, context, once3) {
    this.fn = fn;
    this.context = context;
    this.once = once3 || false;
  }
  function addListener2(emitter, event, fn, context, once3) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once3), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events();
    else
      delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames2() {
    var names2 = [], events2, name2;
    if (this._eventsCount === 0)
      return names2;
    for (name2 in events2 = this._events) {
      if (has.call(events2, name2))
        names2.push(prefix ? name2.slice(1) : name2);
    }
    if (Object.getOwnPropertySymbols) {
      return names2.concat(Object.getOwnPropertySymbols(events2));
    }
    return names2;
  };
  EventEmitter2.prototype.listeners = function listeners2(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i2 = 0, l = handlers.length, ee = new Array(l); i2 < l; i2++) {
      ee[i2] = handlers[i2].fn;
    }
    return ee;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount2(event) {
    var evt = prefix ? prefix + event : event, listeners2 = this._events[evt];
    if (!listeners2)
      return 0;
    if (listeners2.fn)
      return 1;
    return listeners2.length;
  };
  EventEmitter2.prototype.emit = function emit3(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners2 = this._events[evt], len2 = arguments.length, args, i2;
    if (listeners2.fn) {
      if (listeners2.once)
        this.removeListener(event, listeners2.fn, void 0, true);
      switch (len2) {
        case 1:
          return listeners2.fn.call(listeners2.context), true;
        case 2:
          return listeners2.fn.call(listeners2.context, a1), true;
        case 3:
          return listeners2.fn.call(listeners2.context, a1, a2), true;
        case 4:
          return listeners2.fn.call(listeners2.context, a1, a2, a3), true;
        case 5:
          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4), true;
        case 6:
          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4, a5), true;
      }
      for (i2 = 1, args = new Array(len2 - 1); i2 < len2; i2++) {
        args[i2 - 1] = arguments[i2];
      }
      listeners2.fn.apply(listeners2.context, args);
    } else {
      var length3 = listeners2.length, j;
      for (i2 = 0; i2 < length3; i2++) {
        if (listeners2[i2].once)
          this.removeListener(event, listeners2[i2].fn, void 0, true);
        switch (len2) {
          case 1:
            listeners2[i2].fn.call(listeners2[i2].context);
            break;
          case 2:
            listeners2[i2].fn.call(listeners2[i2].context, a1);
            break;
          case 3:
            listeners2[i2].fn.call(listeners2[i2].context, a1, a2);
            break;
          case 4:
            listeners2[i2].fn.call(listeners2[i2].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len2 - 1); j < len2; j++) {
                args[j - 1] = arguments[j];
              }
            listeners2[i2].fn.apply(listeners2[i2].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on3(event, fn, context) {
    return addListener2(this, event, fn, context, false);
  };
  EventEmitter2.prototype.once = function once3(event, fn, context) {
    return addListener2(this, event, fn, context, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener2(event, fn, context, once3) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners2 = this._events[evt];
    if (listeners2.fn) {
      if (listeners2.fn === fn && (!once3 || listeners2.once) && (!context || listeners2.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i2 = 0, events2 = [], length3 = listeners2.length; i2 < length3; i2++) {
        if (listeners2[i2].fn !== fn || once3 && !listeners2[i2].once || context && listeners2[i2].context !== context) {
          events2.push(listeners2[i2]);
        }
      }
      if (events2.length)
        this._events[evt] = events2.length === 1 ? events2[0] : events2;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners2(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix;
  EventEmitter2.EventEmitter = EventEmitter2;
  {
    module.exports = EventEmitter2;
  }
})(eventemitter3);
const EventEmitter$4 = eventemitter3.exports;
class TimeoutError$4 extends Error {
  constructor(message2) {
    super(message2);
    this.name = "TimeoutError";
  }
}
class AbortError$6 extends Error {
  constructor(message2) {
    super();
    this.name = "AbortError";
    this.message = message2;
  }
}
const getDOMException$1 = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError$6(errorMessage) : new DOMException(errorMessage);
const getAbortedReason$1 = (signal) => {
  const reason = signal.reason === void 0 ? getDOMException$1("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException$1(reason);
};
function pTimeout$1(promise2, milliseconds, fallback, options) {
  let timer;
  const cancelablePromise = new Promise((resolve2, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      resolve2(promise2);
      return;
    }
    options = {
      customTimers: { setTimeout, clearTimeout },
      ...options
    };
    if (options.signal) {
      const { signal } = options;
      if (signal.aborted) {
        reject(getAbortedReason$1(signal));
      }
      signal.addEventListener("abort", () => {
        reject(getAbortedReason$1(signal));
      });
    }
    timer = options.customTimers.setTimeout.call(void 0, () => {
      if (typeof fallback === "function") {
        try {
          resolve2(fallback());
        } catch (error2) {
          reject(error2);
        }
        return;
      }
      const message2 = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
      const timeoutError2 = fallback instanceof Error ? fallback : new TimeoutError$4(message2);
      if (typeof promise2.cancel === "function") {
        promise2.cancel();
      }
      reject(timeoutError2);
    }, milliseconds);
    (async () => {
      try {
        resolve2(await promise2);
      } catch (error2) {
        reject(error2);
      } finally {
        options.customTimers.clearTimeout.call(void 0, timer);
      }
    })();
  });
  cancelablePromise.clear = () => {
    clearTimeout(timer);
    timer = void 0;
  };
  return cancelablePromise;
}
function lowerBound(array, value2, comparator) {
  let first2 = 0;
  let count = array.length;
  while (count > 0) {
    const step = Math.trunc(count / 2);
    let it = first2 + step;
    if (comparator(array[it], value2) <= 0) {
      first2 = ++it;
      count -= step + 1;
    } else {
      count = step;
    }
  }
  return first2;
}
var __classPrivateFieldGet$2 = globalThis && globalThis.__classPrivateFieldGet || function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PriorityQueue_queue;
class PriorityQueue {
  constructor() {
    _PriorityQueue_queue.set(this, []);
  }
  enqueue(run, options) {
    options = {
      priority: 0,
      ...options
    };
    const element = {
      priority: options.priority,
      run
    };
    if (this.size && __classPrivateFieldGet$2(this, _PriorityQueue_queue, "f")[this.size - 1].priority >= options.priority) {
      __classPrivateFieldGet$2(this, _PriorityQueue_queue, "f").push(element);
      return;
    }
    const index = lowerBound(__classPrivateFieldGet$2(this, _PriorityQueue_queue, "f"), element, (a, b2) => b2.priority - a.priority);
    __classPrivateFieldGet$2(this, _PriorityQueue_queue, "f").splice(index, 0, element);
  }
  dequeue() {
    const item = __classPrivateFieldGet$2(this, _PriorityQueue_queue, "f").shift();
    return item === null || item === void 0 ? void 0 : item.run;
  }
  filter(options) {
    return __classPrivateFieldGet$2(this, _PriorityQueue_queue, "f").filter((element) => element.priority === options.priority).map((element) => element.run);
  }
  get size() {
    return __classPrivateFieldGet$2(this, _PriorityQueue_queue, "f").length;
  }
}
_PriorityQueue_queue = /* @__PURE__ */ new WeakMap();
var __classPrivateFieldSet = globalThis && globalThis.__classPrivateFieldSet || function(receiver, state, value2, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet$1 = globalThis && globalThis.__classPrivateFieldGet || function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PQueue_instances, _PQueue_carryoverConcurrencyCount, _PQueue_isIntervalIgnored, _PQueue_intervalCount, _PQueue_intervalCap, _PQueue_interval, _PQueue_intervalEnd, _PQueue_intervalId, _PQueue_timeoutId, _PQueue_queue, _PQueue_queueClass, _PQueue_pendingCount, _PQueue_concurrency, _PQueue_isPaused, _PQueue_throwOnTimeout, _PQueue_doesIntervalAllowAnother_get, _PQueue_doesConcurrentAllowAnother_get, _PQueue_next, _PQueue_emitEvents, _PQueue_onResumeInterval, _PQueue_isIntervalPaused_get, _PQueue_tryToStartAnother, _PQueue_initializeIntervalIfNeeded, _PQueue_onInterval, _PQueue_processQueue, _PQueue_onEvent;
const timeoutError = new TimeoutError$4();
class AbortError$5 extends Error {
}
class PQueue extends EventEmitter$4 {
  constructor(options) {
    var _a2, _b, _c, _d;
    super();
    _PQueue_instances.add(this);
    _PQueue_carryoverConcurrencyCount.set(this, void 0);
    _PQueue_isIntervalIgnored.set(this, void 0);
    _PQueue_intervalCount.set(this, 0);
    _PQueue_intervalCap.set(this, void 0);
    _PQueue_interval.set(this, void 0);
    _PQueue_intervalEnd.set(this, 0);
    _PQueue_intervalId.set(this, void 0);
    _PQueue_timeoutId.set(this, void 0);
    _PQueue_queue.set(this, void 0);
    _PQueue_queueClass.set(this, void 0);
    _PQueue_pendingCount.set(this, 0);
    _PQueue_concurrency.set(this, void 0);
    _PQueue_isPaused.set(this, void 0);
    _PQueue_throwOnTimeout.set(this, void 0);
    Object.defineProperty(this, "timeout", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    options = {
      carryoverConcurrencyCount: false,
      intervalCap: Number.POSITIVE_INFINITY,
      interval: 0,
      concurrency: Number.POSITIVE_INFINITY,
      autoStart: true,
      queueClass: PriorityQueue,
      ...options
    };
    if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
      throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b = (_a2 = options.intervalCap) === null || _a2 === void 0 ? void 0 : _a2.toString()) !== null && _b !== void 0 ? _b : ""}\` (${typeof options.intervalCap})`);
    }
    if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
      throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""}\` (${typeof options.interval})`);
    }
    __classPrivateFieldSet(this, _PQueue_carryoverConcurrencyCount, options.carryoverConcurrencyCount, "f");
    __classPrivateFieldSet(this, _PQueue_isIntervalIgnored, options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0, "f");
    __classPrivateFieldSet(this, _PQueue_intervalCap, options.intervalCap, "f");
    __classPrivateFieldSet(this, _PQueue_interval, options.interval, "f");
    __classPrivateFieldSet(this, _PQueue_queue, new options.queueClass(), "f");
    __classPrivateFieldSet(this, _PQueue_queueClass, options.queueClass, "f");
    this.concurrency = options.concurrency;
    this.timeout = options.timeout;
    __classPrivateFieldSet(this, _PQueue_throwOnTimeout, options.throwOnTimeout === true, "f");
    __classPrivateFieldSet(this, _PQueue_isPaused, options.autoStart === false, "f");
  }
  get concurrency() {
    return __classPrivateFieldGet$1(this, _PQueue_concurrency, "f");
  }
  set concurrency(newConcurrency) {
    if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
    }
    __classPrivateFieldSet(this, _PQueue_concurrency, newConcurrency, "f");
    __classPrivateFieldGet$1(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
  }
  async add(fn, options = {}) {
    return new Promise((resolve2, reject) => {
      const run = async () => {
        var _a2;
        var _b, _c;
        __classPrivateFieldSet(this, _PQueue_pendingCount, (_b = __classPrivateFieldGet$1(this, _PQueue_pendingCount, "f"), _b++, _b), "f");
        __classPrivateFieldSet(this, _PQueue_intervalCount, (_c = __classPrivateFieldGet$1(this, _PQueue_intervalCount, "f"), _c++, _c), "f");
        try {
          if ((_a2 = options.signal) === null || _a2 === void 0 ? void 0 : _a2.aborted) {
            reject(new AbortError$5("The task was aborted."));
            return;
          }
          const operation = this.timeout === void 0 && options.timeout === void 0 ? fn({ signal: options.signal }) : pTimeout$1(Promise.resolve(fn({ signal: options.signal })), options.timeout === void 0 ? this.timeout : options.timeout, () => {
            if (options.throwOnTimeout === void 0 ? __classPrivateFieldGet$1(this, _PQueue_throwOnTimeout, "f") : options.throwOnTimeout) {
              reject(timeoutError);
            }
            return void 0;
          });
          const result = await operation;
          resolve2(result);
          this.emit("completed", result);
        } catch (error2) {
          reject(error2);
          this.emit("error", error2);
        }
        __classPrivateFieldGet$1(this, _PQueue_instances, "m", _PQueue_next).call(this);
      };
      __classPrivateFieldGet$1(this, _PQueue_queue, "f").enqueue(run, options);
      __classPrivateFieldGet$1(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this);
      this.emit("add");
    });
  }
  async addAll(functions, options) {
    return Promise.all(functions.map(async (function_) => this.add(function_, options)));
  }
  start() {
    if (!__classPrivateFieldGet$1(this, _PQueue_isPaused, "f")) {
      return this;
    }
    __classPrivateFieldSet(this, _PQueue_isPaused, false, "f");
    __classPrivateFieldGet$1(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
    return this;
  }
  pause() {
    __classPrivateFieldSet(this, _PQueue_isPaused, true, "f");
  }
  clear() {
    __classPrivateFieldSet(this, _PQueue_queue, new (__classPrivateFieldGet$1(this, _PQueue_queueClass, "f"))(), "f");
  }
  async onEmpty() {
    if (__classPrivateFieldGet$1(this, _PQueue_queue, "f").size === 0) {
      return;
    }
    await __classPrivateFieldGet$1(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "empty");
  }
  async onSizeLessThan(limit) {
    if (__classPrivateFieldGet$1(this, _PQueue_queue, "f").size < limit) {
      return;
    }
    await __classPrivateFieldGet$1(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "next", () => __classPrivateFieldGet$1(this, _PQueue_queue, "f").size < limit);
  }
  async onIdle() {
    if (__classPrivateFieldGet$1(this, _PQueue_pendingCount, "f") === 0 && __classPrivateFieldGet$1(this, _PQueue_queue, "f").size === 0) {
      return;
    }
    await __classPrivateFieldGet$1(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "idle");
  }
  get size() {
    return __classPrivateFieldGet$1(this, _PQueue_queue, "f").size;
  }
  sizeBy(options) {
    return __classPrivateFieldGet$1(this, _PQueue_queue, "f").filter(options).length;
  }
  get pending() {
    return __classPrivateFieldGet$1(this, _PQueue_pendingCount, "f");
  }
  get isPaused() {
    return __classPrivateFieldGet$1(this, _PQueue_isPaused, "f");
  }
}
_PQueue_carryoverConcurrencyCount = /* @__PURE__ */ new WeakMap(), _PQueue_isIntervalIgnored = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCount = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCap = /* @__PURE__ */ new WeakMap(), _PQueue_interval = /* @__PURE__ */ new WeakMap(), _PQueue_intervalEnd = /* @__PURE__ */ new WeakMap(), _PQueue_intervalId = /* @__PURE__ */ new WeakMap(), _PQueue_timeoutId = /* @__PURE__ */ new WeakMap(), _PQueue_queue = /* @__PURE__ */ new WeakMap(), _PQueue_queueClass = /* @__PURE__ */ new WeakMap(), _PQueue_pendingCount = /* @__PURE__ */ new WeakMap(), _PQueue_concurrency = /* @__PURE__ */ new WeakMap(), _PQueue_isPaused = /* @__PURE__ */ new WeakMap(), _PQueue_throwOnTimeout = /* @__PURE__ */ new WeakMap(), _PQueue_instances = /* @__PURE__ */ new WeakSet(), _PQueue_doesIntervalAllowAnother_get = function _PQueue_doesIntervalAllowAnother_get2() {
  return __classPrivateFieldGet$1(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet$1(this, _PQueue_intervalCount, "f") < __classPrivateFieldGet$1(this, _PQueue_intervalCap, "f");
}, _PQueue_doesConcurrentAllowAnother_get = function _PQueue_doesConcurrentAllowAnother_get2() {
  return __classPrivateFieldGet$1(this, _PQueue_pendingCount, "f") < __classPrivateFieldGet$1(this, _PQueue_concurrency, "f");
}, _PQueue_next = function _PQueue_next2() {
  var _a2;
  __classPrivateFieldSet(this, _PQueue_pendingCount, (_a2 = __classPrivateFieldGet$1(this, _PQueue_pendingCount, "f"), _a2--, _a2), "f");
  __classPrivateFieldGet$1(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this);
  this.emit("next");
}, _PQueue_emitEvents = function _PQueue_emitEvents2() {
  this.emit("empty");
  if (__classPrivateFieldGet$1(this, _PQueue_pendingCount, "f") === 0) {
    this.emit("idle");
  }
}, _PQueue_onResumeInterval = function _PQueue_onResumeInterval2() {
  __classPrivateFieldGet$1(this, _PQueue_instances, "m", _PQueue_onInterval).call(this);
  __classPrivateFieldGet$1(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this);
  __classPrivateFieldSet(this, _PQueue_timeoutId, void 0, "f");
}, _PQueue_isIntervalPaused_get = function _PQueue_isIntervalPaused_get2() {
  const now = Date.now();
  if (__classPrivateFieldGet$1(this, _PQueue_intervalId, "f") === void 0) {
    const delay2 = __classPrivateFieldGet$1(this, _PQueue_intervalEnd, "f") - now;
    if (delay2 < 0) {
      __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet$1(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet$1(this, _PQueue_pendingCount, "f") : 0, "f");
    } else {
      if (__classPrivateFieldGet$1(this, _PQueue_timeoutId, "f") === void 0) {
        __classPrivateFieldSet(this, _PQueue_timeoutId, setTimeout(() => {
          __classPrivateFieldGet$1(this, _PQueue_instances, "m", _PQueue_onResumeInterval).call(this);
        }, delay2), "f");
      }
      return true;
    }
  }
  return false;
}, _PQueue_tryToStartAnother = function _PQueue_tryToStartAnother2() {
  if (__classPrivateFieldGet$1(this, _PQueue_queue, "f").size === 0) {
    if (__classPrivateFieldGet$1(this, _PQueue_intervalId, "f")) {
      clearInterval(__classPrivateFieldGet$1(this, _PQueue_intervalId, "f"));
    }
    __classPrivateFieldSet(this, _PQueue_intervalId, void 0, "f");
    __classPrivateFieldGet$1(this, _PQueue_instances, "m", _PQueue_emitEvents).call(this);
    return false;
  }
  if (!__classPrivateFieldGet$1(this, _PQueue_isPaused, "f")) {
    const canInitializeInterval = !__classPrivateFieldGet$1(this, _PQueue_instances, "a", _PQueue_isIntervalPaused_get);
    if (__classPrivateFieldGet$1(this, _PQueue_instances, "a", _PQueue_doesIntervalAllowAnother_get) && __classPrivateFieldGet$1(this, _PQueue_instances, "a", _PQueue_doesConcurrentAllowAnother_get)) {
      const job = __classPrivateFieldGet$1(this, _PQueue_queue, "f").dequeue();
      if (!job) {
        return false;
      }
      this.emit("active");
      job();
      if (canInitializeInterval) {
        __classPrivateFieldGet$1(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this);
      }
      return true;
    }
  }
  return false;
}, _PQueue_initializeIntervalIfNeeded = function _PQueue_initializeIntervalIfNeeded2() {
  if (__classPrivateFieldGet$1(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet$1(this, _PQueue_intervalId, "f") !== void 0) {
    return;
  }
  __classPrivateFieldSet(this, _PQueue_intervalId, setInterval(() => {
    __classPrivateFieldGet$1(this, _PQueue_instances, "m", _PQueue_onInterval).call(this);
  }, __classPrivateFieldGet$1(this, _PQueue_interval, "f")), "f");
  __classPrivateFieldSet(this, _PQueue_intervalEnd, Date.now() + __classPrivateFieldGet$1(this, _PQueue_interval, "f"), "f");
}, _PQueue_onInterval = function _PQueue_onInterval2() {
  if (__classPrivateFieldGet$1(this, _PQueue_intervalCount, "f") === 0 && __classPrivateFieldGet$1(this, _PQueue_pendingCount, "f") === 0 && __classPrivateFieldGet$1(this, _PQueue_intervalId, "f")) {
    clearInterval(__classPrivateFieldGet$1(this, _PQueue_intervalId, "f"));
    __classPrivateFieldSet(this, _PQueue_intervalId, void 0, "f");
  }
  __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet$1(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet$1(this, _PQueue_pendingCount, "f") : 0, "f");
  __classPrivateFieldGet$1(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
}, _PQueue_processQueue = function _PQueue_processQueue2() {
  while (__classPrivateFieldGet$1(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this)) {
  }
}, _PQueue_onEvent = async function _PQueue_onEvent2(event, filter2) {
  return new Promise((resolve2) => {
    const listener = () => {
      if (filter2 && !filter2()) {
        return;
      }
      this.off(event, listener);
      resolve2();
    };
    this.on(event, listener);
  });
};
var error = {};
class TimeoutError$3 extends Error {
  constructor(message2 = "Request timed out") {
    super(message2);
    this.name = "TimeoutError";
  }
}
error.TimeoutError = TimeoutError$3;
class AbortError$4 extends Error {
  constructor(message2 = "The operation was aborted.") {
    super(message2);
    this.name = "AbortError";
  }
}
error.AbortError = AbortError$4;
class HTTPError$1 extends Error {
  constructor(response) {
    super(response.statusText);
    this.name = "HTTPError";
    this.response = response;
  }
}
error.HTTPError = HTTPError$1;
var fetch_browser$1 = { exports: {} };
var src$4 = { exports: {} };
var browser$4 = { exports: {} };
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser)
    return browser$4.exports;
  hasRequiredBrowser = 1;
  (function(module, exports) {
    var getGlobal = function() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof globalThis !== "undefined") {
        return globalThis;
      }
      throw new Error("unable to locate globalThis object");
    };
    getGlobal();
    module.exports = exports = globalThis.fetch;
    if (globalThis.fetch) {
      exports.default = globalThis.fetch.bind(globalThis);
    }
    exports.Headers = globalThis.Headers;
    exports.Request = globalThis.Request;
    exports.Response = globalThis.Response;
  })(browser$4, browser$4.exports);
  return browser$4.exports;
}
if (globalThis.fetch && globalThis.Headers && globalThis.Request && globalThis.Response) {
  src$4.exports = {
    default: globalThis.fetch,
    Headers: globalThis.Headers,
    Request: globalThis.Request,
    Response: globalThis.Response
  };
} else {
  src$4.exports = {
    default: requireBrowser().default,
    Headers: requireBrowser().Headers,
    Request: requireBrowser().Request,
    Response: requireBrowser().Response
  };
}
(function(module) {
  module.exports = src$4.exports;
})(fetch_browser$1);
const { TimeoutError: TimeoutError$2, AbortError: AbortError$3 } = error;
const { Response: Response$1, Request: Request$2, Headers: Headers$1, default: fetch$1 } = fetch_browser$1.exports;
const fetchWithProgress = (url2, options = {}) => {
  const request2 = new XMLHttpRequest();
  request2.open(options.method || "GET", url2.toString(), true);
  const { timeout: timeout2, headers } = options;
  if (timeout2 && timeout2 > 0 && timeout2 < Infinity) {
    request2.timeout = timeout2;
  }
  if (options.overrideMimeType != null) {
    request2.overrideMimeType(options.overrideMimeType);
  }
  if (headers) {
    for (const [name2, value2] of new Headers$1(headers)) {
      request2.setRequestHeader(name2, value2);
    }
  }
  if (options.signal) {
    options.signal.onabort = () => request2.abort();
  }
  if (options.onUploadProgress) {
    request2.upload.onprogress = options.onUploadProgress;
  }
  request2.responseType = "arraybuffer";
  return new Promise((resolve2, reject) => {
    const handleEvent = (event) => {
      switch (event.type) {
        case "error": {
          resolve2(Response$1.error());
          break;
        }
        case "load": {
          resolve2(
            new ResponseWithURL(request2.responseURL, request2.response, {
              status: request2.status,
              statusText: request2.statusText,
              headers: parseHeaders(request2.getAllResponseHeaders())
            })
          );
          break;
        }
        case "timeout": {
          reject(new TimeoutError$2());
          break;
        }
        case "abort": {
          reject(new AbortError$3());
          break;
        }
      }
    };
    request2.onerror = handleEvent;
    request2.onload = handleEvent;
    request2.ontimeout = handleEvent;
    request2.onabort = handleEvent;
    request2.send(options.body);
  });
};
const fetchWithStreaming = fetch$1;
const fetchWith = (url2, options = {}) => options.onUploadProgress != null ? fetchWithProgress(url2, options) : fetchWithStreaming(url2, options);
const parseHeaders = (input) => {
  const headers = new Headers$1();
  for (const line of input.trim().split(/[\r\n]+/)) {
    const index = line.indexOf(": ");
    if (index > 0) {
      headers.set(line.slice(0, index), line.slice(index + 1));
    }
  }
  return headers;
};
class ResponseWithURL extends Response$1 {
  constructor(url2, body, options) {
    super(body, options);
    Object.defineProperty(this, "url", { value: url2 });
  }
}
var fetch_browser = {
  fetch: fetchWith,
  Request: Request$2,
  Headers: Headers$1
};
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(mergeOptions$f);
const { fetch, Request: Request$1, Headers } = fetch_browser;
const { TimeoutError: TimeoutError$1, HTTPError } = error;
const merge$2 = require$$2.bind({ ignoreUndefined: true });
const { URL: URL$1, URLSearchParams: URLSearchParams$1 } = isoUrl;
const anySignal = anySignal$2.exports;
const timeout = (promise2, ms2, abortController) => {
  if (ms2 === void 0) {
    return promise2;
  }
  const start = Date.now();
  const timedOut = () => {
    const time = Date.now() - start;
    return time >= ms2;
  };
  return new Promise((resolve2, reject) => {
    const timeoutID = setTimeout(() => {
      if (timedOut()) {
        reject(new TimeoutError$1());
        abortController.abort();
      }
    }, ms2);
    const after = (next) => {
      const fn = (res) => {
        clearTimeout(timeoutID);
        if (timedOut()) {
          reject(new TimeoutError$1());
          return;
        }
        next(res);
      };
      return fn;
    };
    promise2.then(after(resolve2), after(reject));
  });
};
const defaults = {
  throwHttpErrors: true,
  credentials: "same-origin"
};
class HTTP {
  constructor(options = {}) {
    this.opts = merge$2(defaults, options);
  }
  async fetch(resource, options = {}) {
    const opts = merge$2(this.opts, options);
    const headers = new Headers(opts.headers);
    if (typeof resource !== "string" && !(resource instanceof URL$1 || resource instanceof Request$1)) {
      throw new TypeError("`resource` must be a string, URL, or Request");
    }
    const url2 = new URL$1(resource.toString(), opts.base);
    const {
      searchParams,
      transformSearchParams,
      json: json2
    } = opts;
    if (searchParams) {
      if (typeof transformSearchParams === "function") {
        url2.search = transformSearchParams(new URLSearchParams$1(opts.searchParams));
      } else {
        url2.search = new URLSearchParams$1(opts.searchParams);
      }
    }
    if (json2) {
      opts.body = JSON.stringify(opts.json);
      headers.set("content-type", "application/json");
    }
    const abortController = new AbortController();
    const signal = anySignal([abortController.signal, opts.signal]);
    const response = await timeout(
      fetch(
        url2.toString(),
        {
          ...opts,
          signal,
          timeout: void 0,
          headers
        }
      ),
      opts.timeout,
      abortController
    );
    if (!response.ok && opts.throwHttpErrors) {
      if (opts.handleError) {
        await opts.handleError(response);
      }
      throw new HTTPError(response);
    }
    response.iterator = async function* () {
      yield* fromStream(response.body);
    };
    response.ndjson = async function* () {
      for await (const chunk of ndjson(response.iterator())) {
        if (options.transform) {
          yield options.transform(chunk);
        } else {
          yield chunk;
        }
      }
    };
    return response;
  }
  post(resource, options = {}) {
    return this.fetch(resource, { ...options, method: "POST" });
  }
  get(resource, options = {}) {
    return this.fetch(resource, { ...options, method: "GET" });
  }
  put(resource, options = {}) {
    return this.fetch(resource, { ...options, method: "PUT" });
  }
  delete(resource, options = {}) {
    return this.fetch(resource, { ...options, method: "DELETE" });
  }
  options(resource, options = {}) {
    return this.fetch(resource, { ...options, method: "OPTIONS" });
  }
}
const ndjson = async function* (source2) {
  const decoder = new TextDecoder();
  let buf2 = "";
  for await (const chunk of source2) {
    buf2 += decoder.decode(chunk, { stream: true });
    const lines = buf2.split(/\r?\n/);
    for (let i2 = 0; i2 < lines.length - 1; i2++) {
      const l = lines[i2].trim();
      if (l.length > 0) {
        yield JSON.parse(l);
      }
    }
    buf2 = lines[lines.length - 1];
  }
  buf2 += decoder.decode();
  buf2 = buf2.trim();
  if (buf2.length !== 0) {
    yield JSON.parse(buf2);
  }
};
const fromStream = (source2) => {
  if (isNodeReadableStream(source2)) {
    const iter = source2[Symbol.asyncIterator]();
    return {
      [Symbol.asyncIterator]() {
        return {
          next: iter.next.bind(iter),
          return(value2) {
            source2.destroy();
            if (typeof iter.return === "function") {
              return iter.return();
            }
            return Promise.resolve({ done: true, value: value2 });
          }
        };
      }
    };
  }
  if (isWebReadableStream(source2)) {
    const reader2 = source2.getReader();
    return async function* () {
      try {
        while (true) {
          const { done, value: value2 } = await reader2.read();
          if (done)
            return;
          if (value2) {
            yield value2;
          }
        }
      } finally {
        reader2.releaseLock();
      }
    }();
  }
  if (isAsyncIterable$1(source2)) {
    return source2;
  }
  throw new TypeError("Body can't be converted to AsyncIterable");
};
const isAsyncIterable$1 = (value2) => {
  return typeof value2 === "object" && value2 !== null && typeof value2[Symbol.asyncIterator] === "function";
};
const isWebReadableStream = (value2) => {
  return value2 && typeof value2.getReader === "function";
};
const isNodeReadableStream = (value2) => Object.prototype.hasOwnProperty.call(value2, "readable") && Object.prototype.hasOwnProperty.call(value2, "writable");
HTTP.HTTPError = HTTPError;
HTTP.TimeoutError = TimeoutError$1;
HTTP.streamToAsyncIterator = fromStream;
HTTP.post = (resource, options) => new HTTP(options).post(resource, options);
HTTP.get = (resource, options) => new HTTP(options).get(resource, options);
HTTP.put = (resource, options) => new HTTP(options).put(resource, options);
HTTP.delete = (resource, options) => new HTTP(options).delete(resource, options);
HTTP.options = (resource, options) => new HTTP(options).options(resource, options);
var http = HTTP;
const cache$2 = new TLRU$1(1e3);
const ttl = 60 * 1e3;
const Queue$3 = PQueue.default ? PQueue.default : PQueue;
const httpQueue$1 = new Queue$3({ concurrency: 4 });
const ipfsPath = (response) => {
  if (response.Path)
    return response.Path;
  throw new Error(response.Message);
};
async function resolveDnslink(fqdn, opts) {
  const resolve2 = async (fqdn2, opts2 = {}) => {
    const searchParams = new URLSearchParams(opts2);
    searchParams.set("arg", fqdn2);
    const query = searchParams.toString();
    if (!opts2.nocache && cache$2.has(query)) {
      const response2 = cache$2.get(query);
      return ipfsPath(response2);
    }
    const response = await httpQueue$1.add(async () => {
      const res = await http.get("https://ipfs.io/api/v0/dns", { searchParams });
      const query2 = new URL(res.url).search.slice(1);
      const json2 = await res.json();
      cache$2.set(query2, json2, ttl);
      return json2;
    });
    return ipfsPath(response);
  };
  return resolve2(fqdn, opts);
}
function fqdnFixups(domain) {
  if (domain.endsWith(".eth")) {
    domain = domain.replace(/.eth$/, ".eth.link");
  }
  return domain;
}
function createDns$1() {
  const resolveDNS = async (domain, options = { recursive: true }) => {
    if (typeof domain !== "string") {
      throw new Error("Invalid arguments, domain must be a string");
    }
    domain = fqdnFixups(domain);
    return resolveDnslink(domain, options);
  };
  return withTimeoutOption(resolveDNS);
}
function createIsOnline$1({ network }) {
  return () => {
    const net = network.try();
    return net != null && Boolean(net.libp2p.isStarted());
  };
}
const symbol$4 = Symbol.for("@libp2p/peer-id");
function isPeerId(other) {
  return other != null && Boolean(other[symbol$4]);
}
const inspect = Symbol.for("nodejs.util.inspect.custom");
const baseDecoder = Object.values(bases$1).map((codec) => codec.decoder).reduce((acc, curr) => acc.or(curr), bases$1.identity.decoder);
const LIBP2P_KEY_CODE = 114;
const MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36;
const MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;
class PeerIdImpl {
  constructor(init2) {
    this.type = init2.type;
    this.multihash = init2.multihash;
    this.privateKey = init2.privateKey;
    Object.defineProperty(this, "string", {
      enumerable: false,
      writable: true
    });
  }
  get [Symbol.toStringTag]() {
    return `PeerId(${this.toString()})`;
  }
  get [symbol$4]() {
    return true;
  }
  toString() {
    if (this.string == null) {
      this.string = base58btc$1.encode(this.multihash.bytes).slice(1);
    }
    return this.string;
  }
  toCID() {
    return CID.createV1(LIBP2P_KEY_CODE, this.multihash);
  }
  toBytes() {
    return this.multihash.bytes;
  }
  toJSON() {
    return this.toString();
  }
  equals(id) {
    if (id instanceof Uint8Array) {
      return equals$1(this.multihash.bytes, id);
    } else if (typeof id === "string") {
      return peerIdFromString(id).equals(this);
    } else if (id?.multihash?.bytes != null) {
      return equals$1(this.multihash.bytes, id.multihash.bytes);
    } else {
      throw new Error("not valid Id");
    }
  }
  [inspect]() {
    return `PeerId(${this.toString()})`;
  }
}
class RSAPeerIdImpl extends PeerIdImpl {
  constructor(init2) {
    super({ ...init2, type: "RSA" });
    this.type = "RSA";
    this.publicKey = init2.publicKey;
  }
}
class Ed25519PeerIdImpl extends PeerIdImpl {
  constructor(init2) {
    super({ ...init2, type: "Ed25519" });
    this.type = "Ed25519";
    this.publicKey = init2.multihash.digest;
  }
}
class Secp256k1PeerIdImpl extends PeerIdImpl {
  constructor(init2) {
    super({ ...init2, type: "secp256k1" });
    this.type = "secp256k1";
    this.publicKey = init2.multihash.digest;
  }
}
function peerIdFromPeerId(other) {
  if (other.type === "RSA") {
    return new RSAPeerIdImpl(other);
  }
  if (other.type === "Ed25519") {
    return new Ed25519PeerIdImpl(other);
  }
  if (other.type === "secp256k1") {
    return new Secp256k1PeerIdImpl(other);
  }
  throw errCode(new Error("Not a PeerId"), "ERR_INVALID_PARAMETERS");
}
function peerIdFromString(str, decoder) {
  if (str.charAt(0) === "1" || str.charAt(0) === "Q") {
    const multihash = decode$j(base58btc$1.decode(`z${str}`));
    if (str.startsWith("12D")) {
      return new Ed25519PeerIdImpl({ multihash });
    } else if (str.startsWith("16U")) {
      return new Secp256k1PeerIdImpl({ multihash });
    } else {
      return new RSAPeerIdImpl({ multihash });
    }
  }
  return peerIdFromBytes(baseDecoder.decode(str));
}
function peerIdFromBytes(buf2) {
  try {
    const multihash = decode$j(buf2);
    if (multihash.code === identity$5.code) {
      if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
        return new Ed25519PeerIdImpl({ multihash });
      } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
        return new Secp256k1PeerIdImpl({ multihash });
      }
    }
    if (multihash.code === sha256$3.code) {
      return new RSAPeerIdImpl({ multihash });
    }
  } catch {
    return peerIdFromCID(CID.decode(buf2));
  }
  throw new Error("Supplied PeerID CID is invalid");
}
function peerIdFromCID(cid) {
  if (cid == null || cid.multihash == null || cid.version == null || cid.version === 1 && cid.code !== LIBP2P_KEY_CODE) {
    throw new Error("Supplied PeerID CID is invalid");
  }
  const multihash = cid.multihash;
  if (multihash.code === sha256$3.code) {
    return new RSAPeerIdImpl({ multihash: cid.multihash });
  } else if (multihash.code === identity$5.code) {
    if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
      return new Ed25519PeerIdImpl({ multihash: cid.multihash });
    } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
      return new Secp256k1PeerIdImpl({ multihash: cid.multihash });
    }
  }
  throw new Error("Supplied PeerID CID is invalid");
}
async function peerIdFromKeys(publicKey, privateKey) {
  if (publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
    return new Ed25519PeerIdImpl({ multihash: create$8(identity$5.code, publicKey), privateKey });
  }
  if (publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
    return new Secp256k1PeerIdImpl({ multihash: create$8(identity$5.code, publicKey), privateKey });
  }
  return new RSAPeerIdImpl({ multihash: await sha256$3.digest(publicKey), publicKey, privateKey });
}
function createResolve$5({ repo, codecs: codecs2, bases: bases2, name: name2 }) {
  async function resolve2(path$1, opts = {}) {
    if (!path(path$1)) {
      throw new Error("invalid argument " + path$1);
    }
    if (ipnsPath(path$1)) {
      for await (const resolvedPath of name2.resolve(path$1, opts)) {
        path$1 = resolvedPath;
      }
    }
    const [, schema, hash2, ...rest] = path$1.split("/");
    const base3 = opts.cidBase ? await bases2.getBase(opts.cidBase) : void 0;
    const bytes2 = parseBytes(hash2);
    if (rest.length === 0) {
      const str = base3 ? base3.encoder.encode(bytes2) : hash2;
      return `/${schema}/${str}`;
    }
    const cid = CID.decode(bytes2);
    path$1 = rest.join("/");
    const results = resolve$5(cid, path$1, codecs2, repo, opts);
    let value2 = cid;
    let remainderPath = path$1;
    for await (const result of results) {
      if (CID.asCID(result.value)) {
        value2 = result.value;
        remainderPath = result.remainderPath;
      }
    }
    return `/ipfs/${value2.toString(base3 && base3.encoder)}${remainderPath ? "/" + remainderPath : ""}`;
  }
  return withTimeoutOption(resolve2);
}
function parseBytes(str) {
  try {
    return peerIdFromString(str).toBytes();
  } catch {
    return CID.parse(str).bytes;
  }
}
async function last(source2) {
  let res;
  for await (const entry of source2) {
    res = entry;
  }
  return res;
}
function createAdd$7({ addAll }) {
  return (path2, options = {}) => {
    let iter;
    const cid = CID.asCID(path2);
    if (cid) {
      iter = addAll([{
        cid,
        ...options
      }], options);
    } else {
      iter = addAll([{
        path: path2.toString(),
        ...options
      }], options);
    }
    return last(iter);
  };
}
async function* normaliseInput$3(input) {
  if (input === null || input === void 0) {
    throw errCode(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
  }
  const cid = CID.asCID(input);
  if (cid) {
    yield toPin$2({ cid });
    return;
  }
  if (input instanceof String || typeof input === "string") {
    yield toPin$2({ path: input });
    return;
  }
  if (input.cid != null || input.path != null) {
    return yield toPin$2(input);
  }
  if (Symbol.iterator in input) {
    const iterator2 = input[Symbol.iterator]();
    const first2 = iterator2.next();
    if (first2.done)
      return iterator2;
    if (CID.asCID(first2.value) || first2.value instanceof String || typeof first2.value === "string") {
      yield toPin$2({ cid: first2.value });
      for (const cid2 of iterator2) {
        yield toPin$2({ cid: cid2 });
      }
      return;
    }
    if (first2.value.cid != null || first2.value.path != null) {
      yield toPin$2(first2.value);
      for (const obj of iterator2) {
        yield toPin$2(obj);
      }
      return;
    }
    throw errCode(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
  }
  if (Symbol.asyncIterator in input) {
    const iterator2 = input[Symbol.asyncIterator]();
    const first2 = await iterator2.next();
    if (first2.done)
      return iterator2;
    if (CID.asCID(first2.value) || first2.value instanceof String || typeof first2.value === "string") {
      yield toPin$2({ cid: first2.value });
      for await (const cid2 of iterator2) {
        yield toPin$2({ cid: cid2 });
      }
      return;
    }
    if (first2.value.cid != null || first2.value.path != null) {
      yield toPin$2(first2.value);
      for await (const obj of iterator2) {
        yield toPin$2(obj);
      }
      return;
    }
    throw errCode(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
  }
  throw errCode(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
}
function toPin$2(input) {
  const path2 = input.cid || `${input.path}`;
  if (!path2) {
    throw errCode(new Error("Unexpected input: Please path either a CID or an IPFS path"), "ERR_UNEXPECTED_INPUT");
  }
  const pin = {
    path: path2,
    recursive: input.recursive !== false
  };
  if (input.metadata != null) {
    pin.metadata = input.metadata;
  }
  return pin;
}
const PinTypes$1 = {
  direct: "direct",
  recursive: "recursive",
  indirect: "indirect",
  all: "all"
};
function createAddAll$3({ repo, codecs: codecs2 }) {
  async function* addAll(source2, options = {}) {
    const pinAdd = async function* () {
      for await (const { path: path2, recursive: recursive2, metadata } of normaliseInput$3(source2)) {
        const { cid } = await resolvePath$1(repo, codecs2, path2);
        const { reason } = await repo.pins.isPinnedWithType(cid, [PinTypes$1.recursive, PinTypes$1.direct]);
        if (reason === "recursive" && !recursive2) {
          throw new Error(`${cid} already pinned recursively`);
        }
        if (recursive2) {
          await repo.pins.pinRecursively(cid, { metadata });
        } else {
          await repo.pins.pinDirectly(cid, { metadata });
        }
        yield cid;
      }
    };
    const lock2 = Boolean(options.lock);
    if (!lock2) {
      yield* pinAdd();
      return;
    }
    const release = await repo.gcLock.readLock();
    try {
      yield* pinAdd();
    } finally {
      release();
    }
  }
  return withTimeoutOption(addAll);
}
function toPin$1(type, cid, metadata) {
  const output = {
    type,
    cid
  };
  if (metadata) {
    output.metadata = metadata;
  }
  return output;
}
function createLs$9({ repo, codecs: codecs2 }) {
  async function* ls(options = {}) {
    let type = PinTypes$1.all;
    if (options.type) {
      type = options.type;
      if (!Object.keys(PinTypes$1).includes(type)) {
        throw errCode(new Error("Invalid pin type"), "ERR_INVALID_PIN_TYPE");
      }
    }
    if (options.paths) {
      let matched = false;
      for await (const { path: path2 } of normaliseInput$3(options.paths)) {
        const { cid } = await resolvePath$1(repo, codecs2, path2);
        const { reason, pinned, parent: parent2, metadata } = await repo.pins.isPinnedWithType(cid, type);
        if (!pinned) {
          throw errCode(new Error(`path '${path2}' is not pinned`), "ERR_NOT_PINNED");
        }
        switch (reason) {
          case PinTypes$1.direct:
          case PinTypes$1.recursive:
            matched = true;
            yield toPin$1(reason, cid, metadata);
            break;
          default:
            matched = true;
            yield toPin$1(`${PinTypes$1.indirect} through ${parent2}`, cid, metadata);
        }
      }
      if (!matched) {
        throw new Error("No match found");
      }
      return;
    }
    if (type === PinTypes$1.recursive || type === PinTypes$1.all) {
      for await (const { cid, metadata } of repo.pins.recursiveKeys()) {
        yield toPin$1(PinTypes$1.recursive, cid, metadata);
      }
    }
    if (type === PinTypes$1.indirect || type === PinTypes$1.all) {
      for await (const cid of repo.pins.indirectKeys(options)) {
        yield toPin$1(PinTypes$1.indirect, cid);
      }
    }
    if (type === PinTypes$1.direct || type === PinTypes$1.all) {
      for await (const { cid, metadata } of repo.pins.directKeys()) {
        yield toPin$1(PinTypes$1.direct, cid, metadata);
      }
    }
  }
  return withTimeoutOption(ls);
}
function createRm$b({ rmAll }) {
  async function rm(path2, options = {}) {
    const cid = await last(rmAll([{ path: path2, ...options }], options));
    if (!cid) {
      throw new Error("CID expected");
    }
    return cid;
  }
  return rm;
}
function createRmAll$2({ repo, codecs: codecs2 }) {
  async function* rmAll(source2, _options = {}) {
    const release = await repo.gcLock.readLock();
    try {
      for await (const { path: path2, recursive: recursive2 } of normaliseInput$3(source2)) {
        const { cid } = await resolvePath$1(repo, codecs2, path2);
        const { pinned, reason } = await repo.pins.isPinnedWithType(cid, PinTypes$1.all);
        if (!pinned) {
          throw new Error(`${cid} is not pinned`);
        }
        switch (reason) {
          case PinTypes$1.recursive:
            if (!recursive2) {
              throw new Error(`${cid} is pinned recursively`);
            }
            await repo.pins.unpin(cid);
            yield cid;
            break;
          case PinTypes$1.direct:
            await repo.pins.unpin(cid);
            yield cid;
            break;
          default:
            throw new Error(`${cid} is pinned indirectly under ${reason}`);
        }
      }
    } finally {
      release();
    }
  }
  return withTimeoutOption(rmAll);
}
class PinAPI {
  constructor({ codecs: codecs2, repo }) {
    const addAll = createAddAll$3({ codecs: codecs2, repo });
    this.addAll = addAll;
    this.add = createAdd$7({ addAll });
    const rmAll = createRmAll$2({ codecs: codecs2, repo });
    this.rmAll = rmAll;
    this.rm = createRm$b({ rmAll });
    this.ls = createLs$9({ codecs: codecs2, repo });
    this.remote = {
      add: (cid, options = {}) => Promise.reject(new Error("Not implemented")),
      ls: async function* (query, options = {}) {
        return Promise.reject(new Error("Not implemented"));
      },
      rm: (query, options = {}) => Promise.reject(new Error("Not implemented")),
      rmAll: (query, options = {}) => Promise.reject(new Error("Not implemented")),
      service: {
        add: (name2, credentials) => Promise.reject(new Error("Not implemented")),
        rm: (name2, options = {}) => Promise.reject(new Error("Not implemented")),
        ls: (options = {}) => Promise.reject(new Error("Not implemented"))
      }
    };
  }
}
function dbOpenFailedError(err2) {
  err2 = err2 || new Error("Cannot open database");
  return errCode(err2, "ERR_DB_OPEN_FAILED");
}
function dbDeleteFailedError(err2) {
  err2 = err2 || new Error("Delete failed");
  return errCode(err2, "ERR_DB_DELETE_FAILED");
}
function dbWriteFailedError(err2) {
  err2 = err2 || new Error("Write failed");
  return errCode(err2, "ERR_DB_WRITE_FAILED");
}
function notFoundError$1(err2) {
  err2 = err2 || new Error("Not Found");
  return errCode(err2, "ERR_NOT_FOUND");
}
var timestamp = { exports: {} };
/**
 * Timestamp for 64-bit time_t, nanosecond precision and strftime
 *
 * @author Yusuke Kawasaki
 * @license MIT
 * @see https://github.com/kawanet/timestamp-nano
 */
(function(module) {
  (function() {
    module.exports = Timestamp;
    var SEC_DAY = 24 * 3600;
    var YEAR_SLOT = 3200;
    var DAY_SLOT = (365 * 400 + 97) * YEAR_SLOT / 400;
    var SEC_SLOT = SEC_DAY * DAY_SLOT;
    var MSEC_SLOT = SEC_SLOT * 1e3;
    var MAX_MSEC = 1e3 * 1e4 * 1e4 * SEC_DAY;
    var BIT24 = 16777216;
    var BIT32 = 65536 * 65536;
    var DEC6 = 1e3 * 1e3;
    var DEC9 = 1e3 * 1e3 * 1e3;
    var ZERO9 = "000000000";
    var trunc = Math.trunc || Math_trunc;
    var P = Timestamp.prototype;
    Timestamp.fromDate = fromDate;
    Timestamp.fromInt64BE = buildFromInt64(0, 1, 2, 3, 0, 4);
    Timestamp.fromInt64LE = buildFromInt64(3, 2, 1, 0, 4, 0);
    Timestamp.fromString = fromString2;
    Timestamp.fromTimeT = fromTimeT;
    P.year = 0;
    P.time = 0;
    P.nano = 0;
    P.addNano = addNano;
    P.getNano = getNano;
    P.getTimeT = getTimeT;
    P.getYear = getYear;
    P.toDate = toDate;
    P.toJSON = toJSON;
    P.toString = toString2;
    P.writeInt64BE = buildWriteInt64(0, 1, 2, 3, 0, 4);
    P.writeInt64LE = buildWriteInt64(3, 2, 1, 0, 4, 0);
    var FMT_JSON = "%Y-%m-%dT%H:%M:%S.%NZ";
    var FMT_MONTH = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    var FMT_DAY = [
      "Sun",
      "Mon",
      "Tue",
      "Wed",
      "Thu",
      "Fri",
      "Sat"
    ];
    var FMT_STRING = {
      "%": "%",
      F: "%Y-%m-%d",
      n: "\n",
      R: "%H:%M",
      T: "%H:%M:%S",
      t: "	",
      X: "%T",
      Z: "GMT",
      z: "+0000"
    };
    return Timestamp;
    function Timestamp(time, nano, year) {
      var ts = this;
      if (!(ts instanceof Timestamp))
        return new Timestamp(time, nano, year);
      ts.time = +time || 0;
      ts.nano = +nano || 0;
      ts.year = +year || 0;
      normalize(ts);
    }
    function getYear() {
      var year = this.toDate().getUTCFullYear();
      return year + this.year;
    }
    function normalize(ts) {
      var year = ts.year;
      var time = ts.time;
      var nano = ts.nano;
      var changed;
      var slot;
      if (nano < 0 || DEC6 <= nano) {
        var n = Math.floor(nano / DEC6);
        nano -= n * DEC6;
        time += n;
        changed = 1;
      }
      var y = year % YEAR_SLOT;
      if (time < -MAX_MSEC || MAX_MSEC < time || y) {
        slot = trunc(time / MSEC_SLOT);
        if (slot) {
          year += slot * YEAR_SLOT;
          time -= slot * MSEC_SLOT;
        }
        var dt = newDate(time);
        dt.setUTCFullYear(y + dt.getUTCFullYear());
        year -= y;
        time = +dt;
        slot = trunc(year / YEAR_SLOT);
        var total = time + slot * MSEC_SLOT;
        if (slot && -MAX_MSEC <= total && total <= MAX_MSEC) {
          year -= slot * YEAR_SLOT;
          time = total;
        }
        changed = 1;
      }
      if (changed) {
        ts.year = year;
        ts.time = time;
        ts.nano = nano;
      }
      return ts;
    }
    function toDate() {
      var ts = normalize(this);
      return newDate(ts.time);
    }
    function newDate(time) {
      var dt = new Date(0);
      dt.setTime(time);
      return dt;
    }
    function addNano(nano) {
      this.nano += +nano || 0;
      return this;
    }
    function getNano() {
      var ts = normalize(this);
      return (ts.time % 1e3 * DEC6 + +ts.nano + DEC9) % DEC9;
    }
    function fromString2(string2) {
      var time;
      var ts = new Timestamp();
      string2 += "";
      var array = string2.replace(/^\s*[+\-]?\d+/, function(match) {
        var year = +match;
        var y = 1970 + (year - 1970) % 400;
        ts.year = year - y;
        return y;
      }).replace(/(?:Z|([+\-]\d{2}):?(\d{2}))$/, function(match, hour2, min) {
        if (hour2 < 0)
          min *= -1;
        time = (+hour2 * 60 + +min) * 6e4;
        return "";
      }).replace(/\.\d+$/, function(match) {
        ts.nano = +(match + ZERO9).substr(1, 9);
        return "";
      }).split(/\D+/);
      if (array.length > 1) {
        array[1]--;
      } else {
        array[1] = 0;
      }
      ts.time = time = Date.UTC.apply(Date, array) - (time || 0);
      if (isNaN(time)) {
        throw new TypeError("Invalid Date");
      }
      return normalize(ts);
    }
    function fromDate(date) {
      return new Timestamp(+date);
    }
    function fromTimeT(time) {
      return fromTime(time, 0);
    }
    function fromTime(low, high) {
      high |= 0;
      high *= BIT32;
      low = +low || 0;
      var slot = trunc(high / SEC_SLOT) + trunc(low / SEC_SLOT);
      var second2 = high % SEC_SLOT + low % SEC_SLOT;
      var offset = trunc(second2 / SEC_SLOT);
      if (offset) {
        slot += offset;
        second2 -= offset * SEC_SLOT;
      }
      return new Timestamp(second2 * 1e3, 0, slot * YEAR_SLOT);
    }
    function getTimeT() {
      var ts = normalize(this);
      var time = Math.floor(ts.time / 1e3);
      var year = ts.year;
      if (year)
        time += year * DAY_SLOT * SEC_DAY / YEAR_SLOT;
      return time;
    }
    function toJSON() {
      return this.toString().replace(/0{1,6}Z$/, "Z");
    }
    function toString2(format2) {
      var ts = this;
      var dt = ts.toDate();
      var map2 = {
        H,
        L,
        M,
        N,
        S,
        Y,
        a,
        b: b2,
        d,
        e,
        m
      };
      return strftime(format2 || FMT_JSON);
      function strftime(format3) {
        return format3.replace(/%./g, function(match) {
          var m2 = match[1];
          var c = FMT_STRING[m2];
          var f = map2[m2];
          return c ? strftime(c) : f ? f() : match;
        });
      }
      function Y() {
        var year = ts.getYear();
        if (year > 999999) {
          return "+" + year;
        } else if (year > 9999) {
          return "+" + pad(year, 6);
        } else if (year >= 0) {
          return pad(year, 4);
        } else if (year >= -999999) {
          return "-" + pad(-year, 6);
        } else {
          return year;
        }
      }
      function m() {
        return pad2(dt.getUTCMonth() + 1);
      }
      function d() {
        return pad2(dt.getUTCDate());
      }
      function e() {
        return padS(dt.getUTCDate());
      }
      function H() {
        return pad2(dt.getUTCHours());
      }
      function M() {
        return pad2(dt.getUTCMinutes());
      }
      function S() {
        return pad2(dt.getUTCSeconds());
      }
      function L() {
        return pad(dt.getUTCMilliseconds(), 3);
      }
      function N() {
        return pad(ts.getNano(), 9);
      }
      function a() {
        return FMT_DAY[dt.getUTCDay()];
      }
      function b2() {
        return FMT_MONTH[dt.getUTCMonth()];
      }
    }
    function buildWriteInt64(pos0, pos1, pos2, pos3, posH, posL) {
      return writeInt64;
      function writeInt64(buffer2, offset) {
        var ts = normalize(this);
        if (!buffer2)
          buffer2 = new Array(8);
        checkRange(buffer2, offset |= 0);
        var second2 = Math.floor(ts.time / 1e3);
        var day = ts.year * (DAY_SLOT * SEC_DAY / YEAR_SLOT);
        var high = trunc(day / BIT32) + trunc(second2 / BIT32);
        var low = day % BIT32 + second2 % BIT32;
        var slot = Math.floor(low / BIT32);
        if (slot) {
          high += slot;
          low -= slot * BIT32;
        }
        writeUint32(buffer2, offset + posH, high);
        writeUint32(buffer2, offset + posL, low);
        return buffer2;
      }
      function writeUint32(buffer2, offset, value2) {
        buffer2[offset + pos0] = value2 >> 24 & 255;
        buffer2[offset + pos1] = value2 >> 16 & 255;
        buffer2[offset + pos2] = value2 >> 8 & 255;
        buffer2[offset + pos3] = value2 & 255;
      }
    }
    function buildFromInt64(pos0, pos1, pos2, pos3, posH, posL) {
      return fromInt64;
      function fromInt64(buffer2, offset) {
        checkRange(buffer2, offset |= 0);
        var high = readUint322(buffer2, offset + posH);
        var low = readUint322(buffer2, offset + posL);
        return fromTime(low, high);
      }
      function readUint322(buffer2, offset) {
        return buffer2[offset + pos0] * BIT24 + (buffer2[offset + pos1] << 16 | buffer2[offset + pos2] << 8 | buffer2[offset + pos3]);
      }
    }
    function checkRange(buffer2, offset) {
      var last2 = buffer2 && buffer2.length;
      if (last2 == null)
        throw new TypeError("Invalid Buffer");
      if (last2 < offset + 8)
        throw new RangeError("Out of range");
    }
    function Math_trunc(x) {
      var n = x - x % 1;
      return n === 0 && (x < 0 || x === 0 && 1 / x !== 1 / 0) ? -0 : n;
    }
    function padS(v) {
      return (v > 9 ? "" : " ") + (v | 0);
    }
    function pad2(v) {
      return (v > 9 ? "" : "0") + (v | 0);
    }
    function pad(v, len2) {
      return (ZERO9 + (v | 0)).substr(-len2);
    }
  })();
})(timestamp);
const NanoDate = timestamp.exports;
var minimalExports = requireMinimal$2();
function configure$1() {
  minimalExports._configure();
  reader$3._configure(reader_buffer$1);
  writer$2._configure(writer_buffer$1);
}
configure$1();
const methods = [
  "uint64",
  "int64",
  "sint64",
  "fixed64",
  "sfixed64"
];
function patchReader(obj) {
  for (const method of methods) {
    if (obj[method] == null) {
      continue;
    }
    const original = obj[method];
    obj[method] = function() {
      return BigInt(original.call(this).toString());
    };
  }
  return obj;
}
function reader$2(buf2) {
  return patchReader(new reader$3(buf2));
}
function patchWriter(obj) {
  for (const method of methods) {
    if (obj[method] == null) {
      continue;
    }
    const original = obj[method];
    obj[method] = function(val) {
      return original.call(this, val.toString());
    };
  }
  return obj;
}
function writer$1() {
  return patchWriter(writer$2.create());
}
function decodeMessage(buf2, codec) {
  const r = reader$2(buf2 instanceof Uint8Array ? buf2 : buf2.subarray());
  return codec.decode(r);
}
function encodeMessage(message2, codec) {
  const w = writer$1();
  codec.encode(message2, w, {
    lengthDelimited: false
  });
  return w.finish();
}
var CODEC_TYPES;
(function(CODEC_TYPES2) {
  CODEC_TYPES2[CODEC_TYPES2["VARINT"] = 0] = "VARINT";
  CODEC_TYPES2[CODEC_TYPES2["BIT64"] = 1] = "BIT64";
  CODEC_TYPES2[CODEC_TYPES2["LENGTH_DELIMITED"] = 2] = "LENGTH_DELIMITED";
  CODEC_TYPES2[CODEC_TYPES2["START_GROUP"] = 3] = "START_GROUP";
  CODEC_TYPES2[CODEC_TYPES2["END_GROUP"] = 4] = "END_GROUP";
  CODEC_TYPES2[CODEC_TYPES2["BIT32"] = 5] = "BIT32";
})(CODEC_TYPES || (CODEC_TYPES = {}));
function createCodec$1(name2, type, encode3, decode3) {
  return {
    name: name2,
    type,
    encode: encode3,
    decode: decode3
  };
}
function enumeration(v) {
  function findValue(val) {
    if (v[val.toString()] == null) {
      throw new Error("Invalid enum value");
    }
    return v[val];
  }
  const encode3 = function enumEncode(val, writer2) {
    const enumValue = findValue(val);
    writer2.int32(enumValue);
  };
  const decode3 = function enumDecode(reader2) {
    const val = reader2.int32();
    return findValue(val);
  };
  return createCodec$1("enum", CODEC_TYPES.VARINT, encode3, decode3);
}
function message(encode3, decode3) {
  return createCodec$1("message", CODEC_TYPES.LENGTH_DELIMITED, encode3, decode3);
}
var KeyType;
(function(KeyType2) {
  KeyType2["RSA"] = "RSA";
  KeyType2["Ed25519"] = "Ed25519";
  KeyType2["Secp256k1"] = "Secp256k1";
})(KeyType || (KeyType = {}));
var __KeyTypeValues;
(function(__KeyTypeValues2) {
  __KeyTypeValues2[__KeyTypeValues2["RSA"] = 0] = "RSA";
  __KeyTypeValues2[__KeyTypeValues2["Ed25519"] = 1] = "Ed25519";
  __KeyTypeValues2[__KeyTypeValues2["Secp256k1"] = 2] = "Secp256k1";
})(__KeyTypeValues || (__KeyTypeValues = {}));
(function(KeyType2) {
  KeyType2.codec = () => {
    return enumeration(__KeyTypeValues);
  };
})(KeyType || (KeyType = {}));
var PublicKey;
(function(PublicKey2) {
  let _codec;
  PublicKey2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.Type != null) {
          w.uint32(8);
          KeyType.codec().encode(obj.Type, w);
        }
        if (obj.Data != null) {
          w.uint32(18);
          w.bytes(obj.Data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length3) => {
        const obj = {};
        const end2 = length3 == null ? reader2.len : reader2.pos + length3;
        while (reader2.pos < end2) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.Type = KeyType.codec().decode(reader2);
              break;
            case 2:
              obj.Data = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PublicKey2.encode = (obj) => {
    return encodeMessage(obj, PublicKey2.codec());
  };
  PublicKey2.decode = (buf2) => {
    return decodeMessage(buf2, PublicKey2.codec());
  };
})(PublicKey || (PublicKey = {}));
var PrivateKey;
(function(PrivateKey2) {
  let _codec;
  PrivateKey2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.Type != null) {
          w.uint32(8);
          KeyType.codec().encode(obj.Type, w);
        }
        if (obj.Data != null) {
          w.uint32(18);
          w.bytes(obj.Data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length3) => {
        const obj = {};
        const end2 = length3 == null ? reader2.len : reader2.pos + length3;
        while (reader2.pos < end2) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.Type = KeyType.codec().decode(reader2);
              break;
            case 2:
              obj.Data = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PrivateKey2.encode = (obj) => {
    return encodeMessage(obj, PrivateKey2.codec());
  };
  PrivateKey2.decode = (buf2) => {
    return decodeMessage(buf2, PrivateKey2.codec());
  };
})(PrivateKey || (PrivateKey = {}));
var forge$s = {
  options: {
    usePureJavaScript: false
  }
};
var util$2 = { exports: {} };
var api = {};
var baseN$1 = api;
var _reverseAlphabets = {};
api.encode = function(input, alphabet2, maxline) {
  if (typeof alphabet2 !== "string") {
    throw new TypeError('"alphabet" must be a string.');
  }
  if (maxline !== void 0 && typeof maxline !== "number") {
    throw new TypeError('"maxline" must be a number.');
  }
  var output = "";
  if (!(input instanceof Uint8Array)) {
    output = _encodeWithByteBuffer(input, alphabet2);
  } else {
    var i2 = 0;
    var base3 = alphabet2.length;
    var first2 = alphabet2.charAt(0);
    var digits = [0];
    for (i2 = 0; i2 < input.length; ++i2) {
      for (var j = 0, carry = input[i2]; j < digits.length; ++j) {
        carry += digits[j] << 8;
        digits[j] = carry % base3;
        carry = carry / base3 | 0;
      }
      while (carry > 0) {
        digits.push(carry % base3);
        carry = carry / base3 | 0;
      }
    }
    for (i2 = 0; input[i2] === 0 && i2 < input.length - 1; ++i2) {
      output += first2;
    }
    for (i2 = digits.length - 1; i2 >= 0; --i2) {
      output += alphabet2[digits[i2]];
    }
  }
  if (maxline) {
    var regex = new RegExp(".{1," + maxline + "}", "g");
    output = output.match(regex).join("\r\n");
  }
  return output;
};
api.decode = function(input, alphabet2) {
  if (typeof input !== "string") {
    throw new TypeError('"input" must be a string.');
  }
  if (typeof alphabet2 !== "string") {
    throw new TypeError('"alphabet" must be a string.');
  }
  var table2 = _reverseAlphabets[alphabet2];
  if (!table2) {
    table2 = _reverseAlphabets[alphabet2] = [];
    for (var i2 = 0; i2 < alphabet2.length; ++i2) {
      table2[alphabet2.charCodeAt(i2)] = i2;
    }
  }
  input = input.replace(/\s/g, "");
  var base3 = alphabet2.length;
  var first2 = alphabet2.charAt(0);
  var bytes2 = [0];
  for (var i2 = 0; i2 < input.length; i2++) {
    var value2 = table2[input.charCodeAt(i2)];
    if (value2 === void 0) {
      return;
    }
    for (var j = 0, carry = value2; j < bytes2.length; ++j) {
      carry += bytes2[j] * base3;
      bytes2[j] = carry & 255;
      carry >>= 8;
    }
    while (carry > 0) {
      bytes2.push(carry & 255);
      carry >>= 8;
    }
  }
  for (var k = 0; input[k] === first2 && k < input.length - 1; ++k) {
    bytes2.push(0);
  }
  if (typeof Buffer !== "undefined") {
    return Buffer.from(bytes2.reverse());
  }
  return new Uint8Array(bytes2.reverse());
};
function _encodeWithByteBuffer(input, alphabet2) {
  var i2 = 0;
  var base3 = alphabet2.length;
  var first2 = alphabet2.charAt(0);
  var digits = [0];
  for (i2 = 0; i2 < input.length(); ++i2) {
    for (var j = 0, carry = input.at(i2); j < digits.length; ++j) {
      carry += digits[j] << 8;
      digits[j] = carry % base3;
      carry = carry / base3 | 0;
    }
    while (carry > 0) {
      digits.push(carry % base3);
      carry = carry / base3 | 0;
    }
  }
  var output = "";
  for (i2 = 0; input.at(i2) === 0 && i2 < input.length() - 1; ++i2) {
    output += first2;
  }
  for (i2 = digits.length - 1; i2 >= 0; --i2) {
    output += alphabet2[digits[i2]];
  }
  return output;
}
var forge$r = forge$s;
var baseN = baseN$1;
var util$1 = util$2.exports = forge$r.util = forge$r.util || {};
(function() {
  if (typeof process !== "undefined" && process.nextTick && !process.browser) {
    util$1.nextTick = process.nextTick;
    if (typeof setImmediate === "function") {
      util$1.setImmediate = setImmediate;
    } else {
      util$1.setImmediate = util$1.nextTick;
    }
    return;
  }
  if (typeof setImmediate === "function") {
    util$1.setImmediate = function() {
      return setImmediate.apply(void 0, arguments);
    };
    util$1.nextTick = function(callback) {
      return setImmediate(callback);
    };
    return;
  }
  util$1.setImmediate = function(callback) {
    setTimeout(callback, 0);
  };
  if (typeof window !== "undefined" && typeof window.postMessage === "function") {
    let handler = function(event) {
      if (event.source === window && event.data === msg) {
        event.stopPropagation();
        var copy = callbacks.slice();
        callbacks.length = 0;
        copy.forEach(function(callback) {
          callback();
        });
      }
    };
    var msg = "forge.setImmediate";
    var callbacks = [];
    util$1.setImmediate = function(callback) {
      callbacks.push(callback);
      if (callbacks.length === 1) {
        window.postMessage(msg, "*");
      }
    };
    window.addEventListener("message", handler, true);
  }
  if (typeof MutationObserver !== "undefined") {
    var now = Date.now();
    var attr = true;
    var div = document.createElement("div");
    var callbacks = [];
    new MutationObserver(function() {
      var copy = callbacks.slice();
      callbacks.length = 0;
      copy.forEach(function(callback) {
        callback();
      });
    }).observe(div, { attributes: true });
    var oldSetImmediate = util$1.setImmediate;
    util$1.setImmediate = function(callback) {
      if (Date.now() - now > 15) {
        now = Date.now();
        oldSetImmediate(callback);
      } else {
        callbacks.push(callback);
        if (callbacks.length === 1) {
          div.setAttribute("a", attr = !attr);
        }
      }
    };
  }
  util$1.nextTick = util$1.setImmediate;
})();
util$1.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node;
util$1.globalScope = function() {
  if (util$1.isNodejs) {
    return globalThis;
  }
  return typeof self === "undefined" ? window : self;
}();
util$1.isArray = Array.isArray || function(x) {
  return Object.prototype.toString.call(x) === "[object Array]";
};
util$1.isArrayBuffer = function(x) {
  return typeof ArrayBuffer !== "undefined" && x instanceof ArrayBuffer;
};
util$1.isArrayBufferView = function(x) {
  return x && util$1.isArrayBuffer(x.buffer) && x.byteLength !== void 0;
};
function _checkBitsParam(n) {
  if (!(n === 8 || n === 16 || n === 24 || n === 32)) {
    throw new Error("Only 8, 16, 24, or 32 bits supported: " + n);
  }
}
util$1.ByteBuffer = ByteStringBuffer;
function ByteStringBuffer(b2) {
  this.data = "";
  this.read = 0;
  if (typeof b2 === "string") {
    this.data = b2;
  } else if (util$1.isArrayBuffer(b2) || util$1.isArrayBufferView(b2)) {
    if (typeof Buffer !== "undefined" && b2 instanceof Buffer) {
      this.data = b2.toString("binary");
    } else {
      var arr = new Uint8Array(b2);
      try {
        this.data = String.fromCharCode.apply(null, arr);
      } catch (e) {
        for (var i2 = 0; i2 < arr.length; ++i2) {
          this.putByte(arr[i2]);
        }
      }
    }
  } else if (b2 instanceof ByteStringBuffer || typeof b2 === "object" && typeof b2.data === "string" && typeof b2.read === "number") {
    this.data = b2.data;
    this.read = b2.read;
  }
  this._constructedStringLength = 0;
}
util$1.ByteStringBuffer = ByteStringBuffer;
var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
util$1.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {
  this._constructedStringLength += x;
  if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
    this.data.substr(0, 1);
    this._constructedStringLength = 0;
  }
};
util$1.ByteStringBuffer.prototype.length = function() {
  return this.data.length - this.read;
};
util$1.ByteStringBuffer.prototype.isEmpty = function() {
  return this.length() <= 0;
};
util$1.ByteStringBuffer.prototype.putByte = function(b2) {
  return this.putBytes(String.fromCharCode(b2));
};
util$1.ByteStringBuffer.prototype.fillWithByte = function(b2, n) {
  b2 = String.fromCharCode(b2);
  var d = this.data;
  while (n > 0) {
    if (n & 1) {
      d += b2;
    }
    n >>>= 1;
    if (n > 0) {
      b2 += b2;
    }
  }
  this.data = d;
  this._optimizeConstructedString(n);
  return this;
};
util$1.ByteStringBuffer.prototype.putBytes = function(bytes2) {
  this.data += bytes2;
  this._optimizeConstructedString(bytes2.length);
  return this;
};
util$1.ByteStringBuffer.prototype.putString = function(str) {
  return this.putBytes(util$1.encodeUtf8(str));
};
util$1.ByteStringBuffer.prototype.putInt16 = function(i2) {
  return this.putBytes(
    String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255)
  );
};
util$1.ByteStringBuffer.prototype.putInt24 = function(i2) {
  return this.putBytes(
    String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255)
  );
};
util$1.ByteStringBuffer.prototype.putInt32 = function(i2) {
  return this.putBytes(
    String.fromCharCode(i2 >> 24 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255)
  );
};
util$1.ByteStringBuffer.prototype.putInt16Le = function(i2) {
  return this.putBytes(
    String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255)
  );
};
util$1.ByteStringBuffer.prototype.putInt24Le = function(i2) {
  return this.putBytes(
    String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 >> 16 & 255)
  );
};
util$1.ByteStringBuffer.prototype.putInt32Le = function(i2) {
  return this.putBytes(
    String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 24 & 255)
  );
};
util$1.ByteStringBuffer.prototype.putInt = function(i2, n) {
  _checkBitsParam(n);
  var bytes2 = "";
  do {
    n -= 8;
    bytes2 += String.fromCharCode(i2 >> n & 255);
  } while (n > 0);
  return this.putBytes(bytes2);
};
util$1.ByteStringBuffer.prototype.putSignedInt = function(i2, n) {
  if (i2 < 0) {
    i2 += 2 << n - 1;
  }
  return this.putInt(i2, n);
};
util$1.ByteStringBuffer.prototype.putBuffer = function(buffer2) {
  return this.putBytes(buffer2.getBytes());
};
util$1.ByteStringBuffer.prototype.getByte = function() {
  return this.data.charCodeAt(this.read++);
};
util$1.ByteStringBuffer.prototype.getInt16 = function() {
  var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
  this.read += 2;
  return rval;
};
util$1.ByteStringBuffer.prototype.getInt24 = function() {
  var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
  this.read += 3;
  return rval;
};
util$1.ByteStringBuffer.prototype.getInt32 = function() {
  var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
  this.read += 4;
  return rval;
};
util$1.ByteStringBuffer.prototype.getInt16Le = function() {
  var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
  this.read += 2;
  return rval;
};
util$1.ByteStringBuffer.prototype.getInt24Le = function() {
  var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
  this.read += 3;
  return rval;
};
util$1.ByteStringBuffer.prototype.getInt32Le = function() {
  var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
  this.read += 4;
  return rval;
};
util$1.ByteStringBuffer.prototype.getInt = function(n) {
  _checkBitsParam(n);
  var rval = 0;
  do {
    rval = (rval << 8) + this.data.charCodeAt(this.read++);
    n -= 8;
  } while (n > 0);
  return rval;
};
util$1.ByteStringBuffer.prototype.getSignedInt = function(n) {
  var x = this.getInt(n);
  var max = 2 << n - 2;
  if (x >= max) {
    x -= max << 1;
  }
  return x;
};
util$1.ByteStringBuffer.prototype.getBytes = function(count) {
  var rval;
  if (count) {
    count = Math.min(this.length(), count);
    rval = this.data.slice(this.read, this.read + count);
    this.read += count;
  } else if (count === 0) {
    rval = "";
  } else {
    rval = this.read === 0 ? this.data : this.data.slice(this.read);
    this.clear();
  }
  return rval;
};
util$1.ByteStringBuffer.prototype.bytes = function(count) {
  return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
};
util$1.ByteStringBuffer.prototype.at = function(i2) {
  return this.data.charCodeAt(this.read + i2);
};
util$1.ByteStringBuffer.prototype.setAt = function(i2, b2) {
  this.data = this.data.substr(0, this.read + i2) + String.fromCharCode(b2) + this.data.substr(this.read + i2 + 1);
  return this;
};
util$1.ByteStringBuffer.prototype.last = function() {
  return this.data.charCodeAt(this.data.length - 1);
};
util$1.ByteStringBuffer.prototype.copy = function() {
  var c = util$1.createBuffer(this.data);
  c.read = this.read;
  return c;
};
util$1.ByteStringBuffer.prototype.compact = function() {
  if (this.read > 0) {
    this.data = this.data.slice(this.read);
    this.read = 0;
  }
  return this;
};
util$1.ByteStringBuffer.prototype.clear = function() {
  this.data = "";
  this.read = 0;
  return this;
};
util$1.ByteStringBuffer.prototype.truncate = function(count) {
  var len2 = Math.max(0, this.length() - count);
  this.data = this.data.substr(this.read, len2);
  this.read = 0;
  return this;
};
util$1.ByteStringBuffer.prototype.toHex = function() {
  var rval = "";
  for (var i2 = this.read; i2 < this.data.length; ++i2) {
    var b2 = this.data.charCodeAt(i2);
    if (b2 < 16) {
      rval += "0";
    }
    rval += b2.toString(16);
  }
  return rval;
};
util$1.ByteStringBuffer.prototype.toString = function() {
  return util$1.decodeUtf8(this.bytes());
};
function DataBuffer(b2, options) {
  options = options || {};
  this.read = options.readOffset || 0;
  this.growSize = options.growSize || 1024;
  var isArrayBuffer2 = util$1.isArrayBuffer(b2);
  var isArrayBufferView = util$1.isArrayBufferView(b2);
  if (isArrayBuffer2 || isArrayBufferView) {
    if (isArrayBuffer2) {
      this.data = new DataView(b2);
    } else {
      this.data = new DataView(b2.buffer, b2.byteOffset, b2.byteLength);
    }
    this.write = "writeOffset" in options ? options.writeOffset : this.data.byteLength;
    return;
  }
  this.data = new DataView(new ArrayBuffer(0));
  this.write = 0;
  if (b2 !== null && b2 !== void 0) {
    this.putBytes(b2);
  }
  if ("writeOffset" in options) {
    this.write = options.writeOffset;
  }
}
util$1.DataBuffer = DataBuffer;
util$1.DataBuffer.prototype.length = function() {
  return this.write - this.read;
};
util$1.DataBuffer.prototype.isEmpty = function() {
  return this.length() <= 0;
};
util$1.DataBuffer.prototype.accommodate = function(amount, growSize) {
  if (this.length() >= amount) {
    return this;
  }
  growSize = Math.max(growSize || this.growSize, amount);
  var src2 = new Uint8Array(
    this.data.buffer,
    this.data.byteOffset,
    this.data.byteLength
  );
  var dst = new Uint8Array(this.length() + growSize);
  dst.set(src2);
  this.data = new DataView(dst.buffer);
  return this;
};
util$1.DataBuffer.prototype.putByte = function(b2) {
  this.accommodate(1);
  this.data.setUint8(this.write++, b2);
  return this;
};
util$1.DataBuffer.prototype.fillWithByte = function(b2, n) {
  this.accommodate(n);
  for (var i2 = 0; i2 < n; ++i2) {
    this.data.setUint8(b2);
  }
  return this;
};
util$1.DataBuffer.prototype.putBytes = function(bytes2, encoding2) {
  if (util$1.isArrayBufferView(bytes2)) {
    var src2 = new Uint8Array(bytes2.buffer, bytes2.byteOffset, bytes2.byteLength);
    var len2 = src2.byteLength - src2.byteOffset;
    this.accommodate(len2);
    var dst = new Uint8Array(this.data.buffer, this.write);
    dst.set(src2);
    this.write += len2;
    return this;
  }
  if (util$1.isArrayBuffer(bytes2)) {
    var src2 = new Uint8Array(bytes2);
    this.accommodate(src2.byteLength);
    var dst = new Uint8Array(this.data.buffer);
    dst.set(src2, this.write);
    this.write += src2.byteLength;
    return this;
  }
  if (bytes2 instanceof util$1.DataBuffer || typeof bytes2 === "object" && typeof bytes2.read === "number" && typeof bytes2.write === "number" && util$1.isArrayBufferView(bytes2.data)) {
    var src2 = new Uint8Array(bytes2.data.byteLength, bytes2.read, bytes2.length());
    this.accommodate(src2.byteLength);
    var dst = new Uint8Array(bytes2.data.byteLength, this.write);
    dst.set(src2);
    this.write += src2.byteLength;
    return this;
  }
  if (bytes2 instanceof util$1.ByteStringBuffer) {
    bytes2 = bytes2.data;
    encoding2 = "binary";
  }
  encoding2 = encoding2 || "binary";
  if (typeof bytes2 === "string") {
    var view;
    if (encoding2 === "hex") {
      this.accommodate(Math.ceil(bytes2.length / 2));
      view = new Uint8Array(this.data.buffer, this.write);
      this.write += util$1.binary.hex.decode(bytes2, view, this.write);
      return this;
    }
    if (encoding2 === "base64") {
      this.accommodate(Math.ceil(bytes2.length / 4) * 3);
      view = new Uint8Array(this.data.buffer, this.write);
      this.write += util$1.binary.base64.decode(bytes2, view, this.write);
      return this;
    }
    if (encoding2 === "utf8") {
      bytes2 = util$1.encodeUtf8(bytes2);
      encoding2 = "binary";
    }
    if (encoding2 === "binary" || encoding2 === "raw") {
      this.accommodate(bytes2.length);
      view = new Uint8Array(this.data.buffer, this.write);
      this.write += util$1.binary.raw.decode(view);
      return this;
    }
    if (encoding2 === "utf16") {
      this.accommodate(bytes2.length * 2);
      view = new Uint16Array(this.data.buffer, this.write);
      this.write += util$1.text.utf16.encode(view);
      return this;
    }
    throw new Error("Invalid encoding: " + encoding2);
  }
  throw Error("Invalid parameter: " + bytes2);
};
util$1.DataBuffer.prototype.putBuffer = function(buffer2) {
  this.putBytes(buffer2);
  buffer2.clear();
  return this;
};
util$1.DataBuffer.prototype.putString = function(str) {
  return this.putBytes(str, "utf16");
};
util$1.DataBuffer.prototype.putInt16 = function(i2) {
  this.accommodate(2);
  this.data.setInt16(this.write, i2);
  this.write += 2;
  return this;
};
util$1.DataBuffer.prototype.putInt24 = function(i2) {
  this.accommodate(3);
  this.data.setInt16(this.write, i2 >> 8 & 65535);
  this.data.setInt8(this.write, i2 >> 16 & 255);
  this.write += 3;
  return this;
};
util$1.DataBuffer.prototype.putInt32 = function(i2) {
  this.accommodate(4);
  this.data.setInt32(this.write, i2);
  this.write += 4;
  return this;
};
util$1.DataBuffer.prototype.putInt16Le = function(i2) {
  this.accommodate(2);
  this.data.setInt16(this.write, i2, true);
  this.write += 2;
  return this;
};
util$1.DataBuffer.prototype.putInt24Le = function(i2) {
  this.accommodate(3);
  this.data.setInt8(this.write, i2 >> 16 & 255);
  this.data.setInt16(this.write, i2 >> 8 & 65535, true);
  this.write += 3;
  return this;
};
util$1.DataBuffer.prototype.putInt32Le = function(i2) {
  this.accommodate(4);
  this.data.setInt32(this.write, i2, true);
  this.write += 4;
  return this;
};
util$1.DataBuffer.prototype.putInt = function(i2, n) {
  _checkBitsParam(n);
  this.accommodate(n / 8);
  do {
    n -= 8;
    this.data.setInt8(this.write++, i2 >> n & 255);
  } while (n > 0);
  return this;
};
util$1.DataBuffer.prototype.putSignedInt = function(i2, n) {
  _checkBitsParam(n);
  this.accommodate(n / 8);
  if (i2 < 0) {
    i2 += 2 << n - 1;
  }
  return this.putInt(i2, n);
};
util$1.DataBuffer.prototype.getByte = function() {
  return this.data.getInt8(this.read++);
};
util$1.DataBuffer.prototype.getInt16 = function() {
  var rval = this.data.getInt16(this.read);
  this.read += 2;
  return rval;
};
util$1.DataBuffer.prototype.getInt24 = function() {
  var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
  this.read += 3;
  return rval;
};
util$1.DataBuffer.prototype.getInt32 = function() {
  var rval = this.data.getInt32(this.read);
  this.read += 4;
  return rval;
};
util$1.DataBuffer.prototype.getInt16Le = function() {
  var rval = this.data.getInt16(this.read, true);
  this.read += 2;
  return rval;
};
util$1.DataBuffer.prototype.getInt24Le = function() {
  var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
  this.read += 3;
  return rval;
};
util$1.DataBuffer.prototype.getInt32Le = function() {
  var rval = this.data.getInt32(this.read, true);
  this.read += 4;
  return rval;
};
util$1.DataBuffer.prototype.getInt = function(n) {
  _checkBitsParam(n);
  var rval = 0;
  do {
    rval = (rval << 8) + this.data.getInt8(this.read++);
    n -= 8;
  } while (n > 0);
  return rval;
};
util$1.DataBuffer.prototype.getSignedInt = function(n) {
  var x = this.getInt(n);
  var max = 2 << n - 2;
  if (x >= max) {
    x -= max << 1;
  }
  return x;
};
util$1.DataBuffer.prototype.getBytes = function(count) {
  var rval;
  if (count) {
    count = Math.min(this.length(), count);
    rval = this.data.slice(this.read, this.read + count);
    this.read += count;
  } else if (count === 0) {
    rval = "";
  } else {
    rval = this.read === 0 ? this.data : this.data.slice(this.read);
    this.clear();
  }
  return rval;
};
util$1.DataBuffer.prototype.bytes = function(count) {
  return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
};
util$1.DataBuffer.prototype.at = function(i2) {
  return this.data.getUint8(this.read + i2);
};
util$1.DataBuffer.prototype.setAt = function(i2, b2) {
  this.data.setUint8(i2, b2);
  return this;
};
util$1.DataBuffer.prototype.last = function() {
  return this.data.getUint8(this.write - 1);
};
util$1.DataBuffer.prototype.copy = function() {
  return new util$1.DataBuffer(this);
};
util$1.DataBuffer.prototype.compact = function() {
  if (this.read > 0) {
    var src2 = new Uint8Array(this.data.buffer, this.read);
    var dst = new Uint8Array(src2.byteLength);
    dst.set(src2);
    this.data = new DataView(dst);
    this.write -= this.read;
    this.read = 0;
  }
  return this;
};
util$1.DataBuffer.prototype.clear = function() {
  this.data = new DataView(new ArrayBuffer(0));
  this.read = this.write = 0;
  return this;
};
util$1.DataBuffer.prototype.truncate = function(count) {
  this.write = Math.max(0, this.length() - count);
  this.read = Math.min(this.read, this.write);
  return this;
};
util$1.DataBuffer.prototype.toHex = function() {
  var rval = "";
  for (var i2 = this.read; i2 < this.data.byteLength; ++i2) {
    var b2 = this.data.getUint8(i2);
    if (b2 < 16) {
      rval += "0";
    }
    rval += b2.toString(16);
  }
  return rval;
};
util$1.DataBuffer.prototype.toString = function(encoding2) {
  var view = new Uint8Array(this.data, this.read, this.length());
  encoding2 = encoding2 || "utf8";
  if (encoding2 === "binary" || encoding2 === "raw") {
    return util$1.binary.raw.encode(view);
  }
  if (encoding2 === "hex") {
    return util$1.binary.hex.encode(view);
  }
  if (encoding2 === "base64") {
    return util$1.binary.base64.encode(view);
  }
  if (encoding2 === "utf8") {
    return util$1.text.utf8.decode(view);
  }
  if (encoding2 === "utf16") {
    return util$1.text.utf16.decode(view);
  }
  throw new Error("Invalid encoding: " + encoding2);
};
util$1.createBuffer = function(input, encoding2) {
  encoding2 = encoding2 || "raw";
  if (input !== void 0 && encoding2 === "utf8") {
    input = util$1.encodeUtf8(input);
  }
  return new util$1.ByteBuffer(input);
};
util$1.fillString = function(c, n) {
  var s2 = "";
  while (n > 0) {
    if (n & 1) {
      s2 += c;
    }
    n >>>= 1;
    if (n > 0) {
      c += c;
    }
  }
  return s2;
};
util$1.xorBytes = function(s1, s2, n) {
  var s3 = "";
  var b2 = "";
  var t = "";
  var i2 = 0;
  var c = 0;
  for (; n > 0; --n, ++i2) {
    b2 = s1.charCodeAt(i2) ^ s2.charCodeAt(i2);
    if (c >= 10) {
      s3 += t;
      t = "";
      c = 0;
    }
    t += String.fromCharCode(b2);
    ++c;
  }
  s3 += t;
  return s3;
};
util$1.hexToBytes = function(hex) {
  var rval = "";
  var i2 = 0;
  if (hex.length & true) {
    i2 = 1;
    rval += String.fromCharCode(parseInt(hex[0], 16));
  }
  for (; i2 < hex.length; i2 += 2) {
    rval += String.fromCharCode(parseInt(hex.substr(i2, 2), 16));
  }
  return rval;
};
util$1.bytesToHex = function(bytes2) {
  return util$1.createBuffer(bytes2).toHex();
};
util$1.int32ToBytes = function(i2) {
  return String.fromCharCode(i2 >> 24 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255);
};
var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var _base64Idx = [
  62,
  -1,
  -1,
  -1,
  63,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  -1,
  -1,
  -1,
  64,
  -1,
  -1,
  -1,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51
];
var _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
util$1.encode64 = function(input, maxline) {
  var line = "";
  var output = "";
  var chr1, chr2, chr3;
  var i2 = 0;
  while (i2 < input.length) {
    chr1 = input.charCodeAt(i2++);
    chr2 = input.charCodeAt(i2++);
    chr3 = input.charCodeAt(i2++);
    line += _base64.charAt(chr1 >> 2);
    line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
    if (isNaN(chr2)) {
      line += "==";
    } else {
      line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
      line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
    }
    if (maxline && line.length > maxline) {
      output += line.substr(0, maxline) + "\r\n";
      line = line.substr(maxline);
    }
  }
  output += line;
  return output;
};
util$1.decode64 = function(input) {
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
  var output = "";
  var enc1, enc2, enc3, enc4;
  var i2 = 0;
  while (i2 < input.length) {
    enc1 = _base64Idx[input.charCodeAt(i2++) - 43];
    enc2 = _base64Idx[input.charCodeAt(i2++) - 43];
    enc3 = _base64Idx[input.charCodeAt(i2++) - 43];
    enc4 = _base64Idx[input.charCodeAt(i2++) - 43];
    output += String.fromCharCode(enc1 << 2 | enc2 >> 4);
    if (enc3 !== 64) {
      output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);
      if (enc4 !== 64) {
        output += String.fromCharCode((enc3 & 3) << 6 | enc4);
      }
    }
  }
  return output;
};
util$1.encodeUtf8 = function(str) {
  return unescape(encodeURIComponent(str));
};
util$1.decodeUtf8 = function(str) {
  return decodeURIComponent(escape(str));
};
util$1.binary = {
  raw: {},
  hex: {},
  base64: {},
  base58: {},
  baseN: {
    encode: baseN.encode,
    decode: baseN.decode
  }
};
util$1.binary.raw.encode = function(bytes2) {
  return String.fromCharCode.apply(null, bytes2);
};
util$1.binary.raw.decode = function(str, output, offset) {
  var out = output;
  if (!out) {
    out = new Uint8Array(str.length);
  }
  offset = offset || 0;
  var j = offset;
  for (var i2 = 0; i2 < str.length; ++i2) {
    out[j++] = str.charCodeAt(i2);
  }
  return output ? j - offset : out;
};
util$1.binary.hex.encode = util$1.bytesToHex;
util$1.binary.hex.decode = function(hex, output, offset) {
  var out = output;
  if (!out) {
    out = new Uint8Array(Math.ceil(hex.length / 2));
  }
  offset = offset || 0;
  var i2 = 0, j = offset;
  if (hex.length & 1) {
    i2 = 1;
    out[j++] = parseInt(hex[0], 16);
  }
  for (; i2 < hex.length; i2 += 2) {
    out[j++] = parseInt(hex.substr(i2, 2), 16);
  }
  return output ? j - offset : out;
};
util$1.binary.base64.encode = function(input, maxline) {
  var line = "";
  var output = "";
  var chr1, chr2, chr3;
  var i2 = 0;
  while (i2 < input.byteLength) {
    chr1 = input[i2++];
    chr2 = input[i2++];
    chr3 = input[i2++];
    line += _base64.charAt(chr1 >> 2);
    line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
    if (isNaN(chr2)) {
      line += "==";
    } else {
      line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
      line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
    }
    if (maxline && line.length > maxline) {
      output += line.substr(0, maxline) + "\r\n";
      line = line.substr(maxline);
    }
  }
  output += line;
  return output;
};
util$1.binary.base64.decode = function(input, output, offset) {
  var out = output;
  if (!out) {
    out = new Uint8Array(Math.ceil(input.length / 4) * 3);
  }
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
  offset = offset || 0;
  var enc1, enc2, enc3, enc4;
  var i2 = 0, j = offset;
  while (i2 < input.length) {
    enc1 = _base64Idx[input.charCodeAt(i2++) - 43];
    enc2 = _base64Idx[input.charCodeAt(i2++) - 43];
    enc3 = _base64Idx[input.charCodeAt(i2++) - 43];
    enc4 = _base64Idx[input.charCodeAt(i2++) - 43];
    out[j++] = enc1 << 2 | enc2 >> 4;
    if (enc3 !== 64) {
      out[j++] = (enc2 & 15) << 4 | enc3 >> 2;
      if (enc4 !== 64) {
        out[j++] = (enc3 & 3) << 6 | enc4;
      }
    }
  }
  return output ? j - offset : out.subarray(0, j);
};
util$1.binary.base58.encode = function(input, maxline) {
  return util$1.binary.baseN.encode(input, _base58, maxline);
};
util$1.binary.base58.decode = function(input, maxline) {
  return util$1.binary.baseN.decode(input, _base58, maxline);
};
util$1.text = {
  utf8: {},
  utf16: {}
};
util$1.text.utf8.encode = function(str, output, offset) {
  str = util$1.encodeUtf8(str);
  var out = output;
  if (!out) {
    out = new Uint8Array(str.length);
  }
  offset = offset || 0;
  var j = offset;
  for (var i2 = 0; i2 < str.length; ++i2) {
    out[j++] = str.charCodeAt(i2);
  }
  return output ? j - offset : out;
};
util$1.text.utf8.decode = function(bytes2) {
  return util$1.decodeUtf8(String.fromCharCode.apply(null, bytes2));
};
util$1.text.utf16.encode = function(str, output, offset) {
  var out = output;
  if (!out) {
    out = new Uint8Array(str.length * 2);
  }
  var view = new Uint16Array(out.buffer);
  offset = offset || 0;
  var j = offset;
  var k = offset;
  for (var i2 = 0; i2 < str.length; ++i2) {
    view[k++] = str.charCodeAt(i2);
    j += 2;
  }
  return output ? j - offset : out;
};
util$1.text.utf16.decode = function(bytes2) {
  return String.fromCharCode.apply(null, new Uint16Array(bytes2.buffer));
};
util$1.deflate = function(api2, bytes2, raw2) {
  bytes2 = util$1.decode64(api2.deflate(util$1.encode64(bytes2)).rval);
  if (raw2) {
    var start = 2;
    var flg = bytes2.charCodeAt(1);
    if (flg & 32) {
      start = 6;
    }
    bytes2 = bytes2.substring(start, bytes2.length - 4);
  }
  return bytes2;
};
util$1.inflate = function(api2, bytes2, raw2) {
  var rval = api2.inflate(util$1.encode64(bytes2)).rval;
  return rval === null ? null : util$1.decode64(rval);
};
var _setStorageObject = function(api2, id, obj) {
  if (!api2) {
    throw new Error("WebStorage not available.");
  }
  var rval;
  if (obj === null) {
    rval = api2.removeItem(id);
  } else {
    obj = util$1.encode64(JSON.stringify(obj));
    rval = api2.setItem(id, obj);
  }
  if (typeof rval !== "undefined" && rval.rval !== true) {
    var error2 = new Error(rval.error.message);
    error2.id = rval.error.id;
    error2.name = rval.error.name;
    throw error2;
  }
};
var _getStorageObject = function(api2, id) {
  if (!api2) {
    throw new Error("WebStorage not available.");
  }
  var rval = api2.getItem(id);
  if (api2.init) {
    if (rval.rval === null) {
      if (rval.error) {
        var error2 = new Error(rval.error.message);
        error2.id = rval.error.id;
        error2.name = rval.error.name;
        throw error2;
      }
      rval = null;
    } else {
      rval = rval.rval;
    }
  }
  if (rval !== null) {
    rval = JSON.parse(util$1.decode64(rval));
  }
  return rval;
};
var _setItem = function(api2, id, key, data) {
  var obj = _getStorageObject(api2, id);
  if (obj === null) {
    obj = {};
  }
  obj[key] = data;
  _setStorageObject(api2, id, obj);
};
var _getItem = function(api2, id, key) {
  var rval = _getStorageObject(api2, id);
  if (rval !== null) {
    rval = key in rval ? rval[key] : null;
  }
  return rval;
};
var _removeItem = function(api2, id, key) {
  var obj = _getStorageObject(api2, id);
  if (obj !== null && key in obj) {
    delete obj[key];
    var empty2 = true;
    for (var prop in obj) {
      empty2 = false;
      break;
    }
    if (empty2) {
      obj = null;
    }
    _setStorageObject(api2, id, obj);
  }
};
var _clearItems = function(api2, id) {
  _setStorageObject(api2, id, null);
};
var _callStorageFunction = function(func, args, location2) {
  var rval = null;
  if (typeof location2 === "undefined") {
    location2 = ["web", "flash"];
  }
  var type;
  var done = false;
  var exception = null;
  for (var idx in location2) {
    type = location2[idx];
    try {
      if (type === "flash" || type === "both") {
        if (args[0] === null) {
          throw new Error("Flash local storage not available.");
        }
        rval = func.apply(this, args);
        done = type === "flash";
      }
      if (type === "web" || type === "both") {
        args[0] = localStorage;
        rval = func.apply(this, args);
        done = true;
      }
    } catch (ex) {
      exception = ex;
    }
    if (done) {
      break;
    }
  }
  if (!done) {
    throw exception;
  }
  return rval;
};
util$1.setItem = function(api2, id, key, data, location2) {
  _callStorageFunction(_setItem, arguments, location2);
};
util$1.getItem = function(api2, id, key, location2) {
  return _callStorageFunction(_getItem, arguments, location2);
};
util$1.removeItem = function(api2, id, key, location2) {
  _callStorageFunction(_removeItem, arguments, location2);
};
util$1.clearItems = function(api2, id, location2) {
  _callStorageFunction(_clearItems, arguments, location2);
};
util$1.isEmpty = function(obj) {
  for (var prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      return false;
    }
  }
  return true;
};
util$1.format = function(format2) {
  var re2 = /%./g;
  var match;
  var part;
  var argi = 0;
  var parts2 = [];
  var last2 = 0;
  while (match = re2.exec(format2)) {
    part = format2.substring(last2, re2.lastIndex - 2);
    if (part.length > 0) {
      parts2.push(part);
    }
    last2 = re2.lastIndex;
    var code2 = match[0][1];
    switch (code2) {
      case "s":
      case "o":
        if (argi < arguments.length) {
          parts2.push(arguments[argi++ + 1]);
        } else {
          parts2.push("<?>");
        }
        break;
      case "%":
        parts2.push("%");
        break;
      default:
        parts2.push("<%" + code2 + "?>");
    }
  }
  parts2.push(format2.substring(last2));
  return parts2.join("");
};
util$1.formatNumber = function(number, decimals, dec_point, thousands_sep) {
  var n = number, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
  var d = dec_point === void 0 ? "," : dec_point;
  var t = thousands_sep === void 0 ? "." : thousands_sep, s2 = n < 0 ? "-" : "";
  var i2 = parseInt(n = Math.abs(+n || 0).toFixed(c), 10) + "";
  var j = i2.length > 3 ? i2.length % 3 : 0;
  return s2 + (j ? i2.substr(0, j) + t : "") + i2.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c ? d + Math.abs(n - i2).toFixed(c).slice(2) : "");
};
util$1.formatSize = function(size2) {
  if (size2 >= 1073741824) {
    size2 = util$1.formatNumber(size2 / 1073741824, 2, ".", "") + " GiB";
  } else if (size2 >= 1048576) {
    size2 = util$1.formatNumber(size2 / 1048576, 2, ".", "") + " MiB";
  } else if (size2 >= 1024) {
    size2 = util$1.formatNumber(size2 / 1024, 0) + " KiB";
  } else {
    size2 = util$1.formatNumber(size2, 0) + " bytes";
  }
  return size2;
};
util$1.bytesFromIP = function(ip2) {
  if (ip2.indexOf(".") !== -1) {
    return util$1.bytesFromIPv4(ip2);
  }
  if (ip2.indexOf(":") !== -1) {
    return util$1.bytesFromIPv6(ip2);
  }
  return null;
};
util$1.bytesFromIPv4 = function(ip2) {
  ip2 = ip2.split(".");
  if (ip2.length !== 4) {
    return null;
  }
  var b2 = util$1.createBuffer();
  for (var i2 = 0; i2 < ip2.length; ++i2) {
    var num = parseInt(ip2[i2], 10);
    if (isNaN(num)) {
      return null;
    }
    b2.putByte(num);
  }
  return b2.getBytes();
};
util$1.bytesFromIPv6 = function(ip2) {
  var blanks = 0;
  ip2 = ip2.split(":").filter(function(e) {
    if (e.length === 0)
      ++blanks;
    return true;
  });
  var zeros = (8 - ip2.length + blanks) * 2;
  var b2 = util$1.createBuffer();
  for (var i2 = 0; i2 < 8; ++i2) {
    if (!ip2[i2] || ip2[i2].length === 0) {
      b2.fillWithByte(0, zeros);
      zeros = 0;
      continue;
    }
    var bytes2 = util$1.hexToBytes(ip2[i2]);
    if (bytes2.length < 2) {
      b2.putByte(0);
    }
    b2.putBytes(bytes2);
  }
  return b2.getBytes();
};
util$1.bytesToIP = function(bytes2) {
  if (bytes2.length === 4) {
    return util$1.bytesToIPv4(bytes2);
  }
  if (bytes2.length === 16) {
    return util$1.bytesToIPv6(bytes2);
  }
  return null;
};
util$1.bytesToIPv4 = function(bytes2) {
  if (bytes2.length !== 4) {
    return null;
  }
  var ip2 = [];
  for (var i2 = 0; i2 < bytes2.length; ++i2) {
    ip2.push(bytes2.charCodeAt(i2));
  }
  return ip2.join(".");
};
util$1.bytesToIPv6 = function(bytes2) {
  if (bytes2.length !== 16) {
    return null;
  }
  var ip2 = [];
  var zeroGroups = [];
  var zeroMaxGroup = 0;
  for (var i2 = 0; i2 < bytes2.length; i2 += 2) {
    var hex = util$1.bytesToHex(bytes2[i2] + bytes2[i2 + 1]);
    while (hex[0] === "0" && hex !== "0") {
      hex = hex.substr(1);
    }
    if (hex === "0") {
      var last2 = zeroGroups[zeroGroups.length - 1];
      var idx = ip2.length;
      if (!last2 || idx !== last2.end + 1) {
        zeroGroups.push({ start: idx, end: idx });
      } else {
        last2.end = idx;
        if (last2.end - last2.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {
          zeroMaxGroup = zeroGroups.length - 1;
        }
      }
    }
    ip2.push(hex);
  }
  if (zeroGroups.length > 0) {
    var group = zeroGroups[zeroMaxGroup];
    if (group.end - group.start > 0) {
      ip2.splice(group.start, group.end - group.start + 1, "");
      if (group.start === 0) {
        ip2.unshift("");
      }
      if (group.end === 7) {
        ip2.push("");
      }
    }
  }
  return ip2.join(":");
};
util$1.estimateCores = function(options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = {};
  }
  options = options || {};
  if ("cores" in util$1 && !options.update) {
    return callback(null, util$1.cores);
  }
  if (typeof navigator !== "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) {
    util$1.cores = navigator.hardwareConcurrency;
    return callback(null, util$1.cores);
  }
  if (typeof Worker === "undefined") {
    util$1.cores = 1;
    return callback(null, util$1.cores);
  }
  if (typeof Blob === "undefined") {
    util$1.cores = 2;
    return callback(null, util$1.cores);
  }
  var blobUrl = URL.createObjectURL(new Blob([
    "(",
    function() {
      self.addEventListener("message", function(e) {
        var st = Date.now();
        var et = st + 4;
        self.postMessage({ st, et });
      });
    }.toString(),
    ")()"
  ], { type: "application/javascript" }));
  sample([], 5, 16);
  function sample(max, samples, numWorkers) {
    if (samples === 0) {
      var avg = Math.floor(max.reduce(function(avg2, x) {
        return avg2 + x;
      }, 0) / max.length);
      util$1.cores = Math.max(1, avg);
      URL.revokeObjectURL(blobUrl);
      return callback(null, util$1.cores);
    }
    map2(numWorkers, function(err2, results) {
      max.push(reduce2(numWorkers, results));
      sample(max, samples - 1, numWorkers);
    });
  }
  function map2(numWorkers, callback2) {
    var workers = [];
    var results = [];
    for (var i2 = 0; i2 < numWorkers; ++i2) {
      var worker = new Worker(blobUrl);
      worker.addEventListener("message", function(e) {
        results.push(e.data);
        if (results.length === numWorkers) {
          for (var i3 = 0; i3 < numWorkers; ++i3) {
            workers[i3].terminate();
          }
          callback2(null, results);
        }
      });
      workers.push(worker);
    }
    for (var i2 = 0; i2 < numWorkers; ++i2) {
      workers[i2].postMessage(i2);
    }
  }
  function reduce2(numWorkers, results) {
    var overlaps = [];
    for (var n = 0; n < numWorkers; ++n) {
      var r1 = results[n];
      var overlap = overlaps[n] = [];
      for (var i2 = 0; i2 < numWorkers; ++i2) {
        if (n === i2) {
          continue;
        }
        var r2 = results[i2];
        if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) {
          overlap.push(i2);
        }
      }
    }
    return overlaps.reduce(function(max, overlap2) {
      return Math.max(max, overlap2.length);
    }, 0);
  }
};
var forge$q = forge$s;
forge$q.pki = forge$q.pki || {};
var oids$2 = forge$q.pki.oids = forge$q.oids = forge$q.oids || {};
function _IN(id, name2) {
  oids$2[id] = name2;
  oids$2[name2] = id;
}
function _I_(id, name2) {
  oids$2[id] = name2;
}
_IN("1.2.840.113549.1.1.1", "rsaEncryption");
_IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
_IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
_IN("1.2.840.113549.1.1.7", "RSAES-OAEP");
_IN("1.2.840.113549.1.1.8", "mgf1");
_IN("1.2.840.113549.1.1.9", "pSpecified");
_IN("1.2.840.113549.1.1.10", "RSASSA-PSS");
_IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
_IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
_IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
_IN("1.3.101.112", "EdDSA25519");
_IN("1.2.840.10040.4.3", "dsa-with-sha1");
_IN("1.3.14.3.2.7", "desCBC");
_IN("1.3.14.3.2.26", "sha1");
_IN("1.3.14.3.2.29", "sha1WithRSASignature");
_IN("2.16.840.1.101.3.4.2.1", "sha256");
_IN("2.16.840.1.101.3.4.2.2", "sha384");
_IN("2.16.840.1.101.3.4.2.3", "sha512");
_IN("2.16.840.1.101.3.4.2.4", "sha224");
_IN("2.16.840.1.101.3.4.2.5", "sha512-224");
_IN("2.16.840.1.101.3.4.2.6", "sha512-256");
_IN("1.2.840.113549.2.2", "md2");
_IN("1.2.840.113549.2.5", "md5");
_IN("1.2.840.113549.1.7.1", "data");
_IN("1.2.840.113549.1.7.2", "signedData");
_IN("1.2.840.113549.1.7.3", "envelopedData");
_IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
_IN("1.2.840.113549.1.7.5", "digestedData");
_IN("1.2.840.113549.1.7.6", "encryptedData");
_IN("1.2.840.113549.1.9.1", "emailAddress");
_IN("1.2.840.113549.1.9.2", "unstructuredName");
_IN("1.2.840.113549.1.9.3", "contentType");
_IN("1.2.840.113549.1.9.4", "messageDigest");
_IN("1.2.840.113549.1.9.5", "signingTime");
_IN("1.2.840.113549.1.9.6", "counterSignature");
_IN("1.2.840.113549.1.9.7", "challengePassword");
_IN("1.2.840.113549.1.9.8", "unstructuredAddress");
_IN("1.2.840.113549.1.9.14", "extensionRequest");
_IN("1.2.840.113549.1.9.20", "friendlyName");
_IN("1.2.840.113549.1.9.21", "localKeyId");
_IN("1.2.840.113549.1.9.22.1", "x509Certificate");
_IN("1.2.840.113549.1.12.10.1.1", "keyBag");
_IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
_IN("1.2.840.113549.1.12.10.1.3", "certBag");
_IN("1.2.840.113549.1.12.10.1.4", "crlBag");
_IN("1.2.840.113549.1.12.10.1.5", "secretBag");
_IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
_IN("1.2.840.113549.1.5.13", "pkcs5PBES2");
_IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
_IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
_IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
_IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
_IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
_IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
_IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
_IN("1.2.840.113549.2.7", "hmacWithSHA1");
_IN("1.2.840.113549.2.8", "hmacWithSHA224");
_IN("1.2.840.113549.2.9", "hmacWithSHA256");
_IN("1.2.840.113549.2.10", "hmacWithSHA384");
_IN("1.2.840.113549.2.11", "hmacWithSHA512");
_IN("1.2.840.113549.3.7", "des-EDE3-CBC");
_IN("2.16.840.1.101.3.4.1.2", "aes128-CBC");
_IN("2.16.840.1.101.3.4.1.22", "aes192-CBC");
_IN("2.16.840.1.101.3.4.1.42", "aes256-CBC");
_IN("2.5.4.3", "commonName");
_IN("2.5.4.4", "surname");
_IN("2.5.4.5", "serialNumber");
_IN("2.5.4.6", "countryName");
_IN("2.5.4.7", "localityName");
_IN("2.5.4.8", "stateOrProvinceName");
_IN("2.5.4.9", "streetAddress");
_IN("2.5.4.10", "organizationName");
_IN("2.5.4.11", "organizationalUnitName");
_IN("2.5.4.12", "title");
_IN("2.5.4.13", "description");
_IN("2.5.4.15", "businessCategory");
_IN("2.5.4.17", "postalCode");
_IN("2.5.4.42", "givenName");
_IN("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
_IN("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
_IN("2.16.840.1.113730.1.1", "nsCertType");
_IN("2.16.840.1.113730.1.13", "nsComment");
_I_("2.5.29.1", "authorityKeyIdentifier");
_I_("2.5.29.2", "keyAttributes");
_I_("2.5.29.3", "certificatePolicies");
_I_("2.5.29.4", "keyUsageRestriction");
_I_("2.5.29.5", "policyMapping");
_I_("2.5.29.6", "subtreesConstraint");
_I_("2.5.29.7", "subjectAltName");
_I_("2.5.29.8", "issuerAltName");
_I_("2.5.29.9", "subjectDirectoryAttributes");
_I_("2.5.29.10", "basicConstraints");
_I_("2.5.29.11", "nameConstraints");
_I_("2.5.29.12", "policyConstraints");
_I_("2.5.29.13", "basicConstraints");
_IN("2.5.29.14", "subjectKeyIdentifier");
_IN("2.5.29.15", "keyUsage");
_I_("2.5.29.16", "privateKeyUsagePeriod");
_IN("2.5.29.17", "subjectAltName");
_IN("2.5.29.18", "issuerAltName");
_IN("2.5.29.19", "basicConstraints");
_I_("2.5.29.20", "cRLNumber");
_I_("2.5.29.21", "cRLReason");
_I_("2.5.29.22", "expirationDate");
_I_("2.5.29.23", "instructionCode");
_I_("2.5.29.24", "invalidityDate");
_I_("2.5.29.25", "cRLDistributionPoints");
_I_("2.5.29.26", "issuingDistributionPoint");
_I_("2.5.29.27", "deltaCRLIndicator");
_I_("2.5.29.28", "issuingDistributionPoint");
_I_("2.5.29.29", "certificateIssuer");
_I_("2.5.29.30", "nameConstraints");
_IN("2.5.29.31", "cRLDistributionPoints");
_IN("2.5.29.32", "certificatePolicies");
_I_("2.5.29.33", "policyMappings");
_I_("2.5.29.34", "policyConstraints");
_IN("2.5.29.35", "authorityKeyIdentifier");
_I_("2.5.29.36", "policyConstraints");
_IN("2.5.29.37", "extKeyUsage");
_I_("2.5.29.46", "freshestCRL");
_I_("2.5.29.54", "inhibitAnyPolicy");
_IN("1.3.6.1.4.1.11129.2.4.2", "timestampList");
_IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
_IN("1.3.6.1.5.5.7.3.1", "serverAuth");
_IN("1.3.6.1.5.5.7.3.2", "clientAuth");
_IN("1.3.6.1.5.5.7.3.3", "codeSigning");
_IN("1.3.6.1.5.5.7.3.4", "emailProtection");
_IN("1.3.6.1.5.5.7.3.8", "timeStamping");
var forge$p = forge$s;
var asn1$5 = forge$p.asn1 = forge$p.asn1 || {};
asn1$5.Class = {
  UNIVERSAL: 0,
  APPLICATION: 64,
  CONTEXT_SPECIFIC: 128,
  PRIVATE: 192
};
asn1$5.Type = {
  NONE: 0,
  BOOLEAN: 1,
  INTEGER: 2,
  BITSTRING: 3,
  OCTETSTRING: 4,
  NULL: 5,
  OID: 6,
  ODESC: 7,
  EXTERNAL: 8,
  REAL: 9,
  ENUMERATED: 10,
  EMBEDDED: 11,
  UTF8: 12,
  ROID: 13,
  SEQUENCE: 16,
  SET: 17,
  PRINTABLESTRING: 19,
  IA5STRING: 22,
  UTCTIME: 23,
  GENERALIZEDTIME: 24,
  BMPSTRING: 30
};
asn1$5.create = function(tagClass, type, constructed, value2, options) {
  if (forge$p.util.isArray(value2)) {
    var tmp = [];
    for (var i2 = 0; i2 < value2.length; ++i2) {
      if (value2[i2] !== void 0) {
        tmp.push(value2[i2]);
      }
    }
    value2 = tmp;
  }
  var obj = {
    tagClass,
    type,
    constructed,
    composed: constructed || forge$p.util.isArray(value2),
    value: value2
  };
  if (options && "bitStringContents" in options) {
    obj.bitStringContents = options.bitStringContents;
    obj.original = asn1$5.copy(obj);
  }
  return obj;
};
asn1$5.copy = function(obj, options) {
  var copy;
  if (forge$p.util.isArray(obj)) {
    copy = [];
    for (var i2 = 0; i2 < obj.length; ++i2) {
      copy.push(asn1$5.copy(obj[i2], options));
    }
    return copy;
  }
  if (typeof obj === "string") {
    return obj;
  }
  copy = {
    tagClass: obj.tagClass,
    type: obj.type,
    constructed: obj.constructed,
    composed: obj.composed,
    value: asn1$5.copy(obj.value, options)
  };
  if (options && !options.excludeBitStringContents) {
    copy.bitStringContents = obj.bitStringContents;
  }
  return copy;
};
asn1$5.equals = function(obj1, obj2, options) {
  if (forge$p.util.isArray(obj1)) {
    if (!forge$p.util.isArray(obj2)) {
      return false;
    }
    if (obj1.length !== obj2.length) {
      return false;
    }
    for (var i2 = 0; i2 < obj1.length; ++i2) {
      if (!asn1$5.equals(obj1[i2], obj2[i2])) {
        return false;
      }
    }
    return true;
  }
  if (typeof obj1 !== typeof obj2) {
    return false;
  }
  if (typeof obj1 === "string") {
    return obj1 === obj2;
  }
  var equal2 = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1$5.equals(obj1.value, obj2.value);
  if (options && options.includeBitStringContents) {
    equal2 = equal2 && obj1.bitStringContents === obj2.bitStringContents;
  }
  return equal2;
};
asn1$5.getBerValueLength = function(b2) {
  var b22 = b2.getByte();
  if (b22 === 128) {
    return void 0;
  }
  var length3;
  var longForm = b22 & 128;
  if (!longForm) {
    length3 = b22;
  } else {
    length3 = b2.getInt((b22 & 127) << 3);
  }
  return length3;
};
function _checkBufferLength(bytes2, remaining, n) {
  if (n > remaining) {
    var error2 = new Error("Too few bytes to parse DER.");
    error2.available = bytes2.length();
    error2.remaining = remaining;
    error2.requested = n;
    throw error2;
  }
}
var _getValueLength = function(bytes2, remaining) {
  var b2 = bytes2.getByte();
  remaining--;
  if (b2 === 128) {
    return void 0;
  }
  var length3;
  var longForm = b2 & 128;
  if (!longForm) {
    length3 = b2;
  } else {
    var longFormBytes = b2 & 127;
    _checkBufferLength(bytes2, remaining, longFormBytes);
    length3 = bytes2.getInt(longFormBytes << 3);
  }
  if (length3 < 0) {
    throw new Error("Negative length: " + length3);
  }
  return length3;
};
asn1$5.fromDer = function(bytes2, options) {
  if (options === void 0) {
    options = {
      strict: true,
      parseAllBytes: true,
      decodeBitStrings: true
    };
  }
  if (typeof options === "boolean") {
    options = {
      strict: options,
      parseAllBytes: true,
      decodeBitStrings: true
    };
  }
  if (!("strict" in options)) {
    options.strict = true;
  }
  if (!("parseAllBytes" in options)) {
    options.parseAllBytes = true;
  }
  if (!("decodeBitStrings" in options)) {
    options.decodeBitStrings = true;
  }
  if (typeof bytes2 === "string") {
    bytes2 = forge$p.util.createBuffer(bytes2);
  }
  var byteCount = bytes2.length();
  var value2 = _fromDer(bytes2, bytes2.length(), 0, options);
  if (options.parseAllBytes && bytes2.length() !== 0) {
    var error2 = new Error("Unparsed DER bytes remain after ASN.1 parsing.");
    error2.byteCount = byteCount;
    error2.remaining = bytes2.length();
    throw error2;
  }
  return value2;
};
function _fromDer(bytes2, remaining, depth, options) {
  var start;
  _checkBufferLength(bytes2, remaining, 2);
  var b1 = bytes2.getByte();
  remaining--;
  var tagClass = b1 & 192;
  var type = b1 & 31;
  start = bytes2.length();
  var length3 = _getValueLength(bytes2, remaining);
  remaining -= start - bytes2.length();
  if (length3 !== void 0 && length3 > remaining) {
    if (options.strict) {
      var error2 = new Error("Too few bytes to read ASN.1 value.");
      error2.available = bytes2.length();
      error2.remaining = remaining;
      error2.requested = length3;
      throw error2;
    }
    length3 = remaining;
  }
  var value2;
  var bitStringContents;
  var constructed = (b1 & 32) === 32;
  if (constructed) {
    value2 = [];
    if (length3 === void 0) {
      for (; ; ) {
        _checkBufferLength(bytes2, remaining, 2);
        if (bytes2.bytes(2) === String.fromCharCode(0, 0)) {
          bytes2.getBytes(2);
          remaining -= 2;
          break;
        }
        start = bytes2.length();
        value2.push(_fromDer(bytes2, remaining, depth + 1, options));
        remaining -= start - bytes2.length();
      }
    } else {
      while (length3 > 0) {
        start = bytes2.length();
        value2.push(_fromDer(bytes2, length3, depth + 1, options));
        remaining -= start - bytes2.length();
        length3 -= start - bytes2.length();
      }
    }
  }
  if (value2 === void 0 && tagClass === asn1$5.Class.UNIVERSAL && type === asn1$5.Type.BITSTRING) {
    bitStringContents = bytes2.bytes(length3);
  }
  if (value2 === void 0 && options.decodeBitStrings && tagClass === asn1$5.Class.UNIVERSAL && type === asn1$5.Type.BITSTRING && length3 > 1) {
    var savedRead = bytes2.read;
    var savedRemaining = remaining;
    var unused = 0;
    if (type === asn1$5.Type.BITSTRING) {
      _checkBufferLength(bytes2, remaining, 1);
      unused = bytes2.getByte();
      remaining--;
    }
    if (unused === 0) {
      try {
        start = bytes2.length();
        var subOptions = {
          strict: true,
          decodeBitStrings: true
        };
        var composed = _fromDer(bytes2, remaining, depth + 1, subOptions);
        var used = start - bytes2.length();
        remaining -= used;
        if (type == asn1$5.Type.BITSTRING) {
          used++;
        }
        var tc = composed.tagClass;
        if (used === length3 && (tc === asn1$5.Class.UNIVERSAL || tc === asn1$5.Class.CONTEXT_SPECIFIC)) {
          value2 = [composed];
        }
      } catch (ex) {
      }
    }
    if (value2 === void 0) {
      bytes2.read = savedRead;
      remaining = savedRemaining;
    }
  }
  if (value2 === void 0) {
    if (length3 === void 0) {
      if (options.strict) {
        throw new Error("Non-constructed ASN.1 object of indefinite length.");
      }
      length3 = remaining;
    }
    if (type === asn1$5.Type.BMPSTRING) {
      value2 = "";
      for (; length3 > 0; length3 -= 2) {
        _checkBufferLength(bytes2, remaining, 2);
        value2 += String.fromCharCode(bytes2.getInt16());
        remaining -= 2;
      }
    } else {
      value2 = bytes2.getBytes(length3);
      remaining -= length3;
    }
  }
  var asn1Options = bitStringContents === void 0 ? null : {
    bitStringContents
  };
  return asn1$5.create(tagClass, type, constructed, value2, asn1Options);
}
asn1$5.toDer = function(obj) {
  var bytes2 = forge$p.util.createBuffer();
  var b1 = obj.tagClass | obj.type;
  var value2 = forge$p.util.createBuffer();
  var useBitStringContents = false;
  if ("bitStringContents" in obj) {
    useBitStringContents = true;
    if (obj.original) {
      useBitStringContents = asn1$5.equals(obj, obj.original);
    }
  }
  if (useBitStringContents) {
    value2.putBytes(obj.bitStringContents);
  } else if (obj.composed) {
    if (obj.constructed) {
      b1 |= 32;
    } else {
      value2.putByte(0);
    }
    for (var i2 = 0; i2 < obj.value.length; ++i2) {
      if (obj.value[i2] !== void 0) {
        value2.putBuffer(asn1$5.toDer(obj.value[i2]));
      }
    }
  } else {
    if (obj.type === asn1$5.Type.BMPSTRING) {
      for (var i2 = 0; i2 < obj.value.length; ++i2) {
        value2.putInt16(obj.value.charCodeAt(i2));
      }
    } else {
      if (obj.type === asn1$5.Type.INTEGER && obj.value.length > 1 && (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 128) === 0 || obj.value.charCodeAt(0) === 255 && (obj.value.charCodeAt(1) & 128) === 128)) {
        value2.putBytes(obj.value.substr(1));
      } else {
        value2.putBytes(obj.value);
      }
    }
  }
  bytes2.putByte(b1);
  if (value2.length() <= 127) {
    bytes2.putByte(value2.length() & 127);
  } else {
    var len2 = value2.length();
    var lenBytes = "";
    do {
      lenBytes += String.fromCharCode(len2 & 255);
      len2 = len2 >>> 8;
    } while (len2 > 0);
    bytes2.putByte(lenBytes.length | 128);
    for (var i2 = lenBytes.length - 1; i2 >= 0; --i2) {
      bytes2.putByte(lenBytes.charCodeAt(i2));
    }
  }
  bytes2.putBuffer(value2);
  return bytes2;
};
asn1$5.oidToDer = function(oid) {
  var values = oid.split(".");
  var bytes2 = forge$p.util.createBuffer();
  bytes2.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
  var last2, valueBytes, value2, b2;
  for (var i2 = 2; i2 < values.length; ++i2) {
    last2 = true;
    valueBytes = [];
    value2 = parseInt(values[i2], 10);
    do {
      b2 = value2 & 127;
      value2 = value2 >>> 7;
      if (!last2) {
        b2 |= 128;
      }
      valueBytes.push(b2);
      last2 = false;
    } while (value2 > 0);
    for (var n = valueBytes.length - 1; n >= 0; --n) {
      bytes2.putByte(valueBytes[n]);
    }
  }
  return bytes2;
};
asn1$5.derToOid = function(bytes2) {
  var oid;
  if (typeof bytes2 === "string") {
    bytes2 = forge$p.util.createBuffer(bytes2);
  }
  var b2 = bytes2.getByte();
  oid = Math.floor(b2 / 40) + "." + b2 % 40;
  var value2 = 0;
  while (bytes2.length() > 0) {
    b2 = bytes2.getByte();
    value2 = value2 << 7;
    if (b2 & 128) {
      value2 += b2 & 127;
    } else {
      oid += "." + (value2 + b2);
      value2 = 0;
    }
  }
  return oid;
};
asn1$5.utcTimeToDate = function(utc) {
  var date = new Date();
  var year = parseInt(utc.substr(0, 2), 10);
  year = year >= 50 ? 1900 + year : 2e3 + year;
  var MM = parseInt(utc.substr(2, 2), 10) - 1;
  var DD = parseInt(utc.substr(4, 2), 10);
  var hh = parseInt(utc.substr(6, 2), 10);
  var mm = parseInt(utc.substr(8, 2), 10);
  var ss = 0;
  if (utc.length > 11) {
    var c = utc.charAt(10);
    var end2 = 10;
    if (c !== "+" && c !== "-") {
      ss = parseInt(utc.substr(10, 2), 10);
      end2 += 2;
    }
  }
  date.setUTCFullYear(year, MM, DD);
  date.setUTCHours(hh, mm, ss, 0);
  if (end2) {
    c = utc.charAt(end2);
    if (c === "+" || c === "-") {
      var hhoffset = parseInt(utc.substr(end2 + 1, 2), 10);
      var mmoffset = parseInt(utc.substr(end2 + 4, 2), 10);
      var offset = hhoffset * 60 + mmoffset;
      offset *= 6e4;
      if (c === "+") {
        date.setTime(+date - offset);
      } else {
        date.setTime(+date + offset);
      }
    }
  }
  return date;
};
asn1$5.generalizedTimeToDate = function(gentime) {
  var date = new Date();
  var YYYY = parseInt(gentime.substr(0, 4), 10);
  var MM = parseInt(gentime.substr(4, 2), 10) - 1;
  var DD = parseInt(gentime.substr(6, 2), 10);
  var hh = parseInt(gentime.substr(8, 2), 10);
  var mm = parseInt(gentime.substr(10, 2), 10);
  var ss = parseInt(gentime.substr(12, 2), 10);
  var fff = 0;
  var offset = 0;
  var isUTC = false;
  if (gentime.charAt(gentime.length - 1) === "Z") {
    isUTC = true;
  }
  var end2 = gentime.length - 5, c = gentime.charAt(end2);
  if (c === "+" || c === "-") {
    var hhoffset = parseInt(gentime.substr(end2 + 1, 2), 10);
    var mmoffset = parseInt(gentime.substr(end2 + 4, 2), 10);
    offset = hhoffset * 60 + mmoffset;
    offset *= 6e4;
    if (c === "+") {
      offset *= -1;
    }
    isUTC = true;
  }
  if (gentime.charAt(14) === ".") {
    fff = parseFloat(gentime.substr(14), 10) * 1e3;
  }
  if (isUTC) {
    date.setUTCFullYear(YYYY, MM, DD);
    date.setUTCHours(hh, mm, ss, fff);
    date.setTime(+date + offset);
  } else {
    date.setFullYear(YYYY, MM, DD);
    date.setHours(hh, mm, ss, fff);
  }
  return date;
};
asn1$5.dateToUtcTime = function(date) {
  if (typeof date === "string") {
    return date;
  }
  var rval = "";
  var format2 = [];
  format2.push(("" + date.getUTCFullYear()).substr(2));
  format2.push("" + (date.getUTCMonth() + 1));
  format2.push("" + date.getUTCDate());
  format2.push("" + date.getUTCHours());
  format2.push("" + date.getUTCMinutes());
  format2.push("" + date.getUTCSeconds());
  for (var i2 = 0; i2 < format2.length; ++i2) {
    if (format2[i2].length < 2) {
      rval += "0";
    }
    rval += format2[i2];
  }
  rval += "Z";
  return rval;
};
asn1$5.dateToGeneralizedTime = function(date) {
  if (typeof date === "string") {
    return date;
  }
  var rval = "";
  var format2 = [];
  format2.push("" + date.getUTCFullYear());
  format2.push("" + (date.getUTCMonth() + 1));
  format2.push("" + date.getUTCDate());
  format2.push("" + date.getUTCHours());
  format2.push("" + date.getUTCMinutes());
  format2.push("" + date.getUTCSeconds());
  for (var i2 = 0; i2 < format2.length; ++i2) {
    if (format2[i2].length < 2) {
      rval += "0";
    }
    rval += format2[i2];
  }
  rval += "Z";
  return rval;
};
asn1$5.integerToDer = function(x) {
  var rval = forge$p.util.createBuffer();
  if (x >= -128 && x < 128) {
    return rval.putSignedInt(x, 8);
  }
  if (x >= -32768 && x < 32768) {
    return rval.putSignedInt(x, 16);
  }
  if (x >= -8388608 && x < 8388608) {
    return rval.putSignedInt(x, 24);
  }
  if (x >= -2147483648 && x < 2147483648) {
    return rval.putSignedInt(x, 32);
  }
  var error2 = new Error("Integer too large; max is 32-bits.");
  error2.integer = x;
  throw error2;
};
asn1$5.derToInteger = function(bytes2) {
  if (typeof bytes2 === "string") {
    bytes2 = forge$p.util.createBuffer(bytes2);
  }
  var n = bytes2.length() * 8;
  if (n > 32) {
    throw new Error("Integer too large; max is 32-bits.");
  }
  return bytes2.getSignedInt(n);
};
asn1$5.validate = function(obj, v, capture, errors2) {
  var rval = false;
  if ((obj.tagClass === v.tagClass || typeof v.tagClass === "undefined") && (obj.type === v.type || typeof v.type === "undefined")) {
    if (obj.constructed === v.constructed || typeof v.constructed === "undefined") {
      rval = true;
      if (v.value && forge$p.util.isArray(v.value)) {
        var j = 0;
        for (var i2 = 0; rval && i2 < v.value.length; ++i2) {
          rval = v.value[i2].optional || false;
          if (obj.value[j]) {
            rval = asn1$5.validate(obj.value[j], v.value[i2], capture, errors2);
            if (rval) {
              ++j;
            } else if (v.value[i2].optional) {
              rval = true;
            }
          }
          if (!rval && errors2) {
            errors2.push(
              "[" + v.name + '] Tag class "' + v.tagClass + '", type "' + v.type + '" expected value length "' + v.value.length + '", got "' + obj.value.length + '"'
            );
          }
        }
      }
      if (rval && capture) {
        if (v.capture) {
          capture[v.capture] = obj.value;
        }
        if (v.captureAsn1) {
          capture[v.captureAsn1] = obj;
        }
        if (v.captureBitStringContents && "bitStringContents" in obj) {
          capture[v.captureBitStringContents] = obj.bitStringContents;
        }
        if (v.captureBitStringValue && "bitStringContents" in obj) {
          if (obj.bitStringContents.length < 2) {
            capture[v.captureBitStringValue] = "";
          } else {
            var unused = obj.bitStringContents.charCodeAt(0);
            if (unused !== 0) {
              throw new Error(
                "captureBitStringValue only supported for zero unused bits"
              );
            }
            capture[v.captureBitStringValue] = obj.bitStringContents.slice(1);
          }
        }
      }
    } else if (errors2) {
      errors2.push(
        "[" + v.name + '] Expected constructed "' + v.constructed + '", got "' + obj.constructed + '"'
      );
    }
  } else if (errors2) {
    if (obj.tagClass !== v.tagClass) {
      errors2.push(
        "[" + v.name + '] Expected tag class "' + v.tagClass + '", got "' + obj.tagClass + '"'
      );
    }
    if (obj.type !== v.type) {
      errors2.push(
        "[" + v.name + '] Expected type "' + v.type + '", got "' + obj.type + '"'
      );
    }
  }
  return rval;
};
var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
asn1$5.prettyPrint = function(obj, level, indentation) {
  var rval = "";
  level = level || 0;
  indentation = indentation || 2;
  if (level > 0) {
    rval += "\n";
  }
  var indent = "";
  for (var i2 = 0; i2 < level * indentation; ++i2) {
    indent += " ";
  }
  rval += indent + "Tag: ";
  switch (obj.tagClass) {
    case asn1$5.Class.UNIVERSAL:
      rval += "Universal:";
      break;
    case asn1$5.Class.APPLICATION:
      rval += "Application:";
      break;
    case asn1$5.Class.CONTEXT_SPECIFIC:
      rval += "Context-Specific:";
      break;
    case asn1$5.Class.PRIVATE:
      rval += "Private:";
      break;
  }
  if (obj.tagClass === asn1$5.Class.UNIVERSAL) {
    rval += obj.type;
    switch (obj.type) {
      case asn1$5.Type.NONE:
        rval += " (None)";
        break;
      case asn1$5.Type.BOOLEAN:
        rval += " (Boolean)";
        break;
      case asn1$5.Type.INTEGER:
        rval += " (Integer)";
        break;
      case asn1$5.Type.BITSTRING:
        rval += " (Bit string)";
        break;
      case asn1$5.Type.OCTETSTRING:
        rval += " (Octet string)";
        break;
      case asn1$5.Type.NULL:
        rval += " (Null)";
        break;
      case asn1$5.Type.OID:
        rval += " (Object Identifier)";
        break;
      case asn1$5.Type.ODESC:
        rval += " (Object Descriptor)";
        break;
      case asn1$5.Type.EXTERNAL:
        rval += " (External or Instance of)";
        break;
      case asn1$5.Type.REAL:
        rval += " (Real)";
        break;
      case asn1$5.Type.ENUMERATED:
        rval += " (Enumerated)";
        break;
      case asn1$5.Type.EMBEDDED:
        rval += " (Embedded PDV)";
        break;
      case asn1$5.Type.UTF8:
        rval += " (UTF8)";
        break;
      case asn1$5.Type.ROID:
        rval += " (Relative Object Identifier)";
        break;
      case asn1$5.Type.SEQUENCE:
        rval += " (Sequence)";
        break;
      case asn1$5.Type.SET:
        rval += " (Set)";
        break;
      case asn1$5.Type.PRINTABLESTRING:
        rval += " (Printable String)";
        break;
      case asn1$5.Type.IA5String:
        rval += " (IA5String (ASCII))";
        break;
      case asn1$5.Type.UTCTIME:
        rval += " (UTC time)";
        break;
      case asn1$5.Type.GENERALIZEDTIME:
        rval += " (Generalized time)";
        break;
      case asn1$5.Type.BMPSTRING:
        rval += " (BMP String)";
        break;
    }
  } else {
    rval += obj.type;
  }
  rval += "\n";
  rval += indent + "Constructed: " + obj.constructed + "\n";
  if (obj.composed) {
    var subvalues = 0;
    var sub = "";
    for (var i2 = 0; i2 < obj.value.length; ++i2) {
      if (obj.value[i2] !== void 0) {
        subvalues += 1;
        sub += asn1$5.prettyPrint(obj.value[i2], level + 1, indentation);
        if (i2 + 1 < obj.value.length) {
          sub += ",";
        }
      }
    }
    rval += indent + "Sub values: " + subvalues + sub;
  } else {
    rval += indent + "Value: ";
    if (obj.type === asn1$5.Type.OID) {
      var oid = asn1$5.derToOid(obj.value);
      rval += oid;
      if (forge$p.pki && forge$p.pki.oids) {
        if (oid in forge$p.pki.oids) {
          rval += " (" + forge$p.pki.oids[oid] + ") ";
        }
      }
    }
    if (obj.type === asn1$5.Type.INTEGER) {
      try {
        rval += asn1$5.derToInteger(obj.value);
      } catch (ex) {
        rval += "0x" + forge$p.util.bytesToHex(obj.value);
      }
    } else if (obj.type === asn1$5.Type.BITSTRING) {
      if (obj.value.length > 1) {
        rval += "0x" + forge$p.util.bytesToHex(obj.value.slice(1));
      } else {
        rval += "(none)";
      }
      if (obj.value.length > 0) {
        var unused = obj.value.charCodeAt(0);
        if (unused == 1) {
          rval += " (1 unused bit shown)";
        } else if (unused > 1) {
          rval += " (" + unused + " unused bits shown)";
        }
      }
    } else if (obj.type === asn1$5.Type.OCTETSTRING) {
      if (!_nonLatinRegex.test(obj.value)) {
        rval += "(" + obj.value + ") ";
      }
      rval += "0x" + forge$p.util.bytesToHex(obj.value);
    } else if (obj.type === asn1$5.Type.UTF8) {
      try {
        rval += forge$p.util.decodeUtf8(obj.value);
      } catch (e) {
        if (e.message === "URI malformed") {
          rval += "0x" + forge$p.util.bytesToHex(obj.value) + " (malformed UTF8)";
        } else {
          throw e;
        }
      }
    } else if (obj.type === asn1$5.Type.PRINTABLESTRING || obj.type === asn1$5.Type.IA5String) {
      rval += obj.value;
    } else if (_nonLatinRegex.test(obj.value)) {
      rval += "0x" + forge$p.util.bytesToHex(obj.value);
    } else if (obj.value.length === 0) {
      rval += "[null]";
    } else {
      rval += obj.value;
    }
  }
  return rval;
};
var forge$o = forge$s;
forge$o.cipher = forge$o.cipher || {};
forge$o.cipher.algorithms = forge$o.cipher.algorithms || {};
forge$o.cipher.createCipher = function(algorithm, key) {
  var api2 = algorithm;
  if (typeof api2 === "string") {
    api2 = forge$o.cipher.getAlgorithm(api2);
    if (api2) {
      api2 = api2();
    }
  }
  if (!api2) {
    throw new Error("Unsupported algorithm: " + algorithm);
  }
  return new forge$o.cipher.BlockCipher({
    algorithm: api2,
    key,
    decrypt: false
  });
};
forge$o.cipher.createDecipher = function(algorithm, key) {
  var api2 = algorithm;
  if (typeof api2 === "string") {
    api2 = forge$o.cipher.getAlgorithm(api2);
    if (api2) {
      api2 = api2();
    }
  }
  if (!api2) {
    throw new Error("Unsupported algorithm: " + algorithm);
  }
  return new forge$o.cipher.BlockCipher({
    algorithm: api2,
    key,
    decrypt: true
  });
};
forge$o.cipher.registerAlgorithm = function(name2, algorithm) {
  name2 = name2.toUpperCase();
  forge$o.cipher.algorithms[name2] = algorithm;
};
forge$o.cipher.getAlgorithm = function(name2) {
  name2 = name2.toUpperCase();
  if (name2 in forge$o.cipher.algorithms) {
    return forge$o.cipher.algorithms[name2];
  }
  return null;
};
var BlockCipher = forge$o.cipher.BlockCipher = function(options) {
  this.algorithm = options.algorithm;
  this.mode = this.algorithm.mode;
  this.blockSize = this.mode.blockSize;
  this._finish = false;
  this._input = null;
  this.output = null;
  this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
  this._decrypt = options.decrypt;
  this.algorithm.initialize(options);
};
BlockCipher.prototype.start = function(options) {
  options = options || {};
  var opts = {};
  for (var key in options) {
    opts[key] = options[key];
  }
  opts.decrypt = this._decrypt;
  this._finish = false;
  this._input = forge$o.util.createBuffer();
  this.output = options.output || forge$o.util.createBuffer();
  this.mode.start(opts);
};
BlockCipher.prototype.update = function(input) {
  if (input) {
    this._input.putBuffer(input);
  }
  while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {
  }
  this._input.compact();
};
BlockCipher.prototype.finish = function(pad) {
  if (pad && (this.mode.name === "ECB" || this.mode.name === "CBC")) {
    this.mode.pad = function(input) {
      return pad(this.blockSize, input, false);
    };
    this.mode.unpad = function(output) {
      return pad(this.blockSize, output, true);
    };
  }
  var options = {};
  options.decrypt = this._decrypt;
  options.overflow = this._input.length() % this.blockSize;
  if (!this._decrypt && this.mode.pad) {
    if (!this.mode.pad(this._input, options)) {
      return false;
    }
  }
  this._finish = true;
  this.update();
  if (this._decrypt && this.mode.unpad) {
    if (!this.mode.unpad(this.output, options)) {
      return false;
    }
  }
  if (this.mode.afterFinish) {
    if (!this.mode.afterFinish(this.output, options)) {
      return false;
    }
  }
  return true;
};
var forge$n = forge$s;
forge$n.cipher = forge$n.cipher || {};
var modes = forge$n.cipher.modes = forge$n.cipher.modes || {};
modes.ecb = function(options) {
  options = options || {};
  this.name = "ECB";
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = new Array(this._ints);
  this._outBlock = new Array(this._ints);
};
modes.ecb.prototype.start = function(options) {
};
modes.ecb.prototype.encrypt = function(input, output, finish2) {
  if (input.length() < this.blockSize && !(finish2 && input.length() > 0)) {
    return true;
  }
  for (var i2 = 0; i2 < this._ints; ++i2) {
    this._inBlock[i2] = input.getInt32();
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  for (var i2 = 0; i2 < this._ints; ++i2) {
    output.putInt32(this._outBlock[i2]);
  }
};
modes.ecb.prototype.decrypt = function(input, output, finish2) {
  if (input.length() < this.blockSize && !(finish2 && input.length() > 0)) {
    return true;
  }
  for (var i2 = 0; i2 < this._ints; ++i2) {
    this._inBlock[i2] = input.getInt32();
  }
  this.cipher.decrypt(this._inBlock, this._outBlock);
  for (var i2 = 0; i2 < this._ints; ++i2) {
    output.putInt32(this._outBlock[i2]);
  }
};
modes.ecb.prototype.pad = function(input, options) {
  var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
  input.fillWithByte(padding, padding);
  return true;
};
modes.ecb.prototype.unpad = function(output, options) {
  if (options.overflow > 0) {
    return false;
  }
  var len2 = output.length();
  var count = output.at(len2 - 1);
  if (count > this.blockSize << 2) {
    return false;
  }
  output.truncate(count);
  return true;
};
modes.cbc = function(options) {
  options = options || {};
  this.name = "CBC";
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = new Array(this._ints);
  this._outBlock = new Array(this._ints);
};
modes.cbc.prototype.start = function(options) {
  if (options.iv === null) {
    if (!this._prev) {
      throw new Error("Invalid IV parameter.");
    }
    this._iv = this._prev.slice(0);
  } else if (!("iv" in options)) {
    throw new Error("Invalid IV parameter.");
  } else {
    this._iv = transformIV(options.iv, this.blockSize);
    this._prev = this._iv.slice(0);
  }
};
modes.cbc.prototype.encrypt = function(input, output, finish2) {
  if (input.length() < this.blockSize && !(finish2 && input.length() > 0)) {
    return true;
  }
  for (var i2 = 0; i2 < this._ints; ++i2) {
    this._inBlock[i2] = this._prev[i2] ^ input.getInt32();
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  for (var i2 = 0; i2 < this._ints; ++i2) {
    output.putInt32(this._outBlock[i2]);
  }
  this._prev = this._outBlock;
};
modes.cbc.prototype.decrypt = function(input, output, finish2) {
  if (input.length() < this.blockSize && !(finish2 && input.length() > 0)) {
    return true;
  }
  for (var i2 = 0; i2 < this._ints; ++i2) {
    this._inBlock[i2] = input.getInt32();
  }
  this.cipher.decrypt(this._inBlock, this._outBlock);
  for (var i2 = 0; i2 < this._ints; ++i2) {
    output.putInt32(this._prev[i2] ^ this._outBlock[i2]);
  }
  this._prev = this._inBlock.slice(0);
};
modes.cbc.prototype.pad = function(input, options) {
  var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
  input.fillWithByte(padding, padding);
  return true;
};
modes.cbc.prototype.unpad = function(output, options) {
  if (options.overflow > 0) {
    return false;
  }
  var len2 = output.length();
  var count = output.at(len2 - 1);
  if (count > this.blockSize << 2) {
    return false;
  }
  output.truncate(count);
  return true;
};
modes.cfb = function(options) {
  options = options || {};
  this.name = "CFB";
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = null;
  this._outBlock = new Array(this._ints);
  this._partialBlock = new Array(this._ints);
  this._partialOutput = forge$n.util.createBuffer();
  this._partialBytes = 0;
};
modes.cfb.prototype.start = function(options) {
  if (!("iv" in options)) {
    throw new Error("Invalid IV parameter.");
  }
  this._iv = transformIV(options.iv, this.blockSize);
  this._inBlock = this._iv.slice(0);
  this._partialBytes = 0;
};
modes.cfb.prototype.encrypt = function(input, output, finish2) {
  var inputLength = input.length();
  if (inputLength === 0) {
    return true;
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  if (this._partialBytes === 0 && inputLength >= this.blockSize) {
    for (var i2 = 0; i2 < this._ints; ++i2) {
      this._inBlock[i2] = input.getInt32() ^ this._outBlock[i2];
      output.putInt32(this._inBlock[i2]);
    }
    return;
  }
  var partialBytes = (this.blockSize - inputLength) % this.blockSize;
  if (partialBytes > 0) {
    partialBytes = this.blockSize - partialBytes;
  }
  this._partialOutput.clear();
  for (var i2 = 0; i2 < this._ints; ++i2) {
    this._partialBlock[i2] = input.getInt32() ^ this._outBlock[i2];
    this._partialOutput.putInt32(this._partialBlock[i2]);
  }
  if (partialBytes > 0) {
    input.read -= this.blockSize;
  } else {
    for (var i2 = 0; i2 < this._ints; ++i2) {
      this._inBlock[i2] = this._partialBlock[i2];
    }
  }
  if (this._partialBytes > 0) {
    this._partialOutput.getBytes(this._partialBytes);
  }
  if (partialBytes > 0 && !finish2) {
    output.putBytes(this._partialOutput.getBytes(
      partialBytes - this._partialBytes
    ));
    this._partialBytes = partialBytes;
    return true;
  }
  output.putBytes(this._partialOutput.getBytes(
    inputLength - this._partialBytes
  ));
  this._partialBytes = 0;
};
modes.cfb.prototype.decrypt = function(input, output, finish2) {
  var inputLength = input.length();
  if (inputLength === 0) {
    return true;
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  if (this._partialBytes === 0 && inputLength >= this.blockSize) {
    for (var i2 = 0; i2 < this._ints; ++i2) {
      this._inBlock[i2] = input.getInt32();
      output.putInt32(this._inBlock[i2] ^ this._outBlock[i2]);
    }
    return;
  }
  var partialBytes = (this.blockSize - inputLength) % this.blockSize;
  if (partialBytes > 0) {
    partialBytes = this.blockSize - partialBytes;
  }
  this._partialOutput.clear();
  for (var i2 = 0; i2 < this._ints; ++i2) {
    this._partialBlock[i2] = input.getInt32();
    this._partialOutput.putInt32(this._partialBlock[i2] ^ this._outBlock[i2]);
  }
  if (partialBytes > 0) {
    input.read -= this.blockSize;
  } else {
    for (var i2 = 0; i2 < this._ints; ++i2) {
      this._inBlock[i2] = this._partialBlock[i2];
    }
  }
  if (this._partialBytes > 0) {
    this._partialOutput.getBytes(this._partialBytes);
  }
  if (partialBytes > 0 && !finish2) {
    output.putBytes(this._partialOutput.getBytes(
      partialBytes - this._partialBytes
    ));
    this._partialBytes = partialBytes;
    return true;
  }
  output.putBytes(this._partialOutput.getBytes(
    inputLength - this._partialBytes
  ));
  this._partialBytes = 0;
};
modes.ofb = function(options) {
  options = options || {};
  this.name = "OFB";
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = null;
  this._outBlock = new Array(this._ints);
  this._partialOutput = forge$n.util.createBuffer();
  this._partialBytes = 0;
};
modes.ofb.prototype.start = function(options) {
  if (!("iv" in options)) {
    throw new Error("Invalid IV parameter.");
  }
  this._iv = transformIV(options.iv, this.blockSize);
  this._inBlock = this._iv.slice(0);
  this._partialBytes = 0;
};
modes.ofb.prototype.encrypt = function(input, output, finish2) {
  var inputLength = input.length();
  if (input.length() === 0) {
    return true;
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  if (this._partialBytes === 0 && inputLength >= this.blockSize) {
    for (var i2 = 0; i2 < this._ints; ++i2) {
      output.putInt32(input.getInt32() ^ this._outBlock[i2]);
      this._inBlock[i2] = this._outBlock[i2];
    }
    return;
  }
  var partialBytes = (this.blockSize - inputLength) % this.blockSize;
  if (partialBytes > 0) {
    partialBytes = this.blockSize - partialBytes;
  }
  this._partialOutput.clear();
  for (var i2 = 0; i2 < this._ints; ++i2) {
    this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
  }
  if (partialBytes > 0) {
    input.read -= this.blockSize;
  } else {
    for (var i2 = 0; i2 < this._ints; ++i2) {
      this._inBlock[i2] = this._outBlock[i2];
    }
  }
  if (this._partialBytes > 0) {
    this._partialOutput.getBytes(this._partialBytes);
  }
  if (partialBytes > 0 && !finish2) {
    output.putBytes(this._partialOutput.getBytes(
      partialBytes - this._partialBytes
    ));
    this._partialBytes = partialBytes;
    return true;
  }
  output.putBytes(this._partialOutput.getBytes(
    inputLength - this._partialBytes
  ));
  this._partialBytes = 0;
};
modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
modes.ctr = function(options) {
  options = options || {};
  this.name = "CTR";
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = null;
  this._outBlock = new Array(this._ints);
  this._partialOutput = forge$n.util.createBuffer();
  this._partialBytes = 0;
};
modes.ctr.prototype.start = function(options) {
  if (!("iv" in options)) {
    throw new Error("Invalid IV parameter.");
  }
  this._iv = transformIV(options.iv, this.blockSize);
  this._inBlock = this._iv.slice(0);
  this._partialBytes = 0;
};
modes.ctr.prototype.encrypt = function(input, output, finish2) {
  var inputLength = input.length();
  if (inputLength === 0) {
    return true;
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  if (this._partialBytes === 0 && inputLength >= this.blockSize) {
    for (var i2 = 0; i2 < this._ints; ++i2) {
      output.putInt32(input.getInt32() ^ this._outBlock[i2]);
    }
  } else {
    var partialBytes = (this.blockSize - inputLength) % this.blockSize;
    if (partialBytes > 0) {
      partialBytes = this.blockSize - partialBytes;
    }
    this._partialOutput.clear();
    for (var i2 = 0; i2 < this._ints; ++i2) {
      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
    }
    if (partialBytes > 0) {
      input.read -= this.blockSize;
    }
    if (this._partialBytes > 0) {
      this._partialOutput.getBytes(this._partialBytes);
    }
    if (partialBytes > 0 && !finish2) {
      output.putBytes(this._partialOutput.getBytes(
        partialBytes - this._partialBytes
      ));
      this._partialBytes = partialBytes;
      return true;
    }
    output.putBytes(this._partialOutput.getBytes(
      inputLength - this._partialBytes
    ));
    this._partialBytes = 0;
  }
  inc32(this._inBlock);
};
modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
modes.gcm = function(options) {
  options = options || {};
  this.name = "GCM";
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = new Array(this._ints);
  this._outBlock = new Array(this._ints);
  this._partialOutput = forge$n.util.createBuffer();
  this._partialBytes = 0;
  this._R = 3774873600;
};
modes.gcm.prototype.start = function(options) {
  if (!("iv" in options)) {
    throw new Error("Invalid IV parameter.");
  }
  var iv = forge$n.util.createBuffer(options.iv);
  this._cipherLength = 0;
  var additionalData;
  if ("additionalData" in options) {
    additionalData = forge$n.util.createBuffer(options.additionalData);
  } else {
    additionalData = forge$n.util.createBuffer();
  }
  if ("tagLength" in options) {
    this._tagLength = options.tagLength;
  } else {
    this._tagLength = 128;
  }
  this._tag = null;
  if (options.decrypt) {
    this._tag = forge$n.util.createBuffer(options.tag).getBytes();
    if (this._tag.length !== this._tagLength / 8) {
      throw new Error("Authentication tag does not match tag length.");
    }
  }
  this._hashBlock = new Array(this._ints);
  this.tag = null;
  this._hashSubkey = new Array(this._ints);
  this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);
  this.componentBits = 4;
  this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
  var ivLength = iv.length();
  if (ivLength === 12) {
    this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];
  } else {
    this._j0 = [0, 0, 0, 0];
    while (iv.length() > 0) {
      this._j0 = this.ghash(
        this._hashSubkey,
        this._j0,
        [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]
      );
    }
    this._j0 = this.ghash(
      this._hashSubkey,
      this._j0,
      [0, 0].concat(from64To32(ivLength * 8))
    );
  }
  this._inBlock = this._j0.slice(0);
  inc32(this._inBlock);
  this._partialBytes = 0;
  additionalData = forge$n.util.createBuffer(additionalData);
  this._aDataLength = from64To32(additionalData.length() * 8);
  var overflow = additionalData.length() % this.blockSize;
  if (overflow) {
    additionalData.fillWithByte(0, this.blockSize - overflow);
  }
  this._s = [0, 0, 0, 0];
  while (additionalData.length() > 0) {
    this._s = this.ghash(this._hashSubkey, this._s, [
      additionalData.getInt32(),
      additionalData.getInt32(),
      additionalData.getInt32(),
      additionalData.getInt32()
    ]);
  }
};
modes.gcm.prototype.encrypt = function(input, output, finish2) {
  var inputLength = input.length();
  if (inputLength === 0) {
    return true;
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  if (this._partialBytes === 0 && inputLength >= this.blockSize) {
    for (var i2 = 0; i2 < this._ints; ++i2) {
      output.putInt32(this._outBlock[i2] ^= input.getInt32());
    }
    this._cipherLength += this.blockSize;
  } else {
    var partialBytes = (this.blockSize - inputLength) % this.blockSize;
    if (partialBytes > 0) {
      partialBytes = this.blockSize - partialBytes;
    }
    this._partialOutput.clear();
    for (var i2 = 0; i2 < this._ints; ++i2) {
      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
    }
    if (partialBytes <= 0 || finish2) {
      if (finish2) {
        var overflow = inputLength % this.blockSize;
        this._cipherLength += overflow;
        this._partialOutput.truncate(this.blockSize - overflow);
      } else {
        this._cipherLength += this.blockSize;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._outBlock[i2] = this._partialOutput.getInt32();
      }
      this._partialOutput.read -= this.blockSize;
    }
    if (this._partialBytes > 0) {
      this._partialOutput.getBytes(this._partialBytes);
    }
    if (partialBytes > 0 && !finish2) {
      input.read -= this.blockSize;
      output.putBytes(this._partialOutput.getBytes(
        partialBytes - this._partialBytes
      ));
      this._partialBytes = partialBytes;
      return true;
    }
    output.putBytes(this._partialOutput.getBytes(
      inputLength - this._partialBytes
    ));
    this._partialBytes = 0;
  }
  this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);
  inc32(this._inBlock);
};
modes.gcm.prototype.decrypt = function(input, output, finish2) {
  var inputLength = input.length();
  if (inputLength < this.blockSize && !(finish2 && inputLength > 0)) {
    return true;
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  inc32(this._inBlock);
  this._hashBlock[0] = input.getInt32();
  this._hashBlock[1] = input.getInt32();
  this._hashBlock[2] = input.getInt32();
  this._hashBlock[3] = input.getInt32();
  this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
  for (var i2 = 0; i2 < this._ints; ++i2) {
    output.putInt32(this._outBlock[i2] ^ this._hashBlock[i2]);
  }
  if (inputLength < this.blockSize) {
    this._cipherLength += inputLength % this.blockSize;
  } else {
    this._cipherLength += this.blockSize;
  }
};
modes.gcm.prototype.afterFinish = function(output, options) {
  var rval = true;
  if (options.decrypt && options.overflow) {
    output.truncate(this.blockSize - options.overflow);
  }
  this.tag = forge$n.util.createBuffer();
  var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));
  this._s = this.ghash(this._hashSubkey, this._s, lengths);
  var tag = [];
  this.cipher.encrypt(this._j0, tag);
  for (var i2 = 0; i2 < this._ints; ++i2) {
    this.tag.putInt32(this._s[i2] ^ tag[i2]);
  }
  this.tag.truncate(this.tag.length() % (this._tagLength / 8));
  if (options.decrypt && this.tag.bytes() !== this._tag) {
    rval = false;
  }
  return rval;
};
modes.gcm.prototype.multiply = function(x, y) {
  var z_i = [0, 0, 0, 0];
  var v_i = y.slice(0);
  for (var i2 = 0; i2 < 128; ++i2) {
    var x_i = x[i2 / 32 | 0] & 1 << 31 - i2 % 32;
    if (x_i) {
      z_i[0] ^= v_i[0];
      z_i[1] ^= v_i[1];
      z_i[2] ^= v_i[2];
      z_i[3] ^= v_i[3];
    }
    this.pow(v_i, v_i);
  }
  return z_i;
};
modes.gcm.prototype.pow = function(x, out) {
  var lsb = x[3] & 1;
  for (var i2 = 3; i2 > 0; --i2) {
    out[i2] = x[i2] >>> 1 | (x[i2 - 1] & 1) << 31;
  }
  out[0] = x[0] >>> 1;
  if (lsb) {
    out[0] ^= this._R;
  }
};
modes.gcm.prototype.tableMultiply = function(x) {
  var z = [0, 0, 0, 0];
  for (var i2 = 0; i2 < 32; ++i2) {
    var idx = i2 / 8 | 0;
    var x_i = x[idx] >>> (7 - i2 % 8) * 4 & 15;
    var ah = this._m[i2][x_i];
    z[0] ^= ah[0];
    z[1] ^= ah[1];
    z[2] ^= ah[2];
    z[3] ^= ah[3];
  }
  return z;
};
modes.gcm.prototype.ghash = function(h, y, x) {
  y[0] ^= x[0];
  y[1] ^= x[1];
  y[2] ^= x[2];
  y[3] ^= x[3];
  return this.tableMultiply(y);
};
modes.gcm.prototype.generateHashTable = function(h, bits2) {
  var multiplier = 8 / bits2;
  var perInt = 4 * multiplier;
  var size2 = 16 * multiplier;
  var m = new Array(size2);
  for (var i2 = 0; i2 < size2; ++i2) {
    var tmp = [0, 0, 0, 0];
    var idx = i2 / perInt | 0;
    var shft = (perInt - 1 - i2 % perInt) * bits2;
    tmp[idx] = 1 << bits2 - 1 << shft;
    m[i2] = this.generateSubHashTable(this.multiply(tmp, h), bits2);
  }
  return m;
};
modes.gcm.prototype.generateSubHashTable = function(mid, bits2) {
  var size2 = 1 << bits2;
  var half = size2 >>> 1;
  var m = new Array(size2);
  m[half] = mid.slice(0);
  var i2 = half >>> 1;
  while (i2 > 0) {
    this.pow(m[2 * i2], m[i2] = []);
    i2 >>= 1;
  }
  i2 = 2;
  while (i2 < half) {
    for (var j = 1; j < i2; ++j) {
      var m_i = m[i2];
      var m_j = m[j];
      m[i2 + j] = [
        m_i[0] ^ m_j[0],
        m_i[1] ^ m_j[1],
        m_i[2] ^ m_j[2],
        m_i[3] ^ m_j[3]
      ];
    }
    i2 *= 2;
  }
  m[0] = [0, 0, 0, 0];
  for (i2 = half + 1; i2 < size2; ++i2) {
    var c = m[i2 ^ half];
    m[i2] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];
  }
  return m;
};
function transformIV(iv, blockSize) {
  if (typeof iv === "string") {
    iv = forge$n.util.createBuffer(iv);
  }
  if (forge$n.util.isArray(iv) && iv.length > 4) {
    var tmp = iv;
    iv = forge$n.util.createBuffer();
    for (var i2 = 0; i2 < tmp.length; ++i2) {
      iv.putByte(tmp[i2]);
    }
  }
  if (iv.length() < blockSize) {
    throw new Error(
      "Invalid IV length; got " + iv.length() + " bytes and expected " + blockSize + " bytes."
    );
  }
  if (!forge$n.util.isArray(iv)) {
    var ints = [];
    var blocks = blockSize / 4;
    for (var i2 = 0; i2 < blocks; ++i2) {
      ints.push(iv.getInt32());
    }
    iv = ints;
  }
  return iv;
}
function inc32(block) {
  block[block.length - 1] = block[block.length - 1] + 1 & 4294967295;
}
function from64To32(num) {
  return [num / 4294967296 | 0, num & 4294967295];
}
var forge$m = forge$s;
forge$m.aes = forge$m.aes || {};
forge$m.aes.startEncrypting = function(key, iv, output, mode) {
  var cipher = _createCipher$1({
    key,
    output,
    decrypt: false,
    mode
  });
  cipher.start(iv);
  return cipher;
};
forge$m.aes.createEncryptionCipher = function(key, mode) {
  return _createCipher$1({
    key,
    output: null,
    decrypt: false,
    mode
  });
};
forge$m.aes.startDecrypting = function(key, iv, output, mode) {
  var cipher = _createCipher$1({
    key,
    output,
    decrypt: true,
    mode
  });
  cipher.start(iv);
  return cipher;
};
forge$m.aes.createDecryptionCipher = function(key, mode) {
  return _createCipher$1({
    key,
    output: null,
    decrypt: true,
    mode
  });
};
forge$m.aes.Algorithm = function(name2, mode) {
  if (!init) {
    initialize();
  }
  var self2 = this;
  self2.name = name2;
  self2.mode = new mode({
    blockSize: 16,
    cipher: {
      encrypt: function(inBlock, outBlock) {
        return _updateBlock$1(self2._w, inBlock, outBlock, false);
      },
      decrypt: function(inBlock, outBlock) {
        return _updateBlock$1(self2._w, inBlock, outBlock, true);
      }
    }
  });
  self2._init = false;
};
forge$m.aes.Algorithm.prototype.initialize = function(options) {
  if (this._init) {
    return;
  }
  var key = options.key;
  var tmp;
  if (typeof key === "string" && (key.length === 16 || key.length === 24 || key.length === 32)) {
    key = forge$m.util.createBuffer(key);
  } else if (forge$m.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) {
    tmp = key;
    key = forge$m.util.createBuffer();
    for (var i2 = 0; i2 < tmp.length; ++i2) {
      key.putByte(tmp[i2]);
    }
  }
  if (!forge$m.util.isArray(key)) {
    tmp = key;
    key = [];
    var len2 = tmp.length();
    if (len2 === 16 || len2 === 24 || len2 === 32) {
      len2 = len2 >>> 2;
      for (var i2 = 0; i2 < len2; ++i2) {
        key.push(tmp.getInt32());
      }
    }
  }
  if (!forge$m.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) {
    throw new Error("Invalid key parameter.");
  }
  var mode = this.mode.name;
  var encryptOp = ["CFB", "OFB", "CTR", "GCM"].indexOf(mode) !== -1;
  this._w = _expandKey(key, options.decrypt && !encryptOp);
  this._init = true;
};
forge$m.aes._expandKey = function(key, decrypt2) {
  if (!init) {
    initialize();
  }
  return _expandKey(key, decrypt2);
};
forge$m.aes._updateBlock = _updateBlock$1;
registerAlgorithm$1("AES-ECB", forge$m.cipher.modes.ecb);
registerAlgorithm$1("AES-CBC", forge$m.cipher.modes.cbc);
registerAlgorithm$1("AES-CFB", forge$m.cipher.modes.cfb);
registerAlgorithm$1("AES-OFB", forge$m.cipher.modes.ofb);
registerAlgorithm$1("AES-CTR", forge$m.cipher.modes.ctr);
registerAlgorithm$1("AES-GCM", forge$m.cipher.modes.gcm);
function registerAlgorithm$1(name2, mode) {
  var factory2 = function() {
    return new forge$m.aes.Algorithm(name2, mode);
  };
  forge$m.cipher.registerAlgorithm(name2, factory2);
}
var init = false;
var Nb = 4;
var sbox;
var isbox;
var rcon;
var mix;
var imix;
function initialize() {
  init = true;
  rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
  var xtime = new Array(256);
  for (var i2 = 0; i2 < 128; ++i2) {
    xtime[i2] = i2 << 1;
    xtime[i2 + 128] = i2 + 128 << 1 ^ 283;
  }
  sbox = new Array(256);
  isbox = new Array(256);
  mix = new Array(4);
  imix = new Array(4);
  for (var i2 = 0; i2 < 4; ++i2) {
    mix[i2] = new Array(256);
    imix[i2] = new Array(256);
  }
  var e = 0, ei = 0, e2, e4, e8, sx, sx2, me, ime;
  for (var i2 = 0; i2 < 256; ++i2) {
    sx = ei ^ ei << 1 ^ ei << 2 ^ ei << 3 ^ ei << 4;
    sx = sx >> 8 ^ sx & 255 ^ 99;
    sbox[e] = sx;
    isbox[sx] = e;
    sx2 = xtime[sx];
    e2 = xtime[e];
    e4 = xtime[e2];
    e8 = xtime[e4];
    me = sx2 << 24 ^ sx << 16 ^ sx << 8 ^ (sx ^ sx2);
    ime = (e2 ^ e4 ^ e8) << 24 ^ (e ^ e8) << 16 ^ (e ^ e4 ^ e8) << 8 ^ (e ^ e2 ^ e8);
    for (var n = 0; n < 4; ++n) {
      mix[n][e] = me;
      imix[n][sx] = ime;
      me = me << 24 | me >>> 8;
      ime = ime << 24 | ime >>> 8;
    }
    if (e === 0) {
      e = ei = 1;
    } else {
      e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];
      ei ^= xtime[xtime[ei]];
    }
  }
}
function _expandKey(key, decrypt2) {
  var w = key.slice(0);
  var temp, iNk = 1;
  var Nk = w.length;
  var Nr1 = Nk + 6 + 1;
  var end2 = Nb * Nr1;
  for (var i2 = Nk; i2 < end2; ++i2) {
    temp = w[i2 - 1];
    if (i2 % Nk === 0) {
      temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;
      iNk++;
    } else if (Nk > 6 && i2 % Nk === 4) {
      temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];
    }
    w[i2] = w[i2 - Nk] ^ temp;
  }
  if (decrypt2) {
    var tmp;
    var m0 = imix[0];
    var m1 = imix[1];
    var m2 = imix[2];
    var m3 = imix[3];
    var wnew = w.slice(0);
    end2 = w.length;
    for (var i2 = 0, wi = end2 - Nb; i2 < end2; i2 += Nb, wi -= Nb) {
      if (i2 === 0 || i2 === end2 - Nb) {
        wnew[i2] = w[wi];
        wnew[i2 + 1] = w[wi + 3];
        wnew[i2 + 2] = w[wi + 2];
        wnew[i2 + 3] = w[wi + 1];
      } else {
        for (var n = 0; n < Nb; ++n) {
          tmp = w[wi + n];
          wnew[i2 + (3 & -n)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];
        }
      }
    }
    w = wnew;
  }
  return w;
}
function _updateBlock$1(w, input, output, decrypt2) {
  var Nr = w.length / 4 - 1;
  var m0, m1, m2, m3, sub;
  if (decrypt2) {
    m0 = imix[0];
    m1 = imix[1];
    m2 = imix[2];
    m3 = imix[3];
    sub = isbox;
  } else {
    m0 = mix[0];
    m1 = mix[1];
    m2 = mix[2];
    m3 = mix[3];
    sub = sbox;
  }
  var a, b2, c, d, a2, b22, c2;
  a = input[0] ^ w[0];
  b2 = input[decrypt2 ? 3 : 1] ^ w[1];
  c = input[2] ^ w[2];
  d = input[decrypt2 ? 1 : 3] ^ w[3];
  var i2 = 3;
  for (var round = 1; round < Nr; ++round) {
    a2 = m0[a >>> 24] ^ m1[b2 >>> 16 & 255] ^ m2[c >>> 8 & 255] ^ m3[d & 255] ^ w[++i2];
    b22 = m0[b2 >>> 24] ^ m1[c >>> 16 & 255] ^ m2[d >>> 8 & 255] ^ m3[a & 255] ^ w[++i2];
    c2 = m0[c >>> 24] ^ m1[d >>> 16 & 255] ^ m2[a >>> 8 & 255] ^ m3[b2 & 255] ^ w[++i2];
    d = m0[d >>> 24] ^ m1[a >>> 16 & 255] ^ m2[b2 >>> 8 & 255] ^ m3[c & 255] ^ w[++i2];
    a = a2;
    b2 = b22;
    c = c2;
  }
  output[0] = sub[a >>> 24] << 24 ^ sub[b2 >>> 16 & 255] << 16 ^ sub[c >>> 8 & 255] << 8 ^ sub[d & 255] ^ w[++i2];
  output[decrypt2 ? 3 : 1] = sub[b2 >>> 24] << 24 ^ sub[c >>> 16 & 255] << 16 ^ sub[d >>> 8 & 255] << 8 ^ sub[a & 255] ^ w[++i2];
  output[2] = sub[c >>> 24] << 24 ^ sub[d >>> 16 & 255] << 16 ^ sub[a >>> 8 & 255] << 8 ^ sub[b2 & 255] ^ w[++i2];
  output[decrypt2 ? 1 : 3] = sub[d >>> 24] << 24 ^ sub[a >>> 16 & 255] << 16 ^ sub[b2 >>> 8 & 255] << 8 ^ sub[c & 255] ^ w[++i2];
}
function _createCipher$1(options) {
  options = options || {};
  var mode = (options.mode || "CBC").toUpperCase();
  var algorithm = "AES-" + mode;
  var cipher;
  if (options.decrypt) {
    cipher = forge$m.cipher.createDecipher(algorithm, options.key);
  } else {
    cipher = forge$m.cipher.createCipher(algorithm, options.key);
  }
  var start = cipher.start;
  cipher.start = function(iv, options2) {
    var output = null;
    if (options2 instanceof forge$m.util.ByteBuffer) {
      output = options2;
      options2 = {};
    }
    options2 = options2 || {};
    options2.output = output;
    options2.iv = iv;
    start.call(cipher, options2);
  };
  return cipher;
}
var forge$l = forge$s;
forge$l.des = forge$l.des || {};
forge$l.des.startEncrypting = function(key, iv, output, mode) {
  var cipher = _createCipher({
    key,
    output,
    decrypt: false,
    mode: mode || (iv === null ? "ECB" : "CBC")
  });
  cipher.start(iv);
  return cipher;
};
forge$l.des.createEncryptionCipher = function(key, mode) {
  return _createCipher({
    key,
    output: null,
    decrypt: false,
    mode
  });
};
forge$l.des.startDecrypting = function(key, iv, output, mode) {
  var cipher = _createCipher({
    key,
    output,
    decrypt: true,
    mode: mode || (iv === null ? "ECB" : "CBC")
  });
  cipher.start(iv);
  return cipher;
};
forge$l.des.createDecryptionCipher = function(key, mode) {
  return _createCipher({
    key,
    output: null,
    decrypt: true,
    mode
  });
};
forge$l.des.Algorithm = function(name2, mode) {
  var self2 = this;
  self2.name = name2;
  self2.mode = new mode({
    blockSize: 8,
    cipher: {
      encrypt: function(inBlock, outBlock) {
        return _updateBlock(self2._keys, inBlock, outBlock, false);
      },
      decrypt: function(inBlock, outBlock) {
        return _updateBlock(self2._keys, inBlock, outBlock, true);
      }
    }
  });
  self2._init = false;
};
forge$l.des.Algorithm.prototype.initialize = function(options) {
  if (this._init) {
    return;
  }
  var key = forge$l.util.createBuffer(options.key);
  if (this.name.indexOf("3DES") === 0) {
    if (key.length() !== 24) {
      throw new Error("Invalid Triple-DES key size: " + key.length() * 8);
    }
  }
  this._keys = _createKeys(key);
  this._init = true;
};
registerAlgorithm("DES-ECB", forge$l.cipher.modes.ecb);
registerAlgorithm("DES-CBC", forge$l.cipher.modes.cbc);
registerAlgorithm("DES-CFB", forge$l.cipher.modes.cfb);
registerAlgorithm("DES-OFB", forge$l.cipher.modes.ofb);
registerAlgorithm("DES-CTR", forge$l.cipher.modes.ctr);
registerAlgorithm("3DES-ECB", forge$l.cipher.modes.ecb);
registerAlgorithm("3DES-CBC", forge$l.cipher.modes.cbc);
registerAlgorithm("3DES-CFB", forge$l.cipher.modes.cfb);
registerAlgorithm("3DES-OFB", forge$l.cipher.modes.ofb);
registerAlgorithm("3DES-CTR", forge$l.cipher.modes.ctr);
function registerAlgorithm(name2, mode) {
  var factory2 = function() {
    return new forge$l.des.Algorithm(name2, mode);
  };
  forge$l.cipher.registerAlgorithm(name2, factory2);
}
var spfunction1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756];
var spfunction2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344];
var spfunction3 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584];
var spfunction4 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928];
var spfunction5 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080];
var spfunction6 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312];
var spfunction7 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154];
var spfunction8 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
function _createKeys(key) {
  var pc2bytes0 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], pc2bytes1 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], pc2bytes2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], pc2bytes3 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], pc2bytes4 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], pc2bytes5 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], pc2bytes6 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], pc2bytes7 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], pc2bytes8 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], pc2bytes9 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], pc2bytes10 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], pc2bytes11 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], pc2bytes12 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], pc2bytes13 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261];
  var iterations = key.length() > 8 ? 3 : 1;
  var keys = [];
  var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
  var n = 0, tmp;
  for (var j = 0; j < iterations; j++) {
    var left = key.getInt32();
    var right = key.getInt32();
    tmp = (left >>> 4 ^ right) & 252645135;
    right ^= tmp;
    left ^= tmp << 4;
    tmp = (right >>> -16 ^ left) & 65535;
    left ^= tmp;
    right ^= tmp << -16;
    tmp = (left >>> 2 ^ right) & 858993459;
    right ^= tmp;
    left ^= tmp << 2;
    tmp = (right >>> -16 ^ left) & 65535;
    left ^= tmp;
    right ^= tmp << -16;
    tmp = (left >>> 1 ^ right) & 1431655765;
    right ^= tmp;
    left ^= tmp << 1;
    tmp = (right >>> 8 ^ left) & 16711935;
    left ^= tmp;
    right ^= tmp << 8;
    tmp = (left >>> 1 ^ right) & 1431655765;
    right ^= tmp;
    left ^= tmp << 1;
    tmp = left << 8 | right >>> 20 & 240;
    left = right << 24 | right << 8 & 16711680 | right >>> 8 & 65280 | right >>> 24 & 240;
    right = tmp;
    for (var i2 = 0; i2 < shifts.length; ++i2) {
      if (shifts[i2]) {
        left = left << 2 | left >>> 26;
        right = right << 2 | right >>> 26;
      } else {
        left = left << 1 | left >>> 27;
        right = right << 1 | right >>> 27;
      }
      left &= -15;
      right &= -15;
      var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 15] | pc2bytes2[left >>> 20 & 15] | pc2bytes3[left >>> 16 & 15] | pc2bytes4[left >>> 12 & 15] | pc2bytes5[left >>> 8 & 15] | pc2bytes6[left >>> 4 & 15];
      var righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 15] | pc2bytes9[right >>> 20 & 15] | pc2bytes10[right >>> 16 & 15] | pc2bytes11[right >>> 12 & 15] | pc2bytes12[right >>> 8 & 15] | pc2bytes13[right >>> 4 & 15];
      tmp = (righttmp >>> 16 ^ lefttmp) & 65535;
      keys[n++] = lefttmp ^ tmp;
      keys[n++] = righttmp ^ tmp << 16;
    }
  }
  return keys;
}
function _updateBlock(keys, input, output, decrypt2) {
  var iterations = keys.length === 32 ? 3 : 9;
  var looping;
  if (iterations === 3) {
    looping = decrypt2 ? [30, -2, -2] : [0, 32, 2];
  } else {
    looping = decrypt2 ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
  }
  var tmp;
  var left = input[0];
  var right = input[1];
  tmp = (left >>> 4 ^ right) & 252645135;
  right ^= tmp;
  left ^= tmp << 4;
  tmp = (left >>> 16 ^ right) & 65535;
  right ^= tmp;
  left ^= tmp << 16;
  tmp = (right >>> 2 ^ left) & 858993459;
  left ^= tmp;
  right ^= tmp << 2;
  tmp = (right >>> 8 ^ left) & 16711935;
  left ^= tmp;
  right ^= tmp << 8;
  tmp = (left >>> 1 ^ right) & 1431655765;
  right ^= tmp;
  left ^= tmp << 1;
  left = left << 1 | left >>> 31;
  right = right << 1 | right >>> 31;
  for (var j = 0; j < iterations; j += 3) {
    var endloop = looping[j + 1];
    var loopinc = looping[j + 2];
    for (var i2 = looping[j]; i2 != endloop; i2 += loopinc) {
      var right1 = right ^ keys[i2];
      var right2 = (right >>> 4 | right << 28) ^ keys[i2 + 1];
      tmp = left;
      left = right;
      right = tmp ^ (spfunction2[right1 >>> 24 & 63] | spfunction4[right1 >>> 16 & 63] | spfunction6[right1 >>> 8 & 63] | spfunction8[right1 & 63] | spfunction1[right2 >>> 24 & 63] | spfunction3[right2 >>> 16 & 63] | spfunction5[right2 >>> 8 & 63] | spfunction7[right2 & 63]);
    }
    tmp = left;
    left = right;
    right = tmp;
  }
  left = left >>> 1 | left << 31;
  right = right >>> 1 | right << 31;
  tmp = (left >>> 1 ^ right) & 1431655765;
  right ^= tmp;
  left ^= tmp << 1;
  tmp = (right >>> 8 ^ left) & 16711935;
  left ^= tmp;
  right ^= tmp << 8;
  tmp = (right >>> 2 ^ left) & 858993459;
  left ^= tmp;
  right ^= tmp << 2;
  tmp = (left >>> 16 ^ right) & 65535;
  right ^= tmp;
  left ^= tmp << 16;
  tmp = (left >>> 4 ^ right) & 252645135;
  right ^= tmp;
  left ^= tmp << 4;
  output[0] = left;
  output[1] = right;
}
function _createCipher(options) {
  options = options || {};
  var mode = (options.mode || "CBC").toUpperCase();
  var algorithm = "DES-" + mode;
  var cipher;
  if (options.decrypt) {
    cipher = forge$l.cipher.createDecipher(algorithm, options.key);
  } else {
    cipher = forge$l.cipher.createCipher(algorithm, options.key);
  }
  var start = cipher.start;
  cipher.start = function(iv, options2) {
    var output = null;
    if (options2 instanceof forge$l.util.ByteBuffer) {
      output = options2;
      options2 = {};
    }
    options2 = options2 || {};
    options2.output = output;
    options2.iv = iv;
    start.call(cipher, options2);
  };
  return cipher;
}
var forge$k = forge$s;
forge$k.md = forge$k.md || {};
forge$k.md.algorithms = forge$k.md.algorithms || {};
var forge$j = forge$s;
var hmac$2 = forge$j.hmac = forge$j.hmac || {};
hmac$2.create = function() {
  var _key = null;
  var _md = null;
  var _ipadding = null;
  var _opadding = null;
  var ctx = {};
  ctx.start = function(md, key) {
    if (md !== null) {
      if (typeof md === "string") {
        md = md.toLowerCase();
        if (md in forge$j.md.algorithms) {
          _md = forge$j.md.algorithms[md].create();
        } else {
          throw new Error('Unknown hash algorithm "' + md + '"');
        }
      } else {
        _md = md;
      }
    }
    if (key === null) {
      key = _key;
    } else {
      if (typeof key === "string") {
        key = forge$j.util.createBuffer(key);
      } else if (forge$j.util.isArray(key)) {
        var tmp = key;
        key = forge$j.util.createBuffer();
        for (var i2 = 0; i2 < tmp.length; ++i2) {
          key.putByte(tmp[i2]);
        }
      }
      var keylen = key.length();
      if (keylen > _md.blockLength) {
        _md.start();
        _md.update(key.bytes());
        key = _md.digest();
      }
      _ipadding = forge$j.util.createBuffer();
      _opadding = forge$j.util.createBuffer();
      keylen = key.length();
      for (var i2 = 0; i2 < keylen; ++i2) {
        var tmp = key.at(i2);
        _ipadding.putByte(54 ^ tmp);
        _opadding.putByte(92 ^ tmp);
      }
      if (keylen < _md.blockLength) {
        var tmp = _md.blockLength - keylen;
        for (var i2 = 0; i2 < tmp; ++i2) {
          _ipadding.putByte(54);
          _opadding.putByte(92);
        }
      }
      _key = key;
      _ipadding = _ipadding.bytes();
      _opadding = _opadding.bytes();
    }
    _md.start();
    _md.update(_ipadding);
  };
  ctx.update = function(bytes2) {
    _md.update(bytes2);
  };
  ctx.getMac = function() {
    var inner = _md.digest().bytes();
    _md.start();
    _md.update(_opadding);
    _md.update(inner);
    return _md.digest();
  };
  ctx.digest = ctx.getMac;
  return ctx;
};
const globSourceImport = {};
const nodeCrypto = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: globSourceImport
}, Symbol.toStringTag, { value: "Module" }));
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(nodeCrypto);
var forge$i = forge$s;
var pkcs5 = forge$i.pkcs5 = forge$i.pkcs5 || {};
var crypto$5;
if (forge$i.util.isNodejs && !forge$i.options.usePureJavaScript) {
  crypto$5 = require$$1;
}
var pbkdf2$1 = forge$i.pbkdf2 = pkcs5.pbkdf2 = function(p, s2, c, dkLen, md, callback) {
  if (typeof md === "function") {
    callback = md;
    md = null;
  }
  if (forge$i.util.isNodejs && !forge$i.options.usePureJavaScript && crypto$5.pbkdf2 && (md === null || typeof md !== "object") && (crypto$5.pbkdf2Sync.length > 4 || (!md || md === "sha1"))) {
    if (typeof md !== "string") {
      md = "sha1";
    }
    p = Buffer.from(p, "binary");
    s2 = Buffer.from(s2, "binary");
    if (!callback) {
      if (crypto$5.pbkdf2Sync.length === 4) {
        return crypto$5.pbkdf2Sync(p, s2, c, dkLen).toString("binary");
      }
      return crypto$5.pbkdf2Sync(p, s2, c, dkLen, md).toString("binary");
    }
    if (crypto$5.pbkdf2Sync.length === 4) {
      return crypto$5.pbkdf2(p, s2, c, dkLen, function(err3, key) {
        if (err3) {
          return callback(err3);
        }
        callback(null, key.toString("binary"));
      });
    }
    return crypto$5.pbkdf2(p, s2, c, dkLen, md, function(err3, key) {
      if (err3) {
        return callback(err3);
      }
      callback(null, key.toString("binary"));
    });
  }
  if (typeof md === "undefined" || md === null) {
    md = "sha1";
  }
  if (typeof md === "string") {
    if (!(md in forge$i.md.algorithms)) {
      throw new Error("Unknown hash algorithm: " + md);
    }
    md = forge$i.md[md].create();
  }
  var hLen = md.digestLength;
  if (dkLen > 4294967295 * hLen) {
    var err2 = new Error("Derived key is too long.");
    if (callback) {
      return callback(err2);
    }
    throw err2;
  }
  var len2 = Math.ceil(dkLen / hLen);
  var r = dkLen - (len2 - 1) * hLen;
  var prf = forge$i.hmac.create();
  prf.start(md, p);
  var dk = "";
  var xor2, u_c, u_c1;
  if (!callback) {
    for (var i2 = 1; i2 <= len2; ++i2) {
      prf.start(null, null);
      prf.update(s2);
      prf.update(forge$i.util.int32ToBytes(i2));
      xor2 = u_c1 = prf.digest().getBytes();
      for (var j = 2; j <= c; ++j) {
        prf.start(null, null);
        prf.update(u_c1);
        u_c = prf.digest().getBytes();
        xor2 = forge$i.util.xorBytes(xor2, u_c, hLen);
        u_c1 = u_c;
      }
      dk += i2 < len2 ? xor2 : xor2.substr(0, r);
    }
    return dk;
  }
  var i2 = 1, j;
  function outer() {
    if (i2 > len2) {
      return callback(null, dk);
    }
    prf.start(null, null);
    prf.update(s2);
    prf.update(forge$i.util.int32ToBytes(i2));
    xor2 = u_c1 = prf.digest().getBytes();
    j = 2;
    inner();
  }
  function inner() {
    if (j <= c) {
      prf.start(null, null);
      prf.update(u_c1);
      u_c = prf.digest().getBytes();
      xor2 = forge$i.util.xorBytes(xor2, u_c, hLen);
      u_c1 = u_c;
      ++j;
      return forge$i.util.setImmediate(inner);
    }
    dk += i2 < len2 ? xor2 : xor2.substr(0, r);
    ++i2;
    outer();
  }
  outer();
};
var forge$h = forge$s;
var pem = forge$h.pem = forge$h.pem || {};
pem.encode = function(msg, options) {
  options = options || {};
  var rval = "-----BEGIN " + msg.type + "-----\r\n";
  var header;
  if (msg.procType) {
    header = {
      name: "Proc-Type",
      values: [String(msg.procType.version), msg.procType.type]
    };
    rval += foldHeader(header);
  }
  if (msg.contentDomain) {
    header = { name: "Content-Domain", values: [msg.contentDomain] };
    rval += foldHeader(header);
  }
  if (msg.dekInfo) {
    header = { name: "DEK-Info", values: [msg.dekInfo.algorithm] };
    if (msg.dekInfo.parameters) {
      header.values.push(msg.dekInfo.parameters);
    }
    rval += foldHeader(header);
  }
  if (msg.headers) {
    for (var i2 = 0; i2 < msg.headers.length; ++i2) {
      rval += foldHeader(msg.headers[i2]);
    }
  }
  if (msg.procType) {
    rval += "\r\n";
  }
  rval += forge$h.util.encode64(msg.body, options.maxline || 64) + "\r\n";
  rval += "-----END " + msg.type + "-----\r\n";
  return rval;
};
pem.decode = function(str) {
  var rval = [];
  var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
  var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
  var rCRLF = /\r?\n/;
  var match;
  while (true) {
    match = rMessage.exec(str);
    if (!match) {
      break;
    }
    var type = match[1];
    if (type === "NEW CERTIFICATE REQUEST") {
      type = "CERTIFICATE REQUEST";
    }
    var msg = {
      type,
      procType: null,
      contentDomain: null,
      dekInfo: null,
      headers: [],
      body: forge$h.util.decode64(match[3])
    };
    rval.push(msg);
    if (!match[2]) {
      continue;
    }
    var lines = match[2].split(rCRLF);
    var li = 0;
    while (match && li < lines.length) {
      var line = lines[li].replace(/\s+$/, "");
      for (var nl = li + 1; nl < lines.length; ++nl) {
        var next = lines[nl];
        if (!/\s/.test(next[0])) {
          break;
        }
        line += next;
        li = nl;
      }
      match = line.match(rHeader);
      if (match) {
        var header = { name: match[1], values: [] };
        var values = match[2].split(",");
        for (var vi = 0; vi < values.length; ++vi) {
          header.values.push(ltrim(values[vi]));
        }
        if (!msg.procType) {
          if (header.name !== "Proc-Type") {
            throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
          } else if (header.values.length !== 2) {
            throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
          }
          msg.procType = { version: values[0], type: values[1] };
        } else if (!msg.contentDomain && header.name === "Content-Domain") {
          msg.contentDomain = values[0] || "";
        } else if (!msg.dekInfo && header.name === "DEK-Info") {
          if (header.values.length === 0) {
            throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
          }
          msg.dekInfo = { algorithm: values[0], parameters: values[1] || null };
        } else {
          msg.headers.push(header);
        }
      }
      ++li;
    }
    if (msg.procType === "ENCRYPTED" && !msg.dekInfo) {
      throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
    }
  }
  if (rval.length === 0) {
    throw new Error("Invalid PEM formatted message.");
  }
  return rval;
};
function foldHeader(header) {
  var rval = header.name + ": ";
  var values = [];
  var insertSpace = function(match, $1) {
    return " " + $1;
  };
  for (var i2 = 0; i2 < header.values.length; ++i2) {
    values.push(header.values[i2].replace(/^(\S+\r\n)/, insertSpace));
  }
  rval += values.join(",") + "\r\n";
  var length3 = 0;
  var candidate = -1;
  for (var i2 = 0; i2 < rval.length; ++i2, ++length3) {
    if (length3 > 65 && candidate !== -1) {
      var insert = rval[candidate];
      if (insert === ",") {
        ++candidate;
        rval = rval.substr(0, candidate) + "\r\n " + rval.substr(candidate);
      } else {
        rval = rval.substr(0, candidate) + "\r\n" + insert + rval.substr(candidate + 1);
      }
      length3 = i2 - candidate - 1;
      candidate = -1;
      ++i2;
    } else if (rval[i2] === " " || rval[i2] === "	" || rval[i2] === ",") {
      candidate = i2;
    }
  }
  return rval;
}
function ltrim(str) {
  return str.replace(/^\s+/, "");
}
var forge$g = forge$s;
var sha256$2 = forge$g.sha256 = forge$g.sha256 || {};
forge$g.md.sha256 = forge$g.md.algorithms.sha256 = sha256$2;
sha256$2.create = function() {
  if (!_initialized$2) {
    _init$2();
  }
  var _state = null;
  var _input = forge$g.util.createBuffer();
  var _w = new Array(64);
  var md = {
    algorithm: "sha256",
    blockLength: 64,
    digestLength: 32,
    messageLength: 0,
    fullMessageLength: null,
    messageLengthSize: 8
  };
  md.start = function() {
    md.messageLength = 0;
    md.fullMessageLength = md.messageLength64 = [];
    var int32s = md.messageLengthSize / 4;
    for (var i2 = 0; i2 < int32s; ++i2) {
      md.fullMessageLength.push(0);
    }
    _input = forge$g.util.createBuffer();
    _state = {
      h0: 1779033703,
      h1: 3144134277,
      h2: 1013904242,
      h3: 2773480762,
      h4: 1359893119,
      h5: 2600822924,
      h6: 528734635,
      h7: 1541459225
    };
    return md;
  };
  md.start();
  md.update = function(msg, encoding2) {
    if (encoding2 === "utf8") {
      msg = forge$g.util.encodeUtf8(msg);
    }
    var len2 = msg.length;
    md.messageLength += len2;
    len2 = [len2 / 4294967296 >>> 0, len2 >>> 0];
    for (var i2 = md.fullMessageLength.length - 1; i2 >= 0; --i2) {
      md.fullMessageLength[i2] += len2[1];
      len2[1] = len2[0] + (md.fullMessageLength[i2] / 4294967296 >>> 0);
      md.fullMessageLength[i2] = md.fullMessageLength[i2] >>> 0;
      len2[0] = len2[1] / 4294967296 >>> 0;
    }
    _input.putBytes(msg);
    _update$2(_state, _w, _input);
    if (_input.read > 2048 || _input.length() === 0) {
      _input.compact();
    }
    return md;
  };
  md.digest = function() {
    var finalBlock = forge$g.util.createBuffer();
    finalBlock.putBytes(_input.bytes());
    var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
    var overflow = remaining & md.blockLength - 1;
    finalBlock.putBytes(_padding$2.substr(0, md.blockLength - overflow));
    var next, carry;
    var bits2 = md.fullMessageLength[0] * 8;
    for (var i2 = 0; i2 < md.fullMessageLength.length - 1; ++i2) {
      next = md.fullMessageLength[i2 + 1] * 8;
      carry = next / 4294967296 >>> 0;
      bits2 += carry;
      finalBlock.putInt32(bits2 >>> 0);
      bits2 = next >>> 0;
    }
    finalBlock.putInt32(bits2);
    var s2 = {
      h0: _state.h0,
      h1: _state.h1,
      h2: _state.h2,
      h3: _state.h3,
      h4: _state.h4,
      h5: _state.h5,
      h6: _state.h6,
      h7: _state.h7
    };
    _update$2(s2, _w, finalBlock);
    var rval = forge$g.util.createBuffer();
    rval.putInt32(s2.h0);
    rval.putInt32(s2.h1);
    rval.putInt32(s2.h2);
    rval.putInt32(s2.h3);
    rval.putInt32(s2.h4);
    rval.putInt32(s2.h5);
    rval.putInt32(s2.h6);
    rval.putInt32(s2.h7);
    return rval;
  };
  return md;
};
var _padding$2 = null;
var _initialized$2 = false;
var _k$1 = null;
function _init$2() {
  _padding$2 = String.fromCharCode(128);
  _padding$2 += forge$g.util.fillString(String.fromCharCode(0), 64);
  _k$1 = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  _initialized$2 = true;
}
function _update$2(s2, w, bytes2) {
  var t1, t2, s0, s1, ch, maj, i2, a, b2, c, d, e, f, g, h;
  var len2 = bytes2.length();
  while (len2 >= 64) {
    for (i2 = 0; i2 < 16; ++i2) {
      w[i2] = bytes2.getInt32();
    }
    for (; i2 < 64; ++i2) {
      t1 = w[i2 - 2];
      t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
      t2 = w[i2 - 15];
      t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
      w[i2] = t1 + w[i2 - 7] + t2 + w[i2 - 16] | 0;
    }
    a = s2.h0;
    b2 = s2.h1;
    c = s2.h2;
    d = s2.h3;
    e = s2.h4;
    f = s2.h5;
    g = s2.h6;
    h = s2.h7;
    for (i2 = 0; i2 < 64; ++i2) {
      s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
      ch = g ^ e & (f ^ g);
      s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
      maj = a & b2 | c & (a ^ b2);
      t1 = h + s1 + ch + _k$1[i2] + w[i2];
      t2 = s0 + maj;
      h = g;
      g = f;
      f = e;
      e = d + t1 >>> 0;
      d = c;
      c = b2;
      b2 = a;
      a = t1 + t2 >>> 0;
    }
    s2.h0 = s2.h0 + a | 0;
    s2.h1 = s2.h1 + b2 | 0;
    s2.h2 = s2.h2 + c | 0;
    s2.h3 = s2.h3 + d | 0;
    s2.h4 = s2.h4 + e | 0;
    s2.h5 = s2.h5 + f | 0;
    s2.h6 = s2.h6 + g | 0;
    s2.h7 = s2.h7 + h | 0;
    len2 -= 64;
  }
}
var forge$f = forge$s;
var _crypto$1 = null;
if (forge$f.util.isNodejs && !forge$f.options.usePureJavaScript && !process.versions["node-webkit"]) {
  _crypto$1 = require$$1;
}
var prng = forge$f.prng = forge$f.prng || {};
prng.create = function(plugin) {
  var ctx = {
    plugin,
    key: null,
    seed: null,
    time: null,
    reseeds: 0,
    generated: 0,
    keyBytes: ""
  };
  var md = plugin.md;
  var pools = new Array(32);
  for (var i2 = 0; i2 < 32; ++i2) {
    pools[i2] = md.create();
  }
  ctx.pools = pools;
  ctx.pool = 0;
  ctx.generate = function(count, callback) {
    if (!callback) {
      return ctx.generateSync(count);
    }
    var cipher = ctx.plugin.cipher;
    var increment = ctx.plugin.increment;
    var formatKey = ctx.plugin.formatKey;
    var formatSeed = ctx.plugin.formatSeed;
    var b2 = forge$f.util.createBuffer();
    ctx.key = null;
    generate();
    function generate(err2) {
      if (err2) {
        return callback(err2);
      }
      if (b2.length() >= count) {
        return callback(null, b2.getBytes(count));
      }
      if (ctx.generated > 1048575) {
        ctx.key = null;
      }
      if (ctx.key === null) {
        return forge$f.util.nextTick(function() {
          _reseed(generate);
        });
      }
      var bytes2 = cipher(ctx.key, ctx.seed);
      ctx.generated += bytes2.length;
      b2.putBytes(bytes2);
      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
      forge$f.util.setImmediate(generate);
    }
  };
  ctx.generateSync = function(count) {
    var cipher = ctx.plugin.cipher;
    var increment = ctx.plugin.increment;
    var formatKey = ctx.plugin.formatKey;
    var formatSeed = ctx.plugin.formatSeed;
    ctx.key = null;
    var b2 = forge$f.util.createBuffer();
    while (b2.length() < count) {
      if (ctx.generated > 1048575) {
        ctx.key = null;
      }
      if (ctx.key === null) {
        _reseedSync();
      }
      var bytes2 = cipher(ctx.key, ctx.seed);
      ctx.generated += bytes2.length;
      b2.putBytes(bytes2);
      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
    }
    return b2.getBytes(count);
  };
  function _reseed(callback) {
    if (ctx.pools[0].messageLength >= 32) {
      _seed();
      return callback();
    }
    var needed = 32 - ctx.pools[0].messageLength << 5;
    ctx.seedFile(needed, function(err2, bytes2) {
      if (err2) {
        return callback(err2);
      }
      ctx.collect(bytes2);
      _seed();
      callback();
    });
  }
  function _reseedSync() {
    if (ctx.pools[0].messageLength >= 32) {
      return _seed();
    }
    var needed = 32 - ctx.pools[0].messageLength << 5;
    ctx.collect(ctx.seedFileSync(needed));
    _seed();
  }
  function _seed() {
    ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1;
    var md2 = ctx.plugin.md.create();
    md2.update(ctx.keyBytes);
    var _2powK = 1;
    for (var k = 0; k < 32; ++k) {
      if (ctx.reseeds % _2powK === 0) {
        md2.update(ctx.pools[k].digest().getBytes());
        ctx.pools[k].start();
      }
      _2powK = _2powK << 1;
    }
    ctx.keyBytes = md2.digest().getBytes();
    md2.start();
    md2.update(ctx.keyBytes);
    var seedBytes = md2.digest().getBytes();
    ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
    ctx.seed = ctx.plugin.formatSeed(seedBytes);
    ctx.generated = 0;
  }
  function defaultSeedFile(needed) {
    var getRandomValues = null;
    var globalScope = forge$f.util.globalScope;
    var _crypto2 = globalScope.crypto || globalScope.msCrypto;
    if (_crypto2 && _crypto2.getRandomValues) {
      getRandomValues = function(arr) {
        return _crypto2.getRandomValues(arr);
      };
    }
    var b2 = forge$f.util.createBuffer();
    if (getRandomValues) {
      while (b2.length() < needed) {
        var count = Math.max(1, Math.min(needed - b2.length(), 65536) / 4);
        var entropy = new Uint32Array(Math.floor(count));
        try {
          getRandomValues(entropy);
          for (var i3 = 0; i3 < entropy.length; ++i3) {
            b2.putInt32(entropy[i3]);
          }
        } catch (e) {
          if (!(typeof QuotaExceededError !== "undefined" && e instanceof QuotaExceededError)) {
            throw e;
          }
        }
      }
    }
    if (b2.length() < needed) {
      var hi, lo, next;
      var seed2 = Math.floor(Math.random() * 65536);
      while (b2.length() < needed) {
        lo = 16807 * (seed2 & 65535);
        hi = 16807 * (seed2 >> 16);
        lo += (hi & 32767) << 16;
        lo += hi >> 15;
        lo = (lo & 2147483647) + (lo >> 31);
        seed2 = lo & 4294967295;
        for (var i3 = 0; i3 < 3; ++i3) {
          next = seed2 >>> (i3 << 3);
          next ^= Math.floor(Math.random() * 256);
          b2.putByte(next & 255);
        }
      }
    }
    return b2.getBytes(needed);
  }
  if (_crypto$1) {
    ctx.seedFile = function(needed, callback) {
      _crypto$1.randomBytes(needed, function(err2, bytes2) {
        if (err2) {
          return callback(err2);
        }
        callback(null, bytes2.toString());
      });
    };
    ctx.seedFileSync = function(needed) {
      return _crypto$1.randomBytes(needed).toString();
    };
  } else {
    ctx.seedFile = function(needed, callback) {
      try {
        callback(null, defaultSeedFile(needed));
      } catch (e) {
        callback(e);
      }
    };
    ctx.seedFileSync = defaultSeedFile;
  }
  ctx.collect = function(bytes2) {
    var count = bytes2.length;
    for (var i3 = 0; i3 < count; ++i3) {
      ctx.pools[ctx.pool].update(bytes2.substr(i3, 1));
      ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;
    }
  };
  ctx.collectInt = function(i3, n) {
    var bytes2 = "";
    for (var x = 0; x < n; x += 8) {
      bytes2 += String.fromCharCode(i3 >> x & 255);
    }
    ctx.collect(bytes2);
  };
  ctx.registerWorker = function(worker) {
    if (worker === self) {
      ctx.seedFile = function(needed, callback) {
        function listener2(e) {
          var data = e.data;
          if (data.forge && data.forge.prng) {
            self.removeEventListener("message", listener2);
            callback(data.forge.prng.err, data.forge.prng.bytes);
          }
        }
        self.addEventListener("message", listener2);
        self.postMessage({ forge: { prng: { needed } } });
      };
    } else {
      var listener = function(e) {
        var data = e.data;
        if (data.forge && data.forge.prng) {
          ctx.seedFile(data.forge.prng.needed, function(err2, bytes2) {
            worker.postMessage({ forge: { prng: { err: err2, bytes: bytes2 } } });
          });
        }
      };
      worker.addEventListener("message", listener);
    }
  };
  return ctx;
};
var forge$e = forge$s;
(function() {
  if (forge$e.random && forge$e.random.getBytes) {
    return;
  }
  (function(jQuery2) {
    var prng_aes = {};
    var _prng_aes_output = new Array(4);
    var _prng_aes_buffer = forge$e.util.createBuffer();
    prng_aes.formatKey = function(key2) {
      var tmp = forge$e.util.createBuffer(key2);
      key2 = new Array(4);
      key2[0] = tmp.getInt32();
      key2[1] = tmp.getInt32();
      key2[2] = tmp.getInt32();
      key2[3] = tmp.getInt32();
      return forge$e.aes._expandKey(key2, false);
    };
    prng_aes.formatSeed = function(seed2) {
      var tmp = forge$e.util.createBuffer(seed2);
      seed2 = new Array(4);
      seed2[0] = tmp.getInt32();
      seed2[1] = tmp.getInt32();
      seed2[2] = tmp.getInt32();
      seed2[3] = tmp.getInt32();
      return seed2;
    };
    prng_aes.cipher = function(key2, seed2) {
      forge$e.aes._updateBlock(key2, seed2, _prng_aes_output, false);
      _prng_aes_buffer.putInt32(_prng_aes_output[0]);
      _prng_aes_buffer.putInt32(_prng_aes_output[1]);
      _prng_aes_buffer.putInt32(_prng_aes_output[2]);
      _prng_aes_buffer.putInt32(_prng_aes_output[3]);
      return _prng_aes_buffer.getBytes();
    };
    prng_aes.increment = function(seed2) {
      ++seed2[3];
      return seed2;
    };
    prng_aes.md = forge$e.md.sha256;
    function spawnPrng() {
      var ctx = forge$e.prng.create(prng_aes);
      ctx.getBytes = function(count, callback) {
        return ctx.generate(count, callback);
      };
      ctx.getBytesSync = function(count) {
        return ctx.generate(count);
      };
      return ctx;
    }
    var _ctx = spawnPrng();
    var getRandomValues = null;
    var globalScope = forge$e.util.globalScope;
    var _crypto2 = globalScope.crypto || globalScope.msCrypto;
    if (_crypto2 && _crypto2.getRandomValues) {
      getRandomValues = function(arr) {
        return _crypto2.getRandomValues(arr);
      };
    }
    if (!forge$e.util.isNodejs && !getRandomValues) {
      _ctx.collectInt(+new Date(), 32);
      if (typeof navigator !== "undefined") {
        var _navBytes = "";
        for (var key in navigator) {
          try {
            if (typeof navigator[key] == "string") {
              _navBytes += navigator[key];
            }
          } catch (e) {
          }
        }
        _ctx.collect(_navBytes);
        _navBytes = null;
      }
      if (jQuery2) {
        jQuery2().mousemove(function(e) {
          _ctx.collectInt(e.clientX, 16);
          _ctx.collectInt(e.clientY, 16);
        });
        jQuery2().keypress(function(e) {
          _ctx.collectInt(e.charCode, 8);
        });
      }
    }
    if (!forge$e.random) {
      forge$e.random = _ctx;
    } else {
      for (var key in _ctx) {
        forge$e.random[key] = _ctx[key];
      }
    }
    forge$e.random.createInstance = spawnPrng;
  })(typeof jQuery !== "undefined" ? jQuery : null);
})();
var forge$d = forge$s;
var piTable = [
  217,
  120,
  249,
  196,
  25,
  221,
  181,
  237,
  40,
  233,
  253,
  121,
  74,
  160,
  216,
  157,
  198,
  126,
  55,
  131,
  43,
  118,
  83,
  142,
  98,
  76,
  100,
  136,
  68,
  139,
  251,
  162,
  23,
  154,
  89,
  245,
  135,
  179,
  79,
  19,
  97,
  69,
  109,
  141,
  9,
  129,
  125,
  50,
  189,
  143,
  64,
  235,
  134,
  183,
  123,
  11,
  240,
  149,
  33,
  34,
  92,
  107,
  78,
  130,
  84,
  214,
  101,
  147,
  206,
  96,
  178,
  28,
  115,
  86,
  192,
  20,
  167,
  140,
  241,
  220,
  18,
  117,
  202,
  31,
  59,
  190,
  228,
  209,
  66,
  61,
  212,
  48,
  163,
  60,
  182,
  38,
  111,
  191,
  14,
  218,
  70,
  105,
  7,
  87,
  39,
  242,
  29,
  155,
  188,
  148,
  67,
  3,
  248,
  17,
  199,
  246,
  144,
  239,
  62,
  231,
  6,
  195,
  213,
  47,
  200,
  102,
  30,
  215,
  8,
  232,
  234,
  222,
  128,
  82,
  238,
  247,
  132,
  170,
  114,
  172,
  53,
  77,
  106,
  42,
  150,
  26,
  210,
  113,
  90,
  21,
  73,
  116,
  75,
  159,
  208,
  94,
  4,
  24,
  164,
  236,
  194,
  224,
  65,
  110,
  15,
  81,
  203,
  204,
  36,
  145,
  175,
  80,
  161,
  244,
  112,
  57,
  153,
  124,
  58,
  133,
  35,
  184,
  180,
  122,
  252,
  2,
  54,
  91,
  37,
  85,
  151,
  49,
  45,
  93,
  250,
  152,
  227,
  138,
  146,
  174,
  5,
  223,
  41,
  16,
  103,
  108,
  186,
  201,
  211,
  0,
  230,
  207,
  225,
  158,
  168,
  44,
  99,
  22,
  1,
  63,
  88,
  226,
  137,
  169,
  13,
  56,
  52,
  27,
  171,
  51,
  255,
  176,
  187,
  72,
  12,
  95,
  185,
  177,
  205,
  46,
  197,
  243,
  219,
  71,
  229,
  165,
  156,
  119,
  10,
  166,
  32,
  104,
  254,
  127,
  193,
  173
];
var s = [1, 2, 3, 5];
var rol = function(word2, bits2) {
  return word2 << bits2 & 65535 | (word2 & 65535) >> 16 - bits2;
};
var ror = function(word2, bits2) {
  return (word2 & 65535) >> bits2 | word2 << 16 - bits2 & 65535;
};
forge$d.rc2 = forge$d.rc2 || {};
forge$d.rc2.expandKey = function(key, effKeyBits) {
  if (typeof key === "string") {
    key = forge$d.util.createBuffer(key);
  }
  effKeyBits = effKeyBits || 128;
  var L = key;
  var T = key.length();
  var T1 = effKeyBits;
  var T8 = Math.ceil(T1 / 8);
  var TM = 255 >> (T1 & 7);
  var i2;
  for (i2 = T; i2 < 128; i2++) {
    L.putByte(piTable[L.at(i2 - 1) + L.at(i2 - T) & 255]);
  }
  L.setAt(128 - T8, piTable[L.at(128 - T8) & TM]);
  for (i2 = 127 - T8; i2 >= 0; i2--) {
    L.setAt(i2, piTable[L.at(i2 + 1) ^ L.at(i2 + T8)]);
  }
  return L;
};
var createCipher = function(key, bits2, encrypt2) {
  var _finish = false, _input = null, _output = null, _iv = null;
  var mixRound, mashRound;
  var i2, j, K2 = [];
  key = forge$d.rc2.expandKey(key, bits2);
  for (i2 = 0; i2 < 64; i2++) {
    K2.push(key.getInt16Le());
  }
  if (encrypt2) {
    mixRound = function(R2) {
      for (i2 = 0; i2 < 4; i2++) {
        R2[i2] += K2[j] + (R2[(i2 + 3) % 4] & R2[(i2 + 2) % 4]) + (~R2[(i2 + 3) % 4] & R2[(i2 + 1) % 4]);
        R2[i2] = rol(R2[i2], s[i2]);
        j++;
      }
    };
    mashRound = function(R2) {
      for (i2 = 0; i2 < 4; i2++) {
        R2[i2] += K2[R2[(i2 + 3) % 4] & 63];
      }
    };
  } else {
    mixRound = function(R2) {
      for (i2 = 3; i2 >= 0; i2--) {
        R2[i2] = ror(R2[i2], s[i2]);
        R2[i2] -= K2[j] + (R2[(i2 + 3) % 4] & R2[(i2 + 2) % 4]) + (~R2[(i2 + 3) % 4] & R2[(i2 + 1) % 4]);
        j--;
      }
    };
    mashRound = function(R2) {
      for (i2 = 3; i2 >= 0; i2--) {
        R2[i2] -= K2[R2[(i2 + 3) % 4] & 63];
      }
    };
  }
  var runPlan = function(plan) {
    var R2 = [];
    for (i2 = 0; i2 < 4; i2++) {
      var val = _input.getInt16Le();
      if (_iv !== null) {
        if (encrypt2) {
          val ^= _iv.getInt16Le();
        } else {
          _iv.putInt16Le(val);
        }
      }
      R2.push(val & 65535);
    }
    j = encrypt2 ? 0 : 63;
    for (var ptr = 0; ptr < plan.length; ptr++) {
      for (var ctr = 0; ctr < plan[ptr][0]; ctr++) {
        plan[ptr][1](R2);
      }
    }
    for (i2 = 0; i2 < 4; i2++) {
      if (_iv !== null) {
        if (encrypt2) {
          _iv.putInt16Le(R2[i2]);
        } else {
          R2[i2] ^= _iv.getInt16Le();
        }
      }
      _output.putInt16Le(R2[i2]);
    }
  };
  var cipher = null;
  cipher = {
    start: function(iv, output) {
      if (iv) {
        if (typeof iv === "string") {
          iv = forge$d.util.createBuffer(iv);
        }
      }
      _finish = false;
      _input = forge$d.util.createBuffer();
      _output = output || new forge$d.util.createBuffer();
      _iv = iv;
      cipher.output = _output;
    },
    update: function(input) {
      if (!_finish) {
        _input.putBuffer(input);
      }
      while (_input.length() >= 8) {
        runPlan([
          [5, mixRound],
          [1, mashRound],
          [6, mixRound],
          [1, mashRound],
          [5, mixRound]
        ]);
      }
    },
    finish: function(pad) {
      var rval = true;
      if (encrypt2) {
        if (pad) {
          rval = pad(8, _input, !encrypt2);
        } else {
          var padding = _input.length() === 8 ? 8 : 8 - _input.length();
          _input.fillWithByte(padding, padding);
        }
      }
      if (rval) {
        _finish = true;
        cipher.update();
      }
      if (!encrypt2) {
        rval = _input.length() === 0;
        if (rval) {
          if (pad) {
            rval = pad(8, _output, !encrypt2);
          } else {
            var len2 = _output.length();
            var count = _output.at(len2 - 1);
            if (count > len2) {
              rval = false;
            } else {
              _output.truncate(count);
            }
          }
        }
      }
      return rval;
    }
  };
  return cipher;
};
forge$d.rc2.startEncrypting = function(key, iv, output) {
  var cipher = forge$d.rc2.createEncryptionCipher(key, 128);
  cipher.start(iv, output);
  return cipher;
};
forge$d.rc2.createEncryptionCipher = function(key, bits2) {
  return createCipher(key, bits2, true);
};
forge$d.rc2.startDecrypting = function(key, iv, output) {
  var cipher = forge$d.rc2.createDecryptionCipher(key, 128);
  cipher.start(iv, output);
  return cipher;
};
forge$d.rc2.createDecryptionCipher = function(key, bits2) {
  return createCipher(key, bits2, false);
};
var forge$c = forge$s;
forge$c.jsbn = forge$c.jsbn || {};
var dbits;
function BigInteger$2(a, b2, c) {
  this.data = [];
  if (a != null)
    if ("number" == typeof a)
      this.fromNumber(a, b2, c);
    else if (b2 == null && "string" != typeof a)
      this.fromString(a, 256);
    else
      this.fromString(a, b2);
}
forge$c.jsbn.BigInteger = BigInteger$2;
function nbi() {
  return new BigInteger$2(null);
}
function am1(i2, x, w, j, c, n) {
  while (--n >= 0) {
    var v = x * this.data[i2++] + w.data[j] + c;
    c = Math.floor(v / 67108864);
    w.data[j++] = v & 67108863;
  }
  return c;
}
function am2(i2, x, w, j, c, n) {
  var xl = x & 32767, xh = x >> 15;
  while (--n >= 0) {
    var l = this.data[i2] & 32767;
    var h = this.data[i2++] >> 15;
    var m = xh * l + h * xl;
    l = xl * l + ((m & 32767) << 15) + w.data[j] + (c & 1073741823);
    c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
    w.data[j++] = l & 1073741823;
  }
  return c;
}
function am3(i2, x, w, j, c, n) {
  var xl = x & 16383, xh = x >> 14;
  while (--n >= 0) {
    var l = this.data[i2] & 16383;
    var h = this.data[i2++] >> 14;
    var m = xh * l + h * xl;
    l = xl * l + ((m & 16383) << 14) + w.data[j] + c;
    c = (l >> 28) + (m >> 14) + xh * h;
    w.data[j++] = l & 268435455;
  }
  return c;
}
if (typeof navigator === "undefined") {
  BigInteger$2.prototype.am = am3;
  dbits = 28;
} else if (navigator.appName == "Microsoft Internet Explorer") {
  BigInteger$2.prototype.am = am2;
  dbits = 30;
} else if (navigator.appName != "Netscape") {
  BigInteger$2.prototype.am = am1;
  dbits = 26;
} else {
  BigInteger$2.prototype.am = am3;
  dbits = 28;
}
BigInteger$2.prototype.DB = dbits;
BigInteger$2.prototype.DM = (1 << dbits) - 1;
BigInteger$2.prototype.DV = 1 << dbits;
var BI_FP = 52;
BigInteger$2.prototype.FV = Math.pow(2, BI_FP);
BigInteger$2.prototype.F1 = BI_FP - dbits;
BigInteger$2.prototype.F2 = 2 * dbits - BI_FP;
var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
var BI_RC = new Array();
var rr, vv;
rr = "0".charCodeAt(0);
for (vv = 0; vv <= 9; ++vv)
  BI_RC[rr++] = vv;
rr = "a".charCodeAt(0);
for (vv = 10; vv < 36; ++vv)
  BI_RC[rr++] = vv;
rr = "A".charCodeAt(0);
for (vv = 10; vv < 36; ++vv)
  BI_RC[rr++] = vv;
function int2char(n) {
  return BI_RM.charAt(n);
}
function intAt(s2, i2) {
  var c = BI_RC[s2.charCodeAt(i2)];
  return c == null ? -1 : c;
}
function bnpCopyTo(r) {
  for (var i2 = this.t - 1; i2 >= 0; --i2)
    r.data[i2] = this.data[i2];
  r.t = this.t;
  r.s = this.s;
}
function bnpFromInt(x) {
  this.t = 1;
  this.s = x < 0 ? -1 : 0;
  if (x > 0)
    this.data[0] = x;
  else if (x < -1)
    this.data[0] = x + this.DV;
  else
    this.t = 0;
}
function nbv(i2) {
  var r = nbi();
  r.fromInt(i2);
  return r;
}
function bnpFromString(s2, b2) {
  var k;
  if (b2 == 16)
    k = 4;
  else if (b2 == 8)
    k = 3;
  else if (b2 == 256)
    k = 8;
  else if (b2 == 2)
    k = 1;
  else if (b2 == 32)
    k = 5;
  else if (b2 == 4)
    k = 2;
  else {
    this.fromRadix(s2, b2);
    return;
  }
  this.t = 0;
  this.s = 0;
  var i2 = s2.length, mi = false, sh = 0;
  while (--i2 >= 0) {
    var x = k == 8 ? s2[i2] & 255 : intAt(s2, i2);
    if (x < 0) {
      if (s2.charAt(i2) == "-")
        mi = true;
      continue;
    }
    mi = false;
    if (sh == 0)
      this.data[this.t++] = x;
    else if (sh + k > this.DB) {
      this.data[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
      this.data[this.t++] = x >> this.DB - sh;
    } else
      this.data[this.t - 1] |= x << sh;
    sh += k;
    if (sh >= this.DB)
      sh -= this.DB;
  }
  if (k == 8 && (s2[0] & 128) != 0) {
    this.s = -1;
    if (sh > 0)
      this.data[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
  }
  this.clamp();
  if (mi)
    BigInteger$2.ZERO.subTo(this, this);
}
function bnpClamp() {
  var c = this.s & this.DM;
  while (this.t > 0 && this.data[this.t - 1] == c)
    --this.t;
}
function bnToString(b2) {
  if (this.s < 0)
    return "-" + this.negate().toString(b2);
  var k;
  if (b2 == 16)
    k = 4;
  else if (b2 == 8)
    k = 3;
  else if (b2 == 2)
    k = 1;
  else if (b2 == 32)
    k = 5;
  else if (b2 == 4)
    k = 2;
  else
    return this.toRadix(b2);
  var km = (1 << k) - 1, d, m = false, r = "", i2 = this.t;
  var p = this.DB - i2 * this.DB % k;
  if (i2-- > 0) {
    if (p < this.DB && (d = this.data[i2] >> p) > 0) {
      m = true;
      r = int2char(d);
    }
    while (i2 >= 0) {
      if (p < k) {
        d = (this.data[i2] & (1 << p) - 1) << k - p;
        d |= this.data[--i2] >> (p += this.DB - k);
      } else {
        d = this.data[i2] >> (p -= k) & km;
        if (p <= 0) {
          p += this.DB;
          --i2;
        }
      }
      if (d > 0)
        m = true;
      if (m)
        r += int2char(d);
    }
  }
  return m ? r : "0";
}
function bnNegate() {
  var r = nbi();
  BigInteger$2.ZERO.subTo(this, r);
  return r;
}
function bnAbs() {
  return this.s < 0 ? this.negate() : this;
}
function bnCompareTo(a) {
  var r = this.s - a.s;
  if (r != 0)
    return r;
  var i2 = this.t;
  r = i2 - a.t;
  if (r != 0)
    return this.s < 0 ? -r : r;
  while (--i2 >= 0)
    if ((r = this.data[i2] - a.data[i2]) != 0)
      return r;
  return 0;
}
function nbits(x) {
  var r = 1, t;
  if ((t = x >>> 16) != 0) {
    x = t;
    r += 16;
  }
  if ((t = x >> 8) != 0) {
    x = t;
    r += 8;
  }
  if ((t = x >> 4) != 0) {
    x = t;
    r += 4;
  }
  if ((t = x >> 2) != 0) {
    x = t;
    r += 2;
  }
  if ((t = x >> 1) != 0) {
    x = t;
    r += 1;
  }
  return r;
}
function bnBitLength() {
  if (this.t <= 0)
    return 0;
  return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
}
function bnpDLShiftTo(n, r) {
  var i2;
  for (i2 = this.t - 1; i2 >= 0; --i2)
    r.data[i2 + n] = this.data[i2];
  for (i2 = n - 1; i2 >= 0; --i2)
    r.data[i2] = 0;
  r.t = this.t + n;
  r.s = this.s;
}
function bnpDRShiftTo(n, r) {
  for (var i2 = n; i2 < this.t; ++i2)
    r.data[i2 - n] = this.data[i2];
  r.t = Math.max(this.t - n, 0);
  r.s = this.s;
}
function bnpLShiftTo(n, r) {
  var bs = n % this.DB;
  var cbs = this.DB - bs;
  var bm = (1 << cbs) - 1;
  var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i2;
  for (i2 = this.t - 1; i2 >= 0; --i2) {
    r.data[i2 + ds + 1] = this.data[i2] >> cbs | c;
    c = (this.data[i2] & bm) << bs;
  }
  for (i2 = ds - 1; i2 >= 0; --i2)
    r.data[i2] = 0;
  r.data[ds] = c;
  r.t = this.t + ds + 1;
  r.s = this.s;
  r.clamp();
}
function bnpRShiftTo(n, r) {
  r.s = this.s;
  var ds = Math.floor(n / this.DB);
  if (ds >= this.t) {
    r.t = 0;
    return;
  }
  var bs = n % this.DB;
  var cbs = this.DB - bs;
  var bm = (1 << bs) - 1;
  r.data[0] = this.data[ds] >> bs;
  for (var i2 = ds + 1; i2 < this.t; ++i2) {
    r.data[i2 - ds - 1] |= (this.data[i2] & bm) << cbs;
    r.data[i2 - ds] = this.data[i2] >> bs;
  }
  if (bs > 0)
    r.data[this.t - ds - 1] |= (this.s & bm) << cbs;
  r.t = this.t - ds;
  r.clamp();
}
function bnpSubTo(a, r) {
  var i2 = 0, c = 0, m = Math.min(a.t, this.t);
  while (i2 < m) {
    c += this.data[i2] - a.data[i2];
    r.data[i2++] = c & this.DM;
    c >>= this.DB;
  }
  if (a.t < this.t) {
    c -= a.s;
    while (i2 < this.t) {
      c += this.data[i2];
      r.data[i2++] = c & this.DM;
      c >>= this.DB;
    }
    c += this.s;
  } else {
    c += this.s;
    while (i2 < a.t) {
      c -= a.data[i2];
      r.data[i2++] = c & this.DM;
      c >>= this.DB;
    }
    c -= a.s;
  }
  r.s = c < 0 ? -1 : 0;
  if (c < -1)
    r.data[i2++] = this.DV + c;
  else if (c > 0)
    r.data[i2++] = c;
  r.t = i2;
  r.clamp();
}
function bnpMultiplyTo(a, r) {
  var x = this.abs(), y = a.abs();
  var i2 = x.t;
  r.t = i2 + y.t;
  while (--i2 >= 0)
    r.data[i2] = 0;
  for (i2 = 0; i2 < y.t; ++i2)
    r.data[i2 + x.t] = x.am(0, y.data[i2], r, i2, 0, x.t);
  r.s = 0;
  r.clamp();
  if (this.s != a.s)
    BigInteger$2.ZERO.subTo(r, r);
}
function bnpSquareTo(r) {
  var x = this.abs();
  var i2 = r.t = 2 * x.t;
  while (--i2 >= 0)
    r.data[i2] = 0;
  for (i2 = 0; i2 < x.t - 1; ++i2) {
    var c = x.am(i2, x.data[i2], r, 2 * i2, 0, 1);
    if ((r.data[i2 + x.t] += x.am(i2 + 1, 2 * x.data[i2], r, 2 * i2 + 1, c, x.t - i2 - 1)) >= x.DV) {
      r.data[i2 + x.t] -= x.DV;
      r.data[i2 + x.t + 1] = 1;
    }
  }
  if (r.t > 0)
    r.data[r.t - 1] += x.am(i2, x.data[i2], r, 2 * i2, 0, 1);
  r.s = 0;
  r.clamp();
}
function bnpDivRemTo(m, q, r) {
  var pm = m.abs();
  if (pm.t <= 0)
    return;
  var pt = this.abs();
  if (pt.t < pm.t) {
    if (q != null)
      q.fromInt(0);
    if (r != null)
      this.copyTo(r);
    return;
  }
  if (r == null)
    r = nbi();
  var y = nbi(), ts = this.s, ms2 = m.s;
  var nsh = this.DB - nbits(pm.data[pm.t - 1]);
  if (nsh > 0) {
    pm.lShiftTo(nsh, y);
    pt.lShiftTo(nsh, r);
  } else {
    pm.copyTo(y);
    pt.copyTo(r);
  }
  var ys = y.t;
  var y0 = y.data[ys - 1];
  if (y0 == 0)
    return;
  var yt = y0 * (1 << this.F1) + (ys > 1 ? y.data[ys - 2] >> this.F2 : 0);
  var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
  var i2 = r.t, j = i2 - ys, t = q == null ? nbi() : q;
  y.dlShiftTo(j, t);
  if (r.compareTo(t) >= 0) {
    r.data[r.t++] = 1;
    r.subTo(t, r);
  }
  BigInteger$2.ONE.dlShiftTo(ys, t);
  t.subTo(y, y);
  while (y.t < ys)
    y.data[y.t++] = 0;
  while (--j >= 0) {
    var qd = r.data[--i2] == y0 ? this.DM : Math.floor(r.data[i2] * d1 + (r.data[i2 - 1] + e) * d2);
    if ((r.data[i2] += y.am(0, qd, r, j, 0, ys)) < qd) {
      y.dlShiftTo(j, t);
      r.subTo(t, r);
      while (r.data[i2] < --qd)
        r.subTo(t, r);
    }
  }
  if (q != null) {
    r.drShiftTo(ys, q);
    if (ts != ms2)
      BigInteger$2.ZERO.subTo(q, q);
  }
  r.t = ys;
  r.clamp();
  if (nsh > 0)
    r.rShiftTo(nsh, r);
  if (ts < 0)
    BigInteger$2.ZERO.subTo(r, r);
}
function bnMod(a) {
  var r = nbi();
  this.abs().divRemTo(a, null, r);
  if (this.s < 0 && r.compareTo(BigInteger$2.ZERO) > 0)
    a.subTo(r, r);
  return r;
}
function Classic(m) {
  this.m = m;
}
function cConvert(x) {
  if (x.s < 0 || x.compareTo(this.m) >= 0)
    return x.mod(this.m);
  else
    return x;
}
function cRevert(x) {
  return x;
}
function cReduce(x) {
  x.divRemTo(this.m, null, x);
}
function cMulTo(x, y, r) {
  x.multiplyTo(y, r);
  this.reduce(r);
}
function cSqrTo(x, r) {
  x.squareTo(r);
  this.reduce(r);
}
Classic.prototype.convert = cConvert;
Classic.prototype.revert = cRevert;
Classic.prototype.reduce = cReduce;
Classic.prototype.mulTo = cMulTo;
Classic.prototype.sqrTo = cSqrTo;
function bnpInvDigit() {
  if (this.t < 1)
    return 0;
  var x = this.data[0];
  if ((x & 1) == 0)
    return 0;
  var y = x & 3;
  y = y * (2 - (x & 15) * y) & 15;
  y = y * (2 - (x & 255) * y) & 255;
  y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
  y = y * (2 - x * y % this.DV) % this.DV;
  return y > 0 ? this.DV - y : -y;
}
function Montgomery(m) {
  this.m = m;
  this.mp = m.invDigit();
  this.mpl = this.mp & 32767;
  this.mph = this.mp >> 15;
  this.um = (1 << m.DB - 15) - 1;
  this.mt2 = 2 * m.t;
}
function montConvert(x) {
  var r = nbi();
  x.abs().dlShiftTo(this.m.t, r);
  r.divRemTo(this.m, null, r);
  if (x.s < 0 && r.compareTo(BigInteger$2.ZERO) > 0)
    this.m.subTo(r, r);
  return r;
}
function montRevert(x) {
  var r = nbi();
  x.copyTo(r);
  this.reduce(r);
  return r;
}
function montReduce(x) {
  while (x.t <= this.mt2)
    x.data[x.t++] = 0;
  for (var i2 = 0; i2 < this.m.t; ++i2) {
    var j = x.data[i2] & 32767;
    var u0 = j * this.mpl + ((j * this.mph + (x.data[i2] >> 15) * this.mpl & this.um) << 15) & x.DM;
    j = i2 + this.m.t;
    x.data[j] += this.m.am(0, u0, x, i2, 0, this.m.t);
    while (x.data[j] >= x.DV) {
      x.data[j] -= x.DV;
      x.data[++j]++;
    }
  }
  x.clamp();
  x.drShiftTo(this.m.t, x);
  if (x.compareTo(this.m) >= 0)
    x.subTo(this.m, x);
}
function montSqrTo(x, r) {
  x.squareTo(r);
  this.reduce(r);
}
function montMulTo(x, y, r) {
  x.multiplyTo(y, r);
  this.reduce(r);
}
Montgomery.prototype.convert = montConvert;
Montgomery.prototype.revert = montRevert;
Montgomery.prototype.reduce = montReduce;
Montgomery.prototype.mulTo = montMulTo;
Montgomery.prototype.sqrTo = montSqrTo;
function bnpIsEven() {
  return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
}
function bnpExp(e, z) {
  if (e > 4294967295 || e < 1)
    return BigInteger$2.ONE;
  var r = nbi(), r2 = nbi(), g = z.convert(this), i2 = nbits(e) - 1;
  g.copyTo(r);
  while (--i2 >= 0) {
    z.sqrTo(r, r2);
    if ((e & 1 << i2) > 0)
      z.mulTo(r2, g, r);
    else {
      var t = r;
      r = r2;
      r2 = t;
    }
  }
  return z.revert(r);
}
function bnModPowInt(e, m) {
  var z;
  if (e < 256 || m.isEven())
    z = new Classic(m);
  else
    z = new Montgomery(m);
  return this.exp(e, z);
}
BigInteger$2.prototype.copyTo = bnpCopyTo;
BigInteger$2.prototype.fromInt = bnpFromInt;
BigInteger$2.prototype.fromString = bnpFromString;
BigInteger$2.prototype.clamp = bnpClamp;
BigInteger$2.prototype.dlShiftTo = bnpDLShiftTo;
BigInteger$2.prototype.drShiftTo = bnpDRShiftTo;
BigInteger$2.prototype.lShiftTo = bnpLShiftTo;
BigInteger$2.prototype.rShiftTo = bnpRShiftTo;
BigInteger$2.prototype.subTo = bnpSubTo;
BigInteger$2.prototype.multiplyTo = bnpMultiplyTo;
BigInteger$2.prototype.squareTo = bnpSquareTo;
BigInteger$2.prototype.divRemTo = bnpDivRemTo;
BigInteger$2.prototype.invDigit = bnpInvDigit;
BigInteger$2.prototype.isEven = bnpIsEven;
BigInteger$2.prototype.exp = bnpExp;
BigInteger$2.prototype.toString = bnToString;
BigInteger$2.prototype.negate = bnNegate;
BigInteger$2.prototype.abs = bnAbs;
BigInteger$2.prototype.compareTo = bnCompareTo;
BigInteger$2.prototype.bitLength = bnBitLength;
BigInteger$2.prototype.mod = bnMod;
BigInteger$2.prototype.modPowInt = bnModPowInt;
BigInteger$2.ZERO = nbv(0);
BigInteger$2.ONE = nbv(1);
function bnClone() {
  var r = nbi();
  this.copyTo(r);
  return r;
}
function bnIntValue() {
  if (this.s < 0) {
    if (this.t == 1)
      return this.data[0] - this.DV;
    else if (this.t == 0)
      return -1;
  } else if (this.t == 1)
    return this.data[0];
  else if (this.t == 0)
    return 0;
  return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
}
function bnByteValue() {
  return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
}
function bnShortValue() {
  return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
}
function bnpChunkSize(r) {
  return Math.floor(Math.LN2 * this.DB / Math.log(r));
}
function bnSigNum() {
  if (this.s < 0)
    return -1;
  else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0)
    return 0;
  else
    return 1;
}
function bnpToRadix(b2) {
  if (b2 == null)
    b2 = 10;
  if (this.signum() == 0 || b2 < 2 || b2 > 36)
    return "0";
  var cs = this.chunkSize(b2);
  var a = Math.pow(b2, cs);
  var d = nbv(a), y = nbi(), z = nbi(), r = "";
  this.divRemTo(d, y, z);
  while (y.signum() > 0) {
    r = (a + z.intValue()).toString(b2).substr(1) + r;
    y.divRemTo(d, y, z);
  }
  return z.intValue().toString(b2) + r;
}
function bnpFromRadix(s2, b2) {
  this.fromInt(0);
  if (b2 == null)
    b2 = 10;
  var cs = this.chunkSize(b2);
  var d = Math.pow(b2, cs), mi = false, j = 0, w = 0;
  for (var i2 = 0; i2 < s2.length; ++i2) {
    var x = intAt(s2, i2);
    if (x < 0) {
      if (s2.charAt(i2) == "-" && this.signum() == 0)
        mi = true;
      continue;
    }
    w = b2 * w + x;
    if (++j >= cs) {
      this.dMultiply(d);
      this.dAddOffset(w, 0);
      j = 0;
      w = 0;
    }
  }
  if (j > 0) {
    this.dMultiply(Math.pow(b2, j));
    this.dAddOffset(w, 0);
  }
  if (mi)
    BigInteger$2.ZERO.subTo(this, this);
}
function bnpFromNumber(a, b2, c) {
  if ("number" == typeof b2) {
    if (a < 2)
      this.fromInt(1);
    else {
      this.fromNumber(a, c);
      if (!this.testBit(a - 1))
        this.bitwiseTo(BigInteger$2.ONE.shiftLeft(a - 1), op_or, this);
      if (this.isEven())
        this.dAddOffset(1, 0);
      while (!this.isProbablePrime(b2)) {
        this.dAddOffset(2, 0);
        if (this.bitLength() > a)
          this.subTo(BigInteger$2.ONE.shiftLeft(a - 1), this);
      }
    }
  } else {
    var x = new Array(), t = a & 7;
    x.length = (a >> 3) + 1;
    b2.nextBytes(x);
    if (t > 0)
      x[0] &= (1 << t) - 1;
    else
      x[0] = 0;
    this.fromString(x, 256);
  }
}
function bnToByteArray() {
  var i2 = this.t, r = new Array();
  r[0] = this.s;
  var p = this.DB - i2 * this.DB % 8, d, k = 0;
  if (i2-- > 0) {
    if (p < this.DB && (d = this.data[i2] >> p) != (this.s & this.DM) >> p)
      r[k++] = d | this.s << this.DB - p;
    while (i2 >= 0) {
      if (p < 8) {
        d = (this.data[i2] & (1 << p) - 1) << 8 - p;
        d |= this.data[--i2] >> (p += this.DB - 8);
      } else {
        d = this.data[i2] >> (p -= 8) & 255;
        if (p <= 0) {
          p += this.DB;
          --i2;
        }
      }
      if ((d & 128) != 0)
        d |= -256;
      if (k == 0 && (this.s & 128) != (d & 128))
        ++k;
      if (k > 0 || d != this.s)
        r[k++] = d;
    }
  }
  return r;
}
function bnEquals(a) {
  return this.compareTo(a) == 0;
}
function bnMin(a) {
  return this.compareTo(a) < 0 ? this : a;
}
function bnMax(a) {
  return this.compareTo(a) > 0 ? this : a;
}
function bnpBitwiseTo(a, op, r) {
  var i2, f, m = Math.min(a.t, this.t);
  for (i2 = 0; i2 < m; ++i2)
    r.data[i2] = op(this.data[i2], a.data[i2]);
  if (a.t < this.t) {
    f = a.s & this.DM;
    for (i2 = m; i2 < this.t; ++i2)
      r.data[i2] = op(this.data[i2], f);
    r.t = this.t;
  } else {
    f = this.s & this.DM;
    for (i2 = m; i2 < a.t; ++i2)
      r.data[i2] = op(f, a.data[i2]);
    r.t = a.t;
  }
  r.s = op(this.s, a.s);
  r.clamp();
}
function op_and(x, y) {
  return x & y;
}
function bnAnd(a) {
  var r = nbi();
  this.bitwiseTo(a, op_and, r);
  return r;
}
function op_or(x, y) {
  return x | y;
}
function bnOr(a) {
  var r = nbi();
  this.bitwiseTo(a, op_or, r);
  return r;
}
function op_xor(x, y) {
  return x ^ y;
}
function bnXor(a) {
  var r = nbi();
  this.bitwiseTo(a, op_xor, r);
  return r;
}
function op_andnot(x, y) {
  return x & ~y;
}
function bnAndNot(a) {
  var r = nbi();
  this.bitwiseTo(a, op_andnot, r);
  return r;
}
function bnNot() {
  var r = nbi();
  for (var i2 = 0; i2 < this.t; ++i2)
    r.data[i2] = this.DM & ~this.data[i2];
  r.t = this.t;
  r.s = ~this.s;
  return r;
}
function bnShiftLeft(n) {
  var r = nbi();
  if (n < 0)
    this.rShiftTo(-n, r);
  else
    this.lShiftTo(n, r);
  return r;
}
function bnShiftRight(n) {
  var r = nbi();
  if (n < 0)
    this.lShiftTo(-n, r);
  else
    this.rShiftTo(n, r);
  return r;
}
function lbit(x) {
  if (x == 0)
    return -1;
  var r = 0;
  if ((x & 65535) == 0) {
    x >>= 16;
    r += 16;
  }
  if ((x & 255) == 0) {
    x >>= 8;
    r += 8;
  }
  if ((x & 15) == 0) {
    x >>= 4;
    r += 4;
  }
  if ((x & 3) == 0) {
    x >>= 2;
    r += 2;
  }
  if ((x & 1) == 0)
    ++r;
  return r;
}
function bnGetLowestSetBit() {
  for (var i2 = 0; i2 < this.t; ++i2)
    if (this.data[i2] != 0)
      return i2 * this.DB + lbit(this.data[i2]);
  if (this.s < 0)
    return this.t * this.DB;
  return -1;
}
function cbit(x) {
  var r = 0;
  while (x != 0) {
    x &= x - 1;
    ++r;
  }
  return r;
}
function bnBitCount() {
  var r = 0, x = this.s & this.DM;
  for (var i2 = 0; i2 < this.t; ++i2)
    r += cbit(this.data[i2] ^ x);
  return r;
}
function bnTestBit(n) {
  var j = Math.floor(n / this.DB);
  if (j >= this.t)
    return this.s != 0;
  return (this.data[j] & 1 << n % this.DB) != 0;
}
function bnpChangeBit(n, op) {
  var r = BigInteger$2.ONE.shiftLeft(n);
  this.bitwiseTo(r, op, r);
  return r;
}
function bnSetBit(n) {
  return this.changeBit(n, op_or);
}
function bnClearBit(n) {
  return this.changeBit(n, op_andnot);
}
function bnFlipBit(n) {
  return this.changeBit(n, op_xor);
}
function bnpAddTo(a, r) {
  var i2 = 0, c = 0, m = Math.min(a.t, this.t);
  while (i2 < m) {
    c += this.data[i2] + a.data[i2];
    r.data[i2++] = c & this.DM;
    c >>= this.DB;
  }
  if (a.t < this.t) {
    c += a.s;
    while (i2 < this.t) {
      c += this.data[i2];
      r.data[i2++] = c & this.DM;
      c >>= this.DB;
    }
    c += this.s;
  } else {
    c += this.s;
    while (i2 < a.t) {
      c += a.data[i2];
      r.data[i2++] = c & this.DM;
      c >>= this.DB;
    }
    c += a.s;
  }
  r.s = c < 0 ? -1 : 0;
  if (c > 0)
    r.data[i2++] = c;
  else if (c < -1)
    r.data[i2++] = this.DV + c;
  r.t = i2;
  r.clamp();
}
function bnAdd(a) {
  var r = nbi();
  this.addTo(a, r);
  return r;
}
function bnSubtract(a) {
  var r = nbi();
  this.subTo(a, r);
  return r;
}
function bnMultiply(a) {
  var r = nbi();
  this.multiplyTo(a, r);
  return r;
}
function bnDivide(a) {
  var r = nbi();
  this.divRemTo(a, r, null);
  return r;
}
function bnRemainder(a) {
  var r = nbi();
  this.divRemTo(a, null, r);
  return r;
}
function bnDivideAndRemainder(a) {
  var q = nbi(), r = nbi();
  this.divRemTo(a, q, r);
  return new Array(q, r);
}
function bnpDMultiply(n) {
  this.data[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
  ++this.t;
  this.clamp();
}
function bnpDAddOffset(n, w) {
  if (n == 0)
    return;
  while (this.t <= w)
    this.data[this.t++] = 0;
  this.data[w] += n;
  while (this.data[w] >= this.DV) {
    this.data[w] -= this.DV;
    if (++w >= this.t)
      this.data[this.t++] = 0;
    ++this.data[w];
  }
}
function NullExp() {
}
function nNop(x) {
  return x;
}
function nMulTo(x, y, r) {
  x.multiplyTo(y, r);
}
function nSqrTo(x, r) {
  x.squareTo(r);
}
NullExp.prototype.convert = nNop;
NullExp.prototype.revert = nNop;
NullExp.prototype.mulTo = nMulTo;
NullExp.prototype.sqrTo = nSqrTo;
function bnPow(e) {
  return this.exp(e, new NullExp());
}
function bnpMultiplyLowerTo(a, n, r) {
  var i2 = Math.min(this.t + a.t, n);
  r.s = 0;
  r.t = i2;
  while (i2 > 0)
    r.data[--i2] = 0;
  var j;
  for (j = r.t - this.t; i2 < j; ++i2)
    r.data[i2 + this.t] = this.am(0, a.data[i2], r, i2, 0, this.t);
  for (j = Math.min(a.t, n); i2 < j; ++i2)
    this.am(0, a.data[i2], r, i2, 0, n - i2);
  r.clamp();
}
function bnpMultiplyUpperTo(a, n, r) {
  --n;
  var i2 = r.t = this.t + a.t - n;
  r.s = 0;
  while (--i2 >= 0)
    r.data[i2] = 0;
  for (i2 = Math.max(n - this.t, 0); i2 < a.t; ++i2)
    r.data[this.t + i2 - n] = this.am(n - i2, a.data[i2], r, 0, 0, this.t + i2 - n);
  r.clamp();
  r.drShiftTo(1, r);
}
function Barrett(m) {
  this.r2 = nbi();
  this.q3 = nbi();
  BigInteger$2.ONE.dlShiftTo(2 * m.t, this.r2);
  this.mu = this.r2.divide(m);
  this.m = m;
}
function barrettConvert(x) {
  if (x.s < 0 || x.t > 2 * this.m.t)
    return x.mod(this.m);
  else if (x.compareTo(this.m) < 0)
    return x;
  else {
    var r = nbi();
    x.copyTo(r);
    this.reduce(r);
    return r;
  }
}
function barrettRevert(x) {
  return x;
}
function barrettReduce(x) {
  x.drShiftTo(this.m.t - 1, this.r2);
  if (x.t > this.m.t + 1) {
    x.t = this.m.t + 1;
    x.clamp();
  }
  this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
  this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
  while (x.compareTo(this.r2) < 0)
    x.dAddOffset(1, this.m.t + 1);
  x.subTo(this.r2, x);
  while (x.compareTo(this.m) >= 0)
    x.subTo(this.m, x);
}
function barrettSqrTo(x, r) {
  x.squareTo(r);
  this.reduce(r);
}
function barrettMulTo(x, y, r) {
  x.multiplyTo(y, r);
  this.reduce(r);
}
Barrett.prototype.convert = barrettConvert;
Barrett.prototype.revert = barrettRevert;
Barrett.prototype.reduce = barrettReduce;
Barrett.prototype.mulTo = barrettMulTo;
Barrett.prototype.sqrTo = barrettSqrTo;
function bnModPow(e, m) {
  var i2 = e.bitLength(), k, r = nbv(1), z;
  if (i2 <= 0)
    return r;
  else if (i2 < 18)
    k = 1;
  else if (i2 < 48)
    k = 3;
  else if (i2 < 144)
    k = 4;
  else if (i2 < 768)
    k = 5;
  else
    k = 6;
  if (i2 < 8)
    z = new Classic(m);
  else if (m.isEven())
    z = new Barrett(m);
  else
    z = new Montgomery(m);
  var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
  g[1] = z.convert(this);
  if (k > 1) {
    var g2 = nbi();
    z.sqrTo(g[1], g2);
    while (n <= km) {
      g[n] = nbi();
      z.mulTo(g2, g[n - 2], g[n]);
      n += 2;
    }
  }
  var j = e.t - 1, w, is1 = true, r2 = nbi(), t;
  i2 = nbits(e.data[j]) - 1;
  while (j >= 0) {
    if (i2 >= k1)
      w = e.data[j] >> i2 - k1 & km;
    else {
      w = (e.data[j] & (1 << i2 + 1) - 1) << k1 - i2;
      if (j > 0)
        w |= e.data[j - 1] >> this.DB + i2 - k1;
    }
    n = k;
    while ((w & 1) == 0) {
      w >>= 1;
      --n;
    }
    if ((i2 -= n) < 0) {
      i2 += this.DB;
      --j;
    }
    if (is1) {
      g[w].copyTo(r);
      is1 = false;
    } else {
      while (n > 1) {
        z.sqrTo(r, r2);
        z.sqrTo(r2, r);
        n -= 2;
      }
      if (n > 0)
        z.sqrTo(r, r2);
      else {
        t = r;
        r = r2;
        r2 = t;
      }
      z.mulTo(r2, g[w], r);
    }
    while (j >= 0 && (e.data[j] & 1 << i2) == 0) {
      z.sqrTo(r, r2);
      t = r;
      r = r2;
      r2 = t;
      if (--i2 < 0) {
        i2 = this.DB - 1;
        --j;
      }
    }
  }
  return z.revert(r);
}
function bnGCD(a) {
  var x = this.s < 0 ? this.negate() : this.clone();
  var y = a.s < 0 ? a.negate() : a.clone();
  if (x.compareTo(y) < 0) {
    var t = x;
    x = y;
    y = t;
  }
  var i2 = x.getLowestSetBit(), g = y.getLowestSetBit();
  if (g < 0)
    return x;
  if (i2 < g)
    g = i2;
  if (g > 0) {
    x.rShiftTo(g, x);
    y.rShiftTo(g, y);
  }
  while (x.signum() > 0) {
    if ((i2 = x.getLowestSetBit()) > 0)
      x.rShiftTo(i2, x);
    if ((i2 = y.getLowestSetBit()) > 0)
      y.rShiftTo(i2, y);
    if (x.compareTo(y) >= 0) {
      x.subTo(y, x);
      x.rShiftTo(1, x);
    } else {
      y.subTo(x, y);
      y.rShiftTo(1, y);
    }
  }
  if (g > 0)
    y.lShiftTo(g, y);
  return y;
}
function bnpModInt(n) {
  if (n <= 0)
    return 0;
  var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
  if (this.t > 0)
    if (d == 0)
      r = this.data[0] % n;
    else
      for (var i2 = this.t - 1; i2 >= 0; --i2)
        r = (d * r + this.data[i2]) % n;
  return r;
}
function bnModInverse(m) {
  var ac = m.isEven();
  if (this.isEven() && ac || m.signum() == 0)
    return BigInteger$2.ZERO;
  var u = m.clone(), v = this.clone();
  var a = nbv(1), b2 = nbv(0), c = nbv(0), d = nbv(1);
  while (u.signum() != 0) {
    while (u.isEven()) {
      u.rShiftTo(1, u);
      if (ac) {
        if (!a.isEven() || !b2.isEven()) {
          a.addTo(this, a);
          b2.subTo(m, b2);
        }
        a.rShiftTo(1, a);
      } else if (!b2.isEven())
        b2.subTo(m, b2);
      b2.rShiftTo(1, b2);
    }
    while (v.isEven()) {
      v.rShiftTo(1, v);
      if (ac) {
        if (!c.isEven() || !d.isEven()) {
          c.addTo(this, c);
          d.subTo(m, d);
        }
        c.rShiftTo(1, c);
      } else if (!d.isEven())
        d.subTo(m, d);
      d.rShiftTo(1, d);
    }
    if (u.compareTo(v) >= 0) {
      u.subTo(v, u);
      if (ac)
        a.subTo(c, a);
      b2.subTo(d, b2);
    } else {
      v.subTo(u, v);
      if (ac)
        c.subTo(a, c);
      d.subTo(b2, d);
    }
  }
  if (v.compareTo(BigInteger$2.ONE) != 0)
    return BigInteger$2.ZERO;
  if (d.compareTo(m) >= 0)
    return d.subtract(m);
  if (d.signum() < 0)
    d.addTo(m, d);
  else
    return d;
  if (d.signum() < 0)
    return d.add(m);
  else
    return d;
}
var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
function bnIsProbablePrime(t) {
  var i2, x = this.abs();
  if (x.t == 1 && x.data[0] <= lowprimes[lowprimes.length - 1]) {
    for (i2 = 0; i2 < lowprimes.length; ++i2)
      if (x.data[0] == lowprimes[i2])
        return true;
    return false;
  }
  if (x.isEven())
    return false;
  i2 = 1;
  while (i2 < lowprimes.length) {
    var m = lowprimes[i2], j = i2 + 1;
    while (j < lowprimes.length && m < lplim)
      m *= lowprimes[j++];
    m = x.modInt(m);
    while (i2 < j)
      if (m % lowprimes[i2++] == 0)
        return false;
  }
  return x.millerRabin(t);
}
function bnpMillerRabin(t) {
  var n1 = this.subtract(BigInteger$2.ONE);
  var k = n1.getLowestSetBit();
  if (k <= 0)
    return false;
  var r = n1.shiftRight(k);
  var prng2 = bnGetPrng();
  var a;
  for (var i2 = 0; i2 < t; ++i2) {
    do {
      a = new BigInteger$2(this.bitLength(), prng2);
    } while (a.compareTo(BigInteger$2.ONE) <= 0 || a.compareTo(n1) >= 0);
    var y = a.modPow(r, this);
    if (y.compareTo(BigInteger$2.ONE) != 0 && y.compareTo(n1) != 0) {
      var j = 1;
      while (j++ < k && y.compareTo(n1) != 0) {
        y = y.modPowInt(2, this);
        if (y.compareTo(BigInteger$2.ONE) == 0)
          return false;
      }
      if (y.compareTo(n1) != 0)
        return false;
    }
  }
  return true;
}
function bnGetPrng() {
  return {
    nextBytes: function(x) {
      for (var i2 = 0; i2 < x.length; ++i2) {
        x[i2] = Math.floor(Math.random() * 256);
      }
    }
  };
}
BigInteger$2.prototype.chunkSize = bnpChunkSize;
BigInteger$2.prototype.toRadix = bnpToRadix;
BigInteger$2.prototype.fromRadix = bnpFromRadix;
BigInteger$2.prototype.fromNumber = bnpFromNumber;
BigInteger$2.prototype.bitwiseTo = bnpBitwiseTo;
BigInteger$2.prototype.changeBit = bnpChangeBit;
BigInteger$2.prototype.addTo = bnpAddTo;
BigInteger$2.prototype.dMultiply = bnpDMultiply;
BigInteger$2.prototype.dAddOffset = bnpDAddOffset;
BigInteger$2.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
BigInteger$2.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
BigInteger$2.prototype.modInt = bnpModInt;
BigInteger$2.prototype.millerRabin = bnpMillerRabin;
BigInteger$2.prototype.clone = bnClone;
BigInteger$2.prototype.intValue = bnIntValue;
BigInteger$2.prototype.byteValue = bnByteValue;
BigInteger$2.prototype.shortValue = bnShortValue;
BigInteger$2.prototype.signum = bnSigNum;
BigInteger$2.prototype.toByteArray = bnToByteArray;
BigInteger$2.prototype.equals = bnEquals;
BigInteger$2.prototype.min = bnMin;
BigInteger$2.prototype.max = bnMax;
BigInteger$2.prototype.and = bnAnd;
BigInteger$2.prototype.or = bnOr;
BigInteger$2.prototype.xor = bnXor;
BigInteger$2.prototype.andNot = bnAndNot;
BigInteger$2.prototype.not = bnNot;
BigInteger$2.prototype.shiftLeft = bnShiftLeft;
BigInteger$2.prototype.shiftRight = bnShiftRight;
BigInteger$2.prototype.getLowestSetBit = bnGetLowestSetBit;
BigInteger$2.prototype.bitCount = bnBitCount;
BigInteger$2.prototype.testBit = bnTestBit;
BigInteger$2.prototype.setBit = bnSetBit;
BigInteger$2.prototype.clearBit = bnClearBit;
BigInteger$2.prototype.flipBit = bnFlipBit;
BigInteger$2.prototype.add = bnAdd;
BigInteger$2.prototype.subtract = bnSubtract;
BigInteger$2.prototype.multiply = bnMultiply;
BigInteger$2.prototype.divide = bnDivide;
BigInteger$2.prototype.remainder = bnRemainder;
BigInteger$2.prototype.divideAndRemainder = bnDivideAndRemainder;
BigInteger$2.prototype.modPow = bnModPow;
BigInteger$2.prototype.modInverse = bnModInverse;
BigInteger$2.prototype.pow = bnPow;
BigInteger$2.prototype.gcd = bnGCD;
BigInteger$2.prototype.isProbablePrime = bnIsProbablePrime;
var forge$b = forge$s;
var sha1 = forge$b.sha1 = forge$b.sha1 || {};
forge$b.md.sha1 = forge$b.md.algorithms.sha1 = sha1;
sha1.create = function() {
  if (!_initialized$1) {
    _init$1();
  }
  var _state = null;
  var _input = forge$b.util.createBuffer();
  var _w = new Array(80);
  var md = {
    algorithm: "sha1",
    blockLength: 64,
    digestLength: 20,
    messageLength: 0,
    fullMessageLength: null,
    messageLengthSize: 8
  };
  md.start = function() {
    md.messageLength = 0;
    md.fullMessageLength = md.messageLength64 = [];
    var int32s = md.messageLengthSize / 4;
    for (var i2 = 0; i2 < int32s; ++i2) {
      md.fullMessageLength.push(0);
    }
    _input = forge$b.util.createBuffer();
    _state = {
      h0: 1732584193,
      h1: 4023233417,
      h2: 2562383102,
      h3: 271733878,
      h4: 3285377520
    };
    return md;
  };
  md.start();
  md.update = function(msg, encoding2) {
    if (encoding2 === "utf8") {
      msg = forge$b.util.encodeUtf8(msg);
    }
    var len2 = msg.length;
    md.messageLength += len2;
    len2 = [len2 / 4294967296 >>> 0, len2 >>> 0];
    for (var i2 = md.fullMessageLength.length - 1; i2 >= 0; --i2) {
      md.fullMessageLength[i2] += len2[1];
      len2[1] = len2[0] + (md.fullMessageLength[i2] / 4294967296 >>> 0);
      md.fullMessageLength[i2] = md.fullMessageLength[i2] >>> 0;
      len2[0] = len2[1] / 4294967296 >>> 0;
    }
    _input.putBytes(msg);
    _update$1(_state, _w, _input);
    if (_input.read > 2048 || _input.length() === 0) {
      _input.compact();
    }
    return md;
  };
  md.digest = function() {
    var finalBlock = forge$b.util.createBuffer();
    finalBlock.putBytes(_input.bytes());
    var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
    var overflow = remaining & md.blockLength - 1;
    finalBlock.putBytes(_padding$1.substr(0, md.blockLength - overflow));
    var next, carry;
    var bits2 = md.fullMessageLength[0] * 8;
    for (var i2 = 0; i2 < md.fullMessageLength.length - 1; ++i2) {
      next = md.fullMessageLength[i2 + 1] * 8;
      carry = next / 4294967296 >>> 0;
      bits2 += carry;
      finalBlock.putInt32(bits2 >>> 0);
      bits2 = next >>> 0;
    }
    finalBlock.putInt32(bits2);
    var s2 = {
      h0: _state.h0,
      h1: _state.h1,
      h2: _state.h2,
      h3: _state.h3,
      h4: _state.h4
    };
    _update$1(s2, _w, finalBlock);
    var rval = forge$b.util.createBuffer();
    rval.putInt32(s2.h0);
    rval.putInt32(s2.h1);
    rval.putInt32(s2.h2);
    rval.putInt32(s2.h3);
    rval.putInt32(s2.h4);
    return rval;
  };
  return md;
};
var _padding$1 = null;
var _initialized$1 = false;
function _init$1() {
  _padding$1 = String.fromCharCode(128);
  _padding$1 += forge$b.util.fillString(String.fromCharCode(0), 64);
  _initialized$1 = true;
}
function _update$1(s2, w, bytes2) {
  var t, a, b2, c, d, e, f, i2;
  var len2 = bytes2.length();
  while (len2 >= 64) {
    a = s2.h0;
    b2 = s2.h1;
    c = s2.h2;
    d = s2.h3;
    e = s2.h4;
    for (i2 = 0; i2 < 16; ++i2) {
      t = bytes2.getInt32();
      w[i2] = t;
      f = d ^ b2 & (c ^ d);
      t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
      e = d;
      d = c;
      c = (b2 << 30 | b2 >>> 2) >>> 0;
      b2 = a;
      a = t;
    }
    for (; i2 < 20; ++i2) {
      t = w[i2 - 3] ^ w[i2 - 8] ^ w[i2 - 14] ^ w[i2 - 16];
      t = t << 1 | t >>> 31;
      w[i2] = t;
      f = d ^ b2 & (c ^ d);
      t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
      e = d;
      d = c;
      c = (b2 << 30 | b2 >>> 2) >>> 0;
      b2 = a;
      a = t;
    }
    for (; i2 < 32; ++i2) {
      t = w[i2 - 3] ^ w[i2 - 8] ^ w[i2 - 14] ^ w[i2 - 16];
      t = t << 1 | t >>> 31;
      w[i2] = t;
      f = b2 ^ c ^ d;
      t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
      e = d;
      d = c;
      c = (b2 << 30 | b2 >>> 2) >>> 0;
      b2 = a;
      a = t;
    }
    for (; i2 < 40; ++i2) {
      t = w[i2 - 6] ^ w[i2 - 16] ^ w[i2 - 28] ^ w[i2 - 32];
      t = t << 2 | t >>> 30;
      w[i2] = t;
      f = b2 ^ c ^ d;
      t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
      e = d;
      d = c;
      c = (b2 << 30 | b2 >>> 2) >>> 0;
      b2 = a;
      a = t;
    }
    for (; i2 < 60; ++i2) {
      t = w[i2 - 6] ^ w[i2 - 16] ^ w[i2 - 28] ^ w[i2 - 32];
      t = t << 2 | t >>> 30;
      w[i2] = t;
      f = b2 & c | d & (b2 ^ c);
      t = (a << 5 | a >>> 27) + f + e + 2400959708 + t;
      e = d;
      d = c;
      c = (b2 << 30 | b2 >>> 2) >>> 0;
      b2 = a;
      a = t;
    }
    for (; i2 < 80; ++i2) {
      t = w[i2 - 6] ^ w[i2 - 16] ^ w[i2 - 28] ^ w[i2 - 32];
      t = t << 2 | t >>> 30;
      w[i2] = t;
      f = b2 ^ c ^ d;
      t = (a << 5 | a >>> 27) + f + e + 3395469782 + t;
      e = d;
      d = c;
      c = (b2 << 30 | b2 >>> 2) >>> 0;
      b2 = a;
      a = t;
    }
    s2.h0 = s2.h0 + a | 0;
    s2.h1 = s2.h1 + b2 | 0;
    s2.h2 = s2.h2 + c | 0;
    s2.h3 = s2.h3 + d | 0;
    s2.h4 = s2.h4 + e | 0;
    len2 -= 64;
  }
}
var forge$a = forge$s;
var pkcs1 = forge$a.pkcs1 = forge$a.pkcs1 || {};
pkcs1.encode_rsa_oaep = function(key, message2, options) {
  var label;
  var seed2;
  var md;
  var mgf1Md;
  if (typeof options === "string") {
    label = options;
    seed2 = arguments[3] || void 0;
    md = arguments[4] || void 0;
  } else if (options) {
    label = options.label || void 0;
    seed2 = options.seed || void 0;
    md = options.md || void 0;
    if (options.mgf1 && options.mgf1.md) {
      mgf1Md = options.mgf1.md;
    }
  }
  if (!md) {
    md = forge$a.md.sha1.create();
  } else {
    md.start();
  }
  if (!mgf1Md) {
    mgf1Md = md;
  }
  var keyLength = Math.ceil(key.n.bitLength() / 8);
  var maxLength = keyLength - 2 * md.digestLength - 2;
  if (message2.length > maxLength) {
    var error2 = new Error("RSAES-OAEP input message length is too long.");
    error2.length = message2.length;
    error2.maxLength = maxLength;
    throw error2;
  }
  if (!label) {
    label = "";
  }
  md.update(label, "raw");
  var lHash = md.digest();
  var PS = "";
  var PS_length = maxLength - message2.length;
  for (var i2 = 0; i2 < PS_length; i2++) {
    PS += "\0";
  }
  var DB = lHash.getBytes() + PS + "" + message2;
  if (!seed2) {
    seed2 = forge$a.random.getBytes(md.digestLength);
  } else if (seed2.length !== md.digestLength) {
    var error2 = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
    error2.seedLength = seed2.length;
    error2.digestLength = md.digestLength;
    throw error2;
  }
  var dbMask = rsa_mgf1(seed2, keyLength - md.digestLength - 1, mgf1Md);
  var maskedDB = forge$a.util.xorBytes(DB, dbMask, DB.length);
  var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
  var maskedSeed = forge$a.util.xorBytes(seed2, seedMask, seed2.length);
  return "\0" + maskedSeed + maskedDB;
};
pkcs1.decode_rsa_oaep = function(key, em, options) {
  var label;
  var md;
  var mgf1Md;
  if (typeof options === "string") {
    label = options;
    md = arguments[3] || void 0;
  } else if (options) {
    label = options.label || void 0;
    md = options.md || void 0;
    if (options.mgf1 && options.mgf1.md) {
      mgf1Md = options.mgf1.md;
    }
  }
  var keyLength = Math.ceil(key.n.bitLength() / 8);
  if (em.length !== keyLength) {
    var error2 = new Error("RSAES-OAEP encoded message length is invalid.");
    error2.length = em.length;
    error2.expectedLength = keyLength;
    throw error2;
  }
  if (md === void 0) {
    md = forge$a.md.sha1.create();
  } else {
    md.start();
  }
  if (!mgf1Md) {
    mgf1Md = md;
  }
  if (keyLength < 2 * md.digestLength + 2) {
    throw new Error("RSAES-OAEP key is too short for the hash function.");
  }
  if (!label) {
    label = "";
  }
  md.update(label, "raw");
  var lHash = md.digest().getBytes();
  var y = em.charAt(0);
  var maskedSeed = em.substring(1, md.digestLength + 1);
  var maskedDB = em.substring(1 + md.digestLength);
  var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
  var seed2 = forge$a.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);
  var dbMask = rsa_mgf1(seed2, keyLength - md.digestLength - 1, mgf1Md);
  var db = forge$a.util.xorBytes(maskedDB, dbMask, maskedDB.length);
  var lHashPrime = db.substring(0, md.digestLength);
  var error2 = y !== "\0";
  for (var i2 = 0; i2 < md.digestLength; ++i2) {
    error2 |= lHash.charAt(i2) !== lHashPrime.charAt(i2);
  }
  var in_ps = 1;
  var index = md.digestLength;
  for (var j = md.digestLength; j < db.length; j++) {
    var code2 = db.charCodeAt(j);
    var is_0 = code2 & 1 ^ 1;
    var error_mask = in_ps ? 65534 : 0;
    error2 |= code2 & error_mask;
    in_ps = in_ps & is_0;
    index += in_ps;
  }
  if (error2 || db.charCodeAt(index) !== 1) {
    throw new Error("Invalid RSAES-OAEP padding.");
  }
  return db.substring(index + 1);
};
function rsa_mgf1(seed2, maskLength, hash2) {
  if (!hash2) {
    hash2 = forge$a.md.sha1.create();
  }
  var t = "";
  var count = Math.ceil(maskLength / hash2.digestLength);
  for (var i2 = 0; i2 < count; ++i2) {
    var c = String.fromCharCode(
      i2 >> 24 & 255,
      i2 >> 16 & 255,
      i2 >> 8 & 255,
      i2 & 255
    );
    hash2.start();
    hash2.update(seed2 + c);
    t += hash2.digest().getBytes();
  }
  return t.substring(0, maskLength);
}
var forge$9 = forge$s;
(function() {
  if (forge$9.prime) {
    return;
  }
  var prime = forge$9.prime = forge$9.prime || {};
  var BigInteger2 = forge$9.jsbn.BigInteger;
  var GCD_30_DELTA2 = [6, 4, 2, 4, 2, 4, 6, 2];
  var THIRTY = new BigInteger2(null);
  THIRTY.fromInt(30);
  var op_or2 = function(x, y) {
    return x | y;
  };
  prime.generateProbablePrime = function(bits2, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    options = options || {};
    var algorithm = options.algorithm || "PRIMEINC";
    if (typeof algorithm === "string") {
      algorithm = { name: algorithm };
    }
    algorithm.options = algorithm.options || {};
    var prng2 = options.prng || forge$9.random;
    var rng = {
      nextBytes: function(x) {
        var b2 = prng2.getBytesSync(x.length);
        for (var i2 = 0; i2 < x.length; ++i2) {
          x[i2] = b2.charCodeAt(i2);
        }
      }
    };
    if (algorithm.name === "PRIMEINC") {
      return primeincFindPrime(bits2, rng, algorithm.options, callback);
    }
    throw new Error("Invalid prime generation algorithm: " + algorithm.name);
  };
  function primeincFindPrime(bits2, rng, options, callback) {
    if ("workers" in options) {
      return primeincFindPrimeWithWorkers(bits2, rng, options, callback);
    }
    return primeincFindPrimeWithoutWorkers(bits2, rng, options, callback);
  }
  function primeincFindPrimeWithoutWorkers(bits2, rng, options, callback) {
    var num = generateRandom(bits2, rng);
    var deltaIdx = 0;
    var mrTests = getMillerRabinTests(num.bitLength());
    if ("millerRabinTests" in options) {
      mrTests = options.millerRabinTests;
    }
    var maxBlockTime = 10;
    if ("maxBlockTime" in options) {
      maxBlockTime = options.maxBlockTime;
    }
    _primeinc(num, bits2, rng, deltaIdx, mrTests, maxBlockTime, callback);
  }
  function _primeinc(num, bits2, rng, deltaIdx, mrTests, maxBlockTime, callback) {
    var start = +new Date();
    do {
      if (num.bitLength() > bits2) {
        num = generateRandom(bits2, rng);
      }
      if (num.isProbablePrime(mrTests)) {
        return callback(null, num);
      }
      num.dAddOffset(GCD_30_DELTA2[deltaIdx++ % 8], 0);
    } while (maxBlockTime < 0 || +new Date() - start < maxBlockTime);
    forge$9.util.setImmediate(function() {
      _primeinc(num, bits2, rng, deltaIdx, mrTests, maxBlockTime, callback);
    });
  }
  function primeincFindPrimeWithWorkers(bits2, rng, options, callback) {
    if (typeof Worker === "undefined") {
      return primeincFindPrimeWithoutWorkers(bits2, rng, options, callback);
    }
    var num = generateRandom(bits2, rng);
    var numWorkers = options.workers;
    var workLoad = options.workLoad || 100;
    var range = workLoad * 30 / 8;
    var workerScript = options.workerScript || "forge/prime.worker.js";
    if (numWorkers === -1) {
      return forge$9.util.estimateCores(function(err2, cores) {
        if (err2) {
          cores = 2;
        }
        numWorkers = cores - 1;
        generate();
      });
    }
    generate();
    function generate() {
      numWorkers = Math.max(1, numWorkers);
      var workers = [];
      for (var i2 = 0; i2 < numWorkers; ++i2) {
        workers[i2] = new Worker(workerScript);
      }
      for (var i2 = 0; i2 < numWorkers; ++i2) {
        workers[i2].addEventListener("message", workerMessage);
      }
      var found = false;
      function workerMessage(e) {
        if (found) {
          return;
        }
        var data = e.data;
        if (data.found) {
          for (var i3 = 0; i3 < workers.length; ++i3) {
            workers[i3].terminate();
          }
          found = true;
          return callback(null, new BigInteger2(data.prime, 16));
        }
        if (num.bitLength() > bits2) {
          num = generateRandom(bits2, rng);
        }
        var hex = num.toString(16);
        e.target.postMessage({
          hex,
          workLoad
        });
        num.dAddOffset(range, 0);
      }
    }
  }
  function generateRandom(bits2, rng) {
    var num = new BigInteger2(bits2, rng);
    var bits1 = bits2 - 1;
    if (!num.testBit(bits1)) {
      num.bitwiseTo(BigInteger2.ONE.shiftLeft(bits1), op_or2, num);
    }
    num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
    return num;
  }
  function getMillerRabinTests(bits2) {
    if (bits2 <= 100)
      return 27;
    if (bits2 <= 150)
      return 18;
    if (bits2 <= 200)
      return 15;
    if (bits2 <= 250)
      return 12;
    if (bits2 <= 300)
      return 9;
    if (bits2 <= 350)
      return 8;
    if (bits2 <= 400)
      return 7;
    if (bits2 <= 500)
      return 6;
    if (bits2 <= 600)
      return 5;
    if (bits2 <= 800)
      return 4;
    if (bits2 <= 1250)
      return 3;
    return 2;
  }
})();
var forge$8 = forge$s;
if (typeof BigInteger$1 === "undefined") {
  var BigInteger$1 = forge$8.jsbn.BigInteger;
}
var _crypto = forge$8.util.isNodejs ? require$$1 : null;
var asn1$4 = forge$8.asn1;
var util = forge$8.util;
forge$8.pki = forge$8.pki || {};
forge$8.pki.rsa = forge$8.rsa = forge$8.rsa || {};
var pki$3 = forge$8.pki;
var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
var privateKeyValidator = {
  name: "PrivateKeyInfo",
  tagClass: asn1$4.Class.UNIVERSAL,
  type: asn1$4.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "PrivateKeyInfo.version",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.INTEGER,
    constructed: false,
    capture: "privateKeyVersion"
  }, {
    name: "PrivateKeyInfo.privateKeyAlgorithm",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "AlgorithmIdentifier.algorithm",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Type.OID,
      constructed: false,
      capture: "privateKeyOid"
    }]
  }, {
    name: "PrivateKeyInfo",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.OCTETSTRING,
    constructed: false,
    capture: "privateKey"
  }]
};
var rsaPrivateKeyValidator = {
  name: "RSAPrivateKey",
  tagClass: asn1$4.Class.UNIVERSAL,
  type: asn1$4.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "RSAPrivateKey.version",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.INTEGER,
    constructed: false,
    capture: "privateKeyVersion"
  }, {
    name: "RSAPrivateKey.modulus",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.INTEGER,
    constructed: false,
    capture: "privateKeyModulus"
  }, {
    name: "RSAPrivateKey.publicExponent",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.INTEGER,
    constructed: false,
    capture: "privateKeyPublicExponent"
  }, {
    name: "RSAPrivateKey.privateExponent",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.INTEGER,
    constructed: false,
    capture: "privateKeyPrivateExponent"
  }, {
    name: "RSAPrivateKey.prime1",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.INTEGER,
    constructed: false,
    capture: "privateKeyPrime1"
  }, {
    name: "RSAPrivateKey.prime2",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.INTEGER,
    constructed: false,
    capture: "privateKeyPrime2"
  }, {
    name: "RSAPrivateKey.exponent1",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.INTEGER,
    constructed: false,
    capture: "privateKeyExponent1"
  }, {
    name: "RSAPrivateKey.exponent2",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.INTEGER,
    constructed: false,
    capture: "privateKeyExponent2"
  }, {
    name: "RSAPrivateKey.coefficient",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.INTEGER,
    constructed: false,
    capture: "privateKeyCoefficient"
  }]
};
var rsaPublicKeyValidator = {
  name: "RSAPublicKey",
  tagClass: asn1$4.Class.UNIVERSAL,
  type: asn1$4.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "RSAPublicKey.modulus",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.INTEGER,
    constructed: false,
    capture: "publicKeyModulus"
  }, {
    name: "RSAPublicKey.exponent",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.INTEGER,
    constructed: false,
    capture: "publicKeyExponent"
  }]
};
var publicKeyValidator$1 = forge$8.pki.rsa.publicKeyValidator = {
  name: "SubjectPublicKeyInfo",
  tagClass: asn1$4.Class.UNIVERSAL,
  type: asn1$4.Type.SEQUENCE,
  constructed: true,
  captureAsn1: "subjectPublicKeyInfo",
  value: [{
    name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "AlgorithmIdentifier.algorithm",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Type.OID,
      constructed: false,
      capture: "publicKeyOid"
    }]
  }, {
    name: "SubjectPublicKeyInfo.subjectPublicKey",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.BITSTRING,
    constructed: false,
    value: [{
      name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Type.SEQUENCE,
      constructed: true,
      optional: true,
      captureAsn1: "rsaPublicKey"
    }]
  }]
};
var digestInfoValidator = {
  name: "DigestInfo",
  tagClass: asn1$4.Class.UNIVERSAL,
  type: asn1$4.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "DigestInfo.DigestAlgorithm",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "DigestInfo.DigestAlgorithm.algorithmIdentifier",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Type.OID,
      constructed: false,
      capture: "algorithmIdentifier"
    }, {
      name: "DigestInfo.DigestAlgorithm.parameters",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Type.NULL,
      capture: "parameters",
      optional: true,
      constructed: false
    }]
  }, {
    name: "DigestInfo.digest",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.OCTETSTRING,
    constructed: false,
    capture: "digest"
  }]
};
var emsaPkcs1v15encode = function(md) {
  var oid;
  if (md.algorithm in pki$3.oids) {
    oid = pki$3.oids[md.algorithm];
  } else {
    var error2 = new Error("Unknown message digest algorithm.");
    error2.algorithm = md.algorithm;
    throw error2;
  }
  var oidBytes = asn1$4.oidToDer(oid).getBytes();
  var digestInfo = asn1$4.create(
    asn1$4.Class.UNIVERSAL,
    asn1$4.Type.SEQUENCE,
    true,
    []
  );
  var digestAlgorithm = asn1$4.create(
    asn1$4.Class.UNIVERSAL,
    asn1$4.Type.SEQUENCE,
    true,
    []
  );
  digestAlgorithm.value.push(asn1$4.create(
    asn1$4.Class.UNIVERSAL,
    asn1$4.Type.OID,
    false,
    oidBytes
  ));
  digestAlgorithm.value.push(asn1$4.create(
    asn1$4.Class.UNIVERSAL,
    asn1$4.Type.NULL,
    false,
    ""
  ));
  var digest2 = asn1$4.create(
    asn1$4.Class.UNIVERSAL,
    asn1$4.Type.OCTETSTRING,
    false,
    md.digest().getBytes()
  );
  digestInfo.value.push(digestAlgorithm);
  digestInfo.value.push(digest2);
  return asn1$4.toDer(digestInfo).getBytes();
};
var _modPow = function(x, key, pub) {
  if (pub) {
    return x.modPow(key.e, key.n);
  }
  if (!key.p || !key.q) {
    return x.modPow(key.d, key.n);
  }
  if (!key.dP) {
    key.dP = key.d.mod(key.p.subtract(BigInteger$1.ONE));
  }
  if (!key.dQ) {
    key.dQ = key.d.mod(key.q.subtract(BigInteger$1.ONE));
  }
  if (!key.qInv) {
    key.qInv = key.q.modInverse(key.p);
  }
  var r;
  do {
    r = new BigInteger$1(
      forge$8.util.bytesToHex(forge$8.random.getBytes(key.n.bitLength() / 8)),
      16
    );
  } while (r.compareTo(key.n) >= 0 || !r.gcd(key.n).equals(BigInteger$1.ONE));
  x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);
  var xp = x.mod(key.p).modPow(key.dP, key.p);
  var xq = x.mod(key.q).modPow(key.dQ, key.q);
  while (xp.compareTo(xq) < 0) {
    xp = xp.add(key.p);
  }
  var y = xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);
  y = y.multiply(r.modInverse(key.n)).mod(key.n);
  return y;
};
pki$3.rsa.encrypt = function(m, key, bt) {
  var pub = bt;
  var eb;
  var k = Math.ceil(key.n.bitLength() / 8);
  if (bt !== false && bt !== true) {
    pub = bt === 2;
    eb = _encodePkcs1_v1_5(m, key, bt);
  } else {
    eb = forge$8.util.createBuffer();
    eb.putBytes(m);
  }
  var x = new BigInteger$1(eb.toHex(), 16);
  var y = _modPow(x, key, pub);
  var yhex = y.toString(16);
  var ed = forge$8.util.createBuffer();
  var zeros = k - Math.ceil(yhex.length / 2);
  while (zeros > 0) {
    ed.putByte(0);
    --zeros;
  }
  ed.putBytes(forge$8.util.hexToBytes(yhex));
  return ed.getBytes();
};
pki$3.rsa.decrypt = function(ed, key, pub, ml) {
  var k = Math.ceil(key.n.bitLength() / 8);
  if (ed.length !== k) {
    var error2 = new Error("Encrypted message length is invalid.");
    error2.length = ed.length;
    error2.expected = k;
    throw error2;
  }
  var y = new BigInteger$1(forge$8.util.createBuffer(ed).toHex(), 16);
  if (y.compareTo(key.n) >= 0) {
    throw new Error("Encrypted message is invalid.");
  }
  var x = _modPow(y, key, pub);
  var xhex = x.toString(16);
  var eb = forge$8.util.createBuffer();
  var zeros = k - Math.ceil(xhex.length / 2);
  while (zeros > 0) {
    eb.putByte(0);
    --zeros;
  }
  eb.putBytes(forge$8.util.hexToBytes(xhex));
  if (ml !== false) {
    return _decodePkcs1_v1_5(eb.getBytes(), key, pub);
  }
  return eb.getBytes();
};
pki$3.rsa.createKeyPairGenerationState = function(bits2, e, options) {
  if (typeof bits2 === "string") {
    bits2 = parseInt(bits2, 10);
  }
  bits2 = bits2 || 2048;
  options = options || {};
  var prng2 = options.prng || forge$8.random;
  var rng = {
    nextBytes: function(x) {
      var b2 = prng2.getBytesSync(x.length);
      for (var i2 = 0; i2 < x.length; ++i2) {
        x[i2] = b2.charCodeAt(i2);
      }
    }
  };
  var algorithm = options.algorithm || "PRIMEINC";
  var rval;
  if (algorithm === "PRIMEINC") {
    rval = {
      algorithm,
      state: 0,
      bits: bits2,
      rng,
      eInt: e || 65537,
      e: new BigInteger$1(null),
      p: null,
      q: null,
      qBits: bits2 >> 1,
      pBits: bits2 - (bits2 >> 1),
      pqState: 0,
      num: null,
      keys: null
    };
    rval.e.fromInt(rval.eInt);
  } else {
    throw new Error("Invalid key generation algorithm: " + algorithm);
  }
  return rval;
};
pki$3.rsa.stepKeyPairGenerationState = function(state, n) {
  if (!("algorithm" in state)) {
    state.algorithm = "PRIMEINC";
  }
  var THIRTY = new BigInteger$1(null);
  THIRTY.fromInt(30);
  var deltaIdx = 0;
  var op_or2 = function(x, y) {
    return x | y;
  };
  var t1 = +new Date();
  var t2;
  var total = 0;
  while (state.keys === null && (n <= 0 || total < n)) {
    if (state.state === 0) {
      var bits2 = state.p === null ? state.pBits : state.qBits;
      var bits1 = bits2 - 1;
      if (state.pqState === 0) {
        state.num = new BigInteger$1(bits2, state.rng);
        if (!state.num.testBit(bits1)) {
          state.num.bitwiseTo(
            BigInteger$1.ONE.shiftLeft(bits1),
            op_or2,
            state.num
          );
        }
        state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
        deltaIdx = 0;
        ++state.pqState;
      } else if (state.pqState === 1) {
        if (state.num.bitLength() > bits2) {
          state.pqState = 0;
        } else if (state.num.isProbablePrime(
          _getMillerRabinTests(state.num.bitLength())
        )) {
          ++state.pqState;
        } else {
          state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
        }
      } else if (state.pqState === 2) {
        state.pqState = state.num.subtract(BigInteger$1.ONE).gcd(state.e).compareTo(BigInteger$1.ONE) === 0 ? 3 : 0;
      } else if (state.pqState === 3) {
        state.pqState = 0;
        if (state.p === null) {
          state.p = state.num;
        } else {
          state.q = state.num;
        }
        if (state.p !== null && state.q !== null) {
          ++state.state;
        }
        state.num = null;
      }
    } else if (state.state === 1) {
      if (state.p.compareTo(state.q) < 0) {
        state.num = state.p;
        state.p = state.q;
        state.q = state.num;
      }
      ++state.state;
    } else if (state.state === 2) {
      state.p1 = state.p.subtract(BigInteger$1.ONE);
      state.q1 = state.q.subtract(BigInteger$1.ONE);
      state.phi = state.p1.multiply(state.q1);
      ++state.state;
    } else if (state.state === 3) {
      if (state.phi.gcd(state.e).compareTo(BigInteger$1.ONE) === 0) {
        ++state.state;
      } else {
        state.p = null;
        state.q = null;
        state.state = 0;
      }
    } else if (state.state === 4) {
      state.n = state.p.multiply(state.q);
      if (state.n.bitLength() === state.bits) {
        ++state.state;
      } else {
        state.q = null;
        state.state = 0;
      }
    } else if (state.state === 5) {
      var d = state.e.modInverse(state.phi);
      state.keys = {
        privateKey: pki$3.rsa.setPrivateKey(
          state.n,
          state.e,
          d,
          state.p,
          state.q,
          d.mod(state.p1),
          d.mod(state.q1),
          state.q.modInverse(state.p)
        ),
        publicKey: pki$3.rsa.setPublicKey(state.n, state.e)
      };
    }
    t2 = +new Date();
    total += t2 - t1;
    t1 = t2;
  }
  return state.keys !== null;
};
pki$3.rsa.generateKeyPair = function(bits2, e, options, callback) {
  if (arguments.length === 1) {
    if (typeof bits2 === "object") {
      options = bits2;
      bits2 = void 0;
    } else if (typeof bits2 === "function") {
      callback = bits2;
      bits2 = void 0;
    }
  } else if (arguments.length === 2) {
    if (typeof bits2 === "number") {
      if (typeof e === "function") {
        callback = e;
        e = void 0;
      } else if (typeof e !== "number") {
        options = e;
        e = void 0;
      }
    } else {
      options = bits2;
      callback = e;
      bits2 = void 0;
      e = void 0;
    }
  } else if (arguments.length === 3) {
    if (typeof e === "number") {
      if (typeof options === "function") {
        callback = options;
        options = void 0;
      }
    } else {
      callback = options;
      options = e;
      e = void 0;
    }
  }
  options = options || {};
  if (bits2 === void 0) {
    bits2 = options.bits || 2048;
  }
  if (e === void 0) {
    e = options.e || 65537;
  }
  if (!options.prng && bits2 >= 256 && bits2 <= 16384 && (e === 65537 || e === 3)) {
    if (callback) {
      if (_detectNodeCrypto("generateKeyPair")) {
        return _crypto.generateKeyPair("rsa", {
          modulusLength: bits2,
          publicExponent: e,
          publicKeyEncoding: {
            type: "spki",
            format: "pem"
          },
          privateKeyEncoding: {
            type: "pkcs8",
            format: "pem"
          }
        }, function(err2, pub, priv) {
          if (err2) {
            return callback(err2);
          }
          callback(null, {
            privateKey: pki$3.privateKeyFromPem(priv),
            publicKey: pki$3.publicKeyFromPem(pub)
          });
        });
      }
      if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey")) {
        return util.globalScope.crypto.subtle.generateKey({
          name: "RSASSA-PKCS1-v1_5",
          modulusLength: bits2,
          publicExponent: _intToUint8Array(e),
          hash: { name: "SHA-256" }
        }, true, ["sign", "verify"]).then(function(pair2) {
          return util.globalScope.crypto.subtle.exportKey(
            "pkcs8",
            pair2.privateKey
          );
        }).then(void 0, function(err2) {
          callback(err2);
        }).then(function(pkcs8) {
          if (pkcs8) {
            var privateKey = pki$3.privateKeyFromAsn1(
              asn1$4.fromDer(forge$8.util.createBuffer(pkcs8))
            );
            callback(null, {
              privateKey,
              publicKey: pki$3.setRsaPublicKey(privateKey.n, privateKey.e)
            });
          }
        });
      }
      if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
        var genOp = util.globalScope.msCrypto.subtle.generateKey({
          name: "RSASSA-PKCS1-v1_5",
          modulusLength: bits2,
          publicExponent: _intToUint8Array(e),
          hash: { name: "SHA-256" }
        }, true, ["sign", "verify"]);
        genOp.oncomplete = function(e2) {
          var pair2 = e2.target.result;
          var exportOp = util.globalScope.msCrypto.subtle.exportKey(
            "pkcs8",
            pair2.privateKey
          );
          exportOp.oncomplete = function(e3) {
            var pkcs8 = e3.target.result;
            var privateKey = pki$3.privateKeyFromAsn1(
              asn1$4.fromDer(forge$8.util.createBuffer(pkcs8))
            );
            callback(null, {
              privateKey,
              publicKey: pki$3.setRsaPublicKey(privateKey.n, privateKey.e)
            });
          };
          exportOp.onerror = function(err2) {
            callback(err2);
          };
        };
        genOp.onerror = function(err2) {
          callback(err2);
        };
        return;
      }
    } else {
      if (_detectNodeCrypto("generateKeyPairSync")) {
        var keypair = _crypto.generateKeyPairSync("rsa", {
          modulusLength: bits2,
          publicExponent: e,
          publicKeyEncoding: {
            type: "spki",
            format: "pem"
          },
          privateKeyEncoding: {
            type: "pkcs8",
            format: "pem"
          }
        });
        return {
          privateKey: pki$3.privateKeyFromPem(keypair.privateKey),
          publicKey: pki$3.publicKeyFromPem(keypair.publicKey)
        };
      }
    }
  }
  var state = pki$3.rsa.createKeyPairGenerationState(bits2, e, options);
  if (!callback) {
    pki$3.rsa.stepKeyPairGenerationState(state, 0);
    return state.keys;
  }
  _generateKeyPair(state, options, callback);
};
pki$3.setRsaPublicKey = pki$3.rsa.setPublicKey = function(n, e) {
  var key = {
    n,
    e
  };
  key.encrypt = function(data, scheme, schemeOptions) {
    if (typeof scheme === "string") {
      scheme = scheme.toUpperCase();
    } else if (scheme === void 0) {
      scheme = "RSAES-PKCS1-V1_5";
    }
    if (scheme === "RSAES-PKCS1-V1_5") {
      scheme = {
        encode: function(m, key2, pub) {
          return _encodePkcs1_v1_5(m, key2, 2).getBytes();
        }
      };
    } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
      scheme = {
        encode: function(m, key2) {
          return forge$8.pkcs1.encode_rsa_oaep(key2, m, schemeOptions);
        }
      };
    } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
      scheme = { encode: function(e3) {
        return e3;
      } };
    } else if (typeof scheme === "string") {
      throw new Error('Unsupported encryption scheme: "' + scheme + '".');
    }
    var e2 = scheme.encode(data, key, true);
    return pki$3.rsa.encrypt(e2, key, true);
  };
  key.verify = function(digest2, signature, scheme, options) {
    if (typeof scheme === "string") {
      scheme = scheme.toUpperCase();
    } else if (scheme === void 0) {
      scheme = "RSASSA-PKCS1-V1_5";
    }
    if (options === void 0) {
      options = {
        _parseAllDigestBytes: true
      };
    }
    if (!("_parseAllDigestBytes" in options)) {
      options._parseAllDigestBytes = true;
    }
    if (scheme === "RSASSA-PKCS1-V1_5") {
      scheme = {
        verify: function(digest3, d2) {
          d2 = _decodePkcs1_v1_5(d2, key, true);
          var obj = asn1$4.fromDer(d2, {
            parseAllBytes: options._parseAllDigestBytes
          });
          var capture = {};
          var errors2 = [];
          if (!asn1$4.validate(obj, digestInfoValidator, capture, errors2)) {
            var error2 = new Error(
              "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value."
            );
            error2.errors = errors2;
            throw error2;
          }
          var oid = asn1$4.derToOid(capture.algorithmIdentifier);
          if (!(oid === forge$8.oids.md2 || oid === forge$8.oids.md5 || oid === forge$8.oids.sha1 || oid === forge$8.oids.sha224 || oid === forge$8.oids.sha256 || oid === forge$8.oids.sha384 || oid === forge$8.oids.sha512 || oid === forge$8.oids["sha512-224"] || oid === forge$8.oids["sha512-256"])) {
            var error2 = new Error(
              "Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier."
            );
            error2.oid = oid;
            throw error2;
          }
          if (oid === forge$8.oids.md2 || oid === forge$8.oids.md5) {
            if (!("parameters" in capture)) {
              throw new Error(
                "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifer NULL parameters."
              );
            }
          }
          return digest3 === capture.digest;
        }
      };
    } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
      scheme = {
        verify: function(digest3, d2) {
          d2 = _decodePkcs1_v1_5(d2, key, true);
          return digest3 === d2;
        }
      };
    }
    var d = pki$3.rsa.decrypt(signature, key, true, false);
    return scheme.verify(digest2, d, key.n.bitLength());
  };
  return key;
};
pki$3.setRsaPrivateKey = pki$3.rsa.setPrivateKey = function(n, e, d, p, q, dP, dQ, qInv) {
  var key = {
    n,
    e,
    d,
    p,
    q,
    dP,
    dQ,
    qInv
  };
  key.decrypt = function(data, scheme, schemeOptions) {
    if (typeof scheme === "string") {
      scheme = scheme.toUpperCase();
    } else if (scheme === void 0) {
      scheme = "RSAES-PKCS1-V1_5";
    }
    var d2 = pki$3.rsa.decrypt(data, key, false, false);
    if (scheme === "RSAES-PKCS1-V1_5") {
      scheme = { decode: _decodePkcs1_v1_5 };
    } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
      scheme = {
        decode: function(d3, key2) {
          return forge$8.pkcs1.decode_rsa_oaep(key2, d3, schemeOptions);
        }
      };
    } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
      scheme = { decode: function(d3) {
        return d3;
      } };
    } else {
      throw new Error('Unsupported encryption scheme: "' + scheme + '".');
    }
    return scheme.decode(d2, key, false);
  };
  key.sign = function(md, scheme) {
    var bt = false;
    if (typeof scheme === "string") {
      scheme = scheme.toUpperCase();
    }
    if (scheme === void 0 || scheme === "RSASSA-PKCS1-V1_5") {
      scheme = { encode: emsaPkcs1v15encode };
      bt = 1;
    } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
      scheme = { encode: function() {
        return md;
      } };
      bt = 1;
    }
    var d2 = scheme.encode(md, key.n.bitLength());
    return pki$3.rsa.encrypt(d2, key, bt);
  };
  return key;
};
pki$3.wrapRsaPrivateKey = function(rsaKey) {
  return asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
    asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.INTEGER,
      false,
      asn1$4.integerToDer(0).getBytes()
    ),
    asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
      asn1$4.create(
        asn1$4.Class.UNIVERSAL,
        asn1$4.Type.OID,
        false,
        asn1$4.oidToDer(pki$3.oids.rsaEncryption).getBytes()
      ),
      asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.NULL, false, "")
    ]),
    asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.OCTETSTRING,
      false,
      asn1$4.toDer(rsaKey).getBytes()
    )
  ]);
};
pki$3.privateKeyFromAsn1 = function(obj) {
  var capture = {};
  var errors2 = [];
  if (asn1$4.validate(obj, privateKeyValidator, capture, errors2)) {
    obj = asn1$4.fromDer(forge$8.util.createBuffer(capture.privateKey));
  }
  capture = {};
  errors2 = [];
  if (!asn1$4.validate(obj, rsaPrivateKeyValidator, capture, errors2)) {
    var error2 = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
    error2.errors = errors2;
    throw error2;
  }
  var n, e, d, p, q, dP, dQ, qInv;
  n = forge$8.util.createBuffer(capture.privateKeyModulus).toHex();
  e = forge$8.util.createBuffer(capture.privateKeyPublicExponent).toHex();
  d = forge$8.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
  p = forge$8.util.createBuffer(capture.privateKeyPrime1).toHex();
  q = forge$8.util.createBuffer(capture.privateKeyPrime2).toHex();
  dP = forge$8.util.createBuffer(capture.privateKeyExponent1).toHex();
  dQ = forge$8.util.createBuffer(capture.privateKeyExponent2).toHex();
  qInv = forge$8.util.createBuffer(capture.privateKeyCoefficient).toHex();
  return pki$3.setRsaPrivateKey(
    new BigInteger$1(n, 16),
    new BigInteger$1(e, 16),
    new BigInteger$1(d, 16),
    new BigInteger$1(p, 16),
    new BigInteger$1(q, 16),
    new BigInteger$1(dP, 16),
    new BigInteger$1(dQ, 16),
    new BigInteger$1(qInv, 16)
  );
};
pki$3.privateKeyToAsn1 = pki$3.privateKeyToRSAPrivateKey = function(key) {
  return asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
    asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.INTEGER,
      false,
      asn1$4.integerToDer(0).getBytes()
    ),
    asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.INTEGER,
      false,
      _bnToBytes(key.n)
    ),
    asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.INTEGER,
      false,
      _bnToBytes(key.e)
    ),
    asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.INTEGER,
      false,
      _bnToBytes(key.d)
    ),
    asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.INTEGER,
      false,
      _bnToBytes(key.p)
    ),
    asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.INTEGER,
      false,
      _bnToBytes(key.q)
    ),
    asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.INTEGER,
      false,
      _bnToBytes(key.dP)
    ),
    asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.INTEGER,
      false,
      _bnToBytes(key.dQ)
    ),
    asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.INTEGER,
      false,
      _bnToBytes(key.qInv)
    )
  ]);
};
pki$3.publicKeyFromAsn1 = function(obj) {
  var capture = {};
  var errors2 = [];
  if (asn1$4.validate(obj, publicKeyValidator$1, capture, errors2)) {
    var oid = asn1$4.derToOid(capture.publicKeyOid);
    if (oid !== pki$3.oids.rsaEncryption) {
      var error2 = new Error("Cannot read public key. Unknown OID.");
      error2.oid = oid;
      throw error2;
    }
    obj = capture.rsaPublicKey;
  }
  errors2 = [];
  if (!asn1$4.validate(obj, rsaPublicKeyValidator, capture, errors2)) {
    var error2 = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
    error2.errors = errors2;
    throw error2;
  }
  var n = forge$8.util.createBuffer(capture.publicKeyModulus).toHex();
  var e = forge$8.util.createBuffer(capture.publicKeyExponent).toHex();
  return pki$3.setRsaPublicKey(
    new BigInteger$1(n, 16),
    new BigInteger$1(e, 16)
  );
};
pki$3.publicKeyToAsn1 = pki$3.publicKeyToSubjectPublicKeyInfo = function(key) {
  return asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
    asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
      asn1$4.create(
        asn1$4.Class.UNIVERSAL,
        asn1$4.Type.OID,
        false,
        asn1$4.oidToDer(pki$3.oids.rsaEncryption).getBytes()
      ),
      asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.NULL, false, "")
    ]),
    asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.BITSTRING, false, [
      pki$3.publicKeyToRSAPublicKey(key)
    ])
  ]);
};
pki$3.publicKeyToRSAPublicKey = function(key) {
  return asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
    asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.INTEGER,
      false,
      _bnToBytes(key.n)
    ),
    asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.INTEGER,
      false,
      _bnToBytes(key.e)
    )
  ]);
};
function _encodePkcs1_v1_5(m, key, bt) {
  var eb = forge$8.util.createBuffer();
  var k = Math.ceil(key.n.bitLength() / 8);
  if (m.length > k - 11) {
    var error2 = new Error("Message is too long for PKCS#1 v1.5 padding.");
    error2.length = m.length;
    error2.max = k - 11;
    throw error2;
  }
  eb.putByte(0);
  eb.putByte(bt);
  var padNum = k - 3 - m.length;
  var padByte;
  if (bt === 0 || bt === 1) {
    padByte = bt === 0 ? 0 : 255;
    for (var i2 = 0; i2 < padNum; ++i2) {
      eb.putByte(padByte);
    }
  } else {
    while (padNum > 0) {
      var numZeros = 0;
      var padBytes = forge$8.random.getBytes(padNum);
      for (var i2 = 0; i2 < padNum; ++i2) {
        padByte = padBytes.charCodeAt(i2);
        if (padByte === 0) {
          ++numZeros;
        } else {
          eb.putByte(padByte);
        }
      }
      padNum = numZeros;
    }
  }
  eb.putByte(0);
  eb.putBytes(m);
  return eb;
}
function _decodePkcs1_v1_5(em, key, pub, ml) {
  var k = Math.ceil(key.n.bitLength() / 8);
  var eb = forge$8.util.createBuffer(em);
  var first2 = eb.getByte();
  var bt = eb.getByte();
  if (first2 !== 0 || pub && bt !== 0 && bt !== 1 || !pub && bt != 2 || pub && bt === 0 && typeof ml === "undefined") {
    throw new Error("Encryption block is invalid.");
  }
  var padNum = 0;
  if (bt === 0) {
    padNum = k - 3 - ml;
    for (var i2 = 0; i2 < padNum; ++i2) {
      if (eb.getByte() !== 0) {
        throw new Error("Encryption block is invalid.");
      }
    }
  } else if (bt === 1) {
    padNum = 0;
    while (eb.length() > 1) {
      if (eb.getByte() !== 255) {
        --eb.read;
        break;
      }
      ++padNum;
    }
  } else if (bt === 2) {
    padNum = 0;
    while (eb.length() > 1) {
      if (eb.getByte() === 0) {
        --eb.read;
        break;
      }
      ++padNum;
    }
  }
  var zero2 = eb.getByte();
  if (zero2 !== 0 || padNum !== k - 3 - eb.length()) {
    throw new Error("Encryption block is invalid.");
  }
  return eb.getBytes();
}
function _generateKeyPair(state, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = {};
  }
  options = options || {};
  var opts = {
    algorithm: {
      name: options.algorithm || "PRIMEINC",
      options: {
        workers: options.workers || 2,
        workLoad: options.workLoad || 100,
        workerScript: options.workerScript
      }
    }
  };
  if ("prng" in options) {
    opts.prng = options.prng;
  }
  generate();
  function generate() {
    getPrime(state.pBits, function(err2, num) {
      if (err2) {
        return callback(err2);
      }
      state.p = num;
      if (state.q !== null) {
        return finish2(err2, state.q);
      }
      getPrime(state.qBits, finish2);
    });
  }
  function getPrime(bits2, callback2) {
    forge$8.prime.generateProbablePrime(bits2, opts, callback2);
  }
  function finish2(err2, num) {
    if (err2) {
      return callback(err2);
    }
    state.q = num;
    if (state.p.compareTo(state.q) < 0) {
      var tmp = state.p;
      state.p = state.q;
      state.q = tmp;
    }
    if (state.p.subtract(BigInteger$1.ONE).gcd(state.e).compareTo(BigInteger$1.ONE) !== 0) {
      state.p = null;
      generate();
      return;
    }
    if (state.q.subtract(BigInteger$1.ONE).gcd(state.e).compareTo(BigInteger$1.ONE) !== 0) {
      state.q = null;
      getPrime(state.qBits, finish2);
      return;
    }
    state.p1 = state.p.subtract(BigInteger$1.ONE);
    state.q1 = state.q.subtract(BigInteger$1.ONE);
    state.phi = state.p1.multiply(state.q1);
    if (state.phi.gcd(state.e).compareTo(BigInteger$1.ONE) !== 0) {
      state.p = state.q = null;
      generate();
      return;
    }
    state.n = state.p.multiply(state.q);
    if (state.n.bitLength() !== state.bits) {
      state.q = null;
      getPrime(state.qBits, finish2);
      return;
    }
    var d = state.e.modInverse(state.phi);
    state.keys = {
      privateKey: pki$3.rsa.setPrivateKey(
        state.n,
        state.e,
        d,
        state.p,
        state.q,
        d.mod(state.p1),
        d.mod(state.q1),
        state.q.modInverse(state.p)
      ),
      publicKey: pki$3.rsa.setPublicKey(state.n, state.e)
    };
    callback(null, state.keys);
  }
}
function _bnToBytes(b2) {
  var hex = b2.toString(16);
  if (hex[0] >= "8") {
    hex = "00" + hex;
  }
  var bytes2 = forge$8.util.hexToBytes(hex);
  if (bytes2.length > 1 && (bytes2.charCodeAt(0) === 0 && (bytes2.charCodeAt(1) & 128) === 0 || bytes2.charCodeAt(0) === 255 && (bytes2.charCodeAt(1) & 128) === 128)) {
    return bytes2.substr(1);
  }
  return bytes2;
}
function _getMillerRabinTests(bits2) {
  if (bits2 <= 100)
    return 27;
  if (bits2 <= 150)
    return 18;
  if (bits2 <= 200)
    return 15;
  if (bits2 <= 250)
    return 12;
  if (bits2 <= 300)
    return 9;
  if (bits2 <= 350)
    return 8;
  if (bits2 <= 400)
    return 7;
  if (bits2 <= 500)
    return 6;
  if (bits2 <= 600)
    return 5;
  if (bits2 <= 800)
    return 4;
  if (bits2 <= 1250)
    return 3;
  return 2;
}
function _detectNodeCrypto(fn) {
  return forge$8.util.isNodejs && typeof _crypto[fn] === "function";
}
function _detectSubtleCrypto(fn) {
  return typeof util.globalScope !== "undefined" && typeof util.globalScope.crypto === "object" && typeof util.globalScope.crypto.subtle === "object" && typeof util.globalScope.crypto.subtle[fn] === "function";
}
function _detectSubtleMsCrypto(fn) {
  return typeof util.globalScope !== "undefined" && typeof util.globalScope.msCrypto === "object" && typeof util.globalScope.msCrypto.subtle === "object" && typeof util.globalScope.msCrypto.subtle[fn] === "function";
}
function _intToUint8Array(x) {
  var bytes2 = forge$8.util.hexToBytes(x.toString(16));
  var buffer2 = new Uint8Array(bytes2.length);
  for (var i2 = 0; i2 < bytes2.length; ++i2) {
    buffer2[i2] = bytes2.charCodeAt(i2);
  }
  return buffer2;
}
var forge$7 = forge$s;
if (typeof BigInteger === "undefined") {
  var BigInteger = forge$7.jsbn.BigInteger;
}
var asn1$3 = forge$7.asn1;
var pki$2 = forge$7.pki = forge$7.pki || {};
pki$2.pbe = forge$7.pbe = forge$7.pbe || {};
var oids$1 = pki$2.oids;
var encryptedPrivateKeyValidator = {
  name: "EncryptedPrivateKeyInfo",
  tagClass: asn1$3.Class.UNIVERSAL,
  type: asn1$3.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
    tagClass: asn1$3.Class.UNIVERSAL,
    type: asn1$3.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "AlgorithmIdentifier.algorithm",
      tagClass: asn1$3.Class.UNIVERSAL,
      type: asn1$3.Type.OID,
      constructed: false,
      capture: "encryptionOid"
    }, {
      name: "AlgorithmIdentifier.parameters",
      tagClass: asn1$3.Class.UNIVERSAL,
      type: asn1$3.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "encryptionParams"
    }]
  }, {
    name: "EncryptedPrivateKeyInfo.encryptedData",
    tagClass: asn1$3.Class.UNIVERSAL,
    type: asn1$3.Type.OCTETSTRING,
    constructed: false,
    capture: "encryptedData"
  }]
};
var PBES2AlgorithmsValidator = {
  name: "PBES2Algorithms",
  tagClass: asn1$3.Class.UNIVERSAL,
  type: asn1$3.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "PBES2Algorithms.keyDerivationFunc",
    tagClass: asn1$3.Class.UNIVERSAL,
    type: asn1$3.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "PBES2Algorithms.keyDerivationFunc.oid",
      tagClass: asn1$3.Class.UNIVERSAL,
      type: asn1$3.Type.OID,
      constructed: false,
      capture: "kdfOid"
    }, {
      name: "PBES2Algorithms.params",
      tagClass: asn1$3.Class.UNIVERSAL,
      type: asn1$3.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "PBES2Algorithms.params.salt",
        tagClass: asn1$3.Class.UNIVERSAL,
        type: asn1$3.Type.OCTETSTRING,
        constructed: false,
        capture: "kdfSalt"
      }, {
        name: "PBES2Algorithms.params.iterationCount",
        tagClass: asn1$3.Class.UNIVERSAL,
        type: asn1$3.Type.INTEGER,
        constructed: false,
        capture: "kdfIterationCount"
      }, {
        name: "PBES2Algorithms.params.keyLength",
        tagClass: asn1$3.Class.UNIVERSAL,
        type: asn1$3.Type.INTEGER,
        constructed: false,
        optional: true,
        capture: "keyLength"
      }, {
        name: "PBES2Algorithms.params.prf",
        tagClass: asn1$3.Class.UNIVERSAL,
        type: asn1$3.Type.SEQUENCE,
        constructed: true,
        optional: true,
        value: [{
          name: "PBES2Algorithms.params.prf.algorithm",
          tagClass: asn1$3.Class.UNIVERSAL,
          type: asn1$3.Type.OID,
          constructed: false,
          capture: "prfOid"
        }]
      }]
    }]
  }, {
    name: "PBES2Algorithms.encryptionScheme",
    tagClass: asn1$3.Class.UNIVERSAL,
    type: asn1$3.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "PBES2Algorithms.encryptionScheme.oid",
      tagClass: asn1$3.Class.UNIVERSAL,
      type: asn1$3.Type.OID,
      constructed: false,
      capture: "encOid"
    }, {
      name: "PBES2Algorithms.encryptionScheme.iv",
      tagClass: asn1$3.Class.UNIVERSAL,
      type: asn1$3.Type.OCTETSTRING,
      constructed: false,
      capture: "encIv"
    }]
  }]
};
var pkcs12PbeParamsValidator = {
  name: "pkcs-12PbeParams",
  tagClass: asn1$3.Class.UNIVERSAL,
  type: asn1$3.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "pkcs-12PbeParams.salt",
    tagClass: asn1$3.Class.UNIVERSAL,
    type: asn1$3.Type.OCTETSTRING,
    constructed: false,
    capture: "salt"
  }, {
    name: "pkcs-12PbeParams.iterations",
    tagClass: asn1$3.Class.UNIVERSAL,
    type: asn1$3.Type.INTEGER,
    constructed: false,
    capture: "iterations"
  }]
};
pki$2.encryptPrivateKeyInfo = function(obj, password, options) {
  options = options || {};
  options.saltSize = options.saltSize || 8;
  options.count = options.count || 2048;
  options.algorithm = options.algorithm || "aes128";
  options.prfAlgorithm = options.prfAlgorithm || "sha1";
  var salt = forge$7.random.getBytesSync(options.saltSize);
  var count = options.count;
  var countBytes = asn1$3.integerToDer(count);
  var dkLen;
  var encryptionAlgorithm;
  var encryptedData;
  if (options.algorithm.indexOf("aes") === 0 || options.algorithm === "des") {
    var ivLen, encOid, cipherFn;
    switch (options.algorithm) {
      case "aes128":
        dkLen = 16;
        ivLen = 16;
        encOid = oids$1["aes128-CBC"];
        cipherFn = forge$7.aes.createEncryptionCipher;
        break;
      case "aes192":
        dkLen = 24;
        ivLen = 16;
        encOid = oids$1["aes192-CBC"];
        cipherFn = forge$7.aes.createEncryptionCipher;
        break;
      case "aes256":
        dkLen = 32;
        ivLen = 16;
        encOid = oids$1["aes256-CBC"];
        cipherFn = forge$7.aes.createEncryptionCipher;
        break;
      case "des":
        dkLen = 8;
        ivLen = 8;
        encOid = oids$1["desCBC"];
        cipherFn = forge$7.des.createEncryptionCipher;
        break;
      default:
        var error2 = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
        error2.algorithm = options.algorithm;
        throw error2;
    }
    var prfAlgorithm = "hmacWith" + options.prfAlgorithm.toUpperCase();
    var md = prfAlgorithmToMessageDigest(prfAlgorithm);
    var dk = forge$7.pkcs5.pbkdf2(password, salt, count, dkLen, md);
    var iv = forge$7.random.getBytesSync(ivLen);
    var cipher = cipherFn(dk);
    cipher.start(iv);
    cipher.update(asn1$3.toDer(obj));
    cipher.finish();
    encryptedData = cipher.output.getBytes();
    var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);
    encryptionAlgorithm = asn1$3.create(
      asn1$3.Class.UNIVERSAL,
      asn1$3.Type.SEQUENCE,
      true,
      [
        asn1$3.create(
          asn1$3.Class.UNIVERSAL,
          asn1$3.Type.OID,
          false,
          asn1$3.oidToDer(oids$1["pkcs5PBES2"]).getBytes()
        ),
        asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
          asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
            asn1$3.create(
              asn1$3.Class.UNIVERSAL,
              asn1$3.Type.OID,
              false,
              asn1$3.oidToDer(oids$1["pkcs5PBKDF2"]).getBytes()
            ),
            params
          ]),
          asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
            asn1$3.create(
              asn1$3.Class.UNIVERSAL,
              asn1$3.Type.OID,
              false,
              asn1$3.oidToDer(encOid).getBytes()
            ),
            asn1$3.create(
              asn1$3.Class.UNIVERSAL,
              asn1$3.Type.OCTETSTRING,
              false,
              iv
            )
          ])
        ])
      ]
    );
  } else if (options.algorithm === "3des") {
    dkLen = 24;
    var saltBytes = new forge$7.util.ByteBuffer(salt);
    var dk = pki$2.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
    var iv = pki$2.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
    var cipher = forge$7.des.createEncryptionCipher(dk);
    cipher.start(iv);
    cipher.update(asn1$3.toDer(obj));
    cipher.finish();
    encryptedData = cipher.output.getBytes();
    encryptionAlgorithm = asn1$3.create(
      asn1$3.Class.UNIVERSAL,
      asn1$3.Type.SEQUENCE,
      true,
      [
        asn1$3.create(
          asn1$3.Class.UNIVERSAL,
          asn1$3.Type.OID,
          false,
          asn1$3.oidToDer(oids$1["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()
        ),
        asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
          asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.OCTETSTRING, false, salt),
          asn1$3.create(
            asn1$3.Class.UNIVERSAL,
            asn1$3.Type.INTEGER,
            false,
            countBytes.getBytes()
          )
        ])
      ]
    );
  } else {
    var error2 = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
    error2.algorithm = options.algorithm;
    throw error2;
  }
  var rval = asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
    encryptionAlgorithm,
    asn1$3.create(
      asn1$3.Class.UNIVERSAL,
      asn1$3.Type.OCTETSTRING,
      false,
      encryptedData
    )
  ]);
  return rval;
};
pki$2.decryptPrivateKeyInfo = function(obj, password) {
  var rval = null;
  var capture = {};
  var errors2 = [];
  if (!asn1$3.validate(obj, encryptedPrivateKeyValidator, capture, errors2)) {
    var error2 = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
    error2.errors = errors2;
    throw error2;
  }
  var oid = asn1$3.derToOid(capture.encryptionOid);
  var cipher = pki$2.pbe.getCipher(oid, capture.encryptionParams, password);
  var encrypted = forge$7.util.createBuffer(capture.encryptedData);
  cipher.update(encrypted);
  if (cipher.finish()) {
    rval = asn1$3.fromDer(cipher.output);
  }
  return rval;
};
pki$2.encryptedPrivateKeyToPem = function(epki, maxline) {
  var msg = {
    type: "ENCRYPTED PRIVATE KEY",
    body: asn1$3.toDer(epki).getBytes()
  };
  return forge$7.pem.encode(msg, { maxline });
};
pki$2.encryptedPrivateKeyFromPem = function(pem2) {
  var msg = forge$7.pem.decode(pem2)[0];
  if (msg.type !== "ENCRYPTED PRIVATE KEY") {
    var error2 = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
    error2.headerType = msg.type;
    throw error2;
  }
  if (msg.procType && msg.procType.type === "ENCRYPTED") {
    throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
  }
  return asn1$3.fromDer(msg.body);
};
pki$2.encryptRsaPrivateKey = function(rsaKey, password, options) {
  options = options || {};
  if (!options.legacy) {
    var rval = pki$2.wrapRsaPrivateKey(pki$2.privateKeyToAsn1(rsaKey));
    rval = pki$2.encryptPrivateKeyInfo(rval, password, options);
    return pki$2.encryptedPrivateKeyToPem(rval);
  }
  var algorithm;
  var iv;
  var dkLen;
  var cipherFn;
  switch (options.algorithm) {
    case "aes128":
      algorithm = "AES-128-CBC";
      dkLen = 16;
      iv = forge$7.random.getBytesSync(16);
      cipherFn = forge$7.aes.createEncryptionCipher;
      break;
    case "aes192":
      algorithm = "AES-192-CBC";
      dkLen = 24;
      iv = forge$7.random.getBytesSync(16);
      cipherFn = forge$7.aes.createEncryptionCipher;
      break;
    case "aes256":
      algorithm = "AES-256-CBC";
      dkLen = 32;
      iv = forge$7.random.getBytesSync(16);
      cipherFn = forge$7.aes.createEncryptionCipher;
      break;
    case "3des":
      algorithm = "DES-EDE3-CBC";
      dkLen = 24;
      iv = forge$7.random.getBytesSync(8);
      cipherFn = forge$7.des.createEncryptionCipher;
      break;
    case "des":
      algorithm = "DES-CBC";
      dkLen = 8;
      iv = forge$7.random.getBytesSync(8);
      cipherFn = forge$7.des.createEncryptionCipher;
      break;
    default:
      var error2 = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + options.algorithm + '".');
      error2.algorithm = options.algorithm;
      throw error2;
  }
  var dk = forge$7.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
  var cipher = cipherFn(dk);
  cipher.start(iv);
  cipher.update(asn1$3.toDer(pki$2.privateKeyToAsn1(rsaKey)));
  cipher.finish();
  var msg = {
    type: "RSA PRIVATE KEY",
    procType: {
      version: "4",
      type: "ENCRYPTED"
    },
    dekInfo: {
      algorithm,
      parameters: forge$7.util.bytesToHex(iv).toUpperCase()
    },
    body: cipher.output.getBytes()
  };
  return forge$7.pem.encode(msg);
};
pki$2.decryptRsaPrivateKey = function(pem2, password) {
  var rval = null;
  var msg = forge$7.pem.decode(pem2)[0];
  if (msg.type !== "ENCRYPTED PRIVATE KEY" && msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
    var error2 = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
    error2.headerType = error2;
    throw error2;
  }
  if (msg.procType && msg.procType.type === "ENCRYPTED") {
    var dkLen;
    var cipherFn;
    switch (msg.dekInfo.algorithm) {
      case "DES-CBC":
        dkLen = 8;
        cipherFn = forge$7.des.createDecryptionCipher;
        break;
      case "DES-EDE3-CBC":
        dkLen = 24;
        cipherFn = forge$7.des.createDecryptionCipher;
        break;
      case "AES-128-CBC":
        dkLen = 16;
        cipherFn = forge$7.aes.createDecryptionCipher;
        break;
      case "AES-192-CBC":
        dkLen = 24;
        cipherFn = forge$7.aes.createDecryptionCipher;
        break;
      case "AES-256-CBC":
        dkLen = 32;
        cipherFn = forge$7.aes.createDecryptionCipher;
        break;
      case "RC2-40-CBC":
        dkLen = 5;
        cipherFn = function(key) {
          return forge$7.rc2.createDecryptionCipher(key, 40);
        };
        break;
      case "RC2-64-CBC":
        dkLen = 8;
        cipherFn = function(key) {
          return forge$7.rc2.createDecryptionCipher(key, 64);
        };
        break;
      case "RC2-128-CBC":
        dkLen = 16;
        cipherFn = function(key) {
          return forge$7.rc2.createDecryptionCipher(key, 128);
        };
        break;
      default:
        var error2 = new Error('Could not decrypt private key; unsupported encryption algorithm "' + msg.dekInfo.algorithm + '".');
        error2.algorithm = msg.dekInfo.algorithm;
        throw error2;
    }
    var iv = forge$7.util.hexToBytes(msg.dekInfo.parameters);
    var dk = forge$7.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
    var cipher = cipherFn(dk);
    cipher.start(iv);
    cipher.update(forge$7.util.createBuffer(msg.body));
    if (cipher.finish()) {
      rval = cipher.output.getBytes();
    } else {
      return rval;
    }
  } else {
    rval = msg.body;
  }
  if (msg.type === "ENCRYPTED PRIVATE KEY") {
    rval = pki$2.decryptPrivateKeyInfo(asn1$3.fromDer(rval), password);
  } else {
    rval = asn1$3.fromDer(rval);
  }
  if (rval !== null) {
    rval = pki$2.privateKeyFromAsn1(rval);
  }
  return rval;
};
pki$2.pbe.generatePkcs12Key = function(password, salt, id, iter, n, md) {
  var j, l;
  if (typeof md === "undefined" || md === null) {
    if (!("sha1" in forge$7.md)) {
      throw new Error('"sha1" hash algorithm unavailable.');
    }
    md = forge$7.md.sha1.create();
  }
  var u = md.digestLength;
  var v = md.blockLength;
  var result = new forge$7.util.ByteBuffer();
  var passBuf = new forge$7.util.ByteBuffer();
  if (password !== null && password !== void 0) {
    for (l = 0; l < password.length; l++) {
      passBuf.putInt16(password.charCodeAt(l));
    }
    passBuf.putInt16(0);
  }
  var p = passBuf.length();
  var s2 = salt.length();
  var D = new forge$7.util.ByteBuffer();
  D.fillWithByte(id, v);
  var Slen = v * Math.ceil(s2 / v);
  var S = new forge$7.util.ByteBuffer();
  for (l = 0; l < Slen; l++) {
    S.putByte(salt.at(l % s2));
  }
  var Plen = v * Math.ceil(p / v);
  var P = new forge$7.util.ByteBuffer();
  for (l = 0; l < Plen; l++) {
    P.putByte(passBuf.at(l % p));
  }
  var I = S;
  I.putBuffer(P);
  var c = Math.ceil(n / u);
  for (var i2 = 1; i2 <= c; i2++) {
    var buf2 = new forge$7.util.ByteBuffer();
    buf2.putBytes(D.bytes());
    buf2.putBytes(I.bytes());
    for (var round = 0; round < iter; round++) {
      md.start();
      md.update(buf2.getBytes());
      buf2 = md.digest();
    }
    var B = new forge$7.util.ByteBuffer();
    for (l = 0; l < v; l++) {
      B.putByte(buf2.at(l % u));
    }
    var k = Math.ceil(s2 / v) + Math.ceil(p / v);
    var Inew = new forge$7.util.ByteBuffer();
    for (j = 0; j < k; j++) {
      var chunk = new forge$7.util.ByteBuffer(I.getBytes(v));
      var x = 511;
      for (l = B.length() - 1; l >= 0; l--) {
        x = x >> 8;
        x += B.at(l) + chunk.at(l);
        chunk.setAt(l, x & 255);
      }
      Inew.putBuffer(chunk);
    }
    I = Inew;
    result.putBuffer(buf2);
  }
  result.truncate(result.length() - n);
  return result;
};
pki$2.pbe.getCipher = function(oid, params, password) {
  switch (oid) {
    case pki$2.oids["pkcs5PBES2"]:
      return pki$2.pbe.getCipherForPBES2(oid, params, password);
    case pki$2.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
    case pki$2.oids["pbewithSHAAnd40BitRC2-CBC"]:
      return pki$2.pbe.getCipherForPKCS12PBE(oid, params, password);
    default:
      var error2 = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
      error2.oid = oid;
      error2.supportedOids = [
        "pkcs5PBES2",
        "pbeWithSHAAnd3-KeyTripleDES-CBC",
        "pbewithSHAAnd40BitRC2-CBC"
      ];
      throw error2;
  }
};
pki$2.pbe.getCipherForPBES2 = function(oid, params, password) {
  var capture = {};
  var errors2 = [];
  if (!asn1$3.validate(params, PBES2AlgorithmsValidator, capture, errors2)) {
    var error2 = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
    error2.errors = errors2;
    throw error2;
  }
  oid = asn1$3.derToOid(capture.kdfOid);
  if (oid !== pki$2.oids["pkcs5PBKDF2"]) {
    var error2 = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
    error2.oid = oid;
    error2.supportedOids = ["pkcs5PBKDF2"];
    throw error2;
  }
  oid = asn1$3.derToOid(capture.encOid);
  if (oid !== pki$2.oids["aes128-CBC"] && oid !== pki$2.oids["aes192-CBC"] && oid !== pki$2.oids["aes256-CBC"] && oid !== pki$2.oids["des-EDE3-CBC"] && oid !== pki$2.oids["desCBC"]) {
    var error2 = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
    error2.oid = oid;
    error2.supportedOids = [
      "aes128-CBC",
      "aes192-CBC",
      "aes256-CBC",
      "des-EDE3-CBC",
      "desCBC"
    ];
    throw error2;
  }
  var salt = capture.kdfSalt;
  var count = forge$7.util.createBuffer(capture.kdfIterationCount);
  count = count.getInt(count.length() << 3);
  var dkLen;
  var cipherFn;
  switch (pki$2.oids[oid]) {
    case "aes128-CBC":
      dkLen = 16;
      cipherFn = forge$7.aes.createDecryptionCipher;
      break;
    case "aes192-CBC":
      dkLen = 24;
      cipherFn = forge$7.aes.createDecryptionCipher;
      break;
    case "aes256-CBC":
      dkLen = 32;
      cipherFn = forge$7.aes.createDecryptionCipher;
      break;
    case "des-EDE3-CBC":
      dkLen = 24;
      cipherFn = forge$7.des.createDecryptionCipher;
      break;
    case "desCBC":
      dkLen = 8;
      cipherFn = forge$7.des.createDecryptionCipher;
      break;
  }
  var md = prfOidToMessageDigest(capture.prfOid);
  var dk = forge$7.pkcs5.pbkdf2(password, salt, count, dkLen, md);
  var iv = capture.encIv;
  var cipher = cipherFn(dk);
  cipher.start(iv);
  return cipher;
};
pki$2.pbe.getCipherForPKCS12PBE = function(oid, params, password) {
  var capture = {};
  var errors2 = [];
  if (!asn1$3.validate(params, pkcs12PbeParamsValidator, capture, errors2)) {
    var error2 = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
    error2.errors = errors2;
    throw error2;
  }
  var salt = forge$7.util.createBuffer(capture.salt);
  var count = forge$7.util.createBuffer(capture.iterations);
  count = count.getInt(count.length() << 3);
  var dkLen, dIvLen, cipherFn;
  switch (oid) {
    case pki$2.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
      dkLen = 24;
      dIvLen = 8;
      cipherFn = forge$7.des.startDecrypting;
      break;
    case pki$2.oids["pbewithSHAAnd40BitRC2-CBC"]:
      dkLen = 5;
      dIvLen = 8;
      cipherFn = function(key2, iv2) {
        var cipher = forge$7.rc2.createDecryptionCipher(key2, 40);
        cipher.start(iv2, null);
        return cipher;
      };
      break;
    default:
      var error2 = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
      error2.oid = oid;
      throw error2;
  }
  var md = prfOidToMessageDigest(capture.prfOid);
  var key = pki$2.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);
  md.start();
  var iv = pki$2.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);
  return cipherFn(key, iv);
};
pki$2.pbe.opensslDeriveBytes = function(password, salt, dkLen, md) {
  if (typeof md === "undefined" || md === null) {
    if (!("md5" in forge$7.md)) {
      throw new Error('"md5" hash algorithm unavailable.');
    }
    md = forge$7.md.md5.create();
  }
  if (salt === null) {
    salt = "";
  }
  var digests = [hash$2(md, password + salt)];
  for (var length3 = 16, i2 = 1; length3 < dkLen; ++i2, length3 += 16) {
    digests.push(hash$2(md, digests[i2 - 1] + password + salt));
  }
  return digests.join("").substr(0, dkLen);
};
function hash$2(md, bytes2) {
  return md.start().update(bytes2).digest().getBytes();
}
function prfOidToMessageDigest(prfOid) {
  var prfAlgorithm;
  if (!prfOid) {
    prfAlgorithm = "hmacWithSHA1";
  } else {
    prfAlgorithm = pki$2.oids[asn1$3.derToOid(prfOid)];
    if (!prfAlgorithm) {
      var error2 = new Error("Unsupported PRF OID.");
      error2.oid = prfOid;
      error2.supported = [
        "hmacWithSHA1",
        "hmacWithSHA224",
        "hmacWithSHA256",
        "hmacWithSHA384",
        "hmacWithSHA512"
      ];
      throw error2;
    }
  }
  return prfAlgorithmToMessageDigest(prfAlgorithm);
}
function prfAlgorithmToMessageDigest(prfAlgorithm) {
  var factory2 = forge$7.md;
  switch (prfAlgorithm) {
    case "hmacWithSHA224":
      factory2 = forge$7.md.sha512;
    case "hmacWithSHA1":
    case "hmacWithSHA256":
    case "hmacWithSHA384":
    case "hmacWithSHA512":
      prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
      break;
    default:
      var error2 = new Error("Unsupported PRF algorithm.");
      error2.algorithm = prfAlgorithm;
      error2.supported = [
        "hmacWithSHA1",
        "hmacWithSHA224",
        "hmacWithSHA256",
        "hmacWithSHA384",
        "hmacWithSHA512"
      ];
      throw error2;
  }
  if (!factory2 || !(prfAlgorithm in factory2)) {
    throw new Error("Unknown hash algorithm: " + prfAlgorithm);
  }
  return factory2[prfAlgorithm].create();
}
function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {
  var params = asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
    asn1$3.create(
      asn1$3.Class.UNIVERSAL,
      asn1$3.Type.OCTETSTRING,
      false,
      salt
    ),
    asn1$3.create(
      asn1$3.Class.UNIVERSAL,
      asn1$3.Type.INTEGER,
      false,
      countBytes.getBytes()
    )
  ]);
  if (prfAlgorithm !== "hmacWithSHA1") {
    params.value.push(
      asn1$3.create(
        asn1$3.Class.UNIVERSAL,
        asn1$3.Type.INTEGER,
        false,
        forge$7.util.hexToBytes(dkLen.toString(16))
      ),
      asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
        asn1$3.create(
          asn1$3.Class.UNIVERSAL,
          asn1$3.Type.OID,
          false,
          asn1$3.oidToDer(pki$2.oids[prfAlgorithm]).getBytes()
        ),
        asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.NULL, false, "")
      ])
    );
  }
  return params;
}
const webcrypto = {
  get(win = globalThis) {
    const nativeCrypto = win.crypto;
    if (nativeCrypto == null || nativeCrypto.subtle == null) {
      throw Object.assign(new Error("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p-crypto/blob/master/README.md#web-crypto-api"), { code: "ERR_MISSING_WEB_CRYPTO" });
    }
    return nativeCrypto;
  }
};
function bigIntegerToUintBase64url(num, len2) {
  let buf2 = Uint8Array.from(num.abs().toByteArray());
  buf2 = buf2[0] === 0 ? buf2.subarray(1) : buf2;
  if (len2 != null) {
    if (buf2.length > len2)
      throw new Error("byte array longer than desired length");
    buf2 = concat$1([new Uint8Array(len2 - buf2.length), buf2]);
  }
  return toString$5(buf2, "base64url");
}
function base64urlToBigInteger(str) {
  const buf2 = base64urlToBuffer(str);
  return new forge$s.jsbn.BigInteger(toString$5(buf2, "base16"), 16);
}
function base64urlToBuffer(str, len2) {
  let buf2 = fromString$3(str, "base64urlpad");
  if (len2 != null) {
    if (buf2.length > len2)
      throw new Error("byte array longer than desired length");
    buf2 = concat$1([new Uint8Array(len2 - buf2.length), buf2]);
  }
  return buf2;
}
const bits = {
  "P-256": 256,
  "P-384": 384,
  "P-521": 521
};
const curveTypes = Object.keys(bits);
curveTypes.join(" / ");
function create$7(opts) {
  const algorithm = opts?.algorithm ?? "AES-GCM";
  let keyLength = opts?.keyLength ?? 16;
  const nonceLength = opts?.nonceLength ?? 12;
  const digest2 = opts?.digest ?? "SHA-256";
  const saltLength = opts?.saltLength ?? 16;
  const iterations = opts?.iterations ?? 32767;
  const crypto2 = webcrypto.get();
  keyLength *= 8;
  async function encrypt2(data, password) {
    const salt = crypto2.getRandomValues(new Uint8Array(saltLength));
    const nonce = crypto2.getRandomValues(new Uint8Array(nonceLength));
    const aesGcm = { name: algorithm, iv: nonce };
    if (typeof password === "string") {
      password = fromString$3(password);
    }
    const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
    const rawKey = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey", "deriveBits"]);
    const cryptoKey = await crypto2.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["encrypt"]);
    const ciphertext = await crypto2.subtle.encrypt(aesGcm, cryptoKey, data);
    return concat$1([salt, aesGcm.iv, new Uint8Array(ciphertext)]);
  }
  async function decrypt2(data, password) {
    const salt = data.subarray(0, saltLength);
    const nonce = data.subarray(saltLength, saltLength + nonceLength);
    const ciphertext = data.subarray(saltLength + nonceLength);
    const aesGcm = { name: algorithm, iv: nonce };
    if (typeof password === "string") {
      password = fromString$3(password);
    }
    const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
    const rawKey = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey", "deriveBits"]);
    const cryptoKey = await crypto2.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["decrypt"]);
    const plaintext = await crypto2.subtle.decrypt(aesGcm, cryptoKey, ciphertext);
    return new Uint8Array(plaintext);
  }
  const cipher = {
    encrypt: encrypt2,
    decrypt: decrypt2
  };
  return cipher;
}
async function importer$1(privateKey, password) {
  const encryptedKey = base64$4.decode(privateKey);
  const cipher = create$7();
  return await cipher.decrypt(encryptedKey, password);
}
var forge$6 = forge$s;
var sha512$1 = forge$6.sha512 = forge$6.sha512 || {};
forge$6.md.sha512 = forge$6.md.algorithms.sha512 = sha512$1;
var sha384 = forge$6.sha384 = forge$6.sha512.sha384 = forge$6.sha512.sha384 || {};
sha384.create = function() {
  return sha512$1.create("SHA-384");
};
forge$6.md.sha384 = forge$6.md.algorithms.sha384 = sha384;
forge$6.sha512.sha256 = forge$6.sha512.sha256 || {
  create: function() {
    return sha512$1.create("SHA-512/256");
  }
};
forge$6.md["sha512/256"] = forge$6.md.algorithms["sha512/256"] = forge$6.sha512.sha256;
forge$6.sha512.sha224 = forge$6.sha512.sha224 || {
  create: function() {
    return sha512$1.create("SHA-512/224");
  }
};
forge$6.md["sha512/224"] = forge$6.md.algorithms["sha512/224"] = forge$6.sha512.sha224;
sha512$1.create = function(algorithm) {
  if (!_initialized) {
    _init();
  }
  if (typeof algorithm === "undefined") {
    algorithm = "SHA-512";
  }
  if (!(algorithm in _states)) {
    throw new Error("Invalid SHA-512 algorithm: " + algorithm);
  }
  var _state = _states[algorithm];
  var _h = null;
  var _input = forge$6.util.createBuffer();
  var _w = new Array(80);
  for (var wi = 0; wi < 80; ++wi) {
    _w[wi] = new Array(2);
  }
  var digestLength = 64;
  switch (algorithm) {
    case "SHA-384":
      digestLength = 48;
      break;
    case "SHA-512/256":
      digestLength = 32;
      break;
    case "SHA-512/224":
      digestLength = 28;
      break;
  }
  var md = {
    algorithm: algorithm.replace("-", "").toLowerCase(),
    blockLength: 128,
    digestLength,
    messageLength: 0,
    fullMessageLength: null,
    messageLengthSize: 16
  };
  md.start = function() {
    md.messageLength = 0;
    md.fullMessageLength = md.messageLength128 = [];
    var int32s = md.messageLengthSize / 4;
    for (var i2 = 0; i2 < int32s; ++i2) {
      md.fullMessageLength.push(0);
    }
    _input = forge$6.util.createBuffer();
    _h = new Array(_state.length);
    for (var i2 = 0; i2 < _state.length; ++i2) {
      _h[i2] = _state[i2].slice(0);
    }
    return md;
  };
  md.start();
  md.update = function(msg, encoding2) {
    if (encoding2 === "utf8") {
      msg = forge$6.util.encodeUtf8(msg);
    }
    var len2 = msg.length;
    md.messageLength += len2;
    len2 = [len2 / 4294967296 >>> 0, len2 >>> 0];
    for (var i2 = md.fullMessageLength.length - 1; i2 >= 0; --i2) {
      md.fullMessageLength[i2] += len2[1];
      len2[1] = len2[0] + (md.fullMessageLength[i2] / 4294967296 >>> 0);
      md.fullMessageLength[i2] = md.fullMessageLength[i2] >>> 0;
      len2[0] = len2[1] / 4294967296 >>> 0;
    }
    _input.putBytes(msg);
    _update(_h, _w, _input);
    if (_input.read > 2048 || _input.length() === 0) {
      _input.compact();
    }
    return md;
  };
  md.digest = function() {
    var finalBlock = forge$6.util.createBuffer();
    finalBlock.putBytes(_input.bytes());
    var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
    var overflow = remaining & md.blockLength - 1;
    finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
    var next, carry;
    var bits2 = md.fullMessageLength[0] * 8;
    for (var i2 = 0; i2 < md.fullMessageLength.length - 1; ++i2) {
      next = md.fullMessageLength[i2 + 1] * 8;
      carry = next / 4294967296 >>> 0;
      bits2 += carry;
      finalBlock.putInt32(bits2 >>> 0);
      bits2 = next >>> 0;
    }
    finalBlock.putInt32(bits2);
    var h = new Array(_h.length);
    for (var i2 = 0; i2 < _h.length; ++i2) {
      h[i2] = _h[i2].slice(0);
    }
    _update(h, _w, finalBlock);
    var rval = forge$6.util.createBuffer();
    var hlen;
    if (algorithm === "SHA-512") {
      hlen = h.length;
    } else if (algorithm === "SHA-384") {
      hlen = h.length - 2;
    } else {
      hlen = h.length - 4;
    }
    for (var i2 = 0; i2 < hlen; ++i2) {
      rval.putInt32(h[i2][0]);
      if (i2 !== hlen - 1 || algorithm !== "SHA-512/224") {
        rval.putInt32(h[i2][1]);
      }
    }
    return rval;
  };
  return md;
};
var _padding = null;
var _initialized = false;
var _k = null;
var _states = null;
function _init() {
  _padding = String.fromCharCode(128);
  _padding += forge$6.util.fillString(String.fromCharCode(0), 128);
  _k = [
    [1116352408, 3609767458],
    [1899447441, 602891725],
    [3049323471, 3964484399],
    [3921009573, 2173295548],
    [961987163, 4081628472],
    [1508970993, 3053834265],
    [2453635748, 2937671579],
    [2870763221, 3664609560],
    [3624381080, 2734883394],
    [310598401, 1164996542],
    [607225278, 1323610764],
    [1426881987, 3590304994],
    [1925078388, 4068182383],
    [2162078206, 991336113],
    [2614888103, 633803317],
    [3248222580, 3479774868],
    [3835390401, 2666613458],
    [4022224774, 944711139],
    [264347078, 2341262773],
    [604807628, 2007800933],
    [770255983, 1495990901],
    [1249150122, 1856431235],
    [1555081692, 3175218132],
    [1996064986, 2198950837],
    [2554220882, 3999719339],
    [2821834349, 766784016],
    [2952996808, 2566594879],
    [3210313671, 3203337956],
    [3336571891, 1034457026],
    [3584528711, 2466948901],
    [113926993, 3758326383],
    [338241895, 168717936],
    [666307205, 1188179964],
    [773529912, 1546045734],
    [1294757372, 1522805485],
    [1396182291, 2643833823],
    [1695183700, 2343527390],
    [1986661051, 1014477480],
    [2177026350, 1206759142],
    [2456956037, 344077627],
    [2730485921, 1290863460],
    [2820302411, 3158454273],
    [3259730800, 3505952657],
    [3345764771, 106217008],
    [3516065817, 3606008344],
    [3600352804, 1432725776],
    [4094571909, 1467031594],
    [275423344, 851169720],
    [430227734, 3100823752],
    [506948616, 1363258195],
    [659060556, 3750685593],
    [883997877, 3785050280],
    [958139571, 3318307427],
    [1322822218, 3812723403],
    [1537002063, 2003034995],
    [1747873779, 3602036899],
    [1955562222, 1575990012],
    [2024104815, 1125592928],
    [2227730452, 2716904306],
    [2361852424, 442776044],
    [2428436474, 593698344],
    [2756734187, 3733110249],
    [3204031479, 2999351573],
    [3329325298, 3815920427],
    [3391569614, 3928383900],
    [3515267271, 566280711],
    [3940187606, 3454069534],
    [4118630271, 4000239992],
    [116418474, 1914138554],
    [174292421, 2731055270],
    [289380356, 3203993006],
    [460393269, 320620315],
    [685471733, 587496836],
    [852142971, 1086792851],
    [1017036298, 365543100],
    [1126000580, 2618297676],
    [1288033470, 3409855158],
    [1501505948, 4234509866],
    [1607167915, 987167468],
    [1816402316, 1246189591]
  ];
  _states = {};
  _states["SHA-512"] = [
    [1779033703, 4089235720],
    [3144134277, 2227873595],
    [1013904242, 4271175723],
    [2773480762, 1595750129],
    [1359893119, 2917565137],
    [2600822924, 725511199],
    [528734635, 4215389547],
    [1541459225, 327033209]
  ];
  _states["SHA-384"] = [
    [3418070365, 3238371032],
    [1654270250, 914150663],
    [2438529370, 812702999],
    [355462360, 4144912697],
    [1731405415, 4290775857],
    [2394180231, 1750603025],
    [3675008525, 1694076839],
    [1203062813, 3204075428]
  ];
  _states["SHA-512/256"] = [
    [573645204, 4230739756],
    [2673172387, 3360449730],
    [596883563, 1867755857],
    [2520282905, 1497426621],
    [2519219938, 2827943907],
    [3193839141, 1401305490],
    [721525244, 746961066],
    [246885852, 2177182882]
  ];
  _states["SHA-512/224"] = [
    [2352822216, 424955298],
    [1944164710, 2312950998],
    [502970286, 855612546],
    [1738396948, 1479516111],
    [258812777, 2077511080],
    [2011393907, 79989058],
    [1067287976, 1780299464],
    [286451373, 2446758561]
  ];
  _initialized = true;
}
function _update(s2, w, bytes2) {
  var t1_hi, t1_lo;
  var t2_hi, t2_lo;
  var s0_hi, s0_lo;
  var s1_hi, s1_lo;
  var ch_hi, ch_lo;
  var maj_hi, maj_lo;
  var a_hi, a_lo;
  var b_hi, b_lo;
  var c_hi, c_lo;
  var d_hi, d_lo;
  var e_hi, e_lo;
  var f_hi, f_lo;
  var g_hi, g_lo;
  var h_hi, h_lo;
  var i2, hi, lo, w2, w7, w15, w16;
  var len2 = bytes2.length();
  while (len2 >= 128) {
    for (i2 = 0; i2 < 16; ++i2) {
      w[i2][0] = bytes2.getInt32() >>> 0;
      w[i2][1] = bytes2.getInt32() >>> 0;
    }
    for (; i2 < 80; ++i2) {
      w2 = w[i2 - 2];
      hi = w2[0];
      lo = w2[1];
      t1_hi = ((hi >>> 19 | lo << 13) ^ (lo >>> 29 | hi << 3) ^ hi >>> 6) >>> 0;
      t1_lo = ((hi << 13 | lo >>> 19) ^ (lo << 3 | hi >>> 29) ^ (hi << 26 | lo >>> 6)) >>> 0;
      w15 = w[i2 - 15];
      hi = w15[0];
      lo = w15[1];
      t2_hi = ((hi >>> 1 | lo << 31) ^ (hi >>> 8 | lo << 24) ^ hi >>> 7) >>> 0;
      t2_lo = ((hi << 31 | lo >>> 1) ^ (hi << 24 | lo >>> 8) ^ (hi << 25 | lo >>> 7)) >>> 0;
      w7 = w[i2 - 7];
      w16 = w[i2 - 16];
      lo = t1_lo + w7[1] + t2_lo + w16[1];
      w[i2][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo / 4294967296 >>> 0) >>> 0;
      w[i2][1] = lo >>> 0;
    }
    a_hi = s2[0][0];
    a_lo = s2[0][1];
    b_hi = s2[1][0];
    b_lo = s2[1][1];
    c_hi = s2[2][0];
    c_lo = s2[2][1];
    d_hi = s2[3][0];
    d_lo = s2[3][1];
    e_hi = s2[4][0];
    e_lo = s2[4][1];
    f_hi = s2[5][0];
    f_lo = s2[5][1];
    g_hi = s2[6][0];
    g_lo = s2[6][1];
    h_hi = s2[7][0];
    h_lo = s2[7][1];
    for (i2 = 0; i2 < 80; ++i2) {
      s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ (e_hi >>> 18 | e_lo << 14) ^ (e_lo >>> 9 | e_hi << 23)) >>> 0;
      s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ (e_hi << 14 | e_lo >>> 18) ^ (e_lo << 23 | e_hi >>> 9)) >>> 0;
      ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;
      ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0;
      s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ (a_lo >>> 2 | a_hi << 30) ^ (a_lo >>> 7 | a_hi << 25)) >>> 0;
      s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ (a_lo << 30 | a_hi >>> 2) ^ (a_lo << 25 | a_hi >>> 7)) >>> 0;
      maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;
      maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0;
      lo = h_lo + s1_lo + ch_lo + _k[i2][1] + w[i2][1];
      t1_hi = h_hi + s1_hi + ch_hi + _k[i2][0] + w[i2][0] + (lo / 4294967296 >>> 0) >>> 0;
      t1_lo = lo >>> 0;
      lo = s0_lo + maj_lo;
      t2_hi = s0_hi + maj_hi + (lo / 4294967296 >>> 0) >>> 0;
      t2_lo = lo >>> 0;
      h_hi = g_hi;
      h_lo = g_lo;
      g_hi = f_hi;
      g_lo = f_lo;
      f_hi = e_hi;
      f_lo = e_lo;
      lo = d_lo + t1_lo;
      e_hi = d_hi + t1_hi + (lo / 4294967296 >>> 0) >>> 0;
      e_lo = lo >>> 0;
      d_hi = c_hi;
      d_lo = c_lo;
      c_hi = b_hi;
      c_lo = b_lo;
      b_hi = a_hi;
      b_lo = a_lo;
      lo = t1_lo + t2_lo;
      a_hi = t1_hi + t2_hi + (lo / 4294967296 >>> 0) >>> 0;
      a_lo = lo >>> 0;
    }
    lo = s2[0][1] + a_lo;
    s2[0][0] = s2[0][0] + a_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[0][1] = lo >>> 0;
    lo = s2[1][1] + b_lo;
    s2[1][0] = s2[1][0] + b_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[1][1] = lo >>> 0;
    lo = s2[2][1] + c_lo;
    s2[2][0] = s2[2][0] + c_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[2][1] = lo >>> 0;
    lo = s2[3][1] + d_lo;
    s2[3][0] = s2[3][0] + d_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[3][1] = lo >>> 0;
    lo = s2[4][1] + e_lo;
    s2[4][0] = s2[4][0] + e_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[4][1] = lo >>> 0;
    lo = s2[5][1] + f_lo;
    s2[5][0] = s2[5][0] + f_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[5][1] = lo >>> 0;
    lo = s2[6][1] + g_lo;
    s2[6][0] = s2[6][0] + g_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[6][1] = lo >>> 0;
    lo = s2[7][1] + h_lo;
    s2[7][0] = s2[7][0] + h_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[7][1] = lo >>> 0;
    len2 -= 128;
  }
}
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
const _0n$1 = BigInt(0);
const _1n$1 = BigInt(1);
const _2n$1 = BigInt(2);
const _3n = BigInt(3);
const _8n = BigInt(8);
const CURVE$1 = Object.freeze({
  a: _0n$1,
  b: BigInt(7),
  P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: _1n$1,
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
});
function weistrass(x) {
  const { a, b: b2 } = CURVE$1;
  const x2 = mod$1(x * x);
  const x3 = mod$1(x2 * x);
  return mod$1(x3 + a * x + b2);
}
const USE_ENDOMORPHISM = CURVE$1.a === _0n$1;
class ShaError extends Error {
  constructor(message2) {
    super(message2);
  }
}
class JacobianPoint {
  constructor(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  static fromAffine(p) {
    if (!(p instanceof Point$1)) {
      throw new TypeError("JacobianPoint#fromAffine: expected Point");
    }
    return new JacobianPoint(p.x, p.y, _1n$1);
  }
  static toAffineBatch(points) {
    const toInv = invertBatch$1(points.map((p) => p.z));
    return points.map((p, i2) => p.toAffine(toInv[i2]));
  }
  static normalizeZ(points) {
    return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);
  }
  equals(other) {
    if (!(other instanceof JacobianPoint))
      throw new TypeError("JacobianPoint expected");
    const { x: X1, y: Y1, z: Z1 } = this;
    const { x: X2, y: Y2, z: Z2 } = other;
    const Z1Z1 = mod$1(Z1 * Z1);
    const Z2Z2 = mod$1(Z2 * Z2);
    const U1 = mod$1(X1 * Z2Z2);
    const U2 = mod$1(X2 * Z1Z1);
    const S1 = mod$1(mod$1(Y1 * Z2) * Z2Z2);
    const S2 = mod$1(mod$1(Y2 * Z1) * Z1Z1);
    return U1 === U2 && S1 === S2;
  }
  negate() {
    return new JacobianPoint(this.x, mod$1(-this.y), this.z);
  }
  double() {
    const { x: X1, y: Y1, z: Z1 } = this;
    const A = mod$1(X1 * X1);
    const B = mod$1(Y1 * Y1);
    const C = mod$1(B * B);
    const x1b = X1 + B;
    const D = mod$1(_2n$1 * (mod$1(x1b * x1b) - A - C));
    const E = mod$1(_3n * A);
    const F = mod$1(E * E);
    const X3 = mod$1(F - _2n$1 * D);
    const Y3 = mod$1(E * (D - X3) - _8n * C);
    const Z3 = mod$1(_2n$1 * Y1 * Z1);
    return new JacobianPoint(X3, Y3, Z3);
  }
  add(other) {
    if (!(other instanceof JacobianPoint))
      throw new TypeError("JacobianPoint expected");
    const { x: X1, y: Y1, z: Z1 } = this;
    const { x: X2, y: Y2, z: Z2 } = other;
    if (X2 === _0n$1 || Y2 === _0n$1)
      return this;
    if (X1 === _0n$1 || Y1 === _0n$1)
      return other;
    const Z1Z1 = mod$1(Z1 * Z1);
    const Z2Z2 = mod$1(Z2 * Z2);
    const U1 = mod$1(X1 * Z2Z2);
    const U2 = mod$1(X2 * Z1Z1);
    const S1 = mod$1(mod$1(Y1 * Z2) * Z2Z2);
    const S2 = mod$1(mod$1(Y2 * Z1) * Z1Z1);
    const H = mod$1(U2 - U1);
    const r = mod$1(S2 - S1);
    if (H === _0n$1) {
      if (r === _0n$1) {
        return this.double();
      } else {
        return JacobianPoint.ZERO;
      }
    }
    const HH = mod$1(H * H);
    const HHH = mod$1(H * HH);
    const V2 = mod$1(U1 * HH);
    const X3 = mod$1(r * r - HHH - _2n$1 * V2);
    const Y3 = mod$1(r * (V2 - X3) - S1 * HHH);
    const Z3 = mod$1(Z1 * Z2 * H);
    return new JacobianPoint(X3, Y3, Z3);
  }
  subtract(other) {
    return this.add(other.negate());
  }
  multiplyUnsafe(scalar) {
    const P0 = JacobianPoint.ZERO;
    if (typeof scalar === "bigint" && scalar === _0n$1)
      return P0;
    let n = normalizeScalar$1(scalar);
    if (n === _1n$1)
      return this;
    if (!USE_ENDOMORPHISM) {
      let p = P0;
      let d2 = this;
      while (n > _0n$1) {
        if (n & _1n$1)
          p = p.add(d2);
        d2 = d2.double();
        n >>= _1n$1;
      }
      return p;
    }
    let { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);
    let k1p = P0;
    let k2p = P0;
    let d = this;
    while (k1 > _0n$1 || k2 > _0n$1) {
      if (k1 & _1n$1)
        k1p = k1p.add(d);
      if (k2 & _1n$1)
        k2p = k2p.add(d);
      d = d.double();
      k1 >>= _1n$1;
      k2 >>= _1n$1;
    }
    if (k1neg)
      k1p = k1p.negate();
    if (k2neg)
      k2p = k2p.negate();
    k2p = new JacobianPoint(mod$1(k2p.x * CURVE$1.beta), k2p.y, k2p.z);
    return k1p.add(k2p);
  }
  precomputeWindow(W) {
    const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;
    const points = [];
    let p = this;
    let base3 = p;
    for (let window2 = 0; window2 < windows; window2++) {
      base3 = p;
      points.push(base3);
      for (let i2 = 1; i2 < 2 ** (W - 1); i2++) {
        base3 = base3.add(p);
        points.push(base3);
      }
      p = base3.double();
    }
    return points;
  }
  wNAF(n, affinePoint) {
    if (!affinePoint && this.equals(JacobianPoint.BASE))
      affinePoint = Point$1.BASE;
    const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
    if (256 % W) {
      throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
    }
    let precomputes = affinePoint && pointPrecomputes$1.get(affinePoint);
    if (!precomputes) {
      precomputes = this.precomputeWindow(W);
      if (affinePoint && W !== 1) {
        precomputes = JacobianPoint.normalizeZ(precomputes);
        pointPrecomputes$1.set(affinePoint, precomputes);
      }
    }
    let p = JacobianPoint.ZERO;
    let f = JacobianPoint.ZERO;
    const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);
    const windowSize = 2 ** (W - 1);
    const mask = BigInt(2 ** W - 1);
    const maxNumber = 2 ** W;
    const shiftBy = BigInt(W);
    for (let window2 = 0; window2 < windows; window2++) {
      const offset = window2 * windowSize;
      let wbits = Number(n & mask);
      n >>= shiftBy;
      if (wbits > windowSize) {
        wbits -= maxNumber;
        n += _1n$1;
      }
      if (wbits === 0) {
        let pr = precomputes[offset];
        if (window2 % 2)
          pr = pr.negate();
        f = f.add(pr);
      } else {
        let cached = precomputes[offset + Math.abs(wbits) - 1];
        if (wbits < 0)
          cached = cached.negate();
        p = p.add(cached);
      }
    }
    return { p, f };
  }
  multiply(scalar, affinePoint) {
    let n = normalizeScalar$1(scalar);
    let point;
    let fake;
    if (USE_ENDOMORPHISM) {
      const { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);
      let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);
      let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new JacobianPoint(mod$1(k2p.x * CURVE$1.beta), k2p.y, k2p.z);
      point = k1p.add(k2p);
      fake = f1p.add(f2p);
    } else {
      const { p, f } = this.wNAF(n, affinePoint);
      point = p;
      fake = f;
    }
    return JacobianPoint.normalizeZ([point, fake])[0];
  }
  toAffine(invZ = invert$1(this.z)) {
    const { x, y, z } = this;
    const iz1 = invZ;
    const iz2 = mod$1(iz1 * iz1);
    const iz3 = mod$1(iz2 * iz1);
    const ax = mod$1(x * iz2);
    const ay = mod$1(y * iz3);
    const zz = mod$1(z * iz1);
    if (zz !== _1n$1)
      throw new Error("invZ was invalid");
    return new Point$1(ax, ay);
  }
}
JacobianPoint.BASE = new JacobianPoint(CURVE$1.Gx, CURVE$1.Gy, _1n$1);
JacobianPoint.ZERO = new JacobianPoint(_0n$1, _1n$1, _0n$1);
const pointPrecomputes$1 = /* @__PURE__ */ new WeakMap();
class Point$1 {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  _setWindowSize(windowSize) {
    this._WINDOW_SIZE = windowSize;
    pointPrecomputes$1.delete(this);
  }
  hasEvenY() {
    return this.y % _2n$1 === _0n$1;
  }
  static fromCompressedHex(bytes2) {
    const isShort = bytes2.length === 32;
    const x = bytesToNumber(isShort ? bytes2 : bytes2.subarray(1));
    if (!isValidFieldElement(x))
      throw new Error("Point is not on curve");
    const y2 = weistrass(x);
    let y = sqrtMod(y2);
    const isYOdd = (y & _1n$1) === _1n$1;
    if (isShort) {
      if (isYOdd)
        y = mod$1(-y);
    } else {
      const isFirstByteOdd = (bytes2[0] & 1) === 1;
      if (isFirstByteOdd !== isYOdd)
        y = mod$1(-y);
    }
    const point = new Point$1(x, y);
    point.assertValidity();
    return point;
  }
  static fromUncompressedHex(bytes2) {
    const x = bytesToNumber(bytes2.subarray(1, 33));
    const y = bytesToNumber(bytes2.subarray(33, 65));
    const point = new Point$1(x, y);
    point.assertValidity();
    return point;
  }
  static fromHex(hex) {
    const bytes2 = ensureBytes$1(hex);
    const len2 = bytes2.length;
    const header = bytes2[0];
    if (len2 === 32 || len2 === 33 && (header === 2 || header === 3)) {
      return this.fromCompressedHex(bytes2);
    }
    if (len2 === 65 && header === 4)
      return this.fromUncompressedHex(bytes2);
    throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${len2}`);
  }
  static fromPrivateKey(privateKey) {
    return Point$1.BASE.multiply(normalizePrivateKey(privateKey));
  }
  static fromSignature(msgHash, signature, recovery) {
    msgHash = ensureBytes$1(msgHash);
    const h = truncateHash(msgHash);
    const { r, s: s2 } = normalizeSignature(signature);
    if (recovery !== 0 && recovery !== 1) {
      throw new Error("Cannot recover signature: invalid recovery bit");
    }
    const prefix = recovery & 1 ? "03" : "02";
    const R2 = Point$1.fromHex(prefix + numTo32bStr(r));
    const { n } = CURVE$1;
    const rinv = invert$1(r, n);
    const u1 = mod$1(-h * rinv, n);
    const u2 = mod$1(s2 * rinv, n);
    const Q = Point$1.BASE.multiplyAndAddUnsafe(R2, u1, u2);
    if (!Q)
      throw new Error("Cannot recover signature: point at infinify");
    Q.assertValidity();
    return Q;
  }
  toRawBytes(isCompressed = false) {
    return hexToBytes$1(this.toHex(isCompressed));
  }
  toHex(isCompressed = false) {
    const x = numTo32bStr(this.x);
    if (isCompressed) {
      const prefix = this.hasEvenY() ? "02" : "03";
      return `${prefix}${x}`;
    } else {
      return `04${x}${numTo32bStr(this.y)}`;
    }
  }
  toHexX() {
    return this.toHex(true).slice(2);
  }
  toRawX() {
    return this.toRawBytes(true).slice(1);
  }
  assertValidity() {
    const msg = "Point is not on elliptic curve";
    const { x, y } = this;
    if (!isValidFieldElement(x) || !isValidFieldElement(y))
      throw new Error(msg);
    const left = mod$1(y * y);
    const right = weistrass(x);
    if (mod$1(left - right) !== _0n$1)
      throw new Error(msg);
  }
  equals(other) {
    return this.x === other.x && this.y === other.y;
  }
  negate() {
    return new Point$1(this.x, mod$1(-this.y));
  }
  double() {
    return JacobianPoint.fromAffine(this).double().toAffine();
  }
  add(other) {
    return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
  }
  subtract(other) {
    return this.add(other.negate());
  }
  multiply(scalar) {
    return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
  }
  multiplyAndAddUnsafe(Q, a, b2) {
    const P = JacobianPoint.fromAffine(this);
    const aP = a === _0n$1 || a === _1n$1 || this !== Point$1.BASE ? P.multiplyUnsafe(a) : P.multiply(a);
    const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b2);
    const sum = aP.add(bQ);
    return sum.equals(JacobianPoint.ZERO) ? void 0 : sum.toAffine();
  }
}
Point$1.BASE = new Point$1(CURVE$1.Gx, CURVE$1.Gy);
Point$1.ZERO = new Point$1(_0n$1, _0n$1);
function sliceDER(s2) {
  return Number.parseInt(s2[0], 16) >= 8 ? "00" + s2 : s2;
}
function parseDERInt(data) {
  if (data.length < 2 || data[0] !== 2) {
    throw new Error(`Invalid signature integer tag: ${bytesToHex$1(data)}`);
  }
  const len2 = data[1];
  const res = data.subarray(2, len2 + 2);
  if (!len2 || res.length !== len2) {
    throw new Error(`Invalid signature integer: wrong length`);
  }
  if (res[0] === 0 && res[1] <= 127) {
    throw new Error("Invalid signature integer: trailing length");
  }
  return { data: bytesToNumber(res), left: data.subarray(len2 + 2) };
}
function parseDERSignature(data) {
  if (data.length < 2 || data[0] != 48) {
    throw new Error(`Invalid signature tag: ${bytesToHex$1(data)}`);
  }
  if (data[1] !== data.length - 2) {
    throw new Error("Invalid signature: incorrect length");
  }
  const { data: r, left: sBytes } = parseDERInt(data.subarray(2));
  const { data: s2, left: rBytesLeft } = parseDERInt(sBytes);
  if (rBytesLeft.length) {
    throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex$1(rBytesLeft)}`);
  }
  return { r, s: s2 };
}
class Signature$1 {
  constructor(r, s2) {
    this.r = r;
    this.s = s2;
    this.assertValidity();
  }
  static fromCompact(hex) {
    const arr = hex instanceof Uint8Array;
    const name2 = "Signature.fromCompact";
    if (typeof hex !== "string" && !arr)
      throw new TypeError(`${name2}: Expected string or Uint8Array`);
    const str = arr ? bytesToHex$1(hex) : hex;
    if (str.length !== 128)
      throw new Error(`${name2}: Expected 64-byte hex`);
    return new Signature$1(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));
  }
  static fromDER(hex) {
    const arr = hex instanceof Uint8Array;
    if (typeof hex !== "string" && !arr)
      throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);
    const { r, s: s2 } = parseDERSignature(arr ? hex : hexToBytes$1(hex));
    return new Signature$1(r, s2);
  }
  static fromHex(hex) {
    return this.fromDER(hex);
  }
  assertValidity() {
    const { r, s: s2 } = this;
    if (!isWithinCurveOrder(r))
      throw new Error("Invalid Signature: r must be 0 < r < n");
    if (!isWithinCurveOrder(s2))
      throw new Error("Invalid Signature: s must be 0 < s < n");
  }
  hasHighS() {
    const HALF = CURVE$1.n >> _1n$1;
    return this.s > HALF;
  }
  normalizeS() {
    return this.hasHighS() ? new Signature$1(this.r, CURVE$1.n - this.s) : this;
  }
  toDERRawBytes(isCompressed = false) {
    return hexToBytes$1(this.toDERHex(isCompressed));
  }
  toDERHex(isCompressed = false) {
    const sHex = sliceDER(numberToHexUnpadded(this.s));
    if (isCompressed)
      return sHex;
    const rHex = sliceDER(numberToHexUnpadded(this.r));
    const rLen = numberToHexUnpadded(rHex.length / 2);
    const sLen = numberToHexUnpadded(sHex.length / 2);
    const length3 = numberToHexUnpadded(rHex.length / 2 + sHex.length / 2 + 4);
    return `30${length3}02${rLen}${rHex}02${sLen}${sHex}`;
  }
  toRawBytes() {
    return this.toDERRawBytes();
  }
  toHex() {
    return this.toDERHex();
  }
  toCompactRawBytes() {
    return hexToBytes$1(this.toCompactHex());
  }
  toCompactHex() {
    return numTo32bStr(this.r) + numTo32bStr(this.s);
  }
}
function concatBytes$1(...arrays) {
  if (!arrays.every((b2) => b2 instanceof Uint8Array))
    throw new Error("Uint8Array list expected");
  if (arrays.length === 1)
    return arrays[0];
  const length3 = arrays.reduce((a, arr) => a + arr.length, 0);
  const result = new Uint8Array(length3);
  for (let i2 = 0, pad = 0; i2 < arrays.length; i2++) {
    const arr = arrays[i2];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
}
const hexes$1 = Array.from({ length: 256 }, (v, i2) => i2.toString(16).padStart(2, "0"));
function bytesToHex$1(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  let hex = "";
  for (let i2 = 0; i2 < uint8a.length; i2++) {
    hex += hexes$1[uint8a[i2]];
  }
  return hex;
}
const POW_2_256$1 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
function numTo32bStr(num) {
  if (typeof num !== "bigint")
    throw new Error("Expected bigint");
  if (!(_0n$1 <= num && num < POW_2_256$1))
    throw new Error("Expected number < 2^256");
  return num.toString(16).padStart(64, "0");
}
function numTo32b(num) {
  const b2 = hexToBytes$1(numTo32bStr(num));
  if (b2.length !== 32)
    throw new Error("Error: expected 32 bytes");
  return b2;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToNumber: expected string, got " + typeof hex);
  }
  return BigInt(`0x${hex}`);
}
function hexToBytes$1(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToBytes: expected string, got " + typeof hex);
  }
  if (hex.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex" + hex.length);
  const array = new Uint8Array(hex.length / 2);
  for (let i2 = 0; i2 < array.length; i2++) {
    const j = i2 * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i2] = byte;
  }
  return array;
}
function bytesToNumber(bytes2) {
  return hexToNumber(bytesToHex$1(bytes2));
}
function ensureBytes$1(hex) {
  return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes$1(hex);
}
function normalizeScalar$1(num) {
  if (typeof num === "number" && Number.isSafeInteger(num) && num > 0)
    return BigInt(num);
  if (typeof num === "bigint" && isWithinCurveOrder(num))
    return num;
  throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
}
function mod$1(a, b2 = CURVE$1.P) {
  const result = a % b2;
  return result >= _0n$1 ? result : b2 + result;
}
function pow2$1(x, power) {
  const { P } = CURVE$1;
  let res = x;
  while (power-- > _0n$1) {
    res *= res;
    res %= P;
  }
  return res;
}
function sqrtMod(x) {
  const { P } = CURVE$1;
  const _6n = BigInt(6);
  const _11n = BigInt(11);
  const _22n = BigInt(22);
  const _23n = BigInt(23);
  const _44n = BigInt(44);
  const _88n = BigInt(88);
  const b2 = x * x * x % P;
  const b3 = b2 * b2 * x % P;
  const b6 = pow2$1(b3, _3n) * b3 % P;
  const b9 = pow2$1(b6, _3n) * b3 % P;
  const b11 = pow2$1(b9, _2n$1) * b2 % P;
  const b22 = pow2$1(b11, _11n) * b11 % P;
  const b44 = pow2$1(b22, _22n) * b22 % P;
  const b88 = pow2$1(b44, _44n) * b44 % P;
  const b176 = pow2$1(b88, _88n) * b88 % P;
  const b220 = pow2$1(b176, _44n) * b44 % P;
  const b223 = pow2$1(b220, _3n) * b3 % P;
  const t1 = pow2$1(b223, _23n) * b22 % P;
  const t2 = pow2$1(t1, _6n) * b2 % P;
  return pow2$1(t2, _2n$1);
}
function invert$1(number, modulo = CURVE$1.P) {
  if (number === _0n$1 || modulo <= _0n$1) {
    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
  }
  let a = mod$1(number, modulo);
  let b2 = modulo;
  let x = _0n$1, u = _1n$1;
  while (a !== _0n$1) {
    const q = b2 / a;
    const r = b2 % a;
    const m = x - u * q;
    b2 = a, a = r, x = u, u = m;
  }
  const gcd = b2;
  if (gcd !== _1n$1)
    throw new Error("invert: does not exist");
  return mod$1(x, modulo);
}
function invertBatch$1(nums, p = CURVE$1.P) {
  const scratch = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i2) => {
    if (num === _0n$1)
      return acc;
    scratch[i2] = acc;
    return mod$1(acc * num, p);
  }, _1n$1);
  const inverted = invert$1(lastMultiplied, p);
  nums.reduceRight((acc, num, i2) => {
    if (num === _0n$1)
      return acc;
    scratch[i2] = mod$1(acc * scratch[i2], p);
    return mod$1(acc * num, p);
  }, inverted);
  return scratch;
}
const divNearest = (a, b2) => (a + b2 / _2n$1) / b2;
const ENDO = {
  a1: BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
  b1: -_1n$1 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
  a2: BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
  b2: BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
  POW_2_128: BigInt("0x100000000000000000000000000000000")
};
function splitScalarEndo(k) {
  const { n } = CURVE$1;
  const { a1, b1, a2, b2, POW_2_128 } = ENDO;
  const c1 = divNearest(b2 * k, n);
  const c2 = divNearest(-b1 * k, n);
  let k1 = mod$1(k - c1 * a1 - c2 * a2, n);
  let k2 = mod$1(-c1 * b1 - c2 * b2, n);
  const k1neg = k1 > POW_2_128;
  const k2neg = k2 > POW_2_128;
  if (k1neg)
    k1 = n - k1;
  if (k2neg)
    k2 = n - k2;
  if (k1 > POW_2_128 || k2 > POW_2_128) {
    throw new Error("splitScalarEndo: Endomorphism failed, k=" + k);
  }
  return { k1neg, k1, k2neg, k2 };
}
function truncateHash(hash2) {
  const { n } = CURVE$1;
  const byteLength2 = hash2.length;
  const delta = byteLength2 * 8 - 256;
  let h = bytesToNumber(hash2);
  if (delta > 0)
    h = h >> BigInt(delta);
  if (h >= n)
    h -= n;
  return h;
}
let _sha256Sync;
let _hmacSha256Sync;
class HmacDrbg {
  constructor() {
    this.v = new Uint8Array(32).fill(1);
    this.k = new Uint8Array(32).fill(0);
    this.counter = 0;
  }
  hmac(...values) {
    return utils$1.hmacSha256(this.k, ...values);
  }
  hmacSync(...values) {
    return _hmacSha256Sync(this.k, ...values);
  }
  checkSync() {
    if (typeof _hmacSha256Sync !== "function")
      throw new ShaError("hmacSha256Sync needs to be set");
  }
  incr() {
    if (this.counter >= 1e3)
      throw new Error("Tried 1,000 k values for sign(), all were invalid");
    this.counter += 1;
  }
  async reseed(seed2 = new Uint8Array()) {
    this.k = await this.hmac(this.v, Uint8Array.from([0]), seed2);
    this.v = await this.hmac(this.v);
    if (seed2.length === 0)
      return;
    this.k = await this.hmac(this.v, Uint8Array.from([1]), seed2);
    this.v = await this.hmac(this.v);
  }
  reseedSync(seed2 = new Uint8Array()) {
    this.checkSync();
    this.k = this.hmacSync(this.v, Uint8Array.from([0]), seed2);
    this.v = this.hmacSync(this.v);
    if (seed2.length === 0)
      return;
    this.k = this.hmacSync(this.v, Uint8Array.from([1]), seed2);
    this.v = this.hmacSync(this.v);
  }
  async generate() {
    this.incr();
    this.v = await this.hmac(this.v);
    return this.v;
  }
  generateSync() {
    this.checkSync();
    this.incr();
    this.v = this.hmacSync(this.v);
    return this.v;
  }
}
function isWithinCurveOrder(num) {
  return _0n$1 < num && num < CURVE$1.n;
}
function isValidFieldElement(num) {
  return _0n$1 < num && num < CURVE$1.P;
}
function kmdToSig(kBytes, m, d) {
  const k = bytesToNumber(kBytes);
  if (!isWithinCurveOrder(k))
    return;
  const { n } = CURVE$1;
  const q = Point$1.BASE.multiply(k);
  const r = mod$1(q.x, n);
  if (r === _0n$1)
    return;
  const s2 = mod$1(invert$1(k, n) * mod$1(m + d * r, n), n);
  if (s2 === _0n$1)
    return;
  const sig = new Signature$1(r, s2);
  const recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n$1);
  return { sig, recovery };
}
function normalizePrivateKey(key) {
  let num;
  if (typeof key === "bigint") {
    num = key;
  } else if (typeof key === "number" && Number.isSafeInteger(key) && key > 0) {
    num = BigInt(key);
  } else if (typeof key === "string") {
    if (key.length !== 64)
      throw new Error("Expected 32 bytes of private key");
    num = hexToNumber(key);
  } else if (key instanceof Uint8Array) {
    if (key.length !== 32)
      throw new Error("Expected 32 bytes of private key");
    num = bytesToNumber(key);
  } else {
    throw new TypeError("Expected valid private key");
  }
  if (!isWithinCurveOrder(num))
    throw new Error("Expected private key: 0 < key < n");
  return num;
}
function normalizePublicKey(publicKey) {
  if (publicKey instanceof Point$1) {
    publicKey.assertValidity();
    return publicKey;
  } else {
    return Point$1.fromHex(publicKey);
  }
}
function normalizeSignature(signature) {
  if (signature instanceof Signature$1) {
    signature.assertValidity();
    return signature;
  }
  try {
    return Signature$1.fromDER(signature);
  } catch (error2) {
    return Signature$1.fromCompact(signature);
  }
}
function getPublicKey$1(privateKey, isCompressed = false) {
  return Point$1.fromPrivateKey(privateKey).toRawBytes(isCompressed);
}
function bits2int(bytes2) {
  const slice2 = bytes2.length > 32 ? bytes2.slice(0, 32) : bytes2;
  return bytesToNumber(slice2);
}
function bits2octets(bytes2) {
  const z1 = bits2int(bytes2);
  const z2 = mod$1(z1, CURVE$1.n);
  return int2octets(z2 < _0n$1 ? z1 : z2);
}
function int2octets(num) {
  return numTo32b(num);
}
function initSigArgs(msgHash, privateKey, extraEntropy) {
  if (msgHash == null)
    throw new Error(`sign: expected valid message hash, not "${msgHash}"`);
  const h1 = ensureBytes$1(msgHash);
  const d = normalizePrivateKey(privateKey);
  const seedArgs = [int2octets(d), bits2octets(h1)];
  if (extraEntropy != null) {
    if (extraEntropy === true)
      extraEntropy = utils$1.randomBytes(32);
    const e = ensureBytes$1(extraEntropy);
    if (e.length !== 32)
      throw new Error("sign: Expected 32 bytes of extra data");
    seedArgs.push(e);
  }
  const seed2 = concatBytes$1(...seedArgs);
  const m = bits2int(h1);
  return { seed: seed2, m, d };
}
function finalizeSig(recSig, opts) {
  let { sig, recovery } = recSig;
  const { canonical, der, recovered } = Object.assign({ canonical: true, der: true }, opts);
  if (canonical && sig.hasHighS()) {
    sig = sig.normalizeS();
    recovery ^= 1;
  }
  const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();
  return recovered ? [hashed, recovery] : hashed;
}
async function sign$1(msgHash, privKey, opts = {}) {
  const { seed: seed2, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);
  let sig;
  const drbg = new HmacDrbg();
  await drbg.reseed(seed2);
  while (!(sig = kmdToSig(await drbg.generate(), m, d)))
    await drbg.reseed();
  return finalizeSig(sig, opts);
}
const vopts = { strict: true };
function verify$1(signature, msgHash, publicKey, opts = vopts) {
  let sig;
  try {
    sig = normalizeSignature(signature);
    msgHash = ensureBytes$1(msgHash);
  } catch (error2) {
    return false;
  }
  const { r, s: s2 } = sig;
  if (opts.strict && sig.hasHighS())
    return false;
  const h = truncateHash(msgHash);
  let P;
  try {
    P = normalizePublicKey(publicKey);
  } catch (error2) {
    return false;
  }
  const { n } = CURVE$1;
  const sinv = invert$1(s2, n);
  const u1 = mod$1(h * sinv, n);
  const u2 = mod$1(r * sinv, n);
  const R2 = Point$1.BASE.multiplyAndAddUnsafe(P, u1, u2);
  if (!R2)
    return false;
  const v = mod$1(R2.x, n);
  return v === r;
}
Point$1.BASE._setWindowSize(8);
const crypto$4 = {
  node: nodeCrypto,
  web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
};
const TAGGED_HASH_PREFIXES = {};
const utils$1 = {
  bytesToHex: bytesToHex$1,
  hexToBytes: hexToBytes$1,
  concatBytes: concatBytes$1,
  mod: mod$1,
  invert: invert$1,
  isValidPrivateKey(privateKey) {
    try {
      normalizePrivateKey(privateKey);
      return true;
    } catch (error2) {
      return false;
    }
  },
  _bigintTo32Bytes: numTo32b,
  _normalizePrivateKey: normalizePrivateKey,
  hashToPrivateKey: (hash2) => {
    hash2 = ensureBytes$1(hash2);
    if (hash2.length < 40 || hash2.length > 1024)
      throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");
    const num = mod$1(bytesToNumber(hash2), CURVE$1.n - _1n$1) + _1n$1;
    return numTo32b(num);
  },
  randomBytes: (bytesLength = 32) => {
    if (crypto$4.web) {
      return crypto$4.web.getRandomValues(new Uint8Array(bytesLength));
    } else if (crypto$4.node) {
      const { randomBytes: randomBytes2 } = crypto$4.node;
      return Uint8Array.from(randomBytes2(bytesLength));
    } else {
      throw new Error("The environment doesn't have randomBytes function");
    }
  },
  randomPrivateKey: () => {
    return utils$1.hashToPrivateKey(utils$1.randomBytes(40));
  },
  sha256: async (...messages2) => {
    if (crypto$4.web) {
      const buffer2 = await crypto$4.web.subtle.digest("SHA-256", concatBytes$1(...messages2));
      return new Uint8Array(buffer2);
    } else if (crypto$4.node) {
      const { createHash } = crypto$4.node;
      const hash2 = createHash("sha256");
      messages2.forEach((m) => hash2.update(m));
      return Uint8Array.from(hash2.digest());
    } else {
      throw new Error("The environment doesn't have sha256 function");
    }
  },
  hmacSha256: async (key, ...messages2) => {
    if (crypto$4.web) {
      const ckey = await crypto$4.web.subtle.importKey("raw", key, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]);
      const message2 = concatBytes$1(...messages2);
      const buffer2 = await crypto$4.web.subtle.sign("HMAC", ckey, message2);
      return new Uint8Array(buffer2);
    } else if (crypto$4.node) {
      const { createHmac } = crypto$4.node;
      const hash2 = createHmac("sha256", key);
      messages2.forEach((m) => hash2.update(m));
      return Uint8Array.from(hash2.digest());
    } else {
      throw new Error("The environment doesn't have hmac-sha256 function");
    }
  },
  sha256Sync: void 0,
  hmacSha256Sync: void 0,
  taggedHash: async (tag, ...messages2) => {
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === void 0) {
      const tagH = await utils$1.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
      tagP = concatBytes$1(tagH, tagH);
      TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return utils$1.sha256(tagP, ...messages2);
  },
  taggedHashSync: (tag, ...messages2) => {
    if (typeof _sha256Sync !== "function")
      throw new ShaError("sha256Sync is undefined, you need to set it");
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === void 0) {
      const tagH = _sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
      tagP = concatBytes$1(tagH, tagH);
      TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return _sha256Sync(tagP, ...messages2);
  },
  precompute(windowSize = 8, point = Point$1.BASE) {
    const cached = point === Point$1.BASE ? point : new Point$1(point.x, point.y);
    cached._setWindowSize(windowSize);
    cached.multiply(_3n);
    return cached;
  }
};
Object.defineProperties(utils$1, {
  sha256Sync: {
    configurable: false,
    get() {
      return _sha256Sync;
    },
    set(val) {
      if (!_sha256Sync)
        _sha256Sync = val;
    }
  },
  hmacSha256Sync: {
    configurable: false,
    get() {
      return _hmacSha256Sync;
    },
    set(val) {
      if (!_hmacSha256Sync)
        _hmacSha256Sync = val;
    }
  }
});
function randomBytes$3(length3) {
  if (isNaN(length3) || length3 <= 0) {
    throw errCode(new Error("random bytes length must be a Number bigger than 0"), "ERR_INVALID_LENGTH");
  }
  return utils$1.randomBytes(length3);
}
function pkcs1ToJwk(bytes2) {
  const asn12 = forge$s.asn1.fromDer(toString$5(bytes2, "ascii"));
  const privateKey = forge$s.pki.privateKeyFromAsn1(asn12);
  return {
    kty: "RSA",
    n: bigIntegerToUintBase64url(privateKey.n),
    e: bigIntegerToUintBase64url(privateKey.e),
    d: bigIntegerToUintBase64url(privateKey.d),
    p: bigIntegerToUintBase64url(privateKey.p),
    q: bigIntegerToUintBase64url(privateKey.q),
    dp: bigIntegerToUintBase64url(privateKey.dP),
    dq: bigIntegerToUintBase64url(privateKey.dQ),
    qi: bigIntegerToUintBase64url(privateKey.qInv),
    alg: "RS256"
  };
}
function jwkToPkcs1(jwk) {
  if (jwk.n == null || jwk.e == null || jwk.d == null || jwk.p == null || jwk.q == null || jwk.dp == null || jwk.dq == null || jwk.qi == null) {
    throw errCode(new Error("JWK was missing components"), "ERR_INVALID_PARAMETERS");
  }
  const asn12 = forge$s.pki.privateKeyToAsn1({
    n: base64urlToBigInteger(jwk.n),
    e: base64urlToBigInteger(jwk.e),
    d: base64urlToBigInteger(jwk.d),
    p: base64urlToBigInteger(jwk.p),
    q: base64urlToBigInteger(jwk.q),
    dP: base64urlToBigInteger(jwk.dp),
    dQ: base64urlToBigInteger(jwk.dq),
    qInv: base64urlToBigInteger(jwk.qi)
  });
  return fromString$3(forge$s.asn1.toDer(asn12).getBytes(), "ascii");
}
function pkixToJwk(bytes2) {
  const asn12 = forge$s.asn1.fromDer(toString$5(bytes2, "ascii"));
  const publicKey = forge$s.pki.publicKeyFromAsn1(asn12);
  return {
    kty: "RSA",
    n: bigIntegerToUintBase64url(publicKey.n),
    e: bigIntegerToUintBase64url(publicKey.e)
  };
}
function jwkToPkix(jwk) {
  if (jwk.n == null || jwk.e == null) {
    throw errCode(new Error("JWK was missing components"), "ERR_INVALID_PARAMETERS");
  }
  const asn12 = forge$s.pki.publicKeyToAsn1({
    n: base64urlToBigInteger(jwk.n),
    e: base64urlToBigInteger(jwk.e)
  });
  return fromString$3(forge$s.asn1.toDer(asn12).getBytes(), "ascii");
}
function convert(key, types2) {
  return types2.map((t) => base64urlToBigInteger(key[t]));
}
function jwk2priv(key) {
  return forge$s.pki.setRsaPrivateKey(...convert(key, ["n", "e", "d", "p", "q", "dp", "dq", "qi"]));
}
function jwk2pub(key) {
  return forge$s.pki.setRsaPublicKey(...convert(key, ["n", "e"]));
}
async function generateKey$2(bits2) {
  const pair2 = await webcrypto.get().subtle.generateKey({
    name: "RSASSA-PKCS1-v1_5",
    modulusLength: bits2,
    publicExponent: new Uint8Array([1, 0, 1]),
    hash: { name: "SHA-256" }
  }, true, ["sign", "verify"]);
  const keys = await exportKey(pair2);
  return {
    privateKey: keys[0],
    publicKey: keys[1]
  };
}
async function unmarshalPrivateKey$1(key) {
  const privateKey = await webcrypto.get().subtle.importKey("jwk", key, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, true, ["sign"]);
  const pair2 = [
    privateKey,
    await derivePublicFromPrivate(key)
  ];
  const keys = await exportKey({
    privateKey: pair2[0],
    publicKey: pair2[1]
  });
  return {
    privateKey: keys[0],
    publicKey: keys[1]
  };
}
async function hashAndSign$2(key, msg) {
  const privateKey = await webcrypto.get().subtle.importKey("jwk", key, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, false, ["sign"]);
  const sig = await webcrypto.get().subtle.sign({ name: "RSASSA-PKCS1-v1_5" }, privateKey, Uint8Array.from(msg));
  return new Uint8Array(sig, 0, sig.byteLength);
}
async function hashAndVerify$2(key, sig, msg) {
  const publicKey = await webcrypto.get().subtle.importKey("jwk", key, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, false, ["verify"]);
  return await webcrypto.get().subtle.verify({ name: "RSASSA-PKCS1-v1_5" }, publicKey, sig, msg);
}
async function exportKey(pair2) {
  if (pair2.privateKey == null || pair2.publicKey == null) {
    throw errCode(new Error("Private and public key are required"), "ERR_INVALID_PARAMETERS");
  }
  return await Promise.all([
    webcrypto.get().subtle.exportKey("jwk", pair2.privateKey),
    webcrypto.get().subtle.exportKey("jwk", pair2.publicKey)
  ]);
}
async function derivePublicFromPrivate(jwKey) {
  return await webcrypto.get().subtle.importKey("jwk", {
    kty: jwKey.kty,
    n: jwKey.n,
    e: jwKey.e
  }, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, true, ["verify"]);
}
function convertKey(key, pub, msg, handle2) {
  const fkey = pub ? jwk2pub(key) : jwk2priv(key);
  const fmsg = toString$5(Uint8Array.from(msg), "ascii");
  const fomsg = handle2(fmsg, fkey);
  return fromString$3(fomsg, "ascii");
}
function encrypt(key, msg) {
  return convertKey(key, true, msg, (msg2, key2) => key2.encrypt(msg2));
}
function decrypt(key, msg) {
  return convertKey(key, false, msg, (msg2, key2) => key2.decrypt(msg2));
}
async function exporter$1(privateKey, password) {
  const cipher = create$7();
  const encryptedKey = await cipher.encrypt(privateKey, password);
  return base64$4.encode(encryptedKey);
}
class RsaPublicKey {
  constructor(key) {
    this._key = key;
  }
  async verify(data, sig) {
    return await hashAndVerify$2(this._key, sig, data);
  }
  marshal() {
    return jwkToPkix(this._key);
  }
  get bytes() {
    return PublicKey.encode({
      Type: KeyType.RSA,
      Data: this.marshal()
    }).subarray();
  }
  encrypt(bytes2) {
    return encrypt(this._key, bytes2);
  }
  equals(key) {
    return equals$1(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes2 } = await sha256$3.digest(this.bytes);
    return bytes2;
  }
}
class RsaPrivateKey {
  constructor(key, publicKey) {
    this._key = key;
    this._publicKey = publicKey;
  }
  genSecret() {
    return randomBytes$3(16);
  }
  async sign(message2) {
    return await hashAndSign$2(this._key, message2);
  }
  get public() {
    if (this._publicKey == null) {
      throw errCode(new Error("public key not provided"), "ERR_PUBKEY_NOT_PROVIDED");
    }
    return new RsaPublicKey(this._publicKey);
  }
  decrypt(bytes2) {
    return decrypt(this._key, bytes2);
  }
  marshal() {
    return jwkToPkcs1(this._key);
  }
  get bytes() {
    return PrivateKey.encode({
      Type: KeyType.RSA,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals$1(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes2 } = await sha256$3.digest(this.bytes);
    return bytes2;
  }
  async id() {
    const hash2 = await this.public.hash();
    return toString$5(hash2, "base58btc");
  }
  async export(password, format2 = "pkcs-8") {
    if (format2 === "pkcs-8") {
      const buffer2 = new forge$s.util.ByteBuffer(this.marshal());
      const asn12 = forge$s.asn1.fromDer(buffer2);
      const privateKey = forge$s.pki.privateKeyFromAsn1(asn12);
      const options = {
        algorithm: "aes256",
        count: 1e4,
        saltSize: 128 / 8,
        prfAlgorithm: "sha512"
      };
      return forge$s.pki.encryptRsaPrivateKey(privateKey, password, options);
    } else if (format2 === "libp2p-key") {
      return await exporter$1(this.bytes, password);
    } else {
      throw errCode(new Error(`export format '${format2}' is not supported`), "ERR_INVALID_EXPORT_FORMAT");
    }
  }
}
async function unmarshalRsaPrivateKey(bytes2) {
  const jwk = pkcs1ToJwk(bytes2);
  const keys = await unmarshalPrivateKey$1(jwk);
  return new RsaPrivateKey(keys.privateKey, keys.publicKey);
}
function unmarshalRsaPublicKey(bytes2) {
  const jwk = pkixToJwk(bytes2);
  return new RsaPublicKey(jwk);
}
async function fromJwk(jwk) {
  const keys = await unmarshalPrivateKey$1(jwk);
  return new RsaPrivateKey(keys.privateKey, keys.publicKey);
}
async function generateKeyPair$3(bits2) {
  const keys = await generateKey$2(bits2);
  return new RsaPrivateKey(keys.privateKey, keys.publicKey);
}
const RSA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  RsaPublicKey,
  RsaPrivateKey,
  unmarshalRsaPrivateKey,
  unmarshalRsaPublicKey,
  fromJwk,
  generateKeyPair: generateKeyPair$3
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const CU_O = BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989");
const CURVE = Object.freeze({
  a: BigInt(-1),
  d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
  P: BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),
  l: CU_O,
  n: CU_O,
  h: BigInt(8),
  Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
  Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960")
});
const POW_2_256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
const SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742");
const SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
const INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
const ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
const D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
class ExtendedPoint {
  constructor(x, y, z, t) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.t = t;
  }
  static fromAffine(p) {
    if (!(p instanceof Point)) {
      throw new TypeError("ExtendedPoint#fromAffine: expected Point");
    }
    if (p.equals(Point.ZERO))
      return ExtendedPoint.ZERO;
    return new ExtendedPoint(p.x, p.y, _1n, mod(p.x * p.y));
  }
  static toAffineBatch(points) {
    const toInv = invertBatch(points.map((p) => p.z));
    return points.map((p, i2) => p.toAffine(toInv[i2]));
  }
  static normalizeZ(points) {
    return this.toAffineBatch(points).map(this.fromAffine);
  }
  equals(other) {
    assertExtPoint(other);
    const { x: X1, y: Y1, z: Z1 } = this;
    const { x: X2, y: Y2, z: Z2 } = other;
    const X1Z2 = mod(X1 * Z2);
    const X2Z1 = mod(X2 * Z1);
    const Y1Z2 = mod(Y1 * Z2);
    const Y2Z1 = mod(Y2 * Z1);
    return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
  }
  negate() {
    return new ExtendedPoint(mod(-this.x), this.y, this.z, mod(-this.t));
  }
  double() {
    const { x: X1, y: Y1, z: Z1 } = this;
    const { a } = CURVE;
    const A = mod(X1 * X1);
    const B = mod(Y1 * Y1);
    const C = mod(_2n * mod(Z1 * Z1));
    const D = mod(a * A);
    const x1y1 = X1 + Y1;
    const E = mod(mod(x1y1 * x1y1) - A - B);
    const G = D + B;
    const F = G - C;
    const H = D - B;
    const X3 = mod(E * F);
    const Y3 = mod(G * H);
    const T3 = mod(E * H);
    const Z3 = mod(F * G);
    return new ExtendedPoint(X3, Y3, Z3, T3);
  }
  add(other) {
    assertExtPoint(other);
    const { x: X1, y: Y1, z: Z1, t: T1 } = this;
    const { x: X2, y: Y2, z: Z2, t: T2 } = other;
    const A = mod((Y1 - X1) * (Y2 + X2));
    const B = mod((Y1 + X1) * (Y2 - X2));
    const F = mod(B - A);
    if (F === _0n)
      return this.double();
    const C = mod(Z1 * _2n * T2);
    const D = mod(T1 * _2n * Z2);
    const E = D + C;
    const G = B + A;
    const H = D - C;
    const X3 = mod(E * F);
    const Y3 = mod(G * H);
    const T3 = mod(E * H);
    const Z3 = mod(F * G);
    return new ExtendedPoint(X3, Y3, Z3, T3);
  }
  subtract(other) {
    return this.add(other.negate());
  }
  precomputeWindow(W) {
    const windows = 1 + 256 / W;
    const points = [];
    let p = this;
    let base3 = p;
    for (let window2 = 0; window2 < windows; window2++) {
      base3 = p;
      points.push(base3);
      for (let i2 = 1; i2 < 2 ** (W - 1); i2++) {
        base3 = base3.add(p);
        points.push(base3);
      }
      p = base3.double();
    }
    return points;
  }
  wNAF(n, affinePoint) {
    if (!affinePoint && this.equals(ExtendedPoint.BASE))
      affinePoint = Point.BASE;
    const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
    if (256 % W) {
      throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
    }
    let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
    if (!precomputes) {
      precomputes = this.precomputeWindow(W);
      if (affinePoint && W !== 1) {
        precomputes = ExtendedPoint.normalizeZ(precomputes);
        pointPrecomputes.set(affinePoint, precomputes);
      }
    }
    let p = ExtendedPoint.ZERO;
    let f = ExtendedPoint.ZERO;
    const windows = 1 + 256 / W;
    const windowSize = 2 ** (W - 1);
    const mask = BigInt(2 ** W - 1);
    const maxNumber = 2 ** W;
    const shiftBy = BigInt(W);
    for (let window2 = 0; window2 < windows; window2++) {
      const offset = window2 * windowSize;
      let wbits = Number(n & mask);
      n >>= shiftBy;
      if (wbits > windowSize) {
        wbits -= maxNumber;
        n += _1n;
      }
      if (wbits === 0) {
        let pr = precomputes[offset];
        if (window2 % 2)
          pr = pr.negate();
        f = f.add(pr);
      } else {
        let cached = precomputes[offset + Math.abs(wbits) - 1];
        if (wbits < 0)
          cached = cached.negate();
        p = p.add(cached);
      }
    }
    return ExtendedPoint.normalizeZ([p, f])[0];
  }
  multiply(scalar, affinePoint) {
    return this.wNAF(normalizeScalar(scalar, CURVE.l), affinePoint);
  }
  multiplyUnsafe(scalar) {
    let n = normalizeScalar(scalar, CURVE.l, false);
    const G = ExtendedPoint.BASE;
    const P0 = ExtendedPoint.ZERO;
    if (n === _0n)
      return P0;
    if (this.equals(P0) || n === _1n)
      return this;
    if (this.equals(G))
      return this.wNAF(n);
    let p = P0;
    let d = this;
    while (n > _0n) {
      if (n & _1n)
        p = p.add(d);
      d = d.double();
      n >>= _1n;
    }
    return p;
  }
  isSmallOrder() {
    return this.multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);
  }
  isTorsionFree() {
    return this.multiplyUnsafe(CURVE.l).equals(ExtendedPoint.ZERO);
  }
  toAffine(invZ = invert(this.z)) {
    const { x, y, z } = this;
    const ax = mod(x * invZ);
    const ay = mod(y * invZ);
    const zz = mod(z * invZ);
    if (zz !== _1n)
      throw new Error("invZ was invalid");
    return new Point(ax, ay);
  }
  fromRistrettoBytes() {
    legacyRist();
  }
  toRistrettoBytes() {
    legacyRist();
  }
  fromRistrettoHash() {
    legacyRist();
  }
}
ExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n, mod(CURVE.Gx * CURVE.Gy));
ExtendedPoint.ZERO = new ExtendedPoint(_0n, _1n, _1n, _0n);
function assertExtPoint(other) {
  if (!(other instanceof ExtendedPoint))
    throw new TypeError("ExtendedPoint expected");
}
function assertRstPoint(other) {
  if (!(other instanceof RistrettoPoint))
    throw new TypeError("RistrettoPoint expected");
}
function legacyRist() {
  throw new Error("Legacy method: switch to RistrettoPoint");
}
class RistrettoPoint {
  constructor(ep) {
    this.ep = ep;
  }
  static calcElligatorRistrettoMap(r0) {
    const { d } = CURVE;
    const r = mod(SQRT_M1 * r0 * r0);
    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);
    let c = BigInt(-1);
    const D = mod((c - d * r) * mod(r + d));
    let { isValid: Ns_D_is_sq, value: s2 } = uvRatio(Ns, D);
    let s_ = mod(s2 * r0);
    if (!edIsNegative(s_))
      s_ = mod(-s_);
    if (!Ns_D_is_sq)
      s2 = s_;
    if (!Ns_D_is_sq)
      c = r;
    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);
    const s22 = s2 * s2;
    const W0 = mod((s2 + s2) * D);
    const W1 = mod(Nt * SQRT_AD_MINUS_ONE);
    const W2 = mod(_1n - s22);
    const W3 = mod(_1n + s22);
    return new ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));
  }
  static hashToCurve(hex) {
    hex = ensureBytes(hex, 64);
    const r1 = bytes255ToNumberLE(hex.slice(0, 32));
    const R1 = this.calcElligatorRistrettoMap(r1);
    const r2 = bytes255ToNumberLE(hex.slice(32, 64));
    const R2 = this.calcElligatorRistrettoMap(r2);
    return new RistrettoPoint(R1.add(R2));
  }
  static fromHex(hex) {
    hex = ensureBytes(hex, 32);
    const { a, d } = CURVE;
    const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
    const s2 = bytes255ToNumberLE(hex);
    if (!equalBytes(numberTo32BytesLE(s2), hex) || edIsNegative(s2))
      throw new Error(emsg);
    const s22 = mod(s2 * s2);
    const u1 = mod(_1n + a * s22);
    const u2 = mod(_1n - a * s22);
    const u1_2 = mod(u1 * u1);
    const u2_2 = mod(u2 * u2);
    const v = mod(a * d * u1_2 - u2_2);
    const { isValid, value: I } = invertSqrt(mod(v * u2_2));
    const Dx = mod(I * u2);
    const Dy = mod(I * Dx * v);
    let x = mod((s2 + s2) * Dx);
    if (edIsNegative(x))
      x = mod(-x);
    const y = mod(u1 * Dy);
    const t = mod(x * y);
    if (!isValid || edIsNegative(t) || y === _0n)
      throw new Error(emsg);
    return new RistrettoPoint(new ExtendedPoint(x, y, _1n, t));
  }
  toRawBytes() {
    let { x, y, z, t } = this.ep;
    const u1 = mod(mod(z + y) * mod(z - y));
    const u2 = mod(x * y);
    const u2sq = mod(u2 * u2);
    const { value: invsqrt } = invertSqrt(mod(u1 * u2sq));
    const D1 = mod(invsqrt * u1);
    const D2 = mod(invsqrt * u2);
    const zInv = mod(D1 * D2 * t);
    let D;
    if (edIsNegative(t * zInv)) {
      let _x = mod(y * SQRT_M1);
      let _y = mod(x * SQRT_M1);
      x = _x;
      y = _y;
      D = mod(D1 * INVSQRT_A_MINUS_D);
    } else {
      D = D2;
    }
    if (edIsNegative(x * zInv))
      y = mod(-y);
    let s2 = mod((z - y) * D);
    if (edIsNegative(s2))
      s2 = mod(-s2);
    return numberTo32BytesLE(s2);
  }
  toHex() {
    return bytesToHex(this.toRawBytes());
  }
  toString() {
    return this.toHex();
  }
  equals(other) {
    assertRstPoint(other);
    const a = this.ep;
    const b2 = other.ep;
    const one = mod(a.x * b2.y) === mod(a.y * b2.x);
    const two = mod(a.y * b2.y) === mod(a.x * b2.x);
    return one || two;
  }
  add(other) {
    assertRstPoint(other);
    return new RistrettoPoint(this.ep.add(other.ep));
  }
  subtract(other) {
    assertRstPoint(other);
    return new RistrettoPoint(this.ep.subtract(other.ep));
  }
  multiply(scalar) {
    return new RistrettoPoint(this.ep.multiply(scalar));
  }
  multiplyUnsafe(scalar) {
    return new RistrettoPoint(this.ep.multiplyUnsafe(scalar));
  }
}
RistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);
RistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);
const pointPrecomputes = /* @__PURE__ */ new WeakMap();
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  _setWindowSize(windowSize) {
    this._WINDOW_SIZE = windowSize;
    pointPrecomputes.delete(this);
  }
  static fromHex(hex, strict = true) {
    const { d, P } = CURVE;
    hex = ensureBytes(hex, 32);
    const normed = hex.slice();
    normed[31] = hex[31] & ~128;
    const y = bytesToNumberLE(normed);
    if (strict && y >= P)
      throw new Error("Expected 0 < hex < P");
    if (!strict && y >= POW_2_256)
      throw new Error("Expected 0 < hex < 2**256");
    const y2 = mod(y * y);
    const u = mod(y2 - _1n);
    const v = mod(d * y2 + _1n);
    let { isValid, value: x } = uvRatio(u, v);
    if (!isValid)
      throw new Error("Point.fromHex: invalid y coordinate");
    const isXOdd = (x & _1n) === _1n;
    const isLastByteOdd = (hex[31] & 128) !== 0;
    if (isLastByteOdd !== isXOdd) {
      x = mod(-x);
    }
    return new Point(x, y);
  }
  static async fromPrivateKey(privateKey) {
    return (await getExtendedPublicKey(privateKey)).point;
  }
  toRawBytes() {
    const bytes2 = numberTo32BytesLE(this.y);
    bytes2[31] |= this.x & _1n ? 128 : 0;
    return bytes2;
  }
  toHex() {
    return bytesToHex(this.toRawBytes());
  }
  toX25519() {
    const { y } = this;
    const u = mod((_1n + y) * invert(_1n - y));
    return numberTo32BytesLE(u);
  }
  isTorsionFree() {
    return ExtendedPoint.fromAffine(this).isTorsionFree();
  }
  equals(other) {
    return this.x === other.x && this.y === other.y;
  }
  negate() {
    return new Point(mod(-this.x), this.y);
  }
  add(other) {
    return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();
  }
  subtract(other) {
    return this.add(other.negate());
  }
  multiply(scalar) {
    return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();
  }
}
Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
Point.ZERO = new Point(_0n, _1n);
class Signature {
  constructor(r, s2) {
    this.r = r;
    this.s = s2;
    this.assertValidity();
  }
  static fromHex(hex) {
    const bytes2 = ensureBytes(hex, 64);
    const r = Point.fromHex(bytes2.slice(0, 32), false);
    const s2 = bytesToNumberLE(bytes2.slice(32, 64));
    return new Signature(r, s2);
  }
  assertValidity() {
    const { r, s: s2 } = this;
    if (!(r instanceof Point))
      throw new Error("Expected Point instance");
    normalizeScalar(s2, CURVE.l, false);
    return this;
  }
  toRawBytes() {
    const u8 = new Uint8Array(64);
    u8.set(this.r.toRawBytes());
    u8.set(numberTo32BytesLE(this.s), 32);
    return u8;
  }
  toHex() {
    return bytesToHex(this.toRawBytes());
  }
}
function concatBytes(...arrays) {
  if (!arrays.every((a) => a instanceof Uint8Array))
    throw new Error("Expected Uint8Array list");
  if (arrays.length === 1)
    return arrays[0];
  const length3 = arrays.reduce((a, arr) => a + arr.length, 0);
  const result = new Uint8Array(length3);
  for (let i2 = 0, pad = 0; i2 < arrays.length; i2++) {
    const arr = arrays[i2];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
}
const hexes = Array.from({ length: 256 }, (v, i2) => i2.toString(16).padStart(2, "0"));
function bytesToHex(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i2 = 0; i2 < uint8a.length; i2++) {
    hex += hexes[uint8a[i2]];
  }
  return hex;
}
function hexToBytes(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToBytes: expected string, got " + typeof hex);
  }
  if (hex.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex");
  const array = new Uint8Array(hex.length / 2);
  for (let i2 = 0; i2 < array.length; i2++) {
    const j = i2 * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i2] = byte;
  }
  return array;
}
function numberTo32BytesBE(num) {
  const length3 = 32;
  const hex = num.toString(16).padStart(length3 * 2, "0");
  return hexToBytes(hex);
}
function numberTo32BytesLE(num) {
  return numberTo32BytesBE(num).reverse();
}
function edIsNegative(num) {
  return (mod(num) & _1n) === _1n;
}
function bytesToNumberLE(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  return BigInt("0x" + bytesToHex(Uint8Array.from(uint8a).reverse()));
}
const MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function bytes255ToNumberLE(bytes2) {
  return mod(bytesToNumberLE(bytes2) & MAX_255B);
}
function mod(a, b2 = CURVE.P) {
  const res = a % b2;
  return res >= _0n ? res : b2 + res;
}
function invert(number, modulo = CURVE.P) {
  if (number === _0n || modulo <= _0n) {
    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
  }
  let a = mod(number, modulo);
  let b2 = modulo;
  let x = _0n, u = _1n;
  while (a !== _0n) {
    const q = b2 / a;
    const r = b2 % a;
    const m = x - u * q;
    b2 = a, a = r, x = u, u = m;
  }
  const gcd = b2;
  if (gcd !== _1n)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function invertBatch(nums, p = CURVE.P) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i2) => {
    if (num === _0n)
      return acc;
    tmp[i2] = acc;
    return mod(acc * num, p);
  }, _1n);
  const inverted = invert(lastMultiplied, p);
  nums.reduceRight((acc, num, i2) => {
    if (num === _0n)
      return acc;
    tmp[i2] = mod(acc * tmp[i2], p);
    return mod(acc * num, p);
  }, inverted);
  return tmp;
}
function pow2(x, power) {
  const { P } = CURVE;
  let res = x;
  while (power-- > _0n) {
    res *= res;
    res %= P;
  }
  return res;
}
function pow_2_252_3(x) {
  const { P } = CURVE;
  const _5n = BigInt(5);
  const _10n = BigInt(10);
  const _20n = BigInt(20);
  const _40n = BigInt(40);
  const _80n = BigInt(80);
  const x2 = x * x % P;
  const b2 = x2 * x % P;
  const b4 = pow2(b2, _2n) * b2 % P;
  const b5 = pow2(b4, _1n) * x % P;
  const b10 = pow2(b5, _5n) * b5 % P;
  const b20 = pow2(b10, _10n) * b10 % P;
  const b40 = pow2(b20, _20n) * b20 % P;
  const b80 = pow2(b40, _40n) * b40 % P;
  const b160 = pow2(b80, _80n) * b80 % P;
  const b240 = pow2(b160, _80n) * b80 % P;
  const b250 = pow2(b240, _10n) * b10 % P;
  const pow_p_5_8 = pow2(b250, _2n) * x % P;
  return { pow_p_5_8, b2 };
}
function uvRatio(u, v) {
  const v3 = mod(v * v * v);
  const v7 = mod(v3 * v3 * v);
  const pow = pow_2_252_3(u * v7).pow_p_5_8;
  let x = mod(u * v3 * pow);
  const vx2 = mod(v * x * x);
  const root1 = x;
  const root2 = mod(x * SQRT_M1);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod(-u);
  const noRoot = vx2 === mod(-u * SQRT_M1);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if (edIsNegative(x))
    x = mod(-x);
  return { isValid: useRoot1 || useRoot2, value: x };
}
function invertSqrt(number) {
  return uvRatio(_1n, number);
}
function modlLE(hash2) {
  return mod(bytesToNumberLE(hash2), CURVE.l);
}
function equalBytes(b1, b2) {
  if (b1.length !== b2.length) {
    return false;
  }
  for (let i2 = 0; i2 < b1.length; i2++) {
    if (b1[i2] !== b2[i2]) {
      return false;
    }
  }
  return true;
}
function ensureBytes(hex, expectedLength) {
  const bytes2 = hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);
  if (typeof expectedLength === "number" && bytes2.length !== expectedLength)
    throw new Error(`Expected ${expectedLength} bytes`);
  return bytes2;
}
function normalizeScalar(num, max, strict = true) {
  if (!max)
    throw new TypeError("Specify max value");
  if (typeof num === "number" && Number.isSafeInteger(num))
    num = BigInt(num);
  if (typeof num === "bigint" && num < max) {
    if (strict) {
      if (_0n < num)
        return num;
    } else {
      if (_0n <= num)
        return num;
    }
  }
  throw new TypeError("Expected valid scalar: 0 < scalar < max");
}
function adjustBytes25519(bytes2) {
  bytes2[0] &= 248;
  bytes2[31] &= 127;
  bytes2[31] |= 64;
  return bytes2;
}
function checkPrivateKey(key) {
  key = typeof key === "bigint" || typeof key === "number" ? numberTo32BytesBE(normalizeScalar(key, POW_2_256)) : ensureBytes(key);
  if (key.length !== 32)
    throw new Error(`Expected 32 bytes`);
  return key;
}
function getKeyFromHash(hashed) {
  const head = adjustBytes25519(hashed.slice(0, 32));
  const prefix = hashed.slice(32, 64);
  const scalar = modlLE(head);
  const point = Point.BASE.multiply(scalar);
  const pointBytes = point.toRawBytes();
  return { head, prefix, scalar, point, pointBytes };
}
let _sha512Sync;
async function getExtendedPublicKey(key) {
  return getKeyFromHash(await utils.sha512(checkPrivateKey(key)));
}
async function getPublicKey(privateKey) {
  return (await getExtendedPublicKey(privateKey)).pointBytes;
}
async function sign(message2, privateKey) {
  message2 = ensureBytes(message2);
  const { prefix, scalar, pointBytes } = await getExtendedPublicKey(privateKey);
  const r = modlLE(await utils.sha512(prefix, message2));
  const R2 = Point.BASE.multiply(r);
  const k = modlLE(await utils.sha512(R2.toRawBytes(), pointBytes, message2));
  const s2 = mod(r + k * scalar, CURVE.l);
  return new Signature(R2, s2).toRawBytes();
}
function prepareVerification(sig, message2, publicKey) {
  message2 = ensureBytes(message2);
  if (!(publicKey instanceof Point))
    publicKey = Point.fromHex(publicKey, false);
  const { r, s: s2 } = sig instanceof Signature ? sig.assertValidity() : Signature.fromHex(sig);
  const SB = ExtendedPoint.BASE.multiplyUnsafe(s2);
  return { r, s: s2, SB, pub: publicKey, msg: message2 };
}
function finishVerification(publicKey, r, SB, hashed) {
  const k = modlLE(hashed);
  const kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);
  const RkA = ExtendedPoint.fromAffine(r).add(kA);
  return RkA.subtract(SB).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);
}
async function verify(sig, message2, publicKey) {
  const { r, SB, msg, pub } = prepareVerification(sig, message2, publicKey);
  const hashed = await utils.sha512(r.toRawBytes(), pub.toRawBytes(), msg);
  return finishVerification(pub, r, SB, hashed);
}
Point.BASE._setWindowSize(8);
const crypto$3 = {
  node: nodeCrypto,
  web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
};
const utils = {
  bytesToHex,
  hexToBytes,
  concatBytes,
  getExtendedPublicKey,
  mod,
  invert,
  TORSION_SUBGROUP: [
    "0100000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
    "0000000000000000000000000000000000000000000000000000000000000080",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
    "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
    "0000000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
  ],
  hashToPrivateScalar: (hash2) => {
    hash2 = ensureBytes(hash2);
    if (hash2.length < 40 || hash2.length > 1024)
      throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");
    return mod(bytesToNumberLE(hash2), CURVE.l - _1n) + _1n;
  },
  randomBytes: (bytesLength = 32) => {
    if (crypto$3.web) {
      return crypto$3.web.getRandomValues(new Uint8Array(bytesLength));
    } else if (crypto$3.node) {
      const { randomBytes: randomBytes2 } = crypto$3.node;
      return new Uint8Array(randomBytes2(bytesLength).buffer);
    } else {
      throw new Error("The environment doesn't have randomBytes function");
    }
  },
  randomPrivateKey: () => {
    return utils.randomBytes(32);
  },
  sha512: async (...messages2) => {
    const message2 = concatBytes(...messages2);
    if (crypto$3.web) {
      const buffer2 = await crypto$3.web.subtle.digest("SHA-512", message2.buffer);
      return new Uint8Array(buffer2);
    } else if (crypto$3.node) {
      return Uint8Array.from(crypto$3.node.createHash("sha512").update(message2).digest());
    } else {
      throw new Error("The environment doesn't have sha512 function");
    }
  },
  precompute(windowSize = 8, point = Point.BASE) {
    const cached = point.equals(Point.BASE) ? point : new Point(point.x, point.y);
    cached._setWindowSize(windowSize);
    cached.multiply(_2n);
    return cached;
  },
  sha512Sync: void 0
};
Object.defineProperties(utils, {
  sha512Sync: {
    configurable: false,
    get() {
      return _sha512Sync;
    },
    set(val) {
      if (!_sha512Sync)
        _sha512Sync = val;
    }
  }
});
const PUBLIC_KEY_BYTE_LENGTH = 32;
const PRIVATE_KEY_BYTE_LENGTH = 64;
const KEYS_BYTE_LENGTH = 32;
async function generateKey$1() {
  const privateKeyRaw = utils.randomPrivateKey();
  const publicKey = await getPublicKey(privateKeyRaw);
  const privateKey = concatKeys(privateKeyRaw, publicKey);
  return {
    privateKey,
    publicKey
  };
}
async function generateKeyFromSeed(seed2) {
  if (seed2.length !== KEYS_BYTE_LENGTH) {
    throw new TypeError('"seed" must be 32 bytes in length.');
  } else if (!(seed2 instanceof Uint8Array)) {
    throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');
  }
  const privateKeyRaw = seed2;
  const publicKey = await getPublicKey(privateKeyRaw);
  const privateKey = concatKeys(privateKeyRaw, publicKey);
  return {
    privateKey,
    publicKey
  };
}
async function hashAndSign$1(privateKey, msg) {
  const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH);
  return await sign(msg, privateKeyRaw);
}
async function hashAndVerify$1(publicKey, sig, msg) {
  return await verify(sig, msg, publicKey);
}
function concatKeys(privateKeyRaw, publicKey) {
  const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH);
  for (let i2 = 0; i2 < KEYS_BYTE_LENGTH; i2++) {
    privateKey[i2] = privateKeyRaw[i2];
    privateKey[KEYS_BYTE_LENGTH + i2] = publicKey[i2];
  }
  return privateKey;
}
class Ed25519PublicKey {
  constructor(key) {
    this._key = ensureKey(key, PUBLIC_KEY_BYTE_LENGTH);
  }
  async verify(data, sig) {
    return await hashAndVerify$1(this._key, sig, data);
  }
  marshal() {
    return this._key;
  }
  get bytes() {
    return PublicKey.encode({
      Type: KeyType.Ed25519,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals$1(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes2 } = await sha256$3.digest(this.bytes);
    return bytes2;
  }
}
class Ed25519PrivateKey {
  constructor(key, publicKey) {
    this._key = ensureKey(key, PRIVATE_KEY_BYTE_LENGTH);
    this._publicKey = ensureKey(publicKey, PUBLIC_KEY_BYTE_LENGTH);
  }
  async sign(message2) {
    return await hashAndSign$1(this._key, message2);
  }
  get public() {
    return new Ed25519PublicKey(this._publicKey);
  }
  marshal() {
    return this._key;
  }
  get bytes() {
    return PrivateKey.encode({
      Type: KeyType.Ed25519,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals$1(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes2 } = await sha256$3.digest(this.bytes);
    return bytes2;
  }
  async id() {
    const encoding2 = await identity$5.digest(this.public.bytes);
    return base58btc$1.encode(encoding2.bytes).substring(1);
  }
  async export(password, format2 = "libp2p-key") {
    if (format2 === "libp2p-key") {
      return await exporter$1(this.bytes, password);
    } else {
      throw errCode(new Error(`export format '${format2}' is not supported`), "ERR_INVALID_EXPORT_FORMAT");
    }
  }
}
function unmarshalEd25519PrivateKey(bytes2) {
  if (bytes2.length > PRIVATE_KEY_BYTE_LENGTH) {
    bytes2 = ensureKey(bytes2, PRIVATE_KEY_BYTE_LENGTH + PUBLIC_KEY_BYTE_LENGTH);
    const privateKeyBytes2 = bytes2.subarray(0, PRIVATE_KEY_BYTE_LENGTH);
    const publicKeyBytes2 = bytes2.subarray(PRIVATE_KEY_BYTE_LENGTH, bytes2.length);
    return new Ed25519PrivateKey(privateKeyBytes2, publicKeyBytes2);
  }
  bytes2 = ensureKey(bytes2, PRIVATE_KEY_BYTE_LENGTH);
  const privateKeyBytes = bytes2.subarray(0, PRIVATE_KEY_BYTE_LENGTH);
  const publicKeyBytes = bytes2.subarray(PUBLIC_KEY_BYTE_LENGTH);
  return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);
}
function unmarshalEd25519PublicKey(bytes2) {
  bytes2 = ensureKey(bytes2, PUBLIC_KEY_BYTE_LENGTH);
  return new Ed25519PublicKey(bytes2);
}
async function generateKeyPair$2() {
  const { privateKey, publicKey } = await generateKey$1();
  return new Ed25519PrivateKey(privateKey, publicKey);
}
async function generateKeyPairFromSeed(seed2) {
  const { privateKey, publicKey } = await generateKeyFromSeed(seed2);
  return new Ed25519PrivateKey(privateKey, publicKey);
}
function ensureKey(key, length3) {
  key = Uint8Array.from(key ?? []);
  if (key.length !== length3) {
    throw errCode(new Error(`Key must be a Uint8Array of length ${length3}, got ${key.length}`), "ERR_INVALID_KEY_TYPE");
  }
  return key;
}
const Ed25519 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Ed25519PublicKey,
  Ed25519PrivateKey,
  unmarshalEd25519PrivateKey,
  unmarshalEd25519PublicKey,
  generateKeyPair: generateKeyPair$2,
  generateKeyPairFromSeed
}, Symbol.toStringTag, { value: "Module" }));
function generateKey() {
  return utils$1.randomPrivateKey();
}
async function hashAndSign(key, msg) {
  const { digest: digest2 } = await sha256$3.digest(msg);
  try {
    return await sign$1(digest2, key);
  } catch (err2) {
    throw errCode(err2, "ERR_INVALID_INPUT");
  }
}
async function hashAndVerify(key, sig, msg) {
  try {
    const { digest: digest2 } = await sha256$3.digest(msg);
    return verify$1(sig, digest2, key);
  } catch (err2) {
    throw errCode(err2, "ERR_INVALID_INPUT");
  }
}
function compressPublicKey(key) {
  const point = Point$1.fromHex(key).toRawBytes(true);
  return point;
}
function validatePrivateKey(key) {
  try {
    getPublicKey$1(key, true);
  } catch (err2) {
    throw errCode(err2, "ERR_INVALID_PRIVATE_KEY");
  }
}
function validatePublicKey(key) {
  try {
    Point$1.fromHex(key);
  } catch (err2) {
    throw errCode(err2, "ERR_INVALID_PUBLIC_KEY");
  }
}
function computePublicKey(privateKey) {
  try {
    return getPublicKey$1(privateKey, true);
  } catch (err2) {
    throw errCode(err2, "ERR_INVALID_PRIVATE_KEY");
  }
}
class Secp256k1PublicKey {
  constructor(key) {
    validatePublicKey(key);
    this._key = key;
  }
  async verify(data, sig) {
    return await hashAndVerify(this._key, sig, data);
  }
  marshal() {
    return compressPublicKey(this._key);
  }
  get bytes() {
    return PublicKey.encode({
      Type: KeyType.Secp256k1,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals$1(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes2 } = await sha256$3.digest(this.bytes);
    return bytes2;
  }
}
class Secp256k1PrivateKey {
  constructor(key, publicKey) {
    this._key = key;
    this._publicKey = publicKey ?? computePublicKey(key);
    validatePrivateKey(this._key);
    validatePublicKey(this._publicKey);
  }
  async sign(message2) {
    return await hashAndSign(this._key, message2);
  }
  get public() {
    return new Secp256k1PublicKey(this._publicKey);
  }
  marshal() {
    return this._key;
  }
  get bytes() {
    return PrivateKey.encode({
      Type: KeyType.Secp256k1,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals$1(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes2 } = await sha256$3.digest(this.bytes);
    return bytes2;
  }
  async id() {
    const hash2 = await this.public.hash();
    return toString$5(hash2, "base58btc");
  }
  async export(password, format2 = "libp2p-key") {
    if (format2 === "libp2p-key") {
      return await exporter$1(this.bytes, password);
    } else {
      throw errCode(new Error(`export format '${format2}' is not supported`), "ERR_INVALID_EXPORT_FORMAT");
    }
  }
}
function unmarshalSecp256k1PrivateKey(bytes2) {
  return new Secp256k1PrivateKey(bytes2);
}
function unmarshalSecp256k1PublicKey(bytes2) {
  return new Secp256k1PublicKey(bytes2);
}
async function generateKeyPair$1() {
  const privateKeyBytes = await generateKey();
  return new Secp256k1PrivateKey(privateKeyBytes);
}
const Secp256k1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Secp256k1PublicKey,
  Secp256k1PrivateKey,
  unmarshalSecp256k1PrivateKey,
  unmarshalSecp256k1PublicKey,
  generateKeyPair: generateKeyPair$1
}, Symbol.toStringTag, { value: "Module" }));
const supportedKeys = {
  rsa: RSA,
  ed25519: Ed25519,
  secp256k1: Secp256k1
};
function unsupportedKey(type) {
  const supported = Object.keys(supportedKeys).join(" / ");
  return errCode(new Error(`invalid or unsupported key type ${type}. Must be ${supported}`), "ERR_UNSUPPORTED_KEY_TYPE");
}
function typeToKey(type) {
  type = type.toLowerCase();
  if (type === "rsa" || type === "ed25519" || type === "secp256k1") {
    return supportedKeys[type];
  }
  throw unsupportedKey(type);
}
async function generateKeyPair(type, bits2) {
  return await typeToKey(type).generateKeyPair(bits2 ?? 2048);
}
function unmarshalPublicKey(buf2) {
  const decoded = PublicKey.decode(buf2);
  const data = decoded.Data ?? new Uint8Array();
  switch (decoded.Type) {
    case KeyType.RSA:
      return supportedKeys.rsa.unmarshalRsaPublicKey(data);
    case KeyType.Ed25519:
      return supportedKeys.ed25519.unmarshalEd25519PublicKey(data);
    case KeyType.Secp256k1:
      return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data);
    default:
      throw unsupportedKey(decoded.Type ?? "RSA");
  }
}
function marshalPublicKey(key, type) {
  type = (type ?? "rsa").toLowerCase();
  typeToKey(type);
  return key.bytes;
}
async function unmarshalPrivateKey(buf2) {
  const decoded = PrivateKey.decode(buf2);
  const data = decoded.Data ?? new Uint8Array();
  switch (decoded.Type) {
    case KeyType.RSA:
      return await supportedKeys.rsa.unmarshalRsaPrivateKey(data);
    case KeyType.Ed25519:
      return supportedKeys.ed25519.unmarshalEd25519PrivateKey(data);
    case KeyType.Secp256k1:
      return supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data);
    default:
      throw unsupportedKey(decoded.Type ?? "RSA");
  }
}
function marshalPrivateKey(key, type) {
  type = (type ?? "rsa").toLowerCase();
  typeToKey(type);
  return key.bytes;
}
async function importKey(encryptedKey, password) {
  try {
    const key2 = await importer$1(encryptedKey, password);
    return await unmarshalPrivateKey(key2);
  } catch (_) {
  }
  const key = forge$s.pki.decryptRsaPrivateKey(encryptedKey, password);
  if (key === null) {
    throw errCode(new Error("Cannot read the key, most likely the password is wrong or not a RSA key"), "ERR_CANNOT_DECRYPT_PEM");
  }
  let der = forge$s.asn1.toDer(forge$s.pki.privateKeyToAsn1(key));
  der = fromString$3(der.getBytes(), "ascii");
  return await supportedKeys.rsa.unmarshalRsaPrivateKey(der);
}
const ERR_IPNS_EXPIRED_RECORD = "ERR_IPNS_EXPIRED_RECORD";
const ERR_UNRECOGNIZED_VALIDITY = "ERR_UNRECOGNIZED_VALIDITY";
const ERR_SIGNATURE_CREATION = "ERR_SIGNATURE_CREATION";
const ERR_SIGNATURE_VERIFICATION = "ERR_SIGNATURE_VERIFICATION";
const ERR_UNRECOGNIZED_FORMAT = "ERR_UNRECOGNIZED_FORMAT";
const ERR_UNDEFINED_PARAMETER = "ERR_UNDEFINED_PARAMETER";
const ERR_INVALID_RECORD_DATA = "ERR_INVALID_RECORD_DATA";
const ERR_INVALID_EMBEDDED_KEY = "ERR_INVALID_EMBEDDED_KEY";
const ERR_MISSING_PRIVATE_KEY = "ERR_MISSING_PRIVATE_KEY";
var IpnsEntry;
(function(IpnsEntry2) {
  (function(ValidityType) {
    ValidityType["EOL"] = "EOL";
  })(IpnsEntry2.ValidityType || (IpnsEntry2.ValidityType = {}));
  let __ValidityTypeValues;
  (function(__ValidityTypeValues2) {
    __ValidityTypeValues2[__ValidityTypeValues2["EOL"] = 0] = "EOL";
  })(__ValidityTypeValues || (__ValidityTypeValues = {}));
  (function(ValidityType) {
    ValidityType.codec = () => {
      return enumeration(__ValidityTypeValues);
    };
  })(IpnsEntry2.ValidityType || (IpnsEntry2.ValidityType = {}));
  let _codec;
  IpnsEntry2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.value != null) {
          w.uint32(10);
          w.bytes(obj.value);
        }
        if (obj.signature != null) {
          w.uint32(18);
          w.bytes(obj.signature);
        }
        if (obj.validityType != null) {
          w.uint32(24);
          IpnsEntry2.ValidityType.codec().encode(obj.validityType, w);
        }
        if (obj.validity != null) {
          w.uint32(34);
          w.bytes(obj.validity);
        }
        if (obj.sequence != null) {
          w.uint32(40);
          w.uint64(obj.sequence);
        }
        if (obj.ttl != null) {
          w.uint32(48);
          w.uint64(obj.ttl);
        }
        if (obj.pubKey != null) {
          w.uint32(58);
          w.bytes(obj.pubKey);
        }
        if (obj.signatureV2 != null) {
          w.uint32(66);
          w.bytes(obj.signatureV2);
        }
        if (obj.data != null) {
          w.uint32(74);
          w.bytes(obj.data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length3) => {
        const obj = {};
        const end2 = length3 == null ? reader2.len : reader2.pos + length3;
        while (reader2.pos < end2) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.value = reader2.bytes();
              break;
            case 2:
              obj.signature = reader2.bytes();
              break;
            case 3:
              obj.validityType = IpnsEntry2.ValidityType.codec().decode(reader2);
              break;
            case 4:
              obj.validity = reader2.bytes();
              break;
            case 5:
              obj.sequence = reader2.uint64();
              break;
            case 6:
              obj.ttl = reader2.uint64();
              break;
            case 7:
              obj.pubKey = reader2.bytes();
              break;
            case 8:
              obj.signatureV2 = reader2.bytes();
              break;
            case 9:
              obj.data = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  IpnsEntry2.encode = (obj) => {
    return encodeMessage(obj, IpnsEntry2.codec());
  };
  IpnsEntry2.decode = (buf2) => {
    return decodeMessage(buf2, IpnsEntry2.codec());
  };
})(IpnsEntry || (IpnsEntry = {}));
const log$1E = logger$1("ipns:utils");
const IPNS_PREFIX$1 = fromString$3("/ipns/");
function parseRFC3339$1(time) {
  const rfc3339Matcher = new RegExp(
    "(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z"
  );
  const m = String(time).trim().match(rfc3339Matcher);
  if (m == null) {
    throw new Error("Invalid format");
  }
  const year = parseInt(m[1], 10);
  const month = parseInt(m[2], 10) - 1;
  const date = parseInt(m[3], 10);
  const hour2 = parseInt(m[4], 10);
  const minute2 = parseInt(m[5], 10);
  const second2 = parseInt(m[6], 10);
  const millisecond = parseInt(m[7].slice(0, -6), 10);
  return new Date(Date.UTC(year, month, date, hour2, minute2, second2, millisecond));
}
const extractPublicKey = async (peerId, entry) => {
  if (entry == null || peerId == null) {
    const error2 = new Error("one or more of the provided parameters are not defined");
    log$1E.error(error2);
    throw errCode(error2, ERR_UNDEFINED_PARAMETER);
  }
  let pubKey;
  if (entry.pubKey != null) {
    try {
      pubKey = unmarshalPublicKey(entry.pubKey);
    } catch (err2) {
      log$1E.error(err2);
      throw err2;
    }
    const otherId = await peerIdFromKeys(entry.pubKey);
    if (!otherId.equals(peerId)) {
      throw errCode(new Error("Embedded public key did not match PeerID"), ERR_INVALID_EMBEDDED_KEY);
    }
  } else if (peerId.publicKey != null) {
    pubKey = unmarshalPublicKey(peerId.publicKey);
  }
  if (pubKey != null) {
    return pubKey;
  }
  throw errCode(new Error("no public key is available"), ERR_UNDEFINED_PARAMETER);
};
const ipnsEntryDataForV1Sig = (value2, validityType, validity) => {
  const validityTypeBuffer = fromString$3(validityType);
  return concat$1([value2, validity, validityTypeBuffer]);
};
const ipnsEntryDataForV2Sig = (data) => {
  const entryData = fromString$3("ipns-signature:");
  return concat$1([entryData, data]);
};
const marshal = (obj) => {
  return IpnsEntry.encode(obj);
};
const unmarshal = (buf2) => {
  const message2 = IpnsEntry.decode(buf2);
  if (message2.sequence != null) {
    message2.sequence = BigInt(message2.sequence);
  }
  if (message2.ttl != null) {
    message2.ttl = BigInt(message2.ttl);
  }
  return {
    value: message2.value ?? new Uint8Array(0),
    signature: message2.signature ?? new Uint8Array(0),
    validityType: message2.validityType ?? IpnsEntry.ValidityType.EOL,
    validity: message2.validity ?? new Uint8Array(0),
    sequence: message2.sequence ?? 0n,
    pubKey: message2.pubKey,
    ttl: message2.ttl ?? void 0,
    signatureV2: message2.signatureV2,
    data: message2.data
  };
};
const peerIdToRoutingKey = (peerId) => {
  return concat$1([
    IPNS_PREFIX$1,
    peerId.toBytes()
  ]);
};
const peerIdFromRoutingKey = (key) => {
  return peerIdFromBytes(key.slice(IPNS_PREFIX$1.length));
};
const createCborData = (value2, validity, validityType, sequence, ttl2) => {
  let ValidityType;
  if (validityType === IpnsEntry.ValidityType.EOL) {
    ValidityType = 0;
  } else {
    throw errCode(new Error("Unknown validity type"), ERR_UNRECOGNIZED_VALIDITY);
  }
  const data = {
    Value: value2,
    Validity: validity,
    ValidityType,
    Sequence: sequence,
    TTL: ttl2
  };
  return encode$n(data);
};
const parseCborData = (buf2) => {
  const data = decode$h(buf2);
  if (data.ValidityType === 0) {
    data.ValidityType = IpnsEntry.ValidityType.EOL;
  } else {
    throw errCode(new Error("Unknown validity type"), ERR_UNRECOGNIZED_VALIDITY);
  }
  if (Number.isInteger(data.Sequence)) {
    data.Sequence = BigInt(data.Sequence);
  }
  if (Number.isInteger(data.TTL)) {
    data.TTL = BigInt(data.TTL);
  }
  return data;
};
const log$1D = logger$1("ipns");
const ID_MULTIHASH_CODE = identity$5.code;
const namespace$1 = "/ipns/";
const namespaceLength = namespace$1.length;
const create$6 = async (peerId, value2, seq, lifetime) => {
  const expirationDate = new NanoDate(Date.now() + Number(lifetime));
  const validityType = IpnsEntry.ValidityType.EOL;
  const [ms2, ns] = lifetime.toString().split(".");
  const lifetimeNs = BigInt(ms2) * BigInt(1e5) + BigInt(ns ?? "0");
  return await _create(peerId, value2, seq, validityType, expirationDate, lifetimeNs);
};
const _create = async (peerId, value2, seq, validityType, expirationDate, ttl2) => {
  seq = BigInt(seq);
  const isoValidity = fromString$3(expirationDate.toString());
  if (peerId.privateKey == null) {
    throw errCode(new Error("Missing private key"), ERR_MISSING_PRIVATE_KEY);
  }
  const privateKey = await unmarshalPrivateKey(peerId.privateKey);
  const signatureV1 = await signLegacyV1(privateKey, value2, validityType, isoValidity);
  const data = createCborData(value2, isoValidity, validityType, seq, ttl2);
  const sigData = ipnsEntryDataForV2Sig(data);
  const signatureV2 = await privateKey.sign(sigData);
  const entry = {
    value: value2,
    signature: signatureV1,
    validityType,
    validity: isoValidity,
    sequence: seq,
    ttl: ttl2,
    signatureV2,
    data
  };
  if (peerId.publicKey != null) {
    const digest2 = decode$j(peerId.toBytes());
    if (digest2.code !== ID_MULTIHASH_CODE || !equals$1(peerId.publicKey, digest2.digest)) {
      entry.pubKey = peerId.publicKey;
    }
  }
  log$1D("ipns entry for %b created", value2);
  return entry;
};
const rawStdEncoding = (key) => base32upper$1.encode(key).slice(1);
const getLocalKey = (key) => new Key(`/ipns/${rawStdEncoding(key)}`);
const signLegacyV1 = async (privateKey, value2, validityType, validity) => {
  try {
    const dataForSignature = ipnsEntryDataForV1Sig(value2, validityType, validity);
    return await privateKey.sign(dataForSignature);
  } catch (error2) {
    log$1D.error("record signature creation failed", error2);
    throw errCode(new Error("record signature creation failed"), ERR_SIGNATURE_CREATION);
  }
};
const log$1C = logger$1("ipfs:ipns:publisher");
const ERR_NOT_FOUND$3 = notFoundError$1().code;
const defaultRecordLifetime$1 = 60 * 60 * 1e3;
class IpnsPublisher {
  constructor(routing, datastore) {
    this._routing = routing;
    this._datastore = datastore;
  }
  async publishWithEOL(peerId, value2, lifetime, options) {
    const record = await this._updateOrCreateRecord(peerId, value2, lifetime, options);
    return this._putRecordToRouting(record, peerId, options);
  }
  publish(peerId, value2, options) {
    return this.publishWithEOL(peerId, value2, defaultRecordLifetime$1, options);
  }
  async _putRecordToRouting(record, peerId, options) {
    if (!isPeerId(peerId)) {
      const errMsg = "peerId received is not valid";
      log$1C.error(errMsg);
      throw errCode(new Error(errMsg), "ERR_INVALID_PEER_ID");
    }
    if (peerId.publicKey == null) {
      throw errCode(new Error("Public key was missing"), "ERR_MISSING_PUBLIC_KEY");
    }
    const routingKey = peerIdToRoutingKey(peerId);
    await this._publishEntry(routingKey, record, options);
    return record;
  }
  async _publishEntry(key, entry, options) {
    try {
      const res = await this._routing.put(key, entry, options);
      log$1C(`ipns record for ${toString$5(key, "base32")} was stored in the routing`);
      return res;
    } catch (err2) {
      const errMsg = `ipns record for ${toString$5(key, "base32")} could not be stored in the routing - ${err2.stack}`;
      log$1C.error(errMsg);
      log$1C.error(err2);
      throw errCode(new Error(errMsg), "ERR_PUTTING_TO_ROUTING");
    }
  }
  async _getPublished(peerId, options = {}) {
    if (!isPeerId(peerId)) {
      const errMsg = "peerId received is not valid";
      log$1C.error(errMsg);
      throw errCode(new Error(errMsg), "ERR_INVALID_PEER_ID");
    }
    const checkRouting = options.checkRouting !== false;
    try {
      const dsVal = await this._datastore.get(getLocalKey(peerId.toBytes()));
      return this._unmarshalData(dsVal);
    } catch (err2) {
      if (err2.code !== ERR_NOT_FOUND$3) {
        const errMsg = `unexpected error getting the ipns record ${peerId.toString()} from datastore`;
        log$1C.error(errMsg);
        throw errCode(new Error(errMsg), "ERR_UNEXPECTED_DATASTORE_RESPONSE");
      }
      if (!checkRouting) {
        throw errCode(err2, "ERR_NOT_FOUND_AND_CHECK_ROUTING_NOT_ENABLED");
      }
      try {
        const routingKey = peerIdToRoutingKey(peerId);
        const res = await this._routing.get(routingKey);
        return this._unmarshalData(res);
      } catch (err3) {
        log$1C.error(err3);
        throw err3;
      }
    }
  }
  _unmarshalData(data) {
    try {
      return unmarshal(data);
    } catch (err2) {
      throw errCode(err2, "ERR_INVALID_RECORD_DATA");
    }
  }
  async _updateOrCreateRecord(peerId, value2, lifetime, options) {
    if (!isPeerId(peerId)) {
      const errMsg = "peerId received is not valid";
      log$1C.error(errMsg);
      throw errCode(new Error(errMsg), "ERR_INVALID_PEER_ID");
    }
    const getPublishedOptions = {
      checkRouting: true
    };
    let record;
    try {
      record = await this._getPublished(peerId, getPublishedOptions);
    } catch (err2) {
      if (err2.code !== ERR_NOT_FOUND$3) {
        const errMsg = `unexpected error when determining the last published IPNS record for ${peerId.toString()} ${err2.stack}`;
        log$1C.error(errMsg);
        throw errCode(new Error(errMsg), "ERR_DETERMINING_PUBLISHED_RECORD");
      }
    }
    let seqNumber = 0n;
    if (record && record.sequence !== void 0) {
      seqNumber = equals$1(record.value, value2) ? record.sequence : record.sequence + BigInt(1);
    }
    let entryData;
    try {
      entryData = await create$6(peerId, value2, seqNumber, lifetime);
    } catch (err2) {
      const errMsg = `ipns record for ${value2} could not be created`;
      log$1C.error(err2);
      throw errCode(new Error(errMsg), "ERR_CREATING_IPNS_RECORD");
    }
    try {
      const data = marshal(entryData);
      await this._datastore.put(getLocalKey(peerId.toBytes()), data, options);
      log$1C(`ipns record for ${toString$5(value2, "base32")} was stored in the datastore`);
      return data;
    } catch (err2) {
      const errMsg = `ipns record for ${value2} could not be stored in the datastore`;
      log$1C.error(errMsg);
      throw errCode(new Error(errMsg), "ERR_STORING_IN_DATASTORE");
    }
  }
}
IpnsPublisher.defaultRecordLifetime = defaultRecordLifetime$1;
const log$1B = logger$1("ipfs:ipns:republisher");
const minute$3 = 60 * 1e3;
const hour$1 = 60 * minute$3;
const defaultBroadcastInterval = 4 * hour$1;
const defaultRecordLifetime = 24 * hour$1;
class IpnsRepublisher {
  constructor(publisher, datastore, peerId, keychain, options = { pass: "" }) {
    this._publisher = publisher;
    this._datastore = datastore;
    this._peerId = peerId;
    this._keychain = keychain;
    this._options = options;
    this._republishHandle = null;
  }
  async start() {
    if (this._republishHandle) {
      throw errCode(new Error("republisher is already running"), "ERR_REPUBLISH_ALREADY_RUNNING");
    }
    const republishHandle = {
      _task: null,
      _inflightTask: null,
      _timeoutId: null,
      runPeriodically: (period) => {
        republishHandle._timeoutId = setTimeout(async () => {
          republishHandle._timeoutId = null;
          try {
            republishHandle._inflightTask = republishHandle._task();
            await republishHandle._inflightTask;
            if (republishHandle._task) {
              republishHandle.runPeriodically(period);
            }
          } catch (err2) {
            log$1B.error(err2);
          }
        }, period());
      },
      cancel: async () => {
        if (republishHandle._timeoutId != null) {
          clearTimeout(republishHandle._timeoutId);
        }
        republishHandle._task = null;
        await republishHandle._inflightTask;
      }
    };
    const { pass } = this._options;
    let firstRun = true;
    republishHandle._task = async () => {
      const timeoutController = new timeoutAbortController.TimeoutController(3e4);
      try {
        await this._republishEntries(this._peerId, pass, {
          signal: timeoutController.signal
        });
      } finally {
        timeoutController.clear();
      }
    };
    republishHandle.runPeriodically(() => {
      if (firstRun) {
        firstRun = false;
        return this._options.initialBroadcastInterval || minute$3;
      }
      return this._options.broadcastInterval || defaultBroadcastInterval;
    });
    this._republishHandle = republishHandle;
  }
  async stop() {
    const republishHandle = this._republishHandle;
    if (!republishHandle) {
      throw errCode(new Error("republisher is not running"), "ERR_REPUBLISH_NOT_RUNNING");
    }
    this._republishHandle = null;
    await republishHandle.cancel();
  }
  async _republishEntries(peerId, pass, options) {
    try {
      await this._republishEntry(peerId, options);
    } catch (err2) {
      const errMsg = "cannot republish entry for the node's private key";
      log$1B.error(errMsg);
      return;
    }
    if (pass) {
      try {
        const keys = await this._keychain.listKeys();
        for (const key of keys) {
          if (key.name === "self") {
            continue;
          }
          const pem2 = await this._keychain.exportKey(key.name, pass);
          const privKey = await importKey(pem2, pass);
          const peerIdKey = await peerIdFromKeys(privKey.public.bytes, privKey.bytes);
          await this._republishEntry(peerIdKey, options);
        }
      } catch (err2) {
        log$1B.error(err2);
      }
    }
  }
  async _republishEntry(peerId, options) {
    try {
      const value2 = await this._getPreviousValue(peerId);
      await this._publisher.publishWithEOL(peerId, value2, defaultRecordLifetime, options);
    } catch (err2) {
      if (err2.code === "ERR_NO_ENTRY_FOUND") {
        return;
      }
      throw err2;
    }
  }
  async _getPreviousValue(peerId) {
    if (!isPeerId(peerId)) {
      throw errCode(new Error("invalid peer ID"), "ERR_INVALID_PEER_ID");
    }
    try {
      const dsVal = await this._datastore.get(getLocalKey(peerId.toBytes()));
      if (!(dsVal instanceof Uint8Array)) {
        throw errCode(new Error("found ipns record that we couldn't process"), "ERR_INVALID_IPNS_RECORD");
      }
      try {
        const record = unmarshal(dsVal);
        return record.value;
      } catch (err2) {
        log$1B.error(err2);
        throw errCode(new Error("found ipns record that we couldn't convert to a value"), "ERR_INVALID_IPNS_RECORD");
      }
    } catch (err2) {
      if (err2 && err2.notFound) {
        throw errCode(new Error(`no previous entry for record with id: ${peerId.toString()}`), "ERR_NO_ENTRY_FOUND");
      }
      throw err2;
    }
  }
}
const log$1A = logger$1("ipns:validator");
const validate = async (publicKey, entry) => {
  const { value: value2, validityType, validity } = entry;
  let dataForSignature;
  let signature;
  if (entry.signatureV2 != null && entry.data != null) {
    signature = entry.signatureV2;
    dataForSignature = ipnsEntryDataForV2Sig(entry.data);
    validateCborDataMatchesPbData(entry);
  } else {
    throw errCode(new Error("missing data or signatureV2"), ERR_SIGNATURE_VERIFICATION);
  }
  let isValid;
  try {
    isValid = await publicKey.verify(dataForSignature, signature);
  } catch (err2) {
    isValid = false;
  }
  if (!isValid) {
    log$1A.error("record signature verification failed");
    throw errCode(new Error("record signature verification failed"), ERR_SIGNATURE_VERIFICATION);
  }
  if (validity != null && validityType === IpnsEntry.ValidityType.EOL) {
    let validityDate;
    try {
      validityDate = parseRFC3339$1(toString$5(validity));
    } catch (e) {
      log$1A.error("unrecognized validity format (not an rfc3339 format)");
      throw errCode(new Error("unrecognized validity format (not an rfc3339 format)"), ERR_UNRECOGNIZED_FORMAT);
    }
    if (validityDate.getTime() < Date.now()) {
      log$1A.error("record has expired");
      throw errCode(new Error("record has expired"), ERR_IPNS_EXPIRED_RECORD);
    }
  } else if (validityType != null) {
    log$1A.error("unrecognized validity type");
    throw errCode(new Error("unrecognized validity type"), ERR_UNRECOGNIZED_VALIDITY);
  }
  log$1A("ipns entry for %b is valid", value2);
};
const validateCborDataMatchesPbData = (entry) => {
  if (entry.data == null) {
    throw errCode(new Error("Record data is missing"), ERR_INVALID_RECORD_DATA);
  }
  const data = parseCborData(entry.data);
  if (!equals$1(data.Value, entry.value)) {
    throw errCode(new Error('Field "value" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
  if (!equals$1(data.Validity, entry.validity)) {
    throw errCode(new Error('Field "validity" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
  if (data.ValidityType !== entry.validityType) {
    throw errCode(new Error('Field "validityType" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
  if (data.Sequence !== entry.sequence) {
    throw errCode(new Error('Field "sequence" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
  if (data.TTL !== entry.ttl) {
    throw errCode(new Error('Field "ttl" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
};
const ipnsValidator = async (key, marshalledData) => {
  const peerId = peerIdFromRoutingKey(key);
  const receivedEntry = unmarshal(marshalledData);
  const pubKey = await extractPublicKey(peerId, receivedEntry);
  await validate(pubKey, receivedEntry);
};
const log$1z = logger$1("ipfs:ipns:resolver");
const ERR_NOT_FOUND$2 = notFoundError$1().code;
const defaultMaximumRecursiveDepth = 32;
class IpnsResolver {
  constructor(routing) {
    this._routing = routing;
  }
  async resolve(name2, options = {}) {
    if (typeof name2 !== "string") {
      throw errCode(new Error("invalid name"), "ERR_INVALID_NAME");
    }
    const recursive2 = options.recursive && options.recursive.toString() === "true";
    const nameSegments = name2.split("/");
    if (nameSegments.length !== 3 || nameSegments[0] !== "") {
      throw errCode(new Error("invalid name"), "ERR_INVALID_NAME");
    }
    const key = nameSegments[2];
    let depth = Infinity;
    if (recursive2) {
      depth = defaultMaximumRecursiveDepth;
    }
    const res = await this.resolver(key, depth, options);
    log$1z(`${name2} was locally resolved correctly`);
    return res;
  }
  async resolver(name2, depth, options) {
    if (depth === 0) {
      const errMsg = `could not resolve name (recursion limit of ${defaultMaximumRecursiveDepth} exceeded)`;
      log$1z.error(errMsg);
      throw errCode(new Error(errMsg), "ERR_RESOLVE_RECURSION_LIMIT");
    }
    const res = await this._resolveName(name2, options);
    const nameSegments = res.split("/");
    if (nameSegments[1] === "ipfs" || !depth) {
      return res;
    }
    return this.resolver(nameSegments[2], depth - 1, options);
  }
  async _resolveName(name2, options) {
    const peerId = peerIdFromString(name2);
    const routingKey = peerIdToRoutingKey(peerId);
    let record;
    try {
      record = await this._routing.get(routingKey, options);
    } catch (err2) {
      log$1z.error("could not get record from routing", err2);
      if (err2.code === ERR_NOT_FOUND$2) {
        throw errCode(new Error(`record requested for ${name2} was not found in the network`), "ERR_NO_RECORD_FOUND");
      }
      throw errCode(new Error(`unexpected error getting the ipns record ${peerId.toString()}`), "ERR_UNEXPECTED_ERROR_GETTING_RECORD");
    }
    return this._validateRecord(peerId, record);
  }
  async _validateRecord(peerId, record) {
    await ipnsValidator(concat$1([
      fromString$3("/ipns/"),
      peerId.toBytes()
    ]), record);
    const ipnsEntry = unmarshal(record);
    return toString$5(ipnsEntry.value);
  }
}
class TLRU {
  constructor(maxSize) {
    this.lru = hashlru(maxSize);
  }
  get(key) {
    const value2 = this.lru.get(key);
    if (value2) {
      if (value2.expire && value2.expire < Date.now()) {
        this.lru.remove(key);
        return void 0;
      }
      return value2.value;
    }
    return void 0;
  }
  set(key, value2, ttl2) {
    this.lru.set(key, { value: value2, expire: Date.now() + ttl2 });
  }
  has(key) {
    const value2 = this.get(key);
    if (value2) {
      return true;
    }
    return false;
  }
  remove(key) {
    this.lru.remove(key);
  }
  clear() {
    this.lru.clear();
  }
}
const log$1y = logger$1("ipfs:ipns");
const defaultRecordTtl = 60 * 1e3;
class IPNS {
  constructor(routing, datastore, peerId, keychain, options) {
    this.publisher = new IpnsPublisher(routing, datastore);
    this.republisher = new IpnsRepublisher(this.publisher, datastore, peerId, keychain, options);
    this.resolver = new IpnsResolver(routing);
    this.cache = new TLRU(1e3);
    this.routing = routing;
  }
  async publish(peerId, value2, lifetime = IpnsPublisher.defaultRecordLifetime, options) {
    try {
      await this.publisher.publishWithEOL(peerId, value2, lifetime, options);
      log$1y(`IPNS value ${toString$5(value2, "base32")} was published correctly`);
      const id = peerId.toString();
      const ttEol = parseFloat(lifetime);
      const ttl2 = ttEol < defaultRecordTtl ? ttEol : defaultRecordTtl;
      this.cache.set(id, value2, ttl2);
      log$1y(`IPNS value ${toString$5(value2, "base32")} was cached correctly`);
      return {
        name: id,
        value: value2
      };
    } catch (err2) {
      log$1y.error(err2);
      throw err2;
    }
  }
  async resolve(name2, options = {}) {
    if (typeof name2 !== "string") {
      throw errCode(new Error("name received is not valid"), "ERR_INVALID_NAME");
    }
    if (!options.nocache && !options.recursive) {
      const id = name2.split("/")[2];
      const result = this.cache.get(id);
      if (result) {
        return result;
      }
    }
    try {
      const result = await this.resolver.resolve(name2, options);
      log$1y(`IPNS record from ${name2} was resolved correctly`);
      return result;
    } catch (err2) {
      log$1y.error(err2);
      throw err2;
    }
  }
  async initializeKeyspace(peerId, value2, options) {
    return this.publish(peerId, value2, IpnsPublisher.defaultRecordLifetime, options);
  }
}
const all$2 = async (source2) => {
  const arr = [];
  for await (const entry of source2) {
    arr.push(entry);
  }
  return arr;
};
var itAll = all$2;
const sortAll$1 = (iterable, sorter) => {
  return async function* () {
    const values = await itAll(iterable);
    yield* values.sort(sorter);
  }();
};
const drain$1 = async (source2) => {
  for await (const _ of source2) {
  }
};
var itDrain = drain$1;
const filter$2 = async function* (source2, fn) {
  for await (const entry of source2) {
    if (await fn(entry)) {
      yield entry;
    }
  }
};
var itFilter = filter$2;
const take$1 = async function* (source2, limit) {
  let items = 0;
  if (limit < 1) {
    return;
  }
  for await (const entry of source2) {
    yield entry;
    items++;
    if (items === limit) {
      return;
    }
  }
};
var itTake = take$1;
class BaseDatastore {
  open() {
    return Promise.reject(new Error(".open is not implemented"));
  }
  close() {
    return Promise.reject(new Error(".close is not implemented"));
  }
  put(key, val, options) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  get(key, options) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  has(key, options) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  delete(key, options) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *putMany(source2, options = {}) {
    for await (const { key, value: value2 } of source2) {
      await this.put(key, value2, options);
      yield { key, value: value2 };
    }
  }
  async *getMany(source2, options = {}) {
    for await (const key of source2) {
      yield this.get(key, options);
    }
  }
  async *deleteMany(source2, options = {}) {
    for await (const key of source2) {
      await this.delete(key, options);
      yield key;
    }
  }
  batch() {
    let puts = [];
    let dels = [];
    return {
      put(key, value2) {
        puts.push({ key, value: value2 });
      },
      delete(key) {
        dels.push(key);
      },
      commit: async (options) => {
        await itDrain(this.putMany(puts, options));
        puts = [];
        await itDrain(this.deleteMany(dels, options));
        dels = [];
      }
    };
  }
  async *_all(q, options) {
    throw new Error("._all is not implemented");
  }
  async *_allKeys(q, options) {
    throw new Error("._allKeys is not implemented");
  }
  query(q, options) {
    let it = this._all(q, options);
    if (q.prefix != null) {
      it = itFilter(
        it,
        (e) => e.key.toString().startsWith(q.prefix)
      );
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => itFilter(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sortAll$1(it2, f), it);
    }
    if (q.offset != null) {
      let i2 = 0;
      it = itFilter(it, () => i2++ >= q.offset);
    }
    if (q.limit != null) {
      it = itTake(it, q.limit);
    }
    return it;
  }
  queryKeys(q, options) {
    let it = this._allKeys(q, options);
    if (q.prefix != null) {
      it = itFilter(
        it,
        (key) => key.toString().startsWith(q.prefix)
      );
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => itFilter(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sortAll$1(it2, f), it);
    }
    if (q.offset != null) {
      let i2 = 0;
      it = itFilter(it, () => i2++ >= q.offset);
    }
    if (q.limit != null) {
      it = itTake(it, q.limit);
    }
    return it;
  }
}
class FixedFIFO$1 {
  constructor(hwm) {
    if (!(hwm > 0) || (hwm - 1 & hwm) !== 0) {
      throw new Error("Max size for a FixedFIFO should be a power of two");
    }
    this.buffer = new Array(hwm);
    this.mask = hwm - 1;
    this.top = 0;
    this.btm = 0;
    this.next = null;
  }
  push(data) {
    if (this.buffer[this.top] !== void 0) {
      return false;
    }
    this.buffer[this.top] = data;
    this.top = this.top + 1 & this.mask;
    return true;
  }
  shift() {
    const last2 = this.buffer[this.btm];
    if (last2 === void 0) {
      return void 0;
    }
    this.buffer[this.btm] = void 0;
    this.btm = this.btm + 1 & this.mask;
    return last2;
  }
  isEmpty() {
    return this.buffer[this.btm] === void 0;
  }
}
class FIFO {
  constructor(options = {}) {
    this.hwm = options.splitLimit ?? 16;
    this.head = new FixedFIFO$1(this.hwm);
    this.tail = this.head;
    this.size = 0;
  }
  calculateSize(obj) {
    if (obj?.byteLength != null) {
      return obj.byteLength;
    }
    return 1;
  }
  push(val) {
    if (val?.value != null) {
      this.size += this.calculateSize(val.value);
    }
    if (!this.head.push(val)) {
      const prev2 = this.head;
      this.head = prev2.next = new FixedFIFO$1(2 * this.head.buffer.length);
      this.head.push(val);
    }
  }
  shift() {
    let val = this.tail.shift();
    if (val === void 0 && this.tail.next != null) {
      const next = this.tail.next;
      this.tail.next = null;
      this.tail = next;
      val = this.tail.shift();
    }
    if (val?.value != null) {
      this.size -= this.calculateSize(val.value);
    }
    return val;
  }
  isEmpty() {
    return this.head.isEmpty();
  }
}
function pushable(options = {}) {
  const getNext = (buffer2) => {
    const next = buffer2.shift();
    if (next == null) {
      return { done: true };
    }
    if (next.error != null) {
      throw next.error;
    }
    return {
      done: next.done === true,
      value: next.value
    };
  };
  return _pushable(getNext, options);
}
function pushableV(options = {}) {
  const getNext = (buffer2) => {
    let next;
    const values = [];
    while (!buffer2.isEmpty()) {
      next = buffer2.shift();
      if (next == null) {
        break;
      }
      if (next.error != null) {
        throw next.error;
      }
      if (next.done === false) {
        values.push(next.value);
      }
    }
    if (next == null) {
      return { done: true };
    }
    return {
      done: next.done === true,
      value: values
    };
  };
  return _pushable(getNext, options);
}
function _pushable(getNext, options) {
  options = options ?? {};
  let onEnd = options.onEnd;
  let buffer2 = new FIFO();
  let pushable2;
  let onNext;
  let ended;
  const waitNext = async () => {
    if (!buffer2.isEmpty()) {
      return getNext(buffer2);
    }
    if (ended) {
      return { done: true };
    }
    return await new Promise((resolve2, reject) => {
      onNext = (next) => {
        onNext = null;
        buffer2.push(next);
        try {
          resolve2(getNext(buffer2));
        } catch (err2) {
          reject(err2);
        }
        return pushable2;
      };
    });
  };
  const bufferNext = (next) => {
    if (onNext != null) {
      return onNext(next);
    }
    buffer2.push(next);
    return pushable2;
  };
  const bufferError = (err2) => {
    buffer2 = new FIFO();
    if (onNext != null) {
      return onNext({ error: err2 });
    }
    buffer2.push({ error: err2 });
    return pushable2;
  };
  const push3 = (value2) => {
    if (ended) {
      return pushable2;
    }
    if (options?.objectMode !== true && value2?.byteLength == null) {
      throw new Error("objectMode was not true but tried to push non-Uint8Array value");
    }
    return bufferNext({ done: false, value: value2 });
  };
  const end2 = (err2) => {
    if (ended)
      return pushable2;
    ended = true;
    return err2 != null ? bufferError(err2) : bufferNext({ done: true });
  };
  const _return = () => {
    buffer2 = new FIFO();
    end2();
    return { done: true };
  };
  const _throw = (err2) => {
    end2(err2);
    return { done: true };
  };
  pushable2 = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next: waitNext,
    return: _return,
    throw: _throw,
    push: push3,
    end: end2,
    get readableLength() {
      return buffer2.size;
    }
  };
  if (onEnd == null) {
    return pushable2;
  }
  const _pushable2 = pushable2;
  pushable2 = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next() {
      return _pushable2.next();
    },
    throw(err2) {
      _pushable2.throw(err2);
      if (onEnd != null) {
        onEnd(err2);
        onEnd = void 0;
      }
      return { done: true };
    },
    return() {
      _pushable2.return();
      if (onEnd != null) {
        onEnd();
        onEnd = void 0;
      }
      return { done: true };
    },
    push: push3,
    end(err2) {
      _pushable2.end(err2);
      if (onEnd != null) {
        onEnd(err2);
        onEnd = void 0;
      }
      return pushable2;
    },
    get readableLength() {
      return _pushable2.readableLength;
    }
  };
  return pushable2;
}
const log$1x = logger$1("datastore:core:tiered");
class TieredDatastore extends BaseDatastore {
  constructor(stores) {
    super();
    this.stores = stores.slice();
  }
  async open() {
    try {
      await Promise.all(this.stores.map((store) => store.open()));
    } catch (err2) {
      throw dbOpenFailedError();
    }
  }
  async put(key, value2, options) {
    try {
      await Promise.all(this.stores.map((store) => store.put(key, value2, options)));
    } catch (err2) {
      throw dbWriteFailedError();
    }
  }
  async get(key, options) {
    for (const store of this.stores) {
      try {
        const res = await store.get(key, options);
        if (res)
          return res;
      } catch (err2) {
        log$1x.error(err2);
      }
    }
    throw notFoundError$1();
  }
  async has(key, options) {
    for (const s2 of this.stores) {
      if (await s2.has(key, options)) {
        return true;
      }
    }
    return false;
  }
  async delete(key, options) {
    try {
      await Promise.all(this.stores.map((store) => store.delete(key, options)));
    } catch (err2) {
      throw dbDeleteFailedError();
    }
  }
  async *putMany(source2, options = {}) {
    let error2;
    const pushables = this.stores.map((store) => {
      const source3 = pushable({
        objectMode: true
      });
      itDrain(store.putMany(source3, options)).catch((err2) => {
        error2 = err2;
      });
      return source3;
    });
    try {
      for await (const pair2 of source2) {
        if (error2) {
          throw error2;
        }
        pushables.forEach((p) => p.push(pair2));
        yield pair2;
      }
    } finally {
      pushables.forEach((p) => p.end());
    }
  }
  async *deleteMany(source2, options = {}) {
    let error2;
    const pushables = this.stores.map((store) => {
      const source3 = pushable({
        objectMode: true
      });
      itDrain(store.deleteMany(source3, options)).catch((err2) => {
        error2 = err2;
      });
      return source3;
    });
    try {
      for await (const key of source2) {
        if (error2) {
          throw error2;
        }
        pushables.forEach((p) => p.push(key));
        yield key;
      }
    } finally {
      pushables.forEach((p) => p.end());
    }
  }
  async close() {
    await Promise.all(this.stores.map((store) => store.close()));
  }
  batch() {
    const batches = this.stores.map((store) => store.batch());
    return {
      put: (key, value2) => {
        batches.forEach((b2) => b2.put(key, value2));
      },
      delete: (key) => {
        batches.forEach((b2) => b2.delete(key));
      },
      commit: async (options) => {
        for (const batch2 of batches) {
          await batch2.commit(options);
        }
      }
    };
  }
  query(q, options) {
    return this.stores[this.stores.length - 1].query(q, options);
  }
  queryKeys(q, options) {
    return this.stores[this.stores.length - 1].queryKeys(q, options);
  }
}
function get$2(t, e, l, n, r) {
  for (e = e.split ? e.split(".") : e, n = 0; n < e.length; n++)
    t = t ? t[e[n]] : r;
  return t === r ? l : t;
}
const ipnsSelector = (key, data) => {
  const entries = data.map((buf2, index) => ({
    entry: IpnsEntry.decode(buf2),
    index
  }));
  entries.sort((a, b2) => {
    if (a.entry.signatureV2 != null && b2.entry.signatureV2 == null) {
      return -1;
    } else if (a.entry.signatureV2 == null && b2.entry.signatureV2 != null) {
      return 1;
    }
    const aSeq = a.entry.sequence ?? 0n;
    const bSeq = b2.entry.sequence ?? 0n;
    if (aSeq > bSeq) {
      return -1;
    } else if (aSeq < bSeq) {
      return 1;
    }
    const aValidty = a.entry.validity ?? new Uint8Array(0);
    const bValidty = b2.entry.validity ?? new Uint8Array(0);
    const entryAValidityDate = parseRFC3339$1(toString$5(aValidty));
    const entryBValidityDate = parseRFC3339$1(toString$5(bValidty));
    if (entryAValidityDate.getTime() > entryBValidityDate.getTime()) {
      return -1;
    }
    if (entryAValidityDate.getTime() < entryBValidityDate.getTime()) {
      return 1;
    }
    return 0;
  });
  return entries[0].index;
};
const SHARDING_FN = "SHARDING";
const README_FN = "_README";
class MemoryDatastore extends BaseDatastore {
  constructor() {
    super();
    this.data = {};
  }
  open() {
    return Promise.resolve();
  }
  close() {
    return Promise.resolve();
  }
  async put(key, val) {
    this.data[key.toString()] = val;
  }
  async get(key) {
    const exists2 = await this.has(key);
    if (!exists2)
      throw notFoundError$1();
    return this.data[key.toString()];
  }
  async has(key) {
    return this.data[key.toString()] !== void 0;
  }
  async delete(key) {
    delete this.data[key.toString()];
  }
  async *_all() {
    yield* Object.entries(this.data).map(([key, value2]) => ({ key: new Key(key), value: value2 }));
  }
  async *_allKeys() {
    yield* Object.entries(this.data).map(([key]) => new Key(key));
  }
}
const map$4 = async function* (source2, func) {
  for await (const val of source2) {
    yield func(val);
  }
};
var itMap = map$4;
async function* merge$1(...sources) {
  const output = pushable({
    objectMode: true
  });
  void Promise.resolve().then(async () => {
    try {
      await Promise.all(sources.map(async (source2) => {
        for await (const item of source2) {
          output.push(item);
        }
      }));
      output.end();
    } catch (err2) {
      output.end(err2);
    }
  });
  yield* output;
}
const rawPipe = (...fns) => {
  let res;
  while (fns.length > 0) {
    res = fns.shift()(res);
  }
  return res;
};
const isIterable$1 = (obj) => {
  return obj != null && (typeof obj[Symbol.asyncIterator] === "function" || typeof obj[Symbol.iterator] === "function" || typeof obj.next === "function");
};
const isDuplex = (obj) => {
  return obj != null && typeof obj.sink === "function" && isIterable$1(obj.source);
};
const duplexPipelineFn = (duplex2) => {
  return (source2) => {
    const p = duplex2.sink(source2);
    if (p.then != null) {
      const stream2 = pushable({
        objectMode: true
      });
      p.then(() => {
        stream2.end();
      }, (err2) => {
        stream2.end(err2);
      });
      const sourceWrap = async function* () {
        yield* duplex2.source;
        stream2.end();
      };
      return merge$1(stream2, sourceWrap());
    }
    return duplex2.source;
  };
};
function pipe(first2, ...rest) {
  if (isDuplex(first2)) {
    const duplex2 = first2;
    first2 = () => duplex2.source;
  } else if (isIterable$1(first2)) {
    const source2 = first2;
    first2 = () => source2;
  }
  const fns = [first2, ...rest];
  if (fns.length > 1) {
    if (isDuplex(fns[fns.length - 1])) {
      fns[fns.length - 1] = fns[fns.length - 1].sink;
    }
  }
  if (fns.length > 2) {
    for (let i2 = 1; i2 < fns.length - 1; i2++) {
      if (isDuplex(fns[i2])) {
        fns[i2] = duplexPipelineFn(fns[i2]);
      }
    }
  }
  return rawPipe(...fns);
}
new Key(SHARDING_FN);
new Key(README_FN);
var fixedSize = class FixedFIFO2 {
  constructor(hwm) {
    if (!(hwm > 0) || (hwm - 1 & hwm) !== 0)
      throw new Error("Max size for a FixedFIFO should be a power of two");
    this.buffer = new Array(hwm);
    this.mask = hwm - 1;
    this.top = 0;
    this.btm = 0;
    this.next = null;
  }
  push(data) {
    if (this.buffer[this.top] !== void 0)
      return false;
    this.buffer[this.top] = data;
    this.top = this.top + 1 & this.mask;
    return true;
  }
  shift() {
    const last2 = this.buffer[this.btm];
    if (last2 === void 0)
      return void 0;
    this.buffer[this.btm] = void 0;
    this.btm = this.btm + 1 & this.mask;
    return last2;
  }
  peek() {
    return this.buffer[this.btm];
  }
  isEmpty() {
    return this.buffer[this.btm] === void 0;
  }
};
const FixedFIFO = fixedSize;
var fastFifo = class FastFIFO {
  constructor(hwm) {
    this.hwm = hwm || 16;
    this.head = new FixedFIFO(this.hwm);
    this.tail = this.head;
  }
  push(val) {
    if (!this.head.push(val)) {
      const prev2 = this.head;
      this.head = prev2.next = new FixedFIFO(2 * this.head.buffer.length);
      this.head.push(val);
    }
  }
  shift() {
    const val = this.tail.shift();
    if (val === void 0 && this.tail.next) {
      const next = this.tail.next;
      this.tail.next = null;
      this.tail = next;
      return this.tail.shift();
    }
    return val;
  }
  peek() {
    return this.tail.peek();
  }
  isEmpty() {
    return this.head.isEmpty();
  }
};
const namespace = "/record/";
function encodeBase32(buf2) {
  return toString$5(buf2, "base32");
}
function keyToTopic(key) {
  if (typeof key === "string" || key instanceof String) {
    key = fromString$3(key.toString());
  }
  const b64url = toString$5(key, "base64url");
  return `${namespace}${b64url}`;
}
function topicToKey(topic) {
  if (topic.substring(0, namespace.length) !== namespace) {
    throw errCode(new Error("topic received is not from a record"), "ERR_TOPIC_IS_NOT_FROM_RECORD_NAMESPACE");
  }
  const key = topic.substring(namespace.length);
  return fromString$3(key, "base64url");
}
const log$1w = logger$1("datastore-pubsub:publisher");
class PubSubDatastore extends BaseDatastore {
  constructor(pubsub, datastore, peerId, validator, selector, subscriptionKeyFn) {
    super();
    if (!validator) {
      throw errCode(new TypeError("missing validator"), "ERR_INVALID_PARAMETERS");
    }
    if (typeof validator !== "function") {
      throw errCode(new TypeError("missing validate function"), "ERR_INVALID_PARAMETERS");
    }
    if (typeof selector !== "function") {
      throw errCode(new TypeError("missing select function"), "ERR_INVALID_PARAMETERS");
    }
    if (subscriptionKeyFn && typeof subscriptionKeyFn !== "function") {
      throw errCode(new TypeError("invalid subscriptionKeyFn received"), "ERR_INVALID_PARAMETERS");
    }
    this._pubsub = pubsub;
    this._datastore = datastore;
    this._peerId = peerId;
    this._validator = validator;
    this._selector = selector;
    this._handleSubscriptionKeyFn = subscriptionKeyFn;
    this._onMessage = this._onMessage.bind(this);
    this._pubsub.addEventListener("message", this._onMessage);
  }
  async put(key, val, options) {
    if (!(key instanceof Uint8Array)) {
      const errMsg = "datastore key does not have a valid format";
      log$1w.error(errMsg);
      throw errCode(new Error(errMsg), "ERR_INVALID_DATASTORE_KEY");
    }
    if (!(val instanceof Uint8Array)) {
      const errMsg = "received value is not a Uint8Array";
      log$1w.error(errMsg);
      throw errCode(new Error(errMsg), "ERR_INVALID_VALUE_RECEIVED");
    }
    const stringifiedTopic = keyToTopic(key);
    log$1w(`publish value for topic ${stringifiedTopic}`);
    await this._pubsub.publish(stringifiedTopic, val);
  }
  async get(key, options) {
    if (!(key instanceof Uint8Array)) {
      const errMsg = "datastore key does not have a valid format";
      log$1w.error(errMsg);
      throw errCode(new Error(errMsg), "ERR_INVALID_DATASTORE_KEY");
    }
    const stringifiedTopic = keyToTopic(key);
    const subscriptions = await this._pubsub.getTopics();
    if (subscriptions && Array.isArray(subscriptions) && subscriptions.indexOf(stringifiedTopic) > -1) {
      return this._getLocal(key, options);
    }
    try {
      await this._pubsub.subscribe(stringifiedTopic);
    } catch (err2) {
      const errMsg = `cannot subscribe topic ${stringifiedTopic}`;
      log$1w.error(errMsg);
      throw errCode(new Error(errMsg), "ERR_SUBSCRIBING_TOPIC");
    }
    log$1w(`subscribed values for key ${stringifiedTopic}`);
    return this._getLocal(key);
  }
  unsubscribe(key) {
    const stringifiedTopic = keyToTopic(key);
    return this._pubsub.unsubscribe(stringifiedTopic);
  }
  async _getLocal(key, options) {
    const routingKey = new Key("/" + encodeBase32(key), false);
    let dsVal;
    try {
      dsVal = await this._datastore.get(routingKey, options);
    } catch (err2) {
      if (err2.code !== "ERR_NOT_FOUND") {
        const errMsg2 = `unexpected error getting the ipns record for ${routingKey.toString()}`;
        log$1w.error(errMsg2);
        throw errCode(new Error(errMsg2), "ERR_UNEXPECTED_ERROR_GETTING_RECORD");
      }
      const errMsg = `local record requested was not found for ${routingKey.toString()}`;
      log$1w.error(errMsg);
      throw errCode(new Error(errMsg), "ERR_NOT_FOUND");
    }
    if (!(dsVal instanceof Uint8Array)) {
      const errMsg = "found record that we couldn't convert to a value";
      log$1w.error(errMsg);
      throw errCode(new Error(errMsg), "ERR_INVALID_RECORD_RECEIVED");
    }
    return dsVal;
  }
  async _onMessage(evt) {
    const msg = evt.detail;
    if (msg.type !== "signed") {
      log$1w.error("unsigned message received, this module can only work with signed messages");
      return;
    }
    const { data, from: from2, topic } = msg;
    let key;
    try {
      key = topicToKey(topic);
    } catch (err2) {
      log$1w.error(err2);
      return;
    }
    log$1w(`message received for topic ${topic}`);
    if (this._peerId.equals(from2)) {
      log$1w("message discarded as it is from the same peer");
      return;
    }
    if (this._handleSubscriptionKeyFn) {
      let res;
      try {
        res = await this._handleSubscriptionKeyFn(key);
      } catch (err2) {
        log$1w.error("message discarded by the subscriptionKeyFn");
        return;
      }
      key = res;
    }
    try {
      await this._storeIfSubscriptionIsBetter(key, data);
    } catch (err2) {
      log$1w.error(err2);
    }
  }
  async _storeIfSubscriptionIsBetter(key, data, options) {
    let isBetter = false;
    try {
      isBetter = await this._isBetter(key, data);
    } catch (err2) {
      if (err2.code !== "ERR_NOT_VALID_RECORD") {
        throw err2;
      }
    }
    if (isBetter) {
      await this._storeRecord(key, data, options);
    }
  }
  async _validateRecord(key, value2) {
    return this._validator(key, value2);
  }
  async _selectRecord(key, records) {
    const res = await this._selector(key, records);
    return res === 0;
  }
  async _isBetter(key, val) {
    try {
      await this._validateRecord(key, val);
    } catch (err2) {
      const errMsg = "record received through pubsub is not valid";
      log$1w.error(errMsg);
      throw errCode(new Error(errMsg), "ERR_NOT_VALID_RECORD");
    }
    const dsKey = new Key(key);
    let currentRecord;
    try {
      currentRecord = await this._getLocal(dsKey.uint8Array());
    } catch (err2) {
      return true;
    }
    if (equals$1(currentRecord, val)) {
      return false;
    }
    return this._selectRecord(key, [currentRecord, val]);
  }
  async _storeRecord(key, data, options) {
    const routingKey = new Key("/" + encodeBase32(key), false);
    await this._datastore.put(routingKey, data, options);
    log$1w(`record for ${keyToTopic(key)} was stored in the datastore`);
  }
}
const log$1v = logger$1("ipfs:ipns:pubsub");
class IpnsPubsubDatastore {
  constructor(pubsub, localDatastore, peerId) {
    this._subscriptions = {};
    this._handleSubscriptionKey = this._handleSubscriptionKey.bind(this);
    this._pubsubDs = new PubSubDatastore(pubsub, localDatastore, peerId, ipnsValidator, ipnsSelector, this._handleSubscriptionKey);
  }
  async put(key, value2, options) {
    try {
      await this._pubsubDs.put(key, value2, options);
    } catch (err2) {
      log$1v.error(err2);
      throw err2;
    }
  }
  async get(key, options) {
    let res;
    let err2;
    try {
      res = await this._pubsubDs.get(key, options);
    } catch (e) {
      err2 = e;
    }
    const ns = key.slice(0, namespaceLength);
    if (toString$5(ns) === namespace$1) {
      const stringifiedTopic = base58btc$1.encode(key).substring(1);
      const id = base58btc$1.encode(key.slice(namespaceLength)).substring(1);
      this._subscriptions[stringifiedTopic] = id;
      log$1v(`subscribed to pubsub topic ${stringifiedTopic}, id ${id}`);
    }
    if (err2) {
      throw err2;
    }
    return res;
  }
  _handleSubscriptionKey(key) {
    if (key instanceof Uint8Array) {
      key = toString$5(key, "base58btc");
    }
    const subscriber = this._subscriptions[key];
    if (!subscriber) {
      throw errCode(new Error(`key ${key} does not correspond to a subscription`), "ERR_INVALID_KEY");
    }
    try {
      const k = peerIdToRoutingKey(peerIdFromString(subscriber));
      return k;
    } catch (err2) {
      log$1v.error(err2);
      throw err2;
    }
  }
  getSubscriptions() {
    const subscriptions = Object.values(this._subscriptions).filter(Boolean);
    return subscriptions.map((sub) => `${namespace$1}${sub}`);
  }
  async cancel(name2) {
    if (typeof name2 !== "string") {
      throw errCode(new Error("invalid subscription name"), "ERR_INVALID_SUBSCRIPTION_NAME");
    }
    if (name2.startsWith(namespace$1)) {
      name2 = name2.substring(namespaceLength);
    }
    const stringifiedTopic = Object.keys(this._subscriptions).find((key) => this._subscriptions[key] === name2);
    if (!stringifiedTopic) {
      return {
        canceled: false
      };
    }
    const bufTopic = fromString$3(stringifiedTopic);
    this._pubsubDs.unsubscribe(bufTopic);
    delete this._subscriptions[stringifiedTopic];
    log$1v(`unsubscribed pubsub ${stringifiedTopic}: ${name2}`);
    return {
      canceled: true
    };
  }
}
var Record$2;
(function(Record3) {
  let _codec;
  Record3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (opts.writeDefaults === true || obj.key != null && obj.key.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.key);
        }
        if (opts.writeDefaults === true || obj.value != null && obj.value.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.value);
        }
        if (opts.writeDefaults === true || obj.timeReceived !== "") {
          w.uint32(42);
          w.string(obj.timeReceived);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length3) => {
        const obj = {
          key: new Uint8Array(0),
          value: new Uint8Array(0),
          timeReceived: ""
        };
        const end2 = length3 == null ? reader2.len : reader2.pos + length3;
        while (reader2.pos < end2) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.key = reader2.bytes();
              break;
            case 2:
              obj.value = reader2.bytes();
              break;
            case 5:
              obj.timeReceived = reader2.string();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Record3.encode = (obj) => {
    return encodeMessage(obj, Record3.codec());
  };
  Record3.decode = (buf2) => {
    return decodeMessage(buf2, Record3.codec());
  };
})(Record$2 || (Record$2 = {}));
function toRFC3339(time) {
  const year = time.getUTCFullYear();
  const month = String(time.getUTCMonth() + 1).padStart(2, "0");
  const day = String(time.getUTCDate()).padStart(2, "0");
  const hour2 = String(time.getUTCHours()).padStart(2, "0");
  const minute2 = String(time.getUTCMinutes()).padStart(2, "0");
  const seconds = String(time.getUTCSeconds()).padStart(2, "0");
  const milliseconds = time.getUTCMilliseconds();
  const nanoseconds = String(milliseconds * 1e3 * 1e3).padStart(9, "0");
  return `${year}-${month}-${day}T${hour2}:${minute2}:${seconds}.${nanoseconds}Z`;
}
function parseRFC3339(time) {
  const rfc3339Matcher = new RegExp(
    "(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z"
  );
  const m = String(time).trim().match(rfc3339Matcher);
  if (m == null) {
    throw new Error("Invalid format");
  }
  const year = parseInt(m[1], 10);
  const month = parseInt(m[2], 10) - 1;
  const date = parseInt(m[3], 10);
  const hour2 = parseInt(m[4], 10);
  const minute2 = parseInt(m[5], 10);
  const second2 = parseInt(m[6], 10);
  const millisecond = parseInt(m[7].slice(0, -6), 10);
  return new Date(Date.UTC(year, month, date, hour2, minute2, second2, millisecond));
}
class Libp2pRecord {
  constructor(key, value2, timeReceived) {
    if (!(key instanceof Uint8Array)) {
      throw new Error("key must be a Uint8Array");
    }
    if (!(value2 instanceof Uint8Array)) {
      throw new Error("value must be a Uint8Array");
    }
    this.key = key;
    this.value = value2;
    this.timeReceived = timeReceived;
  }
  serialize() {
    return Record$2.encode(this.prepareSerialize());
  }
  prepareSerialize() {
    return {
      key: this.key,
      value: this.value,
      timeReceived: toRFC3339(this.timeReceived)
    };
  }
  static deserialize(raw2) {
    const rec = Record$2.decode(raw2);
    return new Libp2pRecord(rec.key, rec.value, new Date(rec.timeReceived));
  }
  static fromDeserialized(obj) {
    const recvtime = parseRFC3339(obj.timeReceived);
    if (obj.key == null) {
      throw new Error("key missing from deserialized object");
    }
    if (obj.value == null) {
      throw new Error("value missing from deserialized object");
    }
    const rec = new Libp2pRecord(obj.key, obj.value, recvtime);
    return rec;
  }
}
const log$1u = logger$1("ipfs:ipns:offline-datastore");
class OfflineDatastore {
  constructor(datastore) {
    this._datastore = datastore;
    this.stores = [];
  }
  async put(key, value2, options) {
    if (!(key instanceof Uint8Array)) {
      throw errCode(new Error("Offline datastore key must be a Uint8Array"), "ERR_INVALID_KEY");
    }
    if (!(value2 instanceof Uint8Array)) {
      throw errCode(new Error("Offline datastore value must be a Uint8Array"), "ERR_INVALID_VALUE");
    }
    let routingKey;
    try {
      routingKey = this._routingKey(key);
    } catch (err2) {
      log$1u.error(err2);
      throw errCode(new Error("Not possible to generate the routing key"), "ERR_GENERATING_ROUTING_KEY");
    }
    const record = new Libp2pRecord(key, value2, new Date());
    await this._datastore.put(routingKey, record.serialize(), options);
  }
  async get(key, options) {
    if (!(key instanceof Uint8Array)) {
      throw errCode(new Error("Offline datastore key must be a Uint8Array"), "ERR_INVALID_KEY");
    }
    let routingKey;
    try {
      routingKey = this._routingKey(key);
    } catch (err2) {
      log$1u.error(err2);
      throw errCode(new Error("Not possible to generate the routing key"), "ERR_GENERATING_ROUTING_KEY");
    }
    const res = await this._datastore.get(routingKey, options);
    let record;
    try {
      record = Libp2pRecord.deserialize(res);
    } catch (err2) {
      log$1u.error(err2);
      throw err2;
    }
    return record.value;
  }
  _routingKey(key) {
    return new Key("/dht/record/" + toString$5(key, "base32"), false);
  }
}
async function drain(source2) {
  for await (const _ of source2) {
  }
}
const log$1t = logger$1("ipfs:ipns:dht-datastore");
class DHTDatastore {
  constructor(dht) {
    this._dht = dht;
  }
  async put(key, value2, options) {
    try {
      await drain(this._dht.put(key, value2, options));
    } catch (err2) {
      log$1t.error(err2);
      throw err2;
    }
  }
  async get(key, options) {
    for await (const event of this._dht.get(key, options)) {
      if (event.name === "VALUE") {
        return event.value;
      }
    }
    throw notFoundError$1();
  }
}
function createRouting({ libp2p, repo, peerId, options }) {
  const ipnsStores = [];
  let pubsubDs;
  if (get$2(options, "EXPERIMENTAL.ipnsPubsub", false)) {
    pubsubDs = new IpnsPubsubDatastore(libp2p.pubsub, repo.datastore, peerId);
    ipnsStores.push(pubsubDs);
  }
  if (get$2(options, "offline", false) !== true && ["dht", "dhtclient", "dhtserver"].includes(get$2(options, "config.Routing.Type", "none"))) {
    ipnsStores.push(new DHTDatastore(libp2p.dht));
  }
  if (get$2(options, "offline", false) || ipnsStores.length === 0) {
    const offlineDatastore = new OfflineDatastore(repo.datastore);
    ipnsStores.push(offlineDatastore);
  }
  return new TieredDatastore(ipnsStores);
}
const log$1s = logger$1("ipfs:components:ipns");
class IPNSAPI {
  constructor(options = { pass: "" }) {
    this.options = options;
    this.offline = null;
    this.online = null;
  }
  getIPNS() {
    const ipns = this.online || this.offline;
    if (ipns) {
      return ipns;
    } else {
      throw new NotInitializedError();
    }
  }
  get routing() {
    return this.getIPNS().routing;
  }
  startOffline({ repo, peerId, keychain }) {
    if (this.offline != null) {
      throw new AlreadyInitializedError();
    }
    log$1s("initializing IPNS keyspace (offline)");
    const routing = new OfflineDatastore(repo.datastore);
    const ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options);
    this.offline = ipns;
  }
  async startOnline({ libp2p, repo, peerId, keychain }) {
    if (this.online != null) {
      throw new AlreadyInitializedError();
    }
    const routing = createRouting({ libp2p, repo, peerId, options: this.options });
    const ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options);
    await ipns.republisher.start();
    this.online = ipns;
  }
  async stop() {
    const ipns = this.online;
    if (ipns) {
      await ipns.republisher.stop();
      this.online = null;
    }
  }
  publish(peerId, value2, lifetime, options) {
    return this.getIPNS().publish(peerId, value2, lifetime, options);
  }
  resolve(name2, options) {
    return this.getIPNS().resolve(name2, options);
  }
  initializeKeyspace(peerId, value2, options) {
    return this.getIPNS().initializeKeyspace(peerId, value2, options);
  }
}
async function resolvePath({ ipns, repo, codecs: codecs2 }, name2, options) {
  if (ipnsPath(name2)) {
    return ipns.resolve(name2);
  }
  const {
    cid,
    path: path2
  } = toCidAndPath(name2);
  await drain(resolve$5(cid, path2 || "", codecs2, repo, options));
}
const log$1r = logger$1("ipfs:name:publish");
function createPublish$2({ ipns, repo, codecs: codecs2, peerId, isOnline, keychain }) {
  const lookupKey = async (keyName) => {
    let privateKey;
    if (keyName === "self" && peerId.privateKey != null) {
      privateKey = await unmarshalPrivateKey(peerId.privateKey);
    } else {
      try {
        const pem2 = await keychain.exportKey(keyName, "temp");
        privateKey = await importKey(pem2, "temp");
      } catch (err2) {
        log$1r.error(err2);
        throw errCode(err2, "ERR_CANNOT_GET_KEY");
      }
    }
    return peerIdFromKeys(privateKey.public.bytes, privateKey.bytes);
  };
  async function publish(value2, options = {}) {
    const resolve2 = !(options.resolve === false);
    const lifetime = options.lifetime || "24h";
    const key = options.key || "self";
    if (!isOnline()) {
      throw errCode(new Error(OFFLINE_ERROR), "OFFLINE_ERROR");
    }
    try {
      value2 = normalizePath(value2);
    } catch (err2) {
      log$1r.error(err2);
      throw err2;
    }
    let pubLifetime = 0;
    try {
      pubLifetime = parse$3(lifetime) || 0;
      pubLifetime = parseFloat(pubLifetime.toFixed(6));
    } catch (err2) {
      log$1r.error(err2);
      throw err2;
    }
    const results = await Promise.all([
      lookupKey(key),
      resolve2 ? resolvePath({ ipns, repo, codecs: codecs2 }, value2) : Promise.resolve()
    ]);
    const bytes2 = fromString$3(value2);
    const result = await ipns.publish(results[0], bytes2, pubLifetime, options);
    return {
      name: result.name,
      value: toString$5(result.value)
    };
  }
  return withTimeoutOption(publish);
}
var domainNameRegex = /^(?:[a-z0-9](?:[a-z0-9\-]{0,61}[a-z0-9])?\.){0,126}(?:[a-z0-9](?:[a-z0-9\-]{0,61}[a-z0-9]))\.?$/i;
var isDomainName = function isDomainName2(domainName, rootDot) {
  if (rootDot == null)
    rootDot = false;
  if (domainName.length < 2)
    return false;
  if (domainName.length > 255)
    return false;
  var lastChar = domainName[domainName.length - 1];
  if (rootDot) {
    if (lastChar !== ".")
      return false;
  } else {
    if (lastChar === ".")
      return false;
  }
  return domainNameRegex.test(domainName);
};
const mergeOptions$e = mergeOptions$g.bind({ ignoreUndefined: true });
const log$1q = logger$1("ipfs:name:resolve");
const appendRemainder = (result, remainder) => remainder.length > 0 ? result + "/" + remainder.join("/") : result;
function createResolve$4({ dns, ipns, isOnline, options: { offline } }) {
  async function* resolve2(name2, options = {}) {
    options = mergeOptions$e({
      nocache: false,
      recursive: true
    }, options);
    if (offline && options && options.nocache) {
      throw errCode(new Error("cannot specify both offline and nocache"), "ERR_NOCACHE_AND_OFFLINE");
    }
    if (!isOnline() && !offline) {
      throw errCode(new Error(OFFLINE_ERROR), "OFFLINE_ERROR");
    }
    let ipnsName = name2.toString();
    if (!ipnsName.startsWith("/ipns/")) {
      ipnsName = `/ipns/${ipnsName}`;
    }
    let [namespace2, hash2, ...remainder] = ipnsName.slice(1).split("/");
    try {
      if (hash2.substring(0, 1) === "1") {
        const id = peerIdFromString(hash2);
        const digest2 = decode$j(id.toBytes());
        const libp2pKey = CID.createV1(114, digest2);
        hash2 = libp2pKey.toString(base36$2);
      } else {
        const cid = CID.parse(hash2);
        if (cid.version === 1) {
          hash2 = cid.toString(base36$2);
        }
      }
    } catch (err2) {
      if (isDomainName(hash2)) {
        yield appendRemainder(await dns(hash2, options), remainder);
        return;
      }
      log$1q.error(err2);
      throw errCode(new Error("Invalid IPNS name"), "ERR_IPNS_INVALID_NAME");
    }
    const value2 = await ipns.resolve(`/${namespace2}/${hash2}`, options);
    yield appendRemainder(value2 instanceof Uint8Array ? toString$5(value2) : value2, remainder);
  }
  return withTimeoutOption(resolve2);
}
function getPubsubRouting(ipns, options) {
  if (!ipns || !(options && options.ipnsPubsub)) {
    throw errCode(new Error("IPNS pubsub subsystem is not enabled"), "ERR_IPNS_PUBSUB_NOT_ENABLED");
  }
  if (ipns.routing instanceof IpnsPubsubDatastore) {
    return ipns.routing;
  }
  const pubsub = (ipns.routing.stores || []).find((s2) => s2 instanceof IpnsPubsubDatastore);
  if (!pubsub) {
    throw errCode(new Error("IPNS pubsub datastore not found"), "ERR_PUBSUB_DATASTORE_NOT_FOUND");
  }
  return pubsub;
}
function createCancel$1({ ipns, options }) {
  const experimental = options.EXPERIMENTAL;
  async function cancel(name2, options2 = {}) {
    const pubsub = getPubsubRouting(ipns, experimental);
    return pubsub.cancel(name2, options2);
  }
  return withTimeoutOption(cancel);
}
function createState$1({ ipns, options }) {
  const experimental = options.EXPERIMENTAL;
  async function state(_options = {}) {
    try {
      return { enabled: Boolean(getPubsubRouting(ipns, experimental)) };
    } catch (err2) {
      return { enabled: false };
    }
  }
  return withTimeoutOption(state);
}
function createSubs$1({ ipns, options }) {
  const experimental = options.EXPERIMENTAL;
  async function subs(options2 = {}) {
    const pubsub = getPubsubRouting(ipns, experimental);
    return pubsub.getSubscriptions(options2);
  }
  return withTimeoutOption(subs);
}
class PubSubAPI {
  constructor({ ipns, options }) {
    this.cancel = createCancel$1({ ipns, options });
    this.state = createState$1({ ipns, options });
    this.subs = createSubs$1({ ipns, options });
  }
}
class NameAPI {
  constructor({ dns, ipns, repo, codecs: codecs2, peerId, isOnline, keychain, options }) {
    this.publish = createPublish$2({ ipns, repo, codecs: codecs2, peerId, isOnline, keychain });
    this.resolve = createResolve$4({ dns, ipns, isOnline, options });
    this.pubsub = new PubSubAPI({ ipns, options });
  }
}
const ERR_NOT_FOUND$1 = notFoundError$1().code;
const Format = {
  default: "<dst>",
  edges: "<src> -> <dst>"
};
function createRefs$1({ repo, codecs: codecs2, resolve: resolve2, preload: preload2 }) {
  async function* refs(ipfsPath2, options = {}) {
    if (options.maxDepth === 0) {
      return;
    }
    if (options.edges && options.format && options.format !== Format.default) {
      throw new Error("Cannot set edges to true and also specify format");
    }
    options.format = options.edges ? Format.edges : options.format;
    if (typeof options.maxDepth !== "number") {
      options.maxDepth = options.recursive ? Infinity : 1;
    }
    if (options.timeout) {
      const controller = new timeoutAbortController.TimeoutController(options.timeout);
      const signals = [controller.signal];
      if (options.signal) {
        signals.push(options.signal);
      }
      options.signal = anySignal_2(signals);
    }
    const rawPaths = Array.isArray(ipfsPath2) ? ipfsPath2 : [ipfsPath2];
    const paths = rawPaths.map((p) => getFullPath(preload2, p, options));
    for (const path2 of paths) {
      try {
        yield* refsStream(resolve2, repo, codecs2, path2, options);
      } catch (err2) {
        yield {
          ref: "",
          err: err2.message
        };
      }
    }
  }
  return refs;
}
function getFullPath(preload2, ipfsPath2, options) {
  const {
    cid,
    path: path2
  } = toCidAndPath(ipfsPath2);
  if (options.preload !== false) {
    preload2(cid);
  }
  return `/ipfs/${cid}${path2 || ""}`;
}
async function* refsStream(resolve2, repo, codecs2, path2, options) {
  const resPath = await resolve2(path2, options);
  const {
    cid
  } = toCidAndPath(resPath);
  const maxDepth = options.maxDepth != null ? options.maxDepth : Infinity;
  const unique = options.unique || false;
  for await (const obj of objectStream(repo, codecs2, cid, maxDepth, unique, options)) {
    if (!obj.parent) {
      continue;
    }
    if (obj.isDuplicate) {
      continue;
    }
    yield {
      ref: formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format)
    };
  }
}
function formatLink(srcCid, dstCid, linkName = "", format2 = Format.default) {
  let out = format2.replace(/<src>/g, srcCid.toString());
  out = out.replace(/<dst>/g, dstCid.toString());
  out = out.replace(/<linkname>/g, linkName);
  return out;
}
async function* objectStream(repo, codecs2, rootCid, maxDepth, uniqueOnly, options) {
  const seen = /* @__PURE__ */ new Set();
  async function* traverseLevel(parent2, depth) {
    const nextLevelDepth = depth + 1;
    if (nextLevelDepth > maxDepth) {
      return;
    }
    try {
      for await (const link of getLinks(repo, codecs2, parent2.cid, options)) {
        yield {
          parent: parent2,
          node: link,
          isDuplicate: uniqueOnly && seen.has(link.cid.toString())
        };
        if (uniqueOnly) {
          seen.add(link.cid.toString());
        }
        yield* traverseLevel(link, nextLevelDepth);
      }
    } catch (err2) {
      if (err2.code === ERR_NOT_FOUND$1) {
        err2.message = `Could not find object with CID: ${parent2.cid}`;
      }
      throw err2;
    }
  }
  yield* traverseLevel({ cid: rootCid }, 0);
}
async function* getLinks(repo, codecs2, cid, options) {
  const block = await repo.blocks.get(cid, options);
  const codec = await codecs2.getCodec(cid.code);
  const value2 = codec.decode(block);
  const isDagPb = cid.code === code$8;
  const base3 = [];
  for (const [name2, cid2] of links$1(value2, base3)) {
    if (isDagPb) {
      const match = name2.match(/^Links\/(\d+)\/Hash$/);
      if (match) {
        const index = Number(match[1]);
        if (index < value2.Links.length) {
          yield {
            name: value2.Links[index].Name,
            cid: cid2
          };
          continue;
        }
      }
    }
    yield {
      name: name2,
      cid: cid2
    };
  }
}
const links$1 = function* (source2, base3) {
  if (source2 == null) {
    return;
  }
  if (source2 instanceof Uint8Array) {
    return;
  }
  for (const [key, value2] of Object.entries(source2)) {
    const path2 = [...base3, key];
    if (value2 != null && typeof value2 === "object") {
      if (Array.isArray(value2)) {
        for (const [index, element] of value2.entries()) {
          const elementPath = [...path2, index];
          const cid = CID.asCID(element);
          if (cid) {
            yield [elementPath.join("/"), cid];
          } else if (typeof element === "object") {
            yield* links$1(element, elementPath);
          }
        }
      } else {
        const cid = CID.asCID(value2);
        if (cid) {
          yield [path2.join("/"), cid];
        } else {
          yield* links$1(value2, path2);
        }
      }
    }
  }
  return [];
};
function createLocal$1({ repo }) {
  async function* refsLocal(options = {}) {
    for await (const cid of repo.blocks.queryKeys({}, { signal: options.signal })) {
      yield { ref: cid.toString() };
    }
  }
  return withTimeoutOption(refsLocal);
}
function createWantlist$1({ network }) {
  async function wantlist(options = {}) {
    const { bitswap } = await network.use(options);
    const list = bitswap.getWantlist();
    return Array.from(list).map((e) => e[1].cid);
  }
  return withTimeoutOption(wantlist);
}
function createWantlistForPeer$1({ network }) {
  async function wantlistForPeer(peerId, options = {}) {
    const { bitswap } = await network.use(options);
    const list = bitswap.wantlistForPeer(peerId);
    return Array.from(list).map((e) => e[1].cid);
  }
  return withTimeoutOption(wantlistForPeer);
}
function createUnwant$1({ network }) {
  async function unwant(cids, options = {}) {
    const { bitswap } = await network.use(options);
    if (!Array.isArray(cids)) {
      cids = [cids];
    }
    return bitswap.unwant(cids);
  }
  return withTimeoutOption(unwant);
}
function createStat$9({ network }) {
  async function stat(options = {}) {
    const bitswap = (await network.use(options)).bitswap;
    const snapshot = bitswap.stat().snapshot;
    return {
      provideBufLen: parseInt(snapshot.providesBufferLength.toString()),
      blocksReceived: BigInt(snapshot.blocksReceived.toString()),
      wantlist: Array.from(bitswap.getWantlist()).map((e) => e[1].cid),
      peers: bitswap.peers(),
      dupBlksReceived: BigInt(snapshot.dupBlksReceived.toString()),
      dupDataReceived: BigInt(snapshot.dupDataReceived.toString()),
      dataReceived: BigInt(snapshot.dataReceived.toString()),
      blocksSent: BigInt(snapshot.blocksSent.toString()),
      dataSent: BigInt(snapshot.dataSent.toString())
    };
  }
  return withTimeoutOption(stat);
}
class BitswapAPI {
  constructor({ network }) {
    this.wantlist = createWantlist$1({ network });
    this.wantlistForPeer = createWantlistForPeer$1({ network });
    this.unwant = createUnwant$1({ network });
    this.stat = createStat$9({ network });
  }
}
function isValidMultiaddr(ma) {
  try {
    return IPFS$1.matches(ma);
  } catch (err2) {
    return false;
  }
}
function createAdd$6({ repo }) {
  async function add(multiaddr2, options = {}) {
    if (!isValidMultiaddr(multiaddr2)) {
      throw new Error(`${multiaddr2} is not a valid Multiaddr`);
    }
    const config2 = await repo.config.getAll(options);
    const boostrappers = config2.Bootstrap || [];
    boostrappers.push(multiaddr2.toString());
    config2.Bootstrap = Array.from(
      new Set(boostrappers)
    ).sort((a, b2) => a.localeCompare(b2));
    await repo.config.replace(config2);
    return {
      Peers: [multiaddr2]
    };
  }
  return withTimeoutOption(add);
}
function createClear$1({ repo }) {
  async function clear4(options = {}) {
    const config2 = await repo.config.getAll(options);
    const removed = config2.Bootstrap || [];
    config2.Bootstrap = [];
    await repo.config.replace(config2);
    return { Peers: removed.map((ma) => multiaddr(ma)) };
  }
  return withTimeoutOption(clear4);
}
function createList$4({ repo }) {
  async function list(options = {}) {
    const peers = await repo.config.get("Bootstrap", options);
    return { Peers: (peers || []).map((ma) => multiaddr(ma)) };
  }
  return withTimeoutOption(list);
}
const getDefaultConfig = () => ({
  Addresses: {
    Swarm: [],
    Announce: [],
    NoAnnounce: [],
    API: "",
    Gateway: "",
    RPC: "",
    Delegates: [
      "/dns4/node0.delegate.ipfs.io/tcp/443/https",
      "/dns4/node1.delegate.ipfs.io/tcp/443/https",
      "/dns4/node2.delegate.ipfs.io/tcp/443/https",
      "/dns4/node3.delegate.ipfs.io/tcp/443/https"
    ]
  },
  Discovery: {
    MDNS: {
      Enabled: false,
      Interval: 10
    },
    webRTCStar: {
      Enabled: true
    }
  },
  Bootstrap: [
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN",
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb",
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmZa1sAxajnQjVM8WjWXoMbmPd7NsWhfKsPkErzpm9wGkp",
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa",
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt",
    "/dns4/node0.preload.ipfs.io/tcp/443/wss/p2p/QmZMxNdpMkewiVZLMRxaNxUeZpDUb34pWjZ1kZvsd16Zic",
    "/dns4/node1.preload.ipfs.io/tcp/443/wss/p2p/Qmbut9Ywz9YEDrz8ySBSgWyJk41Uvm2QJPhwDJzJyGFsD6",
    "/dns4/node2.preload.ipfs.io/tcp/443/wss/p2p/QmV7gnbW5VTcJ3oyM2Xk1rdFBJ3kTkvxc87UFGsun29STS",
    "/dns4/node3.preload.ipfs.io/tcp/443/wss/p2p/QmY7JB6MQXhxHvq7dBDh4HpbH29v4yE9JRadAVpndvzySN"
  ],
  Pubsub: {
    Enabled: true
  },
  Swarm: {
    ConnMgr: {
      LowWater: 5,
      HighWater: 20
    },
    DisableNatPortMap: true
  },
  Routing: {
    Type: "dhtclient"
  }
});
function createReset$1({ repo }) {
  async function reset2(options = {}) {
    const config2 = await repo.config.getAll(options);
    config2.Bootstrap = getDefaultConfig().Bootstrap;
    await repo.config.replace(config2);
    return {
      Peers: getDefaultConfig().Bootstrap.map((ma) => multiaddr(ma))
    };
  }
  return withTimeoutOption(reset2);
}
function createRm$a({ repo }) {
  async function rm(multiaddr2, options = {}) {
    if (!isValidMultiaddr(multiaddr2)) {
      throw new Error(`${multiaddr2} is not a valid Multiaddr`);
    }
    const config2 = await repo.config.getAll(options);
    config2.Bootstrap = (config2.Bootstrap || []).filter((ma) => ma.toString() !== multiaddr2.toString());
    await repo.config.replace(config2);
    return { Peers: [multiaddr2] };
  }
  return withTimeoutOption(rm);
}
class BootstrapAPI {
  constructor({ repo }) {
    this.add = createAdd$6({ repo });
    this.list = createList$4({ repo });
    this.rm = createRm$a({ repo });
    this.clear = createClear$1({ repo });
    this.reset = createReset$1({ repo });
  }
}
function createGet$9({ preload: preload2, repo }) {
  async function get3(cid, options = {}) {
    if (options.preload !== false) {
      preload2(cid);
    }
    return repo.blocks.get(cid, options);
  }
  return withTimeoutOption(get3);
}
function createPut$6({ codecs: codecs2, hashers, repo, preload: preload2 }) {
  async function put(block, options = {}) {
    const release = options.pin ? await repo.gcLock.readLock() : null;
    try {
      const cidVersion = options.version != null ? options.version : 0;
      const codecName = options.format || (cidVersion === 0 ? "dag-pb" : "raw");
      const hasher = await hashers.getHasher(options.mhtype || "sha2-256");
      const hash2 = await hasher.digest(block);
      const codec = await codecs2.getCodec(codecName);
      const cid = CID.create(cidVersion, codec.code, hash2);
      await repo.blocks.put(cid, block, {
        signal: options.signal
      });
      if (options.preload !== false) {
        preload2(cid);
      }
      if (options.pin === true) {
        await repo.pins.pinRecursively(cid, {
          signal: options.signal
        });
      }
      return cid;
    } finally {
      if (release) {
        release();
      }
    }
  }
  return withTimeoutOption(put);
}
function pDefer$1() {
  const deferred = {};
  deferred.promise = new Promise((resolve2, reject) => {
    deferred.resolve = resolve2;
    deferred.reject = reject;
  });
  return deferred;
}
const CustomEvent$1 = globalThis.CustomEvent ?? Event;
async function* parallel$1(source2, options = {}) {
  let concurrency = options.concurrency ?? Infinity;
  if (concurrency < 1) {
    concurrency = Infinity;
  }
  const ordered = options.ordered == null ? false : options.ordered;
  const emitter = new EventTarget();
  const ops = [];
  let slotAvailable = pDefer$1();
  let resultAvailable = pDefer$1();
  let sourceFinished = false;
  let sourceErr;
  let opErred = false;
  emitter.addEventListener("task-complete", () => {
    resultAvailable.resolve();
  });
  void Promise.resolve().then(async () => {
    try {
      for await (const task of source2) {
        if (ops.length === concurrency) {
          slotAvailable = pDefer$1();
          await slotAvailable.promise;
        }
        if (opErred) {
          break;
        }
        const op = {
          done: false
        };
        ops.push(op);
        task().then((result) => {
          op.done = true;
          op.ok = true;
          op.value = result;
          emitter.dispatchEvent(new CustomEvent$1("task-complete"));
        }, (err2) => {
          op.done = true;
          op.err = err2;
          emitter.dispatchEvent(new CustomEvent$1("task-complete"));
        });
      }
      sourceFinished = true;
      emitter.dispatchEvent(new CustomEvent$1("task-complete"));
    } catch (err2) {
      sourceErr = err2;
      emitter.dispatchEvent(new CustomEvent$1("task-complete"));
    }
  });
  function valuesAvailable() {
    if (ordered) {
      return ops[0]?.done;
    }
    return Boolean(ops.find((op) => op.done));
  }
  function* yieldOrderedValues() {
    while (ops.length > 0 && ops[0].done) {
      const op = ops[0];
      ops.shift();
      if (op.ok) {
        yield op.value;
      } else {
        opErred = true;
        slotAvailable.resolve();
        throw op.err;
      }
      slotAvailable.resolve();
    }
  }
  function* yieldUnOrderedValues() {
    while (valuesAvailable()) {
      for (let i2 = 0; i2 < ops.length; i2++) {
        if (ops[i2].done) {
          const op = ops[i2];
          ops.splice(i2, 1);
          i2--;
          if (op.ok) {
            yield op.value;
          } else {
            opErred = true;
            slotAvailable.resolve();
            throw op.err;
          }
          slotAvailable.resolve();
        }
      }
    }
  }
  while (true) {
    if (!valuesAvailable()) {
      resultAvailable = pDefer$1();
      await resultAvailable.promise;
    }
    if (sourceErr != null) {
      throw sourceErr;
    }
    if (ordered) {
      yield* yieldOrderedValues();
    } else {
      yield* yieldUnOrderedValues();
    }
    if (sourceFinished && ops.length === 0) {
      break;
    }
  }
}
async function* map$3(source2, func) {
  for await (const val of source2) {
    yield func(val);
  }
}
async function* filter$1(source2, fn) {
  for await (const entry of source2) {
    if (await fn(entry)) {
      yield entry;
    }
  }
}
function cleanCid(cid) {
  if (cid instanceof Uint8Array) {
    return CID.decode(cid);
  }
  return CID.parse(cid.toString());
}
const BLOCK_RM_CONCURRENCY$1 = 8;
function createRm$9({ repo }) {
  async function* rm(cids, options = {}) {
    if (!Array.isArray(cids)) {
      cids = [cids];
    }
    const release = await repo.gcLock.writeLock();
    try {
      yield* pipe(
        cids,
        (source2) => map$3(source2, (cid) => {
          return async () => {
            cid = cleanCid(cid);
            const result = { cid };
            try {
              const has = await repo.blocks.has(cid);
              if (!has) {
                throw errCode(new Error("block not found"), "ERR_BLOCK_NOT_FOUND");
              }
              await repo.blocks.delete(cid);
            } catch (err2) {
              if (!options.force) {
                err2.message = `cannot remove ${cid}: ${err2.message}`;
                result.error = err2;
              }
            }
            return result;
          };
        }),
        (source2) => parallel$1(source2, { concurrency: BLOCK_RM_CONCURRENCY$1 }),
        (source2) => filter$1(source2, () => !options.quiet)
      );
    } finally {
      release();
    }
  }
  return withTimeoutOption(rm);
}
function createStat$8({ repo, preload: preload2 }) {
  async function stat(cid, options = {}) {
    cid = cleanCid(cid);
    if (options.preload !== false) {
      preload2(cid);
    }
    const block = await repo.blocks.get(cid);
    return { cid, size: block.length };
  }
  return withTimeoutOption(stat);
}
class BlockAPI {
  constructor({ codecs: codecs2, hashers, preload: preload2, repo }) {
    this.get = createGet$9({ preload: preload2, repo });
    this.put = createPut$6({ codecs: codecs2, hashers, preload: preload2, repo });
    this.rm = createRm$9({ repo });
    this.stat = createStat$8({ preload: preload2, repo });
  }
}
async function* browserReadableStreamToIt(stream2, options = {}) {
  const reader2 = stream2.getReader();
  try {
    while (true) {
      const result = await reader2.read();
      if (result.done) {
        return;
      }
      yield result.value;
    }
  } finally {
    if (options.preventCancel !== true) {
      await reader2.cancel();
    }
    reader2.releaseLock();
  }
}
function blobToIt(blob) {
  if (typeof blob.stream === "function") {
    return browserReadableStreamToIt(blob.stream());
  }
  return browserReadableStreamToIt(new Response(blob).body);
}
function peekableIterator(iterable) {
  const [iterator2, symbol2] = iterable[Symbol.asyncIterator] != null ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator] : [iterable[Symbol.iterator](), Symbol.iterator];
  const queue = [];
  return {
    peek: () => {
      return iterator2.next();
    },
    push: (value2) => {
      queue.push(value2);
    },
    next: () => {
      if (queue.length > 0) {
        return {
          done: false,
          value: queue.shift()
        };
      }
      return iterator2.next();
    },
    [symbol2]() {
      return this;
    }
  };
}
async function all$1(source2) {
  const arr = [];
  for await (const entry of source2) {
    arr.push(entry);
  }
  return arr;
}
function isBytes(obj) {
  return ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;
}
function isBlob(obj) {
  return obj.constructor && (obj.constructor.name === "Blob" || obj.constructor.name === "File") && typeof obj.stream === "function";
}
function isFileObject(obj) {
  return typeof obj === "object" && (obj.path || obj.content);
}
const isReadableStream = (value2) => value2 && typeof value2.getReader === "function";
async function* toAsyncIterable(thing) {
  yield thing;
}
async function normaliseContent$1(input) {
  if (isBytes(input)) {
    return toAsyncIterable(toBytes(input));
  }
  if (typeof input === "string" || input instanceof String) {
    return toAsyncIterable(toBytes(input.toString()));
  }
  if (isBlob(input)) {
    return blobToIt(input);
  }
  if (isReadableStream(input)) {
    input = browserReadableStreamToIt(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = peekableIterator(input);
    const { value: value2, done } = await peekable.peek();
    if (done) {
      return toAsyncIterable(new Uint8Array(0));
    }
    peekable.push(value2);
    if (Number.isInteger(value2)) {
      return toAsyncIterable(Uint8Array.from(await all$1(peekable)));
    }
    if (isBytes(value2) || typeof value2 === "string" || value2 instanceof String) {
      return map$3(peekable, toBytes);
    }
  }
  throw errCode(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
}
function toBytes(chunk) {
  if (chunk instanceof Uint8Array) {
    return chunk;
  }
  if (ArrayBuffer.isView(chunk)) {
    return new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
  }
  if (chunk instanceof ArrayBuffer) {
    return new Uint8Array(chunk);
  }
  if (Array.isArray(chunk)) {
    return Uint8Array.from(chunk);
  }
  return fromString$3(chunk.toString());
}
async function* normaliseCandidateSingle(input, normaliseContent2) {
  if (input === null || input === void 0) {
    throw errCode(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
  }
  if (typeof input === "string" || input instanceof String) {
    yield toFileObject$1(input.toString(), normaliseContent2);
    return;
  }
  if (isBytes(input) || isBlob(input)) {
    yield toFileObject$1(input, normaliseContent2);
    return;
  }
  if (isReadableStream(input)) {
    input = browserReadableStreamToIt(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = peekableIterator(input);
    const { value: value2, done } = await peekable.peek();
    if (done) {
      yield { content: [] };
      return;
    }
    peekable.push(value2);
    if (Number.isInteger(value2) || isBytes(value2) || typeof value2 === "string" || value2 instanceof String) {
      yield toFileObject$1(peekable, normaliseContent2);
      return;
    }
    throw errCode(new Error("Unexpected input: multiple items passed - if you are using ipfs.add, please use ipfs.addAll instead"), "ERR_UNEXPECTED_INPUT");
  }
  if (isFileObject(input)) {
    yield toFileObject$1(input, normaliseContent2);
    return;
  }
  throw errCode(new Error('Unexpected input: cannot convert "' + typeof input + '" into ImportCandidate'), "ERR_UNEXPECTED_INPUT");
}
async function toFileObject$1(input, normaliseContent2) {
  const { path: path2, mode, mtime, content } = input;
  const file = {
    path: path2 || "",
    mode: parseMode(mode),
    mtime: parseMtime$1(mtime)
  };
  if (content) {
    file.content = await normaliseContent2(content);
  } else if (!path2) {
    file.content = await normaliseContent2(input);
  }
  return file;
}
function normaliseInput$2(input) {
  return normaliseCandidateSingle(input, normaliseContent$1);
}
function createAdd$5({ addAll }) {
  async function add(entry, options = {}) {
    const result = await last(addAll(normaliseInput$2(entry), options));
    if (result == null) {
      throw Error("Failed to add a file, if you see this please report a bug");
    }
    return result;
  }
  return add;
}
async function* batch(source2, size2 = 1) {
  let things = [];
  if (size2 < 1) {
    size2 = 1;
  }
  for await (const thing of source2) {
    things.push(thing);
    while (things.length >= size2) {
      yield things.slice(0, size2);
      things = things.slice(size2);
    }
  }
  while (things.length > 0) {
    yield things.slice(0, size2);
    things = things.slice(size2);
  }
}
async function* parallelBatch(source2, size2 = 1) {
  for await (const tasks of batch(source2, size2)) {
    const things = tasks.map(async (p) => {
      return await p().then((value2) => ({ ok: true, value: value2 }), (err2) => ({ ok: false, err: err2 }));
    });
    for (let i2 = 0; i2 < things.length; i2++) {
      const result = await things[i2];
      if (result.ok) {
        yield result.value;
      } else {
        throw result.err;
      }
    }
  }
}
var murmurhash3jsRevisited = { exports: {} };
var murmurHash3js = { exports: {} };
(function(module, exports) {
  (function(root, undefined$1) {
    var library = {
      "version": "3.0.0",
      "x86": {},
      "x64": {},
      "inputValidation": true
    };
    function _validBytes(bytes2) {
      if (!Array.isArray(bytes2) && !ArrayBuffer.isView(bytes2)) {
        return false;
      }
      for (var i2 = 0; i2 < bytes2.length; i2++) {
        if (!Number.isInteger(bytes2[i2]) || bytes2[i2] < 0 || bytes2[i2] > 255) {
          return false;
        }
      }
      return true;
    }
    function _x86Multiply(m, n) {
      return (m & 65535) * n + (((m >>> 16) * n & 65535) << 16);
    }
    function _x86Rotl(m, n) {
      return m << n | m >>> 32 - n;
    }
    function _x86Fmix(h) {
      h ^= h >>> 16;
      h = _x86Multiply(h, 2246822507);
      h ^= h >>> 13;
      h = _x86Multiply(h, 3266489909);
      h ^= h >>> 16;
      return h;
    }
    function _x64Add(m, n) {
      m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
      n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
      var o = [0, 0, 0, 0];
      o[3] += m[3] + n[3];
      o[2] += o[3] >>> 16;
      o[3] &= 65535;
      o[2] += m[2] + n[2];
      o[1] += o[2] >>> 16;
      o[2] &= 65535;
      o[1] += m[1] + n[1];
      o[0] += o[1] >>> 16;
      o[1] &= 65535;
      o[0] += m[0] + n[0];
      o[0] &= 65535;
      return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
    }
    function _x64Multiply(m, n) {
      m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
      n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
      var o = [0, 0, 0, 0];
      o[3] += m[3] * n[3];
      o[2] += o[3] >>> 16;
      o[3] &= 65535;
      o[2] += m[2] * n[3];
      o[1] += o[2] >>> 16;
      o[2] &= 65535;
      o[2] += m[3] * n[2];
      o[1] += o[2] >>> 16;
      o[2] &= 65535;
      o[1] += m[1] * n[3];
      o[0] += o[1] >>> 16;
      o[1] &= 65535;
      o[1] += m[2] * n[2];
      o[0] += o[1] >>> 16;
      o[1] &= 65535;
      o[1] += m[3] * n[1];
      o[0] += o[1] >>> 16;
      o[1] &= 65535;
      o[0] += m[0] * n[3] + m[1] * n[2] + m[2] * n[1] + m[3] * n[0];
      o[0] &= 65535;
      return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
    }
    function _x64Rotl(m, n) {
      n %= 64;
      if (n === 32) {
        return [m[1], m[0]];
      } else if (n < 32) {
        return [m[0] << n | m[1] >>> 32 - n, m[1] << n | m[0] >>> 32 - n];
      } else {
        n -= 32;
        return [m[1] << n | m[0] >>> 32 - n, m[0] << n | m[1] >>> 32 - n];
      }
    }
    function _x64LeftShift(m, n) {
      n %= 64;
      if (n === 0) {
        return m;
      } else if (n < 32) {
        return [m[0] << n | m[1] >>> 32 - n, m[1] << n];
      } else {
        return [m[1] << n - 32, 0];
      }
    }
    function _x64Xor(m, n) {
      return [m[0] ^ n[0], m[1] ^ n[1]];
    }
    function _x64Fmix(h) {
      h = _x64Xor(h, [0, h[0] >>> 1]);
      h = _x64Multiply(h, [4283543511, 3981806797]);
      h = _x64Xor(h, [0, h[0] >>> 1]);
      h = _x64Multiply(h, [3301882366, 444984403]);
      h = _x64Xor(h, [0, h[0] >>> 1]);
      return h;
    }
    library.x86.hash32 = function(bytes2, seed2) {
      if (library.inputValidation && !_validBytes(bytes2)) {
        return undefined$1;
      }
      seed2 = seed2 || 0;
      var remainder = bytes2.length % 4;
      var blocks = bytes2.length - remainder;
      var h1 = seed2;
      var k1 = 0;
      var c1 = 3432918353;
      var c2 = 461845907;
      for (var i2 = 0; i2 < blocks; i2 = i2 + 4) {
        k1 = bytes2[i2] | bytes2[i2 + 1] << 8 | bytes2[i2 + 2] << 16 | bytes2[i2 + 3] << 24;
        k1 = _x86Multiply(k1, c1);
        k1 = _x86Rotl(k1, 15);
        k1 = _x86Multiply(k1, c2);
        h1 ^= k1;
        h1 = _x86Rotl(h1, 13);
        h1 = _x86Multiply(h1, 5) + 3864292196;
      }
      k1 = 0;
      switch (remainder) {
        case 3:
          k1 ^= bytes2[i2 + 2] << 16;
        case 2:
          k1 ^= bytes2[i2 + 1] << 8;
        case 1:
          k1 ^= bytes2[i2];
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
      }
      h1 ^= bytes2.length;
      h1 = _x86Fmix(h1);
      return h1 >>> 0;
    };
    library.x86.hash128 = function(bytes2, seed2) {
      if (library.inputValidation && !_validBytes(bytes2)) {
        return undefined$1;
      }
      seed2 = seed2 || 0;
      var remainder = bytes2.length % 16;
      var blocks = bytes2.length - remainder;
      var h1 = seed2;
      var h2 = seed2;
      var h3 = seed2;
      var h4 = seed2;
      var k1 = 0;
      var k2 = 0;
      var k3 = 0;
      var k4 = 0;
      var c1 = 597399067;
      var c2 = 2869860233;
      var c3 = 951274213;
      var c4 = 2716044179;
      for (var i2 = 0; i2 < blocks; i2 = i2 + 16) {
        k1 = bytes2[i2] | bytes2[i2 + 1] << 8 | bytes2[i2 + 2] << 16 | bytes2[i2 + 3] << 24;
        k2 = bytes2[i2 + 4] | bytes2[i2 + 5] << 8 | bytes2[i2 + 6] << 16 | bytes2[i2 + 7] << 24;
        k3 = bytes2[i2 + 8] | bytes2[i2 + 9] << 8 | bytes2[i2 + 10] << 16 | bytes2[i2 + 11] << 24;
        k4 = bytes2[i2 + 12] | bytes2[i2 + 13] << 8 | bytes2[i2 + 14] << 16 | bytes2[i2 + 15] << 24;
        k1 = _x86Multiply(k1, c1);
        k1 = _x86Rotl(k1, 15);
        k1 = _x86Multiply(k1, c2);
        h1 ^= k1;
        h1 = _x86Rotl(h1, 19);
        h1 += h2;
        h1 = _x86Multiply(h1, 5) + 1444728091;
        k2 = _x86Multiply(k2, c2);
        k2 = _x86Rotl(k2, 16);
        k2 = _x86Multiply(k2, c3);
        h2 ^= k2;
        h2 = _x86Rotl(h2, 17);
        h2 += h3;
        h2 = _x86Multiply(h2, 5) + 197830471;
        k3 = _x86Multiply(k3, c3);
        k3 = _x86Rotl(k3, 17);
        k3 = _x86Multiply(k3, c4);
        h3 ^= k3;
        h3 = _x86Rotl(h3, 15);
        h3 += h4;
        h3 = _x86Multiply(h3, 5) + 2530024501;
        k4 = _x86Multiply(k4, c4);
        k4 = _x86Rotl(k4, 18);
        k4 = _x86Multiply(k4, c1);
        h4 ^= k4;
        h4 = _x86Rotl(h4, 13);
        h4 += h1;
        h4 = _x86Multiply(h4, 5) + 850148119;
      }
      k1 = 0;
      k2 = 0;
      k3 = 0;
      k4 = 0;
      switch (remainder) {
        case 15:
          k4 ^= bytes2[i2 + 14] << 16;
        case 14:
          k4 ^= bytes2[i2 + 13] << 8;
        case 13:
          k4 ^= bytes2[i2 + 12];
          k4 = _x86Multiply(k4, c4);
          k4 = _x86Rotl(k4, 18);
          k4 = _x86Multiply(k4, c1);
          h4 ^= k4;
        case 12:
          k3 ^= bytes2[i2 + 11] << 24;
        case 11:
          k3 ^= bytes2[i2 + 10] << 16;
        case 10:
          k3 ^= bytes2[i2 + 9] << 8;
        case 9:
          k3 ^= bytes2[i2 + 8];
          k3 = _x86Multiply(k3, c3);
          k3 = _x86Rotl(k3, 17);
          k3 = _x86Multiply(k3, c4);
          h3 ^= k3;
        case 8:
          k2 ^= bytes2[i2 + 7] << 24;
        case 7:
          k2 ^= bytes2[i2 + 6] << 16;
        case 6:
          k2 ^= bytes2[i2 + 5] << 8;
        case 5:
          k2 ^= bytes2[i2 + 4];
          k2 = _x86Multiply(k2, c2);
          k2 = _x86Rotl(k2, 16);
          k2 = _x86Multiply(k2, c3);
          h2 ^= k2;
        case 4:
          k1 ^= bytes2[i2 + 3] << 24;
        case 3:
          k1 ^= bytes2[i2 + 2] << 16;
        case 2:
          k1 ^= bytes2[i2 + 1] << 8;
        case 1:
          k1 ^= bytes2[i2];
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
      }
      h1 ^= bytes2.length;
      h2 ^= bytes2.length;
      h3 ^= bytes2.length;
      h4 ^= bytes2.length;
      h1 += h2;
      h1 += h3;
      h1 += h4;
      h2 += h1;
      h3 += h1;
      h4 += h1;
      h1 = _x86Fmix(h1);
      h2 = _x86Fmix(h2);
      h3 = _x86Fmix(h3);
      h4 = _x86Fmix(h4);
      h1 += h2;
      h1 += h3;
      h1 += h4;
      h2 += h1;
      h3 += h1;
      h4 += h1;
      return ("00000000" + (h1 >>> 0).toString(16)).slice(-8) + ("00000000" + (h2 >>> 0).toString(16)).slice(-8) + ("00000000" + (h3 >>> 0).toString(16)).slice(-8) + ("00000000" + (h4 >>> 0).toString(16)).slice(-8);
    };
    library.x64.hash128 = function(bytes2, seed2) {
      if (library.inputValidation && !_validBytes(bytes2)) {
        return undefined$1;
      }
      seed2 = seed2 || 0;
      var remainder = bytes2.length % 16;
      var blocks = bytes2.length - remainder;
      var h1 = [0, seed2];
      var h2 = [0, seed2];
      var k1 = [0, 0];
      var k2 = [0, 0];
      var c1 = [2277735313, 289559509];
      var c2 = [1291169091, 658871167];
      for (var i2 = 0; i2 < blocks; i2 = i2 + 16) {
        k1 = [bytes2[i2 + 4] | bytes2[i2 + 5] << 8 | bytes2[i2 + 6] << 16 | bytes2[i2 + 7] << 24, bytes2[i2] | bytes2[i2 + 1] << 8 | bytes2[i2 + 2] << 16 | bytes2[i2 + 3] << 24];
        k2 = [bytes2[i2 + 12] | bytes2[i2 + 13] << 8 | bytes2[i2 + 14] << 16 | bytes2[i2 + 15] << 24, bytes2[i2 + 8] | bytes2[i2 + 9] << 8 | bytes2[i2 + 10] << 16 | bytes2[i2 + 11] << 24];
        k1 = _x64Multiply(k1, c1);
        k1 = _x64Rotl(k1, 31);
        k1 = _x64Multiply(k1, c2);
        h1 = _x64Xor(h1, k1);
        h1 = _x64Rotl(h1, 27);
        h1 = _x64Add(h1, h2);
        h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 1390208809]);
        k2 = _x64Multiply(k2, c2);
        k2 = _x64Rotl(k2, 33);
        k2 = _x64Multiply(k2, c1);
        h2 = _x64Xor(h2, k2);
        h2 = _x64Rotl(h2, 31);
        h2 = _x64Add(h2, h1);
        h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 944331445]);
      }
      k1 = [0, 0];
      k2 = [0, 0];
      switch (remainder) {
        case 15:
          k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i2 + 14]], 48));
        case 14:
          k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i2 + 13]], 40));
        case 13:
          k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i2 + 12]], 32));
        case 12:
          k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i2 + 11]], 24));
        case 11:
          k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i2 + 10]], 16));
        case 10:
          k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i2 + 9]], 8));
        case 9:
          k2 = _x64Xor(k2, [0, bytes2[i2 + 8]]);
          k2 = _x64Multiply(k2, c2);
          k2 = _x64Rotl(k2, 33);
          k2 = _x64Multiply(k2, c1);
          h2 = _x64Xor(h2, k2);
        case 8:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i2 + 7]], 56));
        case 7:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i2 + 6]], 48));
        case 6:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i2 + 5]], 40));
        case 5:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i2 + 4]], 32));
        case 4:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i2 + 3]], 24));
        case 3:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i2 + 2]], 16));
        case 2:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i2 + 1]], 8));
        case 1:
          k1 = _x64Xor(k1, [0, bytes2[i2]]);
          k1 = _x64Multiply(k1, c1);
          k1 = _x64Rotl(k1, 31);
          k1 = _x64Multiply(k1, c2);
          h1 = _x64Xor(h1, k1);
      }
      h1 = _x64Xor(h1, [0, bytes2.length]);
      h2 = _x64Xor(h2, [0, bytes2.length]);
      h1 = _x64Add(h1, h2);
      h2 = _x64Add(h2, h1);
      h1 = _x64Fmix(h1);
      h2 = _x64Fmix(h2);
      h1 = _x64Add(h1, h2);
      h2 = _x64Add(h2, h1);
      return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[1] >>> 0).toString(16)).slice(-8);
    };
    {
      if (module.exports) {
        exports = module.exports = library;
      }
      exports.murmurHash3 = library;
    }
  })();
})(murmurHash3js, murmurHash3js.exports);
(function(module) {
  module.exports = murmurHash3js.exports;
})(murmurhash3jsRevisited);
const mur = /* @__PURE__ */ getDefaultExportFromCjs(murmurhash3jsRevisited.exports);
function fromNumberTo32BitBuf(number) {
  const bytes2 = new Array(4);
  for (let i2 = 0; i2 < 4; i2++) {
    bytes2[i2] = number & 255;
    number = number >> 8;
  }
  return new Uint8Array(bytes2);
}
from$3({
  name: "murmur3-32",
  code: 35,
  encode: (input) => fromNumberTo32BitBuf(mur.x86.hash32(input))
});
const murmur3128 = from$3({
  name: "murmur3-128",
  code: 34,
  encode: (input) => fromHex(mur.x64.hash128(input))
});
from$3({
  name: "murmur3-x64-64",
  code: 34,
  encode: (input) => fromHex(mur.x64.hash128(input)).subarray(0, 8)
});
async function hamtHashFn$1(buf2) {
  return (await murmur3128.encode(buf2)).slice(0, 8).reverse();
}
const defaultOptions$k = {
  chunker: "fixed",
  strategy: "balanced",
  rawLeaves: false,
  onlyHash: false,
  reduceSingleLeafToSelf: true,
  hasher: sha256$3,
  leafType: "file",
  cidVersion: 0,
  progress: () => () => {
  },
  shardSplitThreshold: 1e3,
  fileImportConcurrency: 50,
  blockWriteConcurrency: 10,
  minChunkSize: 262144,
  maxChunkSize: 262144,
  avgChunkSize: 262144,
  window: 16,
  polynomial: 17437180132763652,
  maxChildrenPerNode: 174,
  layerRepeat: 4,
  wrapWithDirectory: false,
  recursive: false,
  hidden: false,
  timeout: void 0,
  hamtHashFn: hamtHashFn$1,
  hamtHashCode: 34,
  hamtBucketBits: 8
};
const defaultOptions$l = (options = {}) => {
  const defaults2 = mergeOptions$g.bind({ ignoreUndefined: true });
  return defaults2(defaultOptions$k, options);
};
const persist$1 = async (buffer2, blockstore, options) => {
  if (!options.codec) {
    options.codec = dagPB;
  }
  if (!options.hasher) {
    options.hasher = sha256$3;
  }
  if (options.cidVersion === void 0) {
    options.cidVersion = 1;
  }
  if (options.codec === dagPB && options.hasher !== sha256$3) {
    options.cidVersion = 1;
  }
  const multihash = await options.hasher.digest(buffer2);
  const cid = CID.create(options.cidVersion, options.codec.code, multihash);
  if (!options.onlyHash) {
    await blockstore.put(cid, buffer2, {
      signal: options.signal
    });
  }
  return cid;
};
const dirBuilder = async (item, blockstore, options) => {
  const unixfs = new UnixFS({
    type: "directory",
    mtime: item.mtime,
    mode: item.mode
  });
  const buffer2 = encode$o(prepare({ Data: unixfs.marshal() }));
  const cid = await persist$1(buffer2, blockstore, options);
  const path2 = item.path;
  return {
    cid,
    path: path2,
    unixfs,
    size: buffer2.length
  };
};
async function flat(source2, reduce2) {
  return reduce2(await all$1(source2));
}
function balanced(source2, reduce2, options) {
  return reduceToParents(source2, reduce2, options);
}
async function reduceToParents(source2, reduce2, options) {
  const roots2 = [];
  for await (const chunked of batch(source2, options.maxChildrenPerNode)) {
    roots2.push(await reduce2(chunked));
  }
  if (roots2.length > 1) {
    return reduceToParents(roots2, reduce2, options);
  }
  return roots2[0];
}
async function trickleStream(source2, reduce2, options) {
  const root = new Root(options.layerRepeat);
  let iteration = 0;
  let maxDepth = 1;
  let subTree = root;
  for await (const layer of batch(source2, options.maxChildrenPerNode)) {
    if (subTree.isFull()) {
      if (subTree !== root) {
        root.addChild(await subTree.reduce(reduce2));
      }
      if (iteration && iteration % options.layerRepeat === 0) {
        maxDepth++;
      }
      subTree = new SubTree(maxDepth, options.layerRepeat, iteration);
      iteration++;
    }
    subTree.append(layer);
  }
  if (subTree && subTree !== root) {
    root.addChild(await subTree.reduce(reduce2));
  }
  return root.reduce(reduce2);
}
class SubTree {
  constructor(maxDepth, layerRepeat, iteration = 0) {
    this.maxDepth = maxDepth;
    this.layerRepeat = layerRepeat;
    this.currentDepth = 1;
    this.iteration = iteration;
    this.root = this.node = this.parent = {
      children: [],
      depth: this.currentDepth,
      maxDepth,
      maxChildren: (this.maxDepth - this.currentDepth) * this.layerRepeat
    };
  }
  isFull() {
    if (!this.root.data) {
      return false;
    }
    if (this.currentDepth < this.maxDepth && this.node.maxChildren) {
      this._addNextNodeToParent(this.node);
      return false;
    }
    const distantRelative = this._findParent(this.node, this.currentDepth);
    if (distantRelative) {
      this._addNextNodeToParent(distantRelative);
      return false;
    }
    return true;
  }
  _addNextNodeToParent(parent2) {
    this.parent = parent2;
    const nextNode = {
      children: [],
      depth: parent2.depth + 1,
      parent: parent2,
      maxDepth: this.maxDepth,
      maxChildren: Math.floor(parent2.children.length / this.layerRepeat) * this.layerRepeat
    };
    parent2.children.push(nextNode);
    this.currentDepth = nextNode.depth;
    this.node = nextNode;
  }
  append(layer) {
    this.node.data = layer;
  }
  reduce(reduce2) {
    return this._reduce(this.root, reduce2);
  }
  async _reduce(node2, reduce2) {
    let children = [];
    if (node2.children.length) {
      children = await Promise.all(
        node2.children.filter((child) => child.data).map((child) => this._reduce(child, reduce2))
      );
    }
    return reduce2((node2.data || []).concat(children));
  }
  _findParent(node2, depth) {
    const parent2 = node2.parent;
    if (!parent2 || parent2.depth === 0) {
      return;
    }
    if (parent2.children.length === parent2.maxChildren || !parent2.maxChildren) {
      return this._findParent(parent2, depth);
    }
    return parent2;
  }
}
class Root extends SubTree {
  constructor(layerRepeat) {
    super(0, layerRepeat);
    this.root.depth = 0;
    this.currentDepth = 1;
  }
  addChild(child) {
    this.root.children.push(child);
  }
  reduce(reduce2) {
    return reduce2((this.root.data || []).concat(this.root.children));
  }
}
async function* bufferImporter(file, block, options) {
  for await (let buffer2 of file.content) {
    yield async () => {
      options.progress(buffer2.length, file.path);
      let unixfs;
      const opts = {
        codec: dagPB,
        cidVersion: options.cidVersion,
        hasher: options.hasher,
        onlyHash: options.onlyHash
      };
      if (options.rawLeaves) {
        opts.codec = raw;
        opts.cidVersion = 1;
      } else {
        unixfs = new UnixFS({
          type: options.leafType,
          data: buffer2
        });
        buffer2 = encode$o({
          Data: unixfs.marshal(),
          Links: []
        });
      }
      return {
        cid: await persist$1(buffer2, block, opts),
        unixfs,
        size: buffer2.length
      };
    };
  }
}
const dagBuilders = {
  flat,
  balanced,
  trickle: trickleStream
};
async function* buildFileBatch(file, blockstore, options) {
  let count = -1;
  let previous;
  let bufferImporter$1;
  if (typeof options.bufferImporter === "function") {
    bufferImporter$1 = options.bufferImporter;
  } else {
    bufferImporter$1 = bufferImporter;
  }
  for await (const entry of parallelBatch(bufferImporter$1(file, blockstore, options), options.blockWriteConcurrency)) {
    count++;
    if (count === 0) {
      previous = entry;
      continue;
    } else if (count === 1 && previous) {
      yield previous;
      previous = null;
    }
    yield entry;
  }
  if (previous) {
    previous.single = true;
    yield previous;
  }
}
const reduce = (file, blockstore, options) => {
  async function reducer(leaves) {
    if (leaves.length === 1 && leaves[0].single && options.reduceSingleLeafToSelf) {
      const leaf = leaves[0];
      if (file.mtime !== void 0 || file.mode !== void 0) {
        let buffer3 = await blockstore.get(leaf.cid);
        leaf.unixfs = new UnixFS({
          type: "file",
          mtime: file.mtime,
          mode: file.mode,
          data: buffer3
        });
        buffer3 = encode$o(prepare({ Data: leaf.unixfs.marshal() }));
        leaf.cid = await persist$1(buffer3, blockstore, {
          ...options,
          codec: dagPB,
          hasher: options.hasher,
          cidVersion: options.cidVersion
        });
        leaf.size = buffer3.length;
      }
      return {
        cid: leaf.cid,
        path: file.path,
        unixfs: leaf.unixfs,
        size: leaf.size
      };
    }
    const f = new UnixFS({
      type: "file",
      mtime: file.mtime,
      mode: file.mode
    });
    const links2 = leaves.filter((leaf) => {
      if (leaf.cid.code === code$3 && leaf.size) {
        return true;
      }
      if (leaf.unixfs && !leaf.unixfs.data && leaf.unixfs.fileSize()) {
        return true;
      }
      return Boolean(leaf.unixfs && leaf.unixfs.data && leaf.unixfs.data.length);
    }).map((leaf) => {
      if (leaf.cid.code === code$3) {
        f.addBlockSize(leaf.size);
        return {
          Name: "",
          Tsize: leaf.size,
          Hash: leaf.cid
        };
      }
      if (!leaf.unixfs || !leaf.unixfs.data) {
        f.addBlockSize(leaf.unixfs && leaf.unixfs.fileSize() || 0);
      } else {
        f.addBlockSize(leaf.unixfs.data.length);
      }
      return {
        Name: "",
        Tsize: leaf.size,
        Hash: leaf.cid
      };
    });
    const node2 = {
      Data: f.marshal(),
      Links: links2
    };
    const buffer2 = encode$o(prepare(node2));
    const cid = await persist$1(buffer2, blockstore, options);
    return {
      cid,
      path: file.path,
      unixfs: f,
      size: buffer2.length + node2.Links.reduce((acc, curr) => acc + curr.Tsize, 0)
    };
  }
  return reducer;
};
function fileBuilder(file, block, options) {
  const dagBuilder2 = dagBuilders[options.strategy];
  if (!dagBuilder2) {
    throw errCode(new Error(`Unknown importer build strategy name: ${options.strategy}`), "ERR_BAD_STRATEGY");
  }
  return dagBuilder2(buildFileBatch(file, block, options), reduce(file, block, options), options);
}
const symbol$3 = Symbol.for("@achingbrain/uint8arraylist");
function findBufAndOffset(bufs, index) {
  if (index == null || index < 0) {
    throw new RangeError("index is out of bounds");
  }
  let offset = 0;
  for (const buf2 of bufs) {
    const bufEnd = offset + buf2.byteLength;
    if (index < bufEnd) {
      return {
        buf: buf2,
        index: index - offset
      };
    }
    offset = bufEnd;
  }
  throw new RangeError("index is out of bounds");
}
function isUint8ArrayList(value2) {
  return Boolean(value2?.[symbol$3]);
}
class Uint8ArrayList {
  constructor(...data) {
    Object.defineProperty(this, symbol$3, { value: true });
    this.bufs = [];
    this.length = 0;
    if (data.length > 0) {
      this.appendAll(data);
    }
  }
  *[Symbol.iterator]() {
    yield* this.bufs;
  }
  get byteLength() {
    return this.length;
  }
  append(...bufs) {
    this.appendAll(bufs);
  }
  appendAll(bufs) {
    let length3 = 0;
    for (const buf2 of bufs) {
      if (buf2 instanceof Uint8Array) {
        length3 += buf2.byteLength;
        this.bufs.push(buf2);
      } else if (isUint8ArrayList(buf2)) {
        length3 += buf2.byteLength;
        this.bufs.push(...buf2.bufs);
      } else {
        throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");
      }
    }
    this.length += length3;
  }
  prepend(...bufs) {
    this.prependAll(bufs);
  }
  prependAll(bufs) {
    let length3 = 0;
    for (const buf2 of bufs.reverse()) {
      if (buf2 instanceof Uint8Array) {
        length3 += buf2.byteLength;
        this.bufs.unshift(buf2);
      } else if (isUint8ArrayList(buf2)) {
        length3 += buf2.byteLength;
        this.bufs.unshift(...buf2.bufs);
      } else {
        throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");
      }
    }
    this.length += length3;
  }
  get(index) {
    const res = findBufAndOffset(this.bufs, index);
    return res.buf[res.index];
  }
  set(index, value2) {
    const res = findBufAndOffset(this.bufs, index);
    res.buf[res.index] = value2;
  }
  write(buf2, offset = 0) {
    if (buf2 instanceof Uint8Array) {
      for (let i2 = 0; i2 < buf2.length; i2++) {
        this.set(offset + i2, buf2[i2]);
      }
    } else if (isUint8ArrayList(buf2)) {
      for (let i2 = 0; i2 < buf2.length; i2++) {
        this.set(offset + i2, buf2.get(i2));
      }
    } else {
      throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList");
    }
  }
  consume(bytes2) {
    bytes2 = Math.trunc(bytes2);
    if (Number.isNaN(bytes2) || bytes2 <= 0) {
      return;
    }
    if (bytes2 === this.byteLength) {
      this.bufs = [];
      this.length = 0;
      return;
    }
    while (this.bufs.length > 0) {
      if (bytes2 >= this.bufs[0].byteLength) {
        bytes2 -= this.bufs[0].byteLength;
        this.length -= this.bufs[0].byteLength;
        this.bufs.shift();
      } else {
        this.bufs[0] = this.bufs[0].subarray(bytes2);
        this.length -= bytes2;
        break;
      }
    }
  }
  slice(beginInclusive, endExclusive) {
    const { bufs, length: length3 } = this._subList(beginInclusive, endExclusive);
    return concat$1(bufs, length3);
  }
  subarray(beginInclusive, endExclusive) {
    const { bufs, length: length3 } = this._subList(beginInclusive, endExclusive);
    if (bufs.length === 1) {
      return bufs[0];
    }
    return concat$1(bufs, length3);
  }
  sublist(beginInclusive, endExclusive) {
    const { bufs, length: length3 } = this._subList(beginInclusive, endExclusive);
    const list = new Uint8ArrayList();
    list.length = length3;
    list.bufs = bufs;
    return list;
  }
  _subList(beginInclusive, endExclusive) {
    beginInclusive = beginInclusive ?? 0;
    endExclusive = endExclusive ?? this.length;
    if (beginInclusive < 0) {
      beginInclusive = this.length + beginInclusive;
    }
    if (endExclusive < 0) {
      endExclusive = this.length + endExclusive;
    }
    if (beginInclusive < 0 || endExclusive > this.length) {
      throw new RangeError("index is out of bounds");
    }
    if (beginInclusive === endExclusive) {
      return { bufs: [], length: 0 };
    }
    if (beginInclusive === 0 && endExclusive === this.length) {
      return { bufs: [...this.bufs], length: this.length };
    }
    const bufs = [];
    let offset = 0;
    for (let i2 = 0; i2 < this.bufs.length; i2++) {
      const buf2 = this.bufs[i2];
      const bufStart = offset;
      const bufEnd = bufStart + buf2.byteLength;
      offset = bufEnd;
      if (beginInclusive >= bufEnd) {
        continue;
      }
      const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd;
      const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd;
      if (sliceStartInBuf && sliceEndsInBuf) {
        if (beginInclusive === bufStart && endExclusive === bufEnd) {
          bufs.push(buf2);
          break;
        }
        const start = beginInclusive - bufStart;
        bufs.push(buf2.subarray(start, start + (endExclusive - beginInclusive)));
        break;
      }
      if (sliceStartInBuf) {
        if (beginInclusive === 0) {
          bufs.push(buf2);
          continue;
        }
        bufs.push(buf2.subarray(beginInclusive - bufStart));
        continue;
      }
      if (sliceEndsInBuf) {
        if (endExclusive === bufEnd) {
          bufs.push(buf2);
          break;
        }
        bufs.push(buf2.subarray(0, endExclusive - bufStart));
        break;
      }
      bufs.push(buf2);
    }
    return { bufs, length: endExclusive - beginInclusive };
  }
  indexOf(search, offset = 0) {
    if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {
      throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');
    }
    const needle = search instanceof Uint8Array ? search : search.subarray();
    offset = Number(offset ?? 0);
    if (isNaN(offset)) {
      offset = 0;
    }
    if (offset < 0) {
      offset = this.length + offset;
    }
    if (offset < 0) {
      offset = 0;
    }
    if (search.length === 0) {
      return offset > this.length ? this.length : offset;
    }
    const M = needle.byteLength;
    if (M === 0) {
      throw new TypeError("search must be at least 1 byte long");
    }
    const radix = 256;
    const rightmostPositions = new Int32Array(radix);
    for (let c = 0; c < radix; c++) {
      rightmostPositions[c] = -1;
    }
    for (let j = 0; j < M; j++) {
      rightmostPositions[needle[j]] = j;
    }
    const right = rightmostPositions;
    const lastIndex = this.byteLength - needle.byteLength;
    const lastPatIndex = needle.byteLength - 1;
    let skip2;
    for (let i2 = offset; i2 <= lastIndex; i2 += skip2) {
      skip2 = 0;
      for (let j = lastPatIndex; j >= 0; j--) {
        const char = this.get(i2 + j);
        if (needle[j] !== char) {
          skip2 = Math.max(1, j - right[char]);
          break;
        }
      }
      if (skip2 === 0) {
        return i2;
      }
    }
    return -1;
  }
  getInt8(byteOffset) {
    const buf2 = this.subarray(byteOffset, byteOffset + 1);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getInt8(0);
  }
  setInt8(byteOffset, value2) {
    const buf2 = allocUnsafe$4(1);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setInt8(0, value2);
    this.write(buf2, byteOffset);
  }
  getInt16(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 2);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getInt16(0, littleEndian);
  }
  setInt16(byteOffset, value2, littleEndian) {
    const buf2 = alloc(2);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setInt16(0, value2, littleEndian);
    this.write(buf2, byteOffset);
  }
  getInt32(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getInt32(0, littleEndian);
  }
  setInt32(byteOffset, value2, littleEndian) {
    const buf2 = alloc(4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setInt32(0, value2, littleEndian);
    this.write(buf2, byteOffset);
  }
  getBigInt64(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getBigInt64(0, littleEndian);
  }
  setBigInt64(byteOffset, value2, littleEndian) {
    const buf2 = alloc(8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setBigInt64(0, value2, littleEndian);
    this.write(buf2, byteOffset);
  }
  getUint8(byteOffset) {
    const buf2 = this.subarray(byteOffset, byteOffset + 1);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getUint8(0);
  }
  setUint8(byteOffset, value2) {
    const buf2 = allocUnsafe$4(1);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setUint8(0, value2);
    this.write(buf2, byteOffset);
  }
  getUint16(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 2);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getUint16(0, littleEndian);
  }
  setUint16(byteOffset, value2, littleEndian) {
    const buf2 = alloc(2);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setUint16(0, value2, littleEndian);
    this.write(buf2, byteOffset);
  }
  getUint32(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getUint32(0, littleEndian);
  }
  setUint32(byteOffset, value2, littleEndian) {
    const buf2 = alloc(4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setUint32(0, value2, littleEndian);
    this.write(buf2, byteOffset);
  }
  getBigUint64(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getBigUint64(0, littleEndian);
  }
  setBigUint64(byteOffset, value2, littleEndian) {
    const buf2 = alloc(8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setBigUint64(0, value2, littleEndian);
    this.write(buf2, byteOffset);
  }
  getFloat32(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getFloat32(0, littleEndian);
  }
  setFloat32(byteOffset, value2, littleEndian) {
    const buf2 = alloc(4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setFloat32(0, value2, littleEndian);
    this.write(buf2, byteOffset);
  }
  getFloat64(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getFloat64(0, littleEndian);
  }
  setFloat64(byteOffset, value2, littleEndian) {
    const buf2 = alloc(8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setFloat64(0, value2, littleEndian);
    this.write(buf2, byteOffset);
  }
  equals(other) {
    if (other == null) {
      return false;
    }
    if (!(other instanceof Uint8ArrayList)) {
      return false;
    }
    if (other.bufs.length !== this.bufs.length) {
      return false;
    }
    for (let i2 = 0; i2 < this.bufs.length; i2++) {
      if (!equals$1(this.bufs[i2], other.bufs[i2])) {
        return false;
      }
    }
    return true;
  }
  static fromUint8Arrays(bufs, length3) {
    const list = new Uint8ArrayList();
    list.bufs = bufs;
    if (length3 == null) {
      length3 = bufs.reduce((acc, curr) => acc + curr.byteLength, 0);
    }
    list.length = length3;
    return list;
  }
}
class Rabin$1 {
  constructor(asModule, bits2 = 12, min = 8 * 1024, max = 32 * 1024, windowSize = 64, polynomial) {
    this.bits = bits2;
    this.min = min;
    this.max = max;
    this.asModule = asModule;
    this.rabin = new asModule.Rabin(bits2, min, max, windowSize, polynomial);
    this.polynomial = polynomial;
  }
  fingerprint(buf2) {
    const {
      __retain,
      __release,
      __allocArray,
      __getInt32Array,
      Int32Array_ID,
      Uint8Array_ID
    } = this.asModule;
    const lengths = new Int32Array(Math.ceil(buf2.length / this.min));
    const lengthsPtr = __retain(__allocArray(Int32Array_ID, lengths));
    const pointer = __retain(__allocArray(Uint8Array_ID, buf2));
    const out = this.rabin.fingerprint(pointer, lengthsPtr);
    const processed = __getInt32Array(out);
    __release(pointer);
    __release(lengthsPtr);
    const end2 = processed.indexOf(0);
    return end2 >= 0 ? processed.subarray(0, end2) : processed;
  }
}
var rabin$1 = Rabin$1;
var loader = {};
const ID_OFFSET = -8;
const SIZE_OFFSET = -4;
const ARRAYBUFFER_ID = 0;
const STRING_ID = 1;
const ARRAYBUFFERVIEW = 1 << 0;
const ARRAY = 1 << 1;
const VAL_ALIGN_OFFSET = 5;
const VAL_SIGNED = 1 << 10;
const VAL_FLOAT = 1 << 11;
const VAL_MANAGED = 1 << 13;
const ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;
const ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;
const ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;
const ARRAYBUFFERVIEW_SIZE = 12;
const ARRAY_LENGTH_OFFSET = 12;
const ARRAY_SIZE = 16;
const BIGINT = typeof BigUint64Array !== "undefined";
const THIS = Symbol();
const CHUNKSIZE = 1024;
function getStringImpl(buffer2, ptr) {
  const U32 = new Uint32Array(buffer2);
  const U16 = new Uint16Array(buffer2);
  var length3 = U32[ptr + SIZE_OFFSET >>> 2] >>> 1;
  var offset = ptr >>> 1;
  if (length3 <= CHUNKSIZE)
    return String.fromCharCode.apply(String, U16.subarray(offset, offset + length3));
  const parts2 = [];
  do {
    const last2 = U16[offset + CHUNKSIZE - 1];
    const size2 = last2 >= 55296 && last2 < 56320 ? CHUNKSIZE - 1 : CHUNKSIZE;
    parts2.push(String.fromCharCode.apply(String, U16.subarray(offset, offset += size2)));
    length3 -= size2;
  } while (length3 > CHUNKSIZE);
  return parts2.join("") + String.fromCharCode.apply(String, U16.subarray(offset, offset + length3));
}
function preInstantiate(imports) {
  const baseModule = {};
  function getString(memory, ptr) {
    if (!memory)
      return "<yet unknown>";
    return getStringImpl(memory.buffer, ptr);
  }
  const env2 = imports.env = imports.env || {};
  env2.abort = env2.abort || function abort(mesg, file, line, colm) {
    const memory = baseModule.memory || env2.memory;
    throw Error("abort: " + getString(memory, mesg) + " at " + getString(memory, file) + ":" + line + ":" + colm);
  };
  env2.trace = env2.trace || function trace(mesg, n) {
    const memory = baseModule.memory || env2.memory;
    console.log("trace: " + getString(memory, mesg) + (n ? " " : "") + Array.prototype.slice.call(arguments, 2, 2 + n).join(", "));
  };
  imports.Math = imports.Math || Math;
  imports.Date = imports.Date || Date;
  return baseModule;
}
function postInstantiate(baseModule, instance) {
  const rawExports = instance.exports;
  const memory = rawExports.memory;
  const table2 = rawExports.table;
  const alloc3 = rawExports["__alloc"];
  const retain = rawExports["__retain"];
  const rttiBase = rawExports["__rtti_base"] || ~0;
  function getInfo(id) {
    const U32 = new Uint32Array(memory.buffer);
    const count = U32[rttiBase >>> 2];
    if ((id >>>= 0) >= count)
      throw Error("invalid id: " + id);
    return U32[(rttiBase + 4 >>> 2) + id * 2];
  }
  function getBase(id) {
    const U32 = new Uint32Array(memory.buffer);
    const count = U32[rttiBase >>> 2];
    if ((id >>>= 0) >= count)
      throw Error("invalid id: " + id);
    return U32[(rttiBase + 4 >>> 2) + id * 2 + 1];
  }
  function getValueAlign(info) {
    return 31 - Math.clz32(info >>> VAL_ALIGN_OFFSET & 31);
  }
  function __allocString(str) {
    const length3 = str.length;
    const ptr = alloc3(length3 << 1, STRING_ID);
    const U16 = new Uint16Array(memory.buffer);
    for (var i2 = 0, p = ptr >>> 1; i2 < length3; ++i2)
      U16[p + i2] = str.charCodeAt(i2);
    return ptr;
  }
  baseModule.__allocString = __allocString;
  function __getString(ptr) {
    const buffer2 = memory.buffer;
    const id = new Uint32Array(buffer2)[ptr + ID_OFFSET >>> 2];
    if (id !== STRING_ID)
      throw Error("not a string: " + ptr);
    return getStringImpl(buffer2, ptr);
  }
  baseModule.__getString = __getString;
  function getView(alignLog2, signed, float2) {
    const buffer2 = memory.buffer;
    if (float2) {
      switch (alignLog2) {
        case 2:
          return new Float32Array(buffer2);
        case 3:
          return new Float64Array(buffer2);
      }
    } else {
      switch (alignLog2) {
        case 0:
          return new (signed ? Int8Array : Uint8Array)(buffer2);
        case 1:
          return new (signed ? Int16Array : Uint16Array)(buffer2);
        case 2:
          return new (signed ? Int32Array : Uint32Array)(buffer2);
        case 3:
          return new (signed ? BigInt64Array : BigUint64Array)(buffer2);
      }
    }
    throw Error("unsupported align: " + alignLog2);
  }
  function __allocArray(id, values) {
    const info = getInfo(id);
    if (!(info & (ARRAYBUFFERVIEW | ARRAY)))
      throw Error("not an array: " + id + " @ " + info);
    const align = getValueAlign(info);
    const length3 = values.length;
    const buf2 = alloc3(length3 << align, ARRAYBUFFER_ID);
    const arr = alloc3(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);
    const U32 = new Uint32Array(memory.buffer);
    U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = retain(buf2);
    U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf2;
    U32[arr + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length3 << align;
    if (info & ARRAY)
      U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length3;
    const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);
    if (info & VAL_MANAGED) {
      for (let i2 = 0; i2 < length3; ++i2)
        view[(buf2 >>> align) + i2] = retain(values[i2]);
    } else {
      view.set(values, buf2 >>> align);
    }
    return arr;
  }
  baseModule.__allocArray = __allocArray;
  function __getArrayView(arr) {
    const U32 = new Uint32Array(memory.buffer);
    const id = U32[arr + ID_OFFSET >>> 2];
    const info = getInfo(id);
    if (!(info & ARRAYBUFFERVIEW))
      throw Error("not an array: " + id);
    const align = getValueAlign(info);
    var buf2 = U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
    const length3 = info & ARRAY ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2] : U32[buf2 + SIZE_OFFSET >>> 2] >>> align;
    return getView(align, info & VAL_SIGNED, info & VAL_FLOAT).subarray(buf2 >>>= align, buf2 + length3);
  }
  baseModule.__getArrayView = __getArrayView;
  function __getArray(arr) {
    const input = __getArrayView(arr);
    const len2 = input.length;
    const out = new Array(len2);
    for (let i2 = 0; i2 < len2; i2++)
      out[i2] = input[i2];
    return out;
  }
  baseModule.__getArray = __getArray;
  function __getArrayBuffer(ptr) {
    const buffer2 = memory.buffer;
    const length3 = new Uint32Array(buffer2)[ptr + SIZE_OFFSET >>> 2];
    return buffer2.slice(ptr, ptr + length3);
  }
  baseModule.__getArrayBuffer = __getArrayBuffer;
  function getTypedArray(Type2, alignLog2, ptr) {
    return new Type2(getTypedArrayView(Type2, alignLog2, ptr));
  }
  function getTypedArrayView(Type2, alignLog2, ptr) {
    const buffer2 = memory.buffer;
    const U32 = new Uint32Array(buffer2);
    const bufPtr = U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
    return new Type2(buffer2, bufPtr, U32[bufPtr + SIZE_OFFSET >>> 2] >>> alignLog2);
  }
  baseModule.__getInt8Array = getTypedArray.bind(null, Int8Array, 0);
  baseModule.__getInt8ArrayView = getTypedArrayView.bind(null, Int8Array, 0);
  baseModule.__getUint8Array = getTypedArray.bind(null, Uint8Array, 0);
  baseModule.__getUint8ArrayView = getTypedArrayView.bind(null, Uint8Array, 0);
  baseModule.__getUint8ClampedArray = getTypedArray.bind(null, Uint8ClampedArray, 0);
  baseModule.__getUint8ClampedArrayView = getTypedArrayView.bind(null, Uint8ClampedArray, 0);
  baseModule.__getInt16Array = getTypedArray.bind(null, Int16Array, 1);
  baseModule.__getInt16ArrayView = getTypedArrayView.bind(null, Int16Array, 1);
  baseModule.__getUint16Array = getTypedArray.bind(null, Uint16Array, 1);
  baseModule.__getUint16ArrayView = getTypedArrayView.bind(null, Uint16Array, 1);
  baseModule.__getInt32Array = getTypedArray.bind(null, Int32Array, 2);
  baseModule.__getInt32ArrayView = getTypedArrayView.bind(null, Int32Array, 2);
  baseModule.__getUint32Array = getTypedArray.bind(null, Uint32Array, 2);
  baseModule.__getUint32ArrayView = getTypedArrayView.bind(null, Uint32Array, 2);
  if (BIGINT) {
    baseModule.__getInt64Array = getTypedArray.bind(null, BigInt64Array, 3);
    baseModule.__getInt64ArrayView = getTypedArrayView.bind(null, BigInt64Array, 3);
    baseModule.__getUint64Array = getTypedArray.bind(null, BigUint64Array, 3);
    baseModule.__getUint64ArrayView = getTypedArrayView.bind(null, BigUint64Array, 3);
  }
  baseModule.__getFloat32Array = getTypedArray.bind(null, Float32Array, 2);
  baseModule.__getFloat32ArrayView = getTypedArrayView.bind(null, Float32Array, 2);
  baseModule.__getFloat64Array = getTypedArray.bind(null, Float64Array, 3);
  baseModule.__getFloat64ArrayView = getTypedArrayView.bind(null, Float64Array, 3);
  function __instanceof(ptr, baseId) {
    const U32 = new Uint32Array(memory.buffer);
    var id = U32[ptr + ID_OFFSET >>> 2];
    if (id <= U32[rttiBase >>> 2]) {
      do
        if (id == baseId)
          return true;
      while (id = getBase(id));
    }
    return false;
  }
  baseModule.__instanceof = __instanceof;
  baseModule.memory = baseModule.memory || memory;
  baseModule.table = baseModule.table || table2;
  return demangle(rawExports, baseModule);
}
function isResponse(o) {
  return typeof Response !== "undefined" && o instanceof Response;
}
async function instantiate$1(source2, imports) {
  if (isResponse(source2 = await source2))
    return instantiateStreaming(source2, imports);
  return postInstantiate(
    preInstantiate(imports || (imports = {})),
    await WebAssembly.instantiate(
      source2 instanceof WebAssembly.Module ? source2 : await WebAssembly.compile(source2),
      imports
    )
  );
}
loader.instantiate = instantiate$1;
function instantiateSync(source2, imports) {
  return postInstantiate(
    preInstantiate(imports || (imports = {})),
    new WebAssembly.Instance(
      source2 instanceof WebAssembly.Module ? source2 : new WebAssembly.Module(source2),
      imports
    )
  );
}
loader.instantiateSync = instantiateSync;
async function instantiateStreaming(source2, imports) {
  if (!WebAssembly.instantiateStreaming) {
    return instantiate$1(
      isResponse(source2 = await source2) ? source2.arrayBuffer() : source2,
      imports
    );
  }
  return postInstantiate(
    preInstantiate(imports || (imports = {})),
    (await WebAssembly.instantiateStreaming(source2, imports)).instance
  );
}
loader.instantiateStreaming = instantiateStreaming;
function demangle(exports, baseModule) {
  var module = baseModule ? Object.create(baseModule) : {};
  var setArgumentsLength = exports["__argumentsLength"] ? function(length3) {
    exports["__argumentsLength"].value = length3;
  } : exports["__setArgumentsLength"] || exports["__setargc"] || function() {
  };
  for (let internalName in exports) {
    if (!Object.prototype.hasOwnProperty.call(exports, internalName))
      continue;
    const elem = exports[internalName];
    let parts2 = internalName.split(".");
    let curr = module;
    while (parts2.length > 1) {
      let part = parts2.shift();
      if (!Object.prototype.hasOwnProperty.call(curr, part))
        curr[part] = {};
      curr = curr[part];
    }
    let name2 = parts2[0];
    let hash2 = name2.indexOf("#");
    if (hash2 >= 0) {
      let className = name2.substring(0, hash2);
      let classElem = curr[className];
      if (typeof classElem === "undefined" || !classElem.prototype) {
        let ctor = function(...args) {
          return ctor.wrap(ctor.prototype.constructor(0, ...args));
        };
        ctor.prototype = {
          valueOf: function valueOf() {
            return this[THIS];
          }
        };
        ctor.wrap = function(thisValue) {
          return Object.create(ctor.prototype, { [THIS]: { value: thisValue, writable: false } });
        };
        if (classElem)
          Object.getOwnPropertyNames(classElem).forEach(
            (name3) => Object.defineProperty(ctor, name3, Object.getOwnPropertyDescriptor(classElem, name3))
          );
        curr[className] = ctor;
      }
      name2 = name2.substring(hash2 + 1);
      curr = curr[className].prototype;
      if (/^(get|set):/.test(name2)) {
        if (!Object.prototype.hasOwnProperty.call(curr, name2 = name2.substring(4))) {
          let getter = exports[internalName.replace("set:", "get:")];
          let setter = exports[internalName.replace("get:", "set:")];
          Object.defineProperty(curr, name2, {
            get: function() {
              return getter(this[THIS]);
            },
            set: function(value2) {
              setter(this[THIS], value2);
            },
            enumerable: true
          });
        }
      } else {
        if (name2 === "constructor") {
          (curr[name2] = (...args) => {
            setArgumentsLength(args.length);
            return elem(...args);
          }).original = elem;
        } else {
          (curr[name2] = function(...args) {
            setArgumentsLength(args.length);
            return elem(this[THIS], ...args);
          }).original = elem;
        }
      }
    } else {
      if (/^(get|set):/.test(name2)) {
        if (!Object.prototype.hasOwnProperty.call(curr, name2 = name2.substring(4))) {
          Object.defineProperty(curr, name2, {
            get: exports[internalName.replace("set:", "get:")],
            set: exports[internalName.replace("get:", "set:")],
            enumerable: true
          });
        }
      } else if (typeof elem === "function" && elem !== setArgumentsLength) {
        (curr[name2] = (...args) => {
          setArgumentsLength(args.length);
          return elem(...args);
        }).original = elem;
      } else {
        curr[name2] = elem;
      }
    }
  }
  return module;
}
loader.demangle = demangle;
const { instantiate } = loader;
loadWebAssembly.supported = typeof WebAssembly !== "undefined";
function loadWebAssembly(imp = {}) {
  if (!loadWebAssembly.supported)
    return null;
  var wasm = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 78, 14, 96, 2, 127, 126, 0, 96, 1, 127, 1, 126, 96, 2, 127, 127, 0, 96, 1, 127, 1, 127, 96, 1, 127, 0, 96, 2, 127, 127, 1, 127, 96, 3, 127, 127, 127, 1, 127, 96, 0, 0, 96, 3, 127, 127, 127, 0, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 0, 96, 5, 127, 127, 127, 127, 127, 1, 127, 96, 1, 126, 1, 127, 96, 2, 126, 126, 1, 126, 2, 13, 1, 3, 101, 110, 118, 5, 97, 98, 111, 114, 116, 0, 10, 3, 54, 53, 2, 2, 8, 9, 3, 5, 2, 8, 6, 5, 3, 4, 2, 6, 9, 12, 13, 2, 5, 11, 3, 2, 3, 2, 3, 2, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 6, 7, 7, 4, 4, 5, 3, 1, 0, 1, 6, 47, 9, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 0, 65, 3, 11, 127, 0, 65, 4, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 0, 65, 240, 2, 11, 127, 0, 65, 6, 11, 7, 240, 5, 41, 6, 109, 101, 109, 111, 114, 121, 2, 0, 7, 95, 95, 97, 108, 108, 111, 99, 0, 10, 8, 95, 95, 114, 101, 116, 97, 105, 110, 0, 11, 9, 95, 95, 114, 101, 108, 101, 97, 115, 101, 0, 12, 9, 95, 95, 99, 111, 108, 108, 101, 99, 116, 0, 51, 11, 95, 95, 114, 116, 116, 105, 95, 98, 97, 115, 101, 3, 7, 13, 73, 110, 116, 51, 50, 65, 114, 114, 97, 121, 95, 73, 68, 3, 2, 13, 85, 105, 110, 116, 56, 65, 114, 114, 97, 121, 95, 73, 68, 3, 3, 6, 100, 101, 103, 114, 101, 101, 0, 16, 3, 109, 111, 100, 0, 17, 5, 82, 97, 98, 105, 110, 3, 8, 16, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 105, 110, 100, 111, 119, 0, 21, 16, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 105, 110, 100, 111, 119, 0, 22, 21, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 105, 110, 100, 111, 119, 95, 115, 105, 122, 101, 0, 23, 21, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 105, 110, 100, 111, 119, 95, 115, 105, 122, 101, 0, 24, 14, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 112, 111, 115, 0, 25, 14, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 112, 111, 115, 0, 26, 15, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 111, 117, 110, 116, 0, 27, 15, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 111, 117, 110, 116, 0, 28, 13, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 112, 111, 115, 0, 29, 13, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 112, 111, 115, 0, 30, 15, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 115, 116, 97, 114, 116, 0, 31, 15, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 115, 116, 97, 114, 116, 0, 32, 16, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 100, 105, 103, 101, 115, 116, 0, 33, 16, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 100, 105, 103, 101, 115, 116, 0, 34, 21, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 115, 116, 97, 114, 116, 0, 35, 21, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 115, 116, 97, 114, 116, 0, 36, 22, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 108, 101, 110, 103, 116, 104, 0, 37, 22, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 108, 101, 110, 103, 116, 104, 0, 38, 31, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 99, 117, 116, 95, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 39, 31, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 99, 117, 116, 95, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 40, 20, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 112, 111, 108, 121, 110, 111, 109, 105, 97, 108, 0, 41, 20, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 112, 111, 108, 121, 110, 111, 109, 105, 97, 108, 0, 42, 17, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 105, 110, 115, 105, 122, 101, 0, 43, 17, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 105, 110, 115, 105, 122, 101, 0, 44, 17, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 97, 120, 115, 105, 122, 101, 0, 45, 17, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 97, 120, 115, 105, 122, 101, 0, 46, 14, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 97, 115, 107, 0, 47, 14, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 97, 115, 107, 0, 48, 17, 82, 97, 98, 105, 110, 35, 99, 111, 110, 115, 116, 114, 117, 99, 116, 111, 114, 0, 20, 17, 82, 97, 98, 105, 110, 35, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 49, 8, 1, 50, 10, 165, 31, 53, 199, 1, 1, 4, 127, 32, 1, 40, 2, 0, 65, 124, 113, 34, 2, 65, 128, 2, 73, 4, 127, 32, 2, 65, 4, 118, 33, 4, 65, 0, 5, 32, 2, 65, 31, 32, 2, 103, 107, 34, 3, 65, 4, 107, 118, 65, 16, 115, 33, 4, 32, 3, 65, 7, 107, 11, 33, 3, 32, 1, 40, 2, 20, 33, 2, 32, 1, 40, 2, 16, 34, 5, 4, 64, 32, 5, 32, 2, 54, 2, 20, 11, 32, 2, 4, 64, 32, 2, 32, 5, 54, 2, 16, 11, 32, 1, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 70, 4, 64, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 32, 2, 54, 2, 96, 32, 2, 69, 4, 64, 32, 0, 32, 3, 65, 2, 116, 106, 32, 0, 32, 3, 65, 2, 116, 106, 40, 2, 4, 65, 1, 32, 4, 116, 65, 127, 115, 113, 34, 1, 54, 2, 4, 32, 1, 69, 4, 64, 32, 0, 32, 0, 40, 2, 0, 65, 1, 32, 3, 116, 65, 127, 115, 113, 54, 2, 0, 11, 11, 11, 11, 226, 2, 1, 6, 127, 32, 1, 40, 2, 0, 33, 3, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 34, 4, 40, 2, 0, 34, 5, 65, 1, 113, 4, 64, 32, 3, 65, 124, 113, 65, 16, 106, 32, 5, 65, 124, 113, 106, 34, 2, 65, 240, 255, 255, 255, 3, 73, 4, 64, 32, 0, 32, 4, 16, 1, 32, 1, 32, 2, 32, 3, 65, 3, 113, 114, 34, 3, 54, 2, 0, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 34, 4, 40, 2, 0, 33, 5, 11, 11, 32, 3, 65, 2, 113, 4, 64, 32, 1, 65, 4, 107, 40, 2, 0, 34, 2, 40, 2, 0, 34, 6, 65, 124, 113, 65, 16, 106, 32, 3, 65, 124, 113, 106, 34, 7, 65, 240, 255, 255, 255, 3, 73, 4, 64, 32, 0, 32, 2, 16, 1, 32, 2, 32, 7, 32, 6, 65, 3, 113, 114, 34, 3, 54, 2, 0, 32, 2, 33, 1, 11, 11, 32, 4, 32, 5, 65, 2, 114, 54, 2, 0, 32, 4, 65, 4, 107, 32, 1, 54, 2, 0, 32, 0, 32, 3, 65, 124, 113, 34, 2, 65, 128, 2, 73, 4, 127, 32, 2, 65, 4, 118, 33, 4, 65, 0, 5, 32, 2, 65, 31, 32, 2, 103, 107, 34, 2, 65, 4, 107, 118, 65, 16, 115, 33, 4, 32, 2, 65, 7, 107, 11, 34, 3, 65, 4, 116, 32, 4, 106, 65, 2, 116, 106, 40, 2, 96, 33, 2, 32, 1, 65, 0, 54, 2, 16, 32, 1, 32, 2, 54, 2, 20, 32, 2, 4, 64, 32, 2, 32, 1, 54, 2, 16, 11, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 32, 1, 54, 2, 96, 32, 0, 32, 0, 40, 2, 0, 65, 1, 32, 3, 116, 114, 54, 2, 0, 32, 0, 32, 3, 65, 2, 116, 106, 32, 0, 32, 3, 65, 2, 116, 106, 40, 2, 4, 65, 1, 32, 4, 116, 114, 54, 2, 4, 11, 119, 1, 1, 127, 32, 2, 2, 127, 32, 0, 40, 2, 160, 12, 34, 2, 4, 64, 32, 2, 32, 1, 65, 16, 107, 70, 4, 64, 32, 2, 40, 2, 0, 33, 3, 32, 1, 65, 16, 107, 33, 1, 11, 11, 32, 1, 11, 107, 34, 2, 65, 48, 73, 4, 64, 15, 11, 32, 1, 32, 3, 65, 2, 113, 32, 2, 65, 32, 107, 65, 1, 114, 114, 54, 2, 0, 32, 1, 65, 0, 54, 2, 16, 32, 1, 65, 0, 54, 2, 20, 32, 1, 32, 2, 106, 65, 16, 107, 34, 2, 65, 2, 54, 2, 0, 32, 0, 32, 2, 54, 2, 160, 12, 32, 0, 32, 1, 16, 2, 11, 155, 1, 1, 3, 127, 35, 0, 34, 0, 69, 4, 64, 65, 1, 63, 0, 34, 0, 74, 4, 127, 65, 1, 32, 0, 107, 64, 0, 65, 0, 72, 5, 65, 0, 11, 4, 64, 0, 11, 65, 176, 3, 34, 0, 65, 0, 54, 2, 0, 65, 208, 15, 65, 0, 54, 2, 0, 3, 64, 32, 1, 65, 23, 73, 4, 64, 32, 1, 65, 2, 116, 65, 176, 3, 106, 65, 0, 54, 2, 4, 65, 0, 33, 2, 3, 64, 32, 2, 65, 16, 73, 4, 64, 32, 1, 65, 4, 116, 32, 2, 106, 65, 2, 116, 65, 176, 3, 106, 65, 0, 54, 2, 96, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 65, 176, 3, 65, 224, 15, 63, 0, 65, 16, 116, 16, 3, 65, 176, 3, 36, 0, 11, 32, 0, 11, 45, 0, 32, 0, 65, 240, 255, 255, 255, 3, 79, 4, 64, 65, 32, 65, 224, 0, 65, 201, 3, 65, 29, 16, 0, 0, 11, 32, 0, 65, 15, 106, 65, 112, 113, 34, 0, 65, 16, 32, 0, 65, 16, 75, 27, 11, 169, 1, 1, 1, 127, 32, 0, 32, 1, 65, 128, 2, 73, 4, 127, 32, 1, 65, 4, 118, 33, 1, 65, 0, 5, 32, 1, 65, 248, 255, 255, 255, 1, 73, 4, 64, 32, 1, 65, 1, 65, 27, 32, 1, 103, 107, 116, 106, 65, 1, 107, 33, 1, 11, 32, 1, 65, 31, 32, 1, 103, 107, 34, 2, 65, 4, 107, 118, 65, 16, 115, 33, 1, 32, 2, 65, 7, 107, 11, 34, 2, 65, 2, 116, 106, 40, 2, 4, 65, 127, 32, 1, 116, 113, 34, 1, 4, 127, 32, 0, 32, 1, 104, 32, 2, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 5, 32, 0, 40, 2, 0, 65, 127, 32, 2, 65, 1, 106, 116, 113, 34, 1, 4, 127, 32, 0, 32, 0, 32, 1, 104, 34, 0, 65, 2, 116, 106, 40, 2, 4, 104, 32, 0, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 5, 65, 0, 11, 11, 11, 111, 1, 1, 127, 63, 0, 34, 2, 32, 1, 65, 248, 255, 255, 255, 1, 73, 4, 127, 32, 1, 65, 1, 65, 27, 32, 1, 103, 107, 116, 65, 1, 107, 106, 5, 32, 1, 11, 65, 16, 32, 0, 40, 2, 160, 12, 32, 2, 65, 16, 116, 65, 16, 107, 71, 116, 106, 65, 255, 255, 3, 106, 65, 128, 128, 124, 113, 65, 16, 118, 34, 1, 32, 2, 32, 1, 74, 27, 64, 0, 65, 0, 72, 4, 64, 32, 1, 64, 0, 65, 0, 72, 4, 64, 0, 11, 11, 32, 0, 32, 2, 65, 16, 116, 63, 0, 65, 16, 116, 16, 3, 11, 113, 1, 2, 127, 32, 1, 40, 2, 0, 34, 3, 65, 124, 113, 32, 2, 107, 34, 4, 65, 32, 79, 4, 64, 32, 1, 32, 2, 32, 3, 65, 2, 113, 114, 54, 2, 0, 32, 2, 32, 1, 65, 16, 106, 106, 34, 1, 32, 4, 65, 16, 107, 65, 1, 114, 54, 2, 0, 32, 0, 32, 1, 16, 2, 5, 32, 1, 32, 3, 65, 126, 113, 54, 2, 0, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 40, 2, 0, 65, 125, 113, 54, 2, 0, 11, 11, 91, 1, 2, 127, 32, 0, 32, 1, 16, 5, 34, 4, 16, 6, 34, 3, 69, 4, 64, 65, 1, 36, 1, 65, 0, 36, 1, 32, 0, 32, 4, 16, 6, 34, 3, 69, 4, 64, 32, 0, 32, 4, 16, 7, 32, 0, 32, 4, 16, 6, 33, 3, 11, 11, 32, 3, 65, 0, 54, 2, 4, 32, 3, 32, 2, 54, 2, 8, 32, 3, 32, 1, 54, 2, 12, 32, 0, 32, 3, 16, 1, 32, 0, 32, 3, 32, 4, 16, 8, 32, 3, 11, 13, 0, 16, 4, 32, 0, 32, 1, 16, 9, 65, 16, 106, 11, 33, 1, 1, 127, 32, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 11, 18, 0, 32, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 16, 52, 11, 11, 140, 3, 1, 1, 127, 2, 64, 32, 1, 69, 13, 0, 32, 0, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 65, 1, 107, 65, 0, 58, 0, 0, 32, 1, 65, 2, 77, 13, 0, 32, 0, 65, 1, 106, 65, 0, 58, 0, 0, 32, 0, 65, 2, 106, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 34, 2, 65, 2, 107, 65, 0, 58, 0, 0, 32, 2, 65, 3, 107, 65, 0, 58, 0, 0, 32, 1, 65, 6, 77, 13, 0, 32, 0, 65, 3, 106, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 65, 4, 107, 65, 0, 58, 0, 0, 32, 1, 65, 8, 77, 13, 0, 32, 1, 65, 0, 32, 0, 107, 65, 3, 113, 34, 1, 107, 33, 2, 32, 0, 32, 1, 106, 34, 0, 65, 0, 54, 2, 0, 32, 0, 32, 2, 65, 124, 113, 34, 1, 106, 65, 4, 107, 65, 0, 54, 2, 0, 32, 1, 65, 8, 77, 13, 0, 32, 0, 65, 4, 106, 65, 0, 54, 2, 0, 32, 0, 65, 8, 106, 65, 0, 54, 2, 0, 32, 0, 32, 1, 106, 34, 2, 65, 12, 107, 65, 0, 54, 2, 0, 32, 2, 65, 8, 107, 65, 0, 54, 2, 0, 32, 1, 65, 24, 77, 13, 0, 32, 0, 65, 12, 106, 65, 0, 54, 2, 0, 32, 0, 65, 16, 106, 65, 0, 54, 2, 0, 32, 0, 65, 20, 106, 65, 0, 54, 2, 0, 32, 0, 65, 24, 106, 65, 0, 54, 2, 0, 32, 0, 32, 1, 106, 34, 2, 65, 28, 107, 65, 0, 54, 2, 0, 32, 2, 65, 24, 107, 65, 0, 54, 2, 0, 32, 2, 65, 20, 107, 65, 0, 54, 2, 0, 32, 2, 65, 16, 107, 65, 0, 54, 2, 0, 32, 0, 32, 0, 65, 4, 113, 65, 24, 106, 34, 2, 106, 33, 0, 32, 1, 32, 2, 107, 33, 1, 3, 64, 32, 1, 65, 32, 79, 4, 64, 32, 0, 66, 0, 55, 3, 0, 32, 0, 65, 8, 106, 66, 0, 55, 3, 0, 32, 0, 65, 16, 106, 66, 0, 55, 3, 0, 32, 0, 65, 24, 106, 66, 0, 55, 3, 0, 32, 1, 65, 32, 107, 33, 1, 32, 0, 65, 32, 106, 33, 0, 12, 1, 11, 11, 11, 11, 178, 1, 1, 3, 127, 32, 1, 65, 240, 255, 255, 255, 3, 32, 2, 118, 75, 4, 64, 65, 144, 1, 65, 192, 1, 65, 23, 65, 56, 16, 0, 0, 11, 32, 1, 32, 2, 116, 34, 3, 65, 0, 16, 10, 34, 2, 32, 3, 16, 13, 32, 0, 69, 4, 64, 65, 12, 65, 2, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 11, 32, 0, 65, 0, 54, 2, 0, 32, 0, 65, 0, 54, 2, 4, 32, 0, 65, 0, 54, 2, 8, 32, 2, 34, 1, 32, 0, 40, 2, 0, 34, 4, 71, 4, 64, 32, 1, 65, 172, 3, 75, 4, 64, 32, 1, 65, 16, 107, 34, 5, 32, 5, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 4, 16, 12, 11, 32, 0, 32, 1, 54, 2, 0, 32, 0, 32, 2, 54, 2, 4, 32, 0, 32, 3, 54, 2, 8, 32, 0, 11, 46, 1, 2, 127, 65, 12, 65, 5, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 65, 128, 2, 65, 3, 16, 14, 11, 9, 0, 65, 63, 32, 0, 121, 167, 107, 11, 49, 1, 2, 127, 65, 63, 32, 1, 121, 167, 107, 33, 2, 3, 64, 65, 63, 32, 0, 121, 167, 107, 32, 2, 107, 34, 3, 65, 0, 78, 4, 64, 32, 0, 32, 1, 32, 3, 172, 134, 133, 33, 0, 12, 1, 11, 11, 32, 0, 11, 40, 0, 32, 1, 32, 0, 40, 2, 8, 79, 4, 64, 65, 128, 2, 65, 192, 2, 65, 163, 1, 65, 44, 16, 0, 0, 11, 32, 1, 32, 0, 40, 2, 4, 106, 65, 0, 58, 0, 0, 11, 38, 0, 32, 1, 32, 0, 40, 2, 8, 79, 4, 64, 65, 128, 2, 65, 192, 2, 65, 152, 1, 65, 44, 16, 0, 0, 11, 32, 1, 32, 0, 40, 2, 4, 106, 45, 0, 0, 11, 254, 5, 2, 1, 127, 4, 126, 32, 0, 69, 4, 64, 65, 232, 0, 65, 6, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 5, 32, 5, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 11, 32, 0, 65, 0, 54, 2, 0, 32, 0, 65, 0, 54, 2, 4, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 24, 32, 0, 66, 0, 55, 3, 32, 32, 0, 66, 0, 55, 3, 40, 32, 0, 66, 0, 55, 3, 48, 32, 0, 66, 0, 55, 3, 56, 32, 0, 66, 0, 55, 3, 64, 32, 0, 66, 0, 55, 3, 72, 32, 0, 66, 0, 55, 3, 80, 32, 0, 66, 0, 55, 3, 88, 32, 0, 66, 0, 55, 3, 96, 32, 0, 32, 2, 173, 55, 3, 80, 32, 0, 32, 3, 173, 55, 3, 88, 65, 12, 65, 4, 16, 10, 34, 2, 65, 172, 3, 75, 4, 64, 32, 2, 65, 16, 107, 34, 3, 32, 3, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 32, 4, 65, 0, 16, 14, 33, 2, 32, 0, 40, 2, 0, 16, 12, 32, 0, 32, 2, 54, 2, 0, 32, 0, 32, 4, 54, 2, 4, 32, 0, 66, 1, 32, 1, 173, 134, 66, 1, 125, 55, 3, 96, 32, 0, 66, 243, 130, 183, 218, 216, 230, 232, 30, 55, 3, 72, 35, 4, 69, 4, 64, 65, 0, 33, 2, 3, 64, 32, 2, 65, 128, 2, 72, 4, 64, 32, 2, 65, 255, 1, 113, 173, 33, 6, 32, 0, 41, 3, 72, 34, 7, 33, 8, 65, 63, 32, 7, 121, 167, 107, 33, 1, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 1, 107, 34, 3, 65, 0, 78, 4, 64, 32, 6, 32, 8, 32, 3, 172, 134, 133, 33, 6, 12, 1, 11, 11, 65, 0, 33, 4, 3, 64, 32, 4, 32, 0, 40, 2, 4, 65, 1, 107, 72, 4, 64, 32, 6, 66, 8, 134, 33, 6, 32, 0, 41, 3, 72, 34, 7, 33, 8, 65, 63, 32, 7, 121, 167, 107, 33, 1, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 1, 107, 34, 3, 65, 0, 78, 4, 64, 32, 6, 32, 8, 32, 3, 172, 134, 133, 33, 6, 12, 1, 11, 11, 32, 4, 65, 1, 106, 33, 4, 12, 1, 11, 11, 35, 6, 40, 2, 4, 32, 2, 65, 3, 116, 106, 32, 6, 55, 3, 0, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 65, 63, 32, 0, 41, 3, 72, 121, 167, 107, 172, 33, 7, 65, 0, 33, 2, 3, 64, 32, 2, 65, 128, 2, 72, 4, 64, 35, 5, 33, 1, 32, 2, 172, 32, 7, 134, 34, 8, 33, 6, 65, 63, 32, 0, 41, 3, 72, 34, 9, 121, 167, 107, 33, 3, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 3, 107, 34, 4, 65, 0, 78, 4, 64, 32, 6, 32, 9, 32, 4, 172, 134, 133, 33, 6, 12, 1, 11, 11, 32, 1, 40, 2, 4, 32, 2, 65, 3, 116, 106, 32, 6, 32, 8, 132, 55, 3, 0, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 65, 1, 36, 4, 11, 32, 0, 66, 0, 55, 3, 24, 32, 0, 66, 0, 55, 3, 32, 65, 0, 33, 2, 3, 64, 32, 2, 32, 0, 40, 2, 4, 72, 4, 64, 32, 0, 40, 2, 0, 32, 2, 16, 18, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 32, 0, 66, 0, 55, 3, 40, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 40, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 1, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 65, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 1, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 6, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 6, 66, 8, 134, 66, 1, 132, 133, 55, 3, 40, 32, 0, 11, 38, 1, 1, 127, 32, 0, 40, 2, 0, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 11, 55, 1, 2, 127, 32, 1, 32, 0, 40, 2, 0, 34, 2, 71, 4, 64, 32, 1, 65, 172, 3, 75, 4, 64, 32, 1, 65, 16, 107, 34, 3, 32, 3, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 16, 12, 11, 32, 0, 32, 1, 54, 2, 0, 11, 7, 0, 32, 0, 40, 2, 4, 11, 9, 0, 32, 0, 32, 1, 54, 2, 4, 11, 7, 0, 32, 0, 40, 2, 8, 11, 9, 0, 32, 0, 32, 1, 54, 2, 8, 11, 7, 0, 32, 0, 41, 3, 16, 11, 9, 0, 32, 0, 32, 1, 55, 3, 16, 11, 7, 0, 32, 0, 41, 3, 24, 11, 9, 0, 32, 0, 32, 1, 55, 3, 24, 11, 7, 0, 32, 0, 41, 3, 32, 11, 9, 0, 32, 0, 32, 1, 55, 3, 32, 11, 7, 0, 32, 0, 41, 3, 40, 11, 9, 0, 32, 0, 32, 1, 55, 3, 40, 11, 7, 0, 32, 0, 41, 3, 48, 11, 9, 0, 32, 0, 32, 1, 55, 3, 48, 11, 7, 0, 32, 0, 41, 3, 56, 11, 9, 0, 32, 0, 32, 1, 55, 3, 56, 11, 7, 0, 32, 0, 41, 3, 64, 11, 9, 0, 32, 0, 32, 1, 55, 3, 64, 11, 7, 0, 32, 0, 41, 3, 72, 11, 9, 0, 32, 0, 32, 1, 55, 3, 72, 11, 7, 0, 32, 0, 41, 3, 80, 11, 9, 0, 32, 0, 32, 1, 55, 3, 80, 11, 7, 0, 32, 0, 41, 3, 88, 11, 9, 0, 32, 0, 32, 1, 55, 3, 88, 11, 7, 0, 32, 0, 41, 3, 96, 11, 9, 0, 32, 0, 32, 1, 55, 3, 96, 11, 172, 4, 2, 5, 127, 1, 126, 32, 2, 65, 172, 3, 75, 4, 64, 32, 2, 65, 16, 107, 34, 4, 32, 4, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 33, 4, 65, 0, 33, 2, 32, 1, 40, 2, 8, 33, 5, 32, 1, 40, 2, 4, 33, 6, 3, 64, 2, 127, 65, 0, 33, 3, 3, 64, 32, 3, 32, 5, 72, 4, 64, 32, 3, 32, 6, 106, 45, 0, 0, 33, 1, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 7, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 32, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 7, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 8, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 1, 173, 32, 8, 66, 8, 134, 132, 133, 55, 3, 40, 32, 0, 32, 0, 41, 3, 16, 66, 1, 124, 55, 3, 16, 32, 0, 32, 0, 41, 3, 24, 66, 1, 124, 55, 3, 24, 32, 0, 41, 3, 16, 32, 0, 41, 3, 80, 90, 4, 127, 32, 0, 41, 3, 40, 32, 0, 41, 3, 96, 131, 80, 5, 65, 0, 11, 4, 127, 65, 1, 5, 32, 0, 41, 3, 16, 32, 0, 41, 3, 88, 90, 11, 4, 64, 32, 0, 32, 0, 41, 3, 32, 55, 3, 48, 32, 0, 32, 0, 41, 3, 16, 55, 3, 56, 32, 0, 32, 0, 41, 3, 40, 55, 3, 64, 65, 0, 33, 1, 3, 64, 32, 1, 32, 0, 40, 2, 4, 72, 4, 64, 32, 0, 40, 2, 0, 32, 1, 16, 18, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 32, 0, 66, 0, 55, 3, 40, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 40, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 1, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 65, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 1, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 8, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 8, 66, 8, 134, 66, 1, 132, 133, 55, 3, 40, 32, 3, 65, 1, 106, 12, 3, 11, 32, 3, 65, 1, 106, 33, 3, 12, 1, 11, 11, 65, 127, 11, 34, 1, 65, 0, 78, 4, 64, 32, 5, 32, 1, 107, 33, 5, 32, 1, 32, 6, 106, 33, 6, 32, 2, 34, 1, 65, 1, 106, 33, 2, 32, 4, 40, 2, 4, 32, 1, 65, 2, 116, 106, 32, 0, 41, 3, 56, 62, 2, 0, 12, 1, 11, 11, 32, 4, 11, 10, 0, 16, 15, 36, 5, 16, 15, 36, 6, 11, 3, 0, 1, 11, 73, 1, 2, 127, 32, 0, 40, 2, 4, 34, 1, 65, 255, 255, 255, 255, 0, 113, 34, 2, 65, 1, 70, 4, 64, 32, 0, 65, 16, 106, 16, 53, 32, 0, 32, 0, 40, 2, 0, 65, 1, 114, 54, 2, 0, 35, 0, 32, 0, 16, 2, 5, 32, 0, 32, 2, 65, 1, 107, 32, 1, 65, 128, 128, 128, 128, 127, 113, 114, 54, 2, 4, 11, 11, 58, 0, 2, 64, 2, 64, 2, 64, 32, 0, 65, 8, 107, 40, 2, 0, 14, 7, 0, 0, 1, 1, 1, 1, 1, 2, 11, 15, 11, 32, 0, 40, 2, 0, 34, 0, 4, 64, 32, 0, 65, 172, 3, 79, 4, 64, 32, 0, 65, 16, 107, 16, 52, 11, 11, 15, 11, 0, 11, 11, 137, 3, 7, 0, 65, 16, 11, 55, 40, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 40, 0, 0, 0, 97, 0, 108, 0, 108, 0, 111, 0, 99, 0, 97, 0, 116, 0, 105, 0, 111, 0, 110, 0, 32, 0, 116, 0, 111, 0, 111, 0, 32, 0, 108, 0, 97, 0, 114, 0, 103, 0, 101, 0, 65, 208, 0, 11, 45, 30, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 30, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 114, 0, 116, 0, 47, 0, 116, 0, 108, 0, 115, 0, 102, 0, 46, 0, 116, 0, 115, 0, 65, 128, 1, 11, 43, 28, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 28, 0, 0, 0, 73, 0, 110, 0, 118, 0, 97, 0, 108, 0, 105, 0, 100, 0, 32, 0, 108, 0, 101, 0, 110, 0, 103, 0, 116, 0, 104, 0, 65, 176, 1, 11, 53, 38, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 38, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 97, 0, 114, 0, 114, 0, 97, 0, 121, 0, 98, 0, 117, 0, 102, 0, 102, 0, 101, 0, 114, 0, 46, 0, 116, 0, 115, 0, 65, 240, 1, 11, 51, 36, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 36, 0, 0, 0, 73, 0, 110, 0, 100, 0, 101, 0, 120, 0, 32, 0, 111, 0, 117, 0, 116, 0, 32, 0, 111, 0, 102, 0, 32, 0, 114, 0, 97, 0, 110, 0, 103, 0, 101, 0, 65, 176, 2, 11, 51, 36, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 36, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 116, 0, 121, 0, 112, 0, 101, 0, 100, 0, 97, 0, 114, 0, 114, 0, 97, 0, 121, 0, 46, 0, 116, 0, 115, 0, 65, 240, 2, 11, 53, 7, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 145, 4, 0, 0, 2, 0, 0, 0, 49, 0, 0, 0, 2, 0, 0, 0, 17, 1, 0, 0, 2, 0, 0, 0, 16, 0, 34, 16, 115, 111, 117, 114, 99, 101, 77, 97, 112, 112, 105, 110, 103, 85, 82, 76, 16, 46, 47, 114, 97, 98, 105, 110, 46, 119, 97, 115, 109, 46, 109, 97, 112]);
  return instantiate(new Response(new Blob([wasm], { type: "application/wasm" })), imp);
}
var rabinWasm = loadWebAssembly;
const Rabin = rabin$1;
const getRabin = rabinWasm;
const create$5 = async (avg, min, max, windowSize, polynomial) => {
  const compiled = await getRabin();
  return new Rabin(compiled, avg, min, max, windowSize, polynomial);
};
var src$3 = {
  Rabin,
  create: create$5
};
async function* rabinChunker(source2, options) {
  let min, max, avg;
  if (options.minChunkSize && options.maxChunkSize && options.avgChunkSize) {
    avg = options.avgChunkSize;
    min = options.minChunkSize;
    max = options.maxChunkSize;
  } else if (!options.avgChunkSize) {
    throw errCode(new Error("please specify an average chunk size"), "ERR_INVALID_AVG_CHUNK_SIZE");
  } else {
    avg = options.avgChunkSize;
    min = avg / 3;
    max = avg + avg / 2;
  }
  if (min < 16) {
    throw errCode(new Error("rabin min must be greater than 16"), "ERR_INVALID_MIN_CHUNK_SIZE");
  }
  if (max < min) {
    max = min;
  }
  if (avg < min) {
    avg = min;
  }
  const sizepow = Math.floor(Math.log2(avg));
  for await (const chunk of rabin(source2, {
    min,
    max,
    bits: sizepow,
    window: options.window,
    polynomial: options.polynomial
  })) {
    yield chunk;
  }
}
async function* rabin(source2, options) {
  const r = await src$3.create(options.bits, options.min, options.max, options.window);
  const buffers = new Uint8ArrayList();
  for await (const chunk of source2) {
    buffers.append(chunk);
    const sizes = r.fingerprint(chunk);
    for (let i2 = 0; i2 < sizes.length; i2++) {
      const size2 = sizes[i2];
      const buf2 = buffers.slice(0, size2);
      buffers.consume(size2);
      yield buf2;
    }
  }
  if (buffers.length) {
    yield buffers.subarray(0);
  }
}
async function* fixedSizeChunker(source2, options) {
  let list = new Uint8ArrayList();
  let currentLength = 0;
  let emitted = false;
  const maxChunkSize = options.maxChunkSize;
  for await (const buffer2 of source2) {
    list.append(buffer2);
    currentLength += buffer2.length;
    while (currentLength >= maxChunkSize) {
      yield list.slice(0, maxChunkSize);
      emitted = true;
      if (maxChunkSize === list.length) {
        list = new Uint8ArrayList();
        currentLength = 0;
      } else {
        const newBl = new Uint8ArrayList();
        newBl.append(list.sublist(maxChunkSize));
        list = newBl;
        currentLength -= maxChunkSize;
      }
    }
  }
  if (!emitted || currentLength) {
    yield list.subarray(0, currentLength);
  }
}
async function* validateChunks(source2) {
  for await (const content of source2) {
    if (content.length === void 0) {
      throw errCode(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
    }
    if (typeof content === "string" || content instanceof String) {
      yield fromString$3(content.toString());
    } else if (Array.isArray(content)) {
      yield Uint8Array.from(content);
    } else if (content instanceof Uint8Array) {
      yield content;
    } else {
      throw errCode(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
    }
  }
}
function isIterable(thing) {
  return Symbol.iterator in thing;
}
function isAsyncIterable(thing) {
  return Symbol.asyncIterator in thing;
}
function contentAsAsyncIterable(content) {
  try {
    if (content instanceof Uint8Array) {
      return async function* () {
        yield content;
      }();
    } else if (isIterable(content)) {
      return async function* () {
        yield* content;
      }();
    } else if (isAsyncIterable(content)) {
      return content;
    }
  } catch {
    throw errCode(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
  }
  throw errCode(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
}
async function* dagBuilder(source2, blockstore, options) {
  for await (const entry of source2) {
    if (entry.path) {
      if (entry.path.substring(0, 2) === "./") {
        options.wrapWithDirectory = true;
      }
      entry.path = entry.path.split("/").filter((path2) => path2 && path2 !== ".").join("/");
    }
    if (entry.content) {
      let chunker;
      if (typeof options.chunker === "function") {
        chunker = options.chunker;
      } else if (options.chunker === "rabin") {
        chunker = rabinChunker;
      } else {
        chunker = fixedSizeChunker;
      }
      let chunkValidator;
      if (typeof options.chunkValidator === "function") {
        chunkValidator = options.chunkValidator;
      } else {
        chunkValidator = validateChunks;
      }
      const file = {
        path: entry.path,
        mtime: entry.mtime,
        mode: entry.mode,
        content: chunker(chunkValidator(contentAsAsyncIterable(entry.content), options), options)
      };
      yield () => fileBuilder(file, blockstore, options);
    } else if (entry.path) {
      const dir = {
        path: entry.path,
        mtime: entry.mtime,
        mode: entry.mode
      };
      yield () => dirBuilder(dir, blockstore, options);
    } else {
      throw new Error("Import candidate must have content or path or both");
    }
  }
}
class Dir$1 {
  constructor(props, options) {
    this.options = options || {};
    this.root = props.root;
    this.dir = props.dir;
    this.path = props.path;
    this.dirty = props.dirty;
    this.flat = props.flat;
    this.parent = props.parent;
    this.parentKey = props.parentKey;
    this.unixfs = props.unixfs;
    this.mode = props.mode;
    this.mtime = props.mtime;
    this.cid = void 0;
    this.size = void 0;
  }
  async put(name2, value2) {
  }
  get(name2) {
    return Promise.resolve(this);
  }
  async *eachChildSeries() {
  }
  async *flush(blockstore) {
  }
}
class DirFlat extends Dir$1 {
  constructor(props, options) {
    super(props, options);
    this._children = {};
  }
  async put(name2, value2) {
    this.cid = void 0;
    this.size = void 0;
    this._children[name2] = value2;
  }
  get(name2) {
    return Promise.resolve(this._children[name2]);
  }
  childCount() {
    return Object.keys(this._children).length;
  }
  directChildrenCount() {
    return this.childCount();
  }
  onlyChild() {
    return this._children[Object.keys(this._children)[0]];
  }
  async *eachChildSeries() {
    const keys = Object.keys(this._children);
    for (let i2 = 0; i2 < keys.length; i2++) {
      const key = keys[i2];
      yield {
        key,
        child: this._children[key]
      };
    }
  }
  async *flush(block) {
    const children = Object.keys(this._children);
    const links2 = [];
    for (let i2 = 0; i2 < children.length; i2++) {
      let child = this._children[children[i2]];
      if (child instanceof Dir$1) {
        for await (const entry of child.flush(block)) {
          child = entry;
          yield child;
        }
      }
      if (child.size != null && child.cid) {
        links2.push({
          Name: children[i2],
          Tsize: child.size,
          Hash: child.cid
        });
      }
    }
    const unixfs = new UnixFS({
      type: "directory",
      mtime: this.mtime,
      mode: this.mode
    });
    const node2 = { Data: unixfs.marshal(), Links: links2 };
    const buffer2 = encode$o(prepare(node2));
    const cid = await persist$1(buffer2, block, this.options);
    const size2 = buffer2.length + node2.Links.reduce(
      (acc, curr) => acc + (curr.Tsize == null ? 0 : curr.Tsize),
      0
    );
    this.cid = cid;
    this.size = size2;
    yield {
      cid,
      unixfs,
      path: this.path,
      size: size2
    };
  }
}
const BITS_PER_BYTE = 7;
var sparseArray = class SparseArray {
  constructor() {
    this._bitArrays = [];
    this._data = [];
    this._length = 0;
    this._changedLength = false;
    this._changedData = false;
  }
  set(index, value2) {
    let pos = this._internalPositionFor(index, false);
    if (value2 === void 0) {
      if (pos !== -1) {
        this._unsetInternalPos(pos);
        this._unsetBit(index);
        this._changedLength = true;
        this._changedData = true;
      }
    } else {
      let needsSort = false;
      if (pos === -1) {
        pos = this._data.length;
        this._setBit(index);
        this._changedData = true;
      } else {
        needsSort = true;
      }
      this._setInternalPos(pos, index, value2, needsSort);
      this._changedLength = true;
    }
  }
  unset(index) {
    this.set(index, void 0);
  }
  get(index) {
    this._sortData();
    const pos = this._internalPositionFor(index, true);
    if (pos === -1) {
      return void 0;
    }
    return this._data[pos][1];
  }
  push(value2) {
    this.set(this.length, value2);
    return this.length;
  }
  get length() {
    this._sortData();
    if (this._changedLength) {
      const last2 = this._data[this._data.length - 1];
      this._length = last2 ? last2[0] + 1 : 0;
      this._changedLength = false;
    }
    return this._length;
  }
  forEach(iterator2) {
    let i2 = 0;
    while (i2 < this.length) {
      iterator2(this.get(i2), i2, this);
      i2++;
    }
  }
  map(iterator2) {
    let i2 = 0;
    let mapped = new Array(this.length);
    while (i2 < this.length) {
      mapped[i2] = iterator2(this.get(i2), i2, this);
      i2++;
    }
    return mapped;
  }
  reduce(reducer, initialValue) {
    let i2 = 0;
    let acc = initialValue;
    while (i2 < this.length) {
      const value2 = this.get(i2);
      acc = reducer(acc, value2, i2);
      i2++;
    }
    return acc;
  }
  find(finder) {
    let i2 = 0, found, last2;
    while (i2 < this.length && !found) {
      last2 = this.get(i2);
      found = finder(last2);
      i2++;
    }
    return found ? last2 : void 0;
  }
  _internalPositionFor(index, noCreate) {
    const bytePos = this._bytePosFor(index, noCreate);
    if (bytePos >= this._bitArrays.length) {
      return -1;
    }
    const byte = this._bitArrays[bytePos];
    const bitPos = index - bytePos * BITS_PER_BYTE;
    const exists2 = (byte & 1 << bitPos) > 0;
    if (!exists2) {
      return -1;
    }
    const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0);
    const mask = ~(4294967295 << bitPos + 1);
    const bytePopCount = popCount(byte & mask);
    const arrayPos = previousPopCount + bytePopCount - 1;
    return arrayPos;
  }
  _bytePosFor(index, noCreate) {
    const bytePos = Math.floor(index / BITS_PER_BYTE);
    const targetLength = bytePos + 1;
    while (!noCreate && this._bitArrays.length < targetLength) {
      this._bitArrays.push(0);
    }
    return bytePos;
  }
  _setBit(index) {
    const bytePos = this._bytePosFor(index, false);
    this._bitArrays[bytePos] |= 1 << index - bytePos * BITS_PER_BYTE;
  }
  _unsetBit(index) {
    const bytePos = this._bytePosFor(index, false);
    this._bitArrays[bytePos] &= ~(1 << index - bytePos * BITS_PER_BYTE);
  }
  _setInternalPos(pos, index, value2, needsSort) {
    const data = this._data;
    const elem = [index, value2];
    if (needsSort) {
      this._sortData();
      data[pos] = elem;
    } else {
      if (data.length) {
        if (data[data.length - 1][0] >= index) {
          data.push(elem);
        } else if (data[0][0] <= index) {
          data.unshift(elem);
        } else {
          const randomIndex = Math.round(data.length / 2);
          this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex));
        }
      } else {
        this._data.push(elem);
      }
      this._changedData = true;
      this._changedLength = true;
    }
  }
  _unsetInternalPos(pos) {
    this._data.splice(pos, 1);
  }
  _sortData() {
    if (this._changedData) {
      this._data.sort(sortInternal);
    }
    this._changedData = false;
  }
  bitField() {
    const bytes2 = [];
    let pendingBitsForResultingByte = 8;
    let pendingBitsForNewByte = 0;
    let resultingByte = 0;
    let newByte;
    const pending = this._bitArrays.slice();
    while (pending.length || pendingBitsForNewByte) {
      if (pendingBitsForNewByte === 0) {
        newByte = pending.shift();
        pendingBitsForNewByte = 7;
      }
      const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte);
      const mask = ~(255 << usingBits);
      const masked = newByte & mask;
      resultingByte |= masked << 8 - pendingBitsForResultingByte;
      newByte = newByte >>> usingBits;
      pendingBitsForNewByte -= usingBits;
      pendingBitsForResultingByte -= usingBits;
      if (!pendingBitsForResultingByte || !pendingBitsForNewByte && !pending.length) {
        bytes2.push(resultingByte);
        resultingByte = 0;
        pendingBitsForResultingByte = 8;
      }
    }
    for (var i2 = bytes2.length - 1; i2 > 0; i2--) {
      const value2 = bytes2[i2];
      if (value2 === 0) {
        bytes2.pop();
      } else {
        break;
      }
    }
    return bytes2;
  }
  compactArray() {
    this._sortData();
    return this._data.map(valueOnly);
  }
};
function popCountReduce(count, byte) {
  return count + popCount(byte);
}
function popCount(_v) {
  let v = _v;
  v = v - (v >> 1 & 1431655765);
  v = (v & 858993459) + (v >> 2 & 858993459);
  return (v + (v >> 4) & 252645135) * 16843009 >> 24;
}
function sortInternal(a, b2) {
  return a[0] - b2[0];
}
function valueOnly(elem) {
  return elem[1];
}
class Bucket {
  constructor(options, parent2, posAtParent = 0) {
    this._options = options;
    this._popCount = 0;
    this._parent = parent2;
    this._posAtParent = posAtParent;
    this._children = new sparseArray();
    this.key = null;
  }
  async put(key, value2) {
    const place = await this._findNewBucketAndPos(key);
    await place.bucket._putAt(place, key, value2);
  }
  async get(key) {
    const child = await this._findChild(key);
    if (child != null) {
      return child.value;
    }
  }
  async del(key) {
    const place = await this._findPlace(key);
    const child = place.bucket._at(place.pos);
    if (child != null && child.key === key) {
      place.bucket._delAt(place.pos);
    }
  }
  leafCount() {
    const children = this._children.compactArray();
    return children.reduce((acc, child) => {
      if (child instanceof Bucket) {
        return acc + child.leafCount();
      }
      return acc + 1;
    }, 0);
  }
  childrenCount() {
    return this._children.length;
  }
  onlyChild() {
    return this._children.get(0);
  }
  *eachLeafSeries() {
    const children = this._children.compactArray();
    for (const child of children) {
      if (child instanceof Bucket) {
        yield* child.eachLeafSeries();
      } else {
        yield child;
      }
    }
  }
  serialize(map2, reduce2) {
    const acc = [];
    return reduce2(this._children.reduce((acc2, child, index) => {
      if (child != null) {
        if (child instanceof Bucket) {
          acc2.push(child.serialize(map2, reduce2));
        } else {
          acc2.push(map2(child, index));
        }
      }
      return acc2;
    }, acc));
  }
  async asyncTransform(asyncMap, asyncReduce) {
    return await asyncTransformBucket(this, asyncMap, asyncReduce);
  }
  toJSON() {
    return this.serialize(mapNode, reduceNodes);
  }
  prettyPrint() {
    return JSON.stringify(this.toJSON(), null, "  ");
  }
  tableSize() {
    return Math.pow(2, this._options.bits);
  }
  async _findChild(key) {
    const result = await this._findPlace(key);
    const child = result.bucket._at(result.pos);
    if (child instanceof Bucket) {
      return void 0;
    }
    if (child != null && child.key === key) {
      return child;
    }
  }
  async _findPlace(key) {
    const hashValue = this._options.hash(typeof key === "string" ? fromString$3(key) : key);
    const index = await hashValue.take(this._options.bits);
    const child = this._children.get(index);
    if (child instanceof Bucket) {
      return await child._findPlace(hashValue);
    }
    return {
      bucket: this,
      pos: index,
      hash: hashValue,
      existingChild: child
    };
  }
  async _findNewBucketAndPos(key) {
    const place = await this._findPlace(key);
    if (place.existingChild != null && place.existingChild.key !== key) {
      const bucket = new Bucket(this._options, place.bucket, place.pos);
      place.bucket._putObjectAt(place.pos, bucket);
      const newPlace = await bucket._findPlace(place.existingChild.hash);
      newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value);
      return await bucket._findNewBucketAndPos(place.hash);
    }
    return place;
  }
  _putAt(place, key, value2) {
    this._putObjectAt(place.pos, {
      key,
      value: value2,
      hash: place.hash
    });
  }
  _putObjectAt(pos, object) {
    if (this._children.get(pos) == null) {
      this._popCount++;
    }
    this._children.set(pos, object);
  }
  _delAt(pos) {
    if (pos === -1) {
      throw new Error("Invalid position");
    }
    if (this._children.get(pos) != null) {
      this._popCount--;
    }
    this._children.unset(pos);
    this._level();
  }
  _level() {
    if (this._parent != null && this._popCount <= 1) {
      if (this._popCount === 1) {
        const onlyChild = this._children.find(exists);
        if (onlyChild != null && !(onlyChild instanceof Bucket)) {
          const hash2 = onlyChild.hash;
          hash2.untake(this._options.bits);
          const place = {
            pos: this._posAtParent,
            hash: hash2,
            bucket: this._parent
          };
          this._parent._putAt(place, onlyChild.key, onlyChild.value);
        }
      } else {
        this._parent._delAt(this._posAtParent);
      }
    }
  }
  _at(index) {
    return this._children.get(index);
  }
}
function exists(o) {
  return Boolean(o);
}
function mapNode(node2, _) {
  return node2.key;
}
function reduceNodes(nodes) {
  return nodes;
}
async function asyncTransformBucket(bucket, asyncMap, asyncReduce) {
  const output = [];
  for (const child of bucket._children.compactArray()) {
    if (child instanceof Bucket) {
      await asyncTransformBucket(child, asyncMap, asyncReduce);
    } else {
      const mappedChildren = await asyncMap(child);
      output.push({
        bitField: bucket._children.bitField(),
        children: mappedChildren
      });
    }
  }
  return await asyncReduce(output);
}
const START_MASKS = [
  255,
  254,
  252,
  248,
  240,
  224,
  192,
  128
];
const STOP_MASKS = [
  1,
  3,
  7,
  15,
  31,
  63,
  127,
  255
];
class ConsumableBuffer {
  constructor(value2) {
    this._value = value2;
    this._currentBytePos = value2.length - 1;
    this._currentBitPos = 7;
  }
  availableBits() {
    return this._currentBitPos + 1 + this._currentBytePos * 8;
  }
  totalBits() {
    return this._value.length * 8;
  }
  take(bits2) {
    let pendingBits = bits2;
    let result = 0;
    while (pendingBits > 0 && this._haveBits()) {
      const byte = this._value[this._currentBytePos];
      const availableBits = this._currentBitPos + 1;
      const taking = Math.min(availableBits, pendingBits);
      const value2 = byteBitsToInt(byte, availableBits - taking, taking);
      result = (result << taking) + value2;
      pendingBits -= taking;
      this._currentBitPos -= taking;
      if (this._currentBitPos < 0) {
        this._currentBitPos = 7;
        this._currentBytePos--;
      }
    }
    return result;
  }
  untake(bits2) {
    this._currentBitPos += bits2;
    while (this._currentBitPos > 7) {
      this._currentBitPos -= 8;
      this._currentBytePos += 1;
    }
  }
  _haveBits() {
    return this._currentBytePos >= 0;
  }
}
function byteBitsToInt(byte, start, length3) {
  const mask = maskFor(start, length3);
  return (byte & mask) >>> start;
}
function maskFor(start, length3) {
  return START_MASKS[start] & STOP_MASKS[Math.min(length3 + start - 1, 7)];
}
function wrapHash(hashFn2) {
  function hashing(value2) {
    if (value2 instanceof InfiniteHash) {
      return value2;
    } else {
      return new InfiniteHash(value2, hashFn2);
    }
  }
  return hashing;
}
class InfiniteHash {
  constructor(value2, hashFn2) {
    if (!(value2 instanceof Uint8Array)) {
      throw new Error("can only hash Uint8Arrays");
    }
    this._value = value2;
    this._hashFn = hashFn2;
    this._depth = -1;
    this._availableBits = 0;
    this._currentBufferIndex = 0;
    this._buffers = [];
  }
  async take(bits2) {
    let pendingBits = bits2;
    while (this._availableBits < pendingBits) {
      await this._produceMoreBits();
    }
    let result = 0;
    while (pendingBits > 0) {
      const hash2 = this._buffers[this._currentBufferIndex];
      const available = Math.min(hash2.availableBits(), pendingBits);
      const took = hash2.take(available);
      result = (result << available) + took;
      pendingBits -= available;
      this._availableBits -= available;
      if (hash2.availableBits() === 0) {
        this._currentBufferIndex++;
      }
    }
    return result;
  }
  untake(bits2) {
    let pendingBits = bits2;
    while (pendingBits > 0) {
      const hash2 = this._buffers[this._currentBufferIndex];
      const availableForUntake = Math.min(hash2.totalBits() - hash2.availableBits(), pendingBits);
      hash2.untake(availableForUntake);
      pendingBits -= availableForUntake;
      this._availableBits += availableForUntake;
      if (this._currentBufferIndex > 0 && hash2.totalBits() === hash2.availableBits()) {
        this._depth--;
        this._currentBufferIndex--;
      }
    }
  }
  async _produceMoreBits() {
    this._depth++;
    const value2 = this._depth > 0 ? concat$1([this._value, Uint8Array.from([this._depth])]) : this._value;
    const hashValue = await this._hashFn(value2);
    const buffer2 = new ConsumableBuffer(hashValue);
    this._buffers.push(buffer2);
    this._availableBits += buffer2.availableBits();
  }
}
function createHAMT(options) {
  if (options == null || options.hashFn == null) {
    throw new Error("please define an options.hashFn");
  }
  const bucketOptions = {
    bits: options.bits ?? 8,
    hash: wrapHash(options.hashFn)
  };
  return new Bucket(bucketOptions);
}
class DirSharded$1 extends Dir$1 {
  constructor(props, options) {
    super(props, options);
    this._bucket = createHAMT({
      hashFn: options.hamtHashFn,
      bits: options.hamtBucketBits
    });
  }
  async put(name2, value2) {
    await this._bucket.put(name2, value2);
  }
  get(name2) {
    return this._bucket.get(name2);
  }
  childCount() {
    return this._bucket.leafCount();
  }
  directChildrenCount() {
    return this._bucket.childrenCount();
  }
  onlyChild() {
    return this._bucket.onlyChild();
  }
  async *eachChildSeries() {
    for await (const { key, value: value2 } of this._bucket.eachLeafSeries()) {
      yield {
        key,
        child: value2
      };
    }
  }
  async *flush(blockstore) {
    for await (const entry of flush$1(this._bucket, blockstore, this, this.options)) {
      yield {
        ...entry,
        path: this.path
      };
    }
  }
}
async function* flush$1(bucket, blockstore, shardRoot, options) {
  const children = bucket._children;
  const links2 = [];
  let childrenSize = 0;
  for (let i2 = 0; i2 < children.length; i2++) {
    const child = children.get(i2);
    if (!child) {
      continue;
    }
    const labelPrefix = i2.toString(16).toUpperCase().padStart(2, "0");
    if (child instanceof Bucket) {
      let shard;
      for await (const subShard of await flush$1(child, blockstore, null, options)) {
        shard = subShard;
      }
      if (!shard) {
        throw new Error("Could not flush sharded directory, no subshard found");
      }
      links2.push({
        Name: labelPrefix,
        Tsize: shard.size,
        Hash: shard.cid
      });
      childrenSize += shard.size;
    } else if (typeof child.value.flush === "function") {
      const dir2 = child.value;
      let flushedDir;
      for await (const entry of dir2.flush(blockstore)) {
        flushedDir = entry;
        yield flushedDir;
      }
      const label = labelPrefix + child.key;
      links2.push({
        Name: label,
        Tsize: flushedDir.size,
        Hash: flushedDir.cid
      });
      childrenSize += flushedDir.size;
    } else {
      const value2 = child.value;
      if (!value2.cid) {
        continue;
      }
      const label = labelPrefix + child.key;
      const size3 = value2.size;
      links2.push({
        Name: label,
        Tsize: size3,
        Hash: value2.cid
      });
      childrenSize += size3;
    }
  }
  const data = Uint8Array.from(children.bitField().reverse());
  const dir = new UnixFS({
    type: "hamt-sharded-directory",
    data,
    fanout: bucket.tableSize(),
    hashType: options.hamtHashCode,
    mtime: shardRoot && shardRoot.mtime,
    mode: shardRoot && shardRoot.mode
  });
  const node2 = {
    Data: dir.marshal(),
    Links: links2
  };
  const buffer2 = encode$o(prepare(node2));
  const cid = await persist$1(buffer2, blockstore, options);
  const size2 = buffer2.length + childrenSize;
  yield {
    cid,
    unixfs: dir,
    size: size2
  };
}
async function flatToShard(child, dir, threshold, options) {
  let newDir = dir;
  if (dir instanceof DirFlat && dir.directChildrenCount() >= threshold) {
    newDir = await convertToShard(dir, options);
  }
  const parent2 = newDir.parent;
  if (parent2) {
    if (newDir !== dir) {
      if (child) {
        child.parent = newDir;
      }
      if (!newDir.parentKey) {
        throw new Error("No parent key found");
      }
      await parent2.put(newDir.parentKey, newDir);
    }
    return flatToShard(newDir, parent2, threshold, options);
  }
  return newDir;
}
async function convertToShard(oldDir, options) {
  const newDir = new DirSharded$1({
    root: oldDir.root,
    dir: true,
    parent: oldDir.parent,
    parentKey: oldDir.parentKey,
    path: oldDir.path,
    dirty: oldDir.dirty,
    flat: false,
    mtime: oldDir.mtime,
    mode: oldDir.mode
  }, options);
  for await (const { key, child } of oldDir.eachChildSeries()) {
    await newDir.put(key, child);
  }
  return newDir;
}
const toPathComponents$2 = (path2 = "") => {
  return (path2.trim().match(/([^\\/]|\\\/)+/g) || []).filter(Boolean);
};
async function addToTree(elem, tree2, options) {
  const pathElems = toPathComponents$2(elem.path || "");
  const lastIndex = pathElems.length - 1;
  let parent2 = tree2;
  let currentPath = "";
  for (let i2 = 0; i2 < pathElems.length; i2++) {
    const pathElem = pathElems[i2];
    currentPath += `${currentPath ? "/" : ""}${pathElem}`;
    const last2 = i2 === lastIndex;
    parent2.dirty = true;
    parent2.cid = void 0;
    parent2.size = void 0;
    if (last2) {
      await parent2.put(pathElem, elem);
      tree2 = await flatToShard(null, parent2, options.shardSplitThreshold, options);
    } else {
      let dir = await parent2.get(pathElem);
      if (!dir || !(dir instanceof Dir$1)) {
        dir = new DirFlat({
          root: false,
          dir: true,
          parent: parent2,
          parentKey: pathElem,
          path: currentPath,
          dirty: true,
          flat: true,
          mtime: dir && dir.unixfs && dir.unixfs.mtime,
          mode: dir && dir.unixfs && dir.unixfs.mode
        }, options);
      }
      await parent2.put(pathElem, dir);
      parent2 = dir;
    }
  }
  return tree2;
}
async function* flushAndYield(tree2, blockstore) {
  if (!(tree2 instanceof Dir$1)) {
    if (tree2 && tree2.unixfs && tree2.unixfs.isDirectory()) {
      yield tree2;
    }
    return;
  }
  yield* tree2.flush(blockstore);
}
async function* treeBuilder(source2, block, options) {
  let tree2 = new DirFlat({
    root: true,
    dir: true,
    path: "",
    dirty: true,
    flat: true
  }, options);
  for await (const entry of source2) {
    if (!entry) {
      continue;
    }
    tree2 = await addToTree(entry, tree2, options);
    if (!entry.unixfs || !entry.unixfs.isDirectory()) {
      yield entry;
    }
  }
  if (options.wrapWithDirectory) {
    yield* flushAndYield(tree2, block);
  } else {
    for await (const unwrapped of tree2.eachChildSeries()) {
      if (!unwrapped) {
        continue;
      }
      yield* flushAndYield(unwrapped.child, block);
    }
  }
}
async function* importer(source2, blockstore, options = {}) {
  const opts = defaultOptions$l(options);
  let dagBuilder$1;
  if (typeof options.dagBuilder === "function") {
    dagBuilder$1 = options.dagBuilder;
  } else {
    dagBuilder$1 = dagBuilder;
  }
  let treeBuilder$1;
  if (typeof options.treeBuilder === "function") {
    treeBuilder$1 = options.treeBuilder;
  } else {
    treeBuilder$1 = treeBuilder;
  }
  let candidates;
  if (Symbol.asyncIterator in source2 || Symbol.iterator in source2) {
    candidates = source2;
  } else {
    candidates = [source2];
  }
  for await (const entry of treeBuilder$1(parallelBatch(dagBuilder$1(candidates, blockstore, opts), opts.fileImportConcurrency), blockstore, opts)) {
    yield {
      cid: entry.cid,
      path: entry.path,
      unixfs: entry.unixfs,
      size: entry.size
    };
  }
}
async function* normaliseCandidateMultiple(input, normaliseContent2) {
  if (typeof input === "string" || input instanceof String || isBytes(input) || isBlob(input) || input._readableState) {
    throw errCode(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
  }
  if (isReadableStream(input)) {
    input = browserReadableStreamToIt(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = peekableIterator(input);
    const { value: value2, done } = await peekable.peek();
    if (done) {
      yield* [];
      return;
    }
    peekable.push(value2);
    if (Number.isInteger(value2)) {
      throw errCode(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
    }
    if (value2._readableState) {
      yield* map$3(peekable, (value3) => toFileObject({ content: value3 }, normaliseContent2));
      return;
    }
    if (isBytes(value2)) {
      yield toFileObject({ content: peekable }, normaliseContent2);
      return;
    }
    if (isFileObject(value2) || value2[Symbol.iterator] || value2[Symbol.asyncIterator] || isReadableStream(value2) || isBlob(value2)) {
      yield* map$3(peekable, (value3) => toFileObject(value3, normaliseContent2));
      return;
    }
  }
  if (isFileObject(input)) {
    throw errCode(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
  }
  throw errCode(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
}
async function toFileObject(input, normaliseContent2) {
  const { path: path2, mode, mtime, content } = input;
  const file = {
    path: path2 || "",
    mode: parseMode(mode),
    mtime: parseMtime$1(mtime)
  };
  if (content) {
    file.content = await normaliseContent2(content);
  } else if (!path2) {
    file.content = await normaliseContent2(input);
  }
  return file;
}
function normaliseInput$1(input) {
  return normaliseCandidateMultiple(input, normaliseContent$1);
}
const parseChunkerString = (chunker) => {
  if (!chunker) {
    return {
      chunker: "fixed"
    };
  } else if (chunker.startsWith("size-")) {
    const sizeStr = chunker.split("-")[1];
    const size2 = parseInt(sizeStr);
    if (isNaN(size2)) {
      throw new Error("Chunker parameter size must be an integer");
    }
    return {
      chunker: "fixed",
      maxChunkSize: size2
    };
  } else if (chunker.startsWith("rabin")) {
    return {
      chunker: "rabin",
      ...parseRabinString(chunker)
    };
  } else {
    throw new Error(`Unrecognized chunker option: ${chunker}`);
  }
};
const parseRabinString = (chunker) => {
  const options = {};
  const parts2 = chunker.split("-");
  switch (parts2.length) {
    case 1:
      options.avgChunkSize = 262144;
      break;
    case 2:
      options.avgChunkSize = parseChunkSize(parts2[1], "avg");
      break;
    case 4:
      options.minChunkSize = parseChunkSize(parts2[1], "min");
      options.avgChunkSize = parseChunkSize(parts2[2], "avg");
      options.maxChunkSize = parseChunkSize(parts2[3], "max");
      break;
    default:
      throw new Error('Incorrect chunker format (expected "rabin" "rabin-[avg]" or "rabin-[min]-[avg]-[max]"');
  }
  return options;
};
const parseChunkSize = (str, name2) => {
  const size2 = parseInt(str);
  if (isNaN(size2)) {
    throw new Error(`Chunker parameter ${name2} must be an integer`);
  }
  return size2;
};
const mergeOptions$d = mergeOptions$g.bind({ ignoreUndefined: true });
function createAddAll$2({ repo, preload: preload2, hashers, options }) {
  const isShardingEnabled = options && options.sharding;
  async function* addAll(source2, options2 = {}) {
    const opts = mergeOptions$d({
      shardSplitThreshold: isShardingEnabled ? 1e3 : Infinity,
      strategy: "balanced"
    }, options2, {
      ...parseChunkerString(options2.chunker)
    });
    if (opts.hashAlg && opts.hashAlg !== "sha2-256" && opts.cidVersion !== 1) {
      opts.cidVersion = 1;
    }
    if (opts.trickle) {
      opts.strategy = "trickle";
    }
    if (opts.strategy === "trickle") {
      opts.leafType = "raw";
      opts.reduceSingleLeafToSelf = false;
    }
    if (opts.cidVersion > 0 && opts.rawLeaves === void 0) {
      opts.rawLeaves = true;
    }
    if (opts.hashAlg !== void 0 && opts.rawLeaves === void 0) {
      opts.rawLeaves = true;
    }
    delete opts.trickle;
    const totals = {};
    if (opts.progress) {
      const prog = opts.progress;
      opts.progress = (bytes2, path2) => {
        if (!totals[path2]) {
          totals[path2] = 0;
        }
        totals[path2] += bytes2;
        prog(totals[path2], path2);
      };
    }
    let hasher;
    if (opts.hashAlg != null) {
      hasher = await hashers.getHasher(opts.hashAlg);
    }
    const iterator2 = pipe(
      normaliseInput$1(source2),
      (source3) => importer(source3, repo.blocks, {
        ...opts,
        hasher,
        pin: false
      }),
      transformFile(opts),
      preloadFile(preload2, opts),
      pinFile(repo, opts)
    );
    const releaseLock = await repo.gcLock.readLock();
    try {
      for await (const added of iterator2) {
        const path2 = added.path ?? added.cid.toString();
        delete totals[path2];
        yield {
          ...added,
          path: path2
        };
      }
    } finally {
      releaseLock();
    }
  }
  return withTimeoutOption(addAll);
}
function transformFile(opts) {
  async function* transformFile2(source2) {
    for await (const file of source2) {
      let cid = file.cid;
      if (opts.cidVersion === 1) {
        cid = cid.toV1();
      }
      let path2 = file.path ? file.path : cid.toString();
      if (opts.wrapWithDirectory && !file.path) {
        path2 = "";
      }
      yield {
        path: path2,
        cid,
        size: file.size,
        mode: file.unixfs && file.unixfs.mode,
        mtime: file.unixfs && file.unixfs.mtime
      };
    }
  }
  return transformFile2;
}
function preloadFile(preload2, opts) {
  async function* maybePreloadFile(source2) {
    for await (const file of source2) {
      const isRootFile = !file.path || opts.wrapWithDirectory ? file.path === "" : !file.path.includes("/");
      const shouldPreload = isRootFile && !opts.onlyHash && opts.preload !== false;
      if (shouldPreload) {
        preload2(file.cid);
      }
      yield file;
    }
  }
  return maybePreloadFile;
}
function pinFile(repo, opts) {
  async function* maybePinFile(source2) {
    for await (const file of source2) {
      const isRootDir = !(file.path && file.path.includes("/"));
      const shouldPin = (opts.pin == null ? true : opts.pin) && isRootDir && !opts.onlyHash;
      if (shouldPin) {
        await repo.pins.pinRecursively(file.cid);
      }
      yield file;
    }
  }
  return maybePinFile;
}
const hashFn = async function(buf2) {
  return (await murmur3128.encode(buf2)).slice(0, 8).reverse();
};
const addLinksToHamtBucket$1 = (links2, bucket, rootBucket) => {
  return Promise.all(
    links2.map((link) => {
      if (link.Name == null) {
        throw new Error("Unexpected Link without a Name");
      }
      if (link.Name.length === 2) {
        const pos = parseInt(link.Name, 16);
        return bucket._putObjectAt(pos, new Bucket({
          hash: rootBucket._options.hash,
          bits: rootBucket._options.bits
        }, bucket, pos));
      }
      return rootBucket.put(link.Name.substring(2), true);
    })
  );
};
const toPrefix$1 = (position) => {
  return position.toString(16).toUpperCase().padStart(2, "0").substring(0, 2);
};
const toBucketPath$1 = (position) => {
  let bucket = position.bucket;
  const path2 = [];
  while (bucket._parent) {
    path2.push(bucket);
    bucket = bucket._parent;
  }
  path2.push(bucket);
  return path2.reverse();
};
const findShardCid = async (node2, name2, blockstore, context, options) => {
  if (!context) {
    const rootBucket = createHAMT({
      hashFn
    });
    context = {
      rootBucket,
      hamtDepth: 1,
      lastBucket: rootBucket
    };
  }
  await addLinksToHamtBucket$1(node2.Links, context.lastBucket, context.rootBucket);
  const position = await context.rootBucket._findNewBucketAndPos(name2);
  let prefix = toPrefix$1(position.pos);
  const bucketPath = toBucketPath$1(position);
  if (bucketPath.length > context.hamtDepth) {
    context.lastBucket = bucketPath[context.hamtDepth];
    prefix = toPrefix$1(context.lastBucket._posAtParent);
  }
  const link = node2.Links.find((link2) => {
    if (link2.Name == null) {
      return false;
    }
    const entryPrefix = link2.Name.substring(0, 2);
    const entryName = link2.Name.substring(2);
    if (entryPrefix !== prefix) {
      return false;
    }
    if (entryName && entryName !== name2) {
      return false;
    }
    return true;
  });
  if (!link) {
    return null;
  }
  if (link.Name != null && link.Name.substring(2) === name2) {
    return link.Hash;
  }
  context.hamtDepth++;
  const block = await blockstore.get(link.Hash, options);
  node2 = decode$i(block);
  return findShardCid(node2, name2, blockstore, context, options);
};
function extractDataFromBlock(block, blockStart, requestedStart, requestedEnd) {
  const blockLength = block.length;
  const blockEnd = blockStart + blockLength;
  if (requestedStart >= blockEnd || requestedEnd < blockStart) {
    return new Uint8Array(0);
  }
  if (requestedEnd >= blockStart && requestedEnd < blockEnd) {
    block = block.subarray(0, requestedEnd - blockStart);
  }
  if (requestedStart >= blockStart && requestedStart < blockEnd) {
    block = block.subarray(requestedStart - blockStart);
  }
  return block;
}
const validateOffsetAndLength = (size2, offset, length3) => {
  if (!offset) {
    offset = 0;
  }
  if (offset < 0) {
    throw errCode(new Error("Offset must be greater than or equal to 0"), "ERR_INVALID_PARAMS");
  }
  if (offset > size2) {
    throw errCode(new Error("Offset must be less than the file size"), "ERR_INVALID_PARAMS");
  }
  if (!length3 && length3 !== 0) {
    length3 = size2 - offset;
  }
  if (length3 < 0) {
    throw errCode(new Error("Length must be greater than or equal to 0"), "ERR_INVALID_PARAMS");
  }
  if (offset + length3 > size2) {
    length3 = size2 - offset;
  }
  return {
    offset,
    length: length3
  };
};
async function walkDAG(blockstore, node2, queue, streamPosition, start, end2, walkQueue, options) {
  if (node2 instanceof Uint8Array) {
    queue.push(extractDataFromBlock(node2, streamPosition, start, end2));
    return;
  }
  if (node2.Data == null) {
    throw errCode(new Error("no data in PBNode"), "ERR_NOT_UNIXFS");
  }
  let file;
  try {
    file = UnixFS.unmarshal(node2.Data);
  } catch (err2) {
    throw errCode(err2, "ERR_NOT_UNIXFS");
  }
  if (file.data != null) {
    const data = file.data;
    const buf2 = extractDataFromBlock(data, streamPosition, start, end2);
    queue.push(buf2);
    streamPosition += buf2.byteLength;
  }
  const childOps = [];
  for (let i2 = 0; i2 < node2.Links.length; i2++) {
    const childLink = node2.Links[i2];
    const childStart = streamPosition;
    const childEnd = childStart + file.blockSizes[i2];
    if (start >= childStart && start < childEnd || end2 >= childStart && end2 <= childEnd || start < childStart && end2 > childEnd) {
      childOps.push({
        link: childLink,
        blockStart: streamPosition
      });
    }
    streamPosition = childEnd;
    if (streamPosition > end2) {
      break;
    }
  }
  await pipe(
    childOps,
    (source2) => map$3(source2, (op) => {
      return async () => {
        const block = await blockstore.get(op.link.Hash, {
          signal: options.signal
        });
        return {
          ...op,
          block
        };
      };
    }),
    (source2) => parallel$1(source2, {
      ordered: true
    }),
    async (source2) => {
      for await (const { link, block, blockStart } of source2) {
        let child;
        switch (link.Hash.code) {
          case code$8:
            child = decode$i(block);
            break;
          case code$3:
            child = block;
            break;
          default:
            queue.end(errCode(new Error(`Unsupported codec: ${link.Hash.code}`), "ERR_NOT_UNIXFS"));
            return;
        }
        walkQueue.add(async () => {
          await walkDAG(blockstore, child, queue, blockStart, start, end2, walkQueue, options);
        });
      }
    }
  );
}
const fileContent = (cid, node2, unixfs, path2, resolve2, depth, blockstore) => {
  async function* yieldFileContent(options = {}) {
    const fileSize = unixfs.fileSize();
    if (fileSize === void 0) {
      throw new Error("File was a directory");
    }
    const {
      offset,
      length: length3
    } = validateOffsetAndLength(fileSize, options.offset, options.length);
    if (length3 === 0) {
      return;
    }
    const walkQueue = new PQueue({
      concurrency: 1
    });
    const queue = pushable();
    walkQueue.add(async () => {
      await walkDAG(blockstore, node2, queue, 0, offset, offset + length3, walkQueue, options);
    });
    walkQueue.on("error", (error2) => {
      queue.end(error2);
    });
    let read2 = 0;
    for await (const buf2 of queue) {
      if (buf2 == null) {
        continue;
      }
      read2 += buf2.byteLength;
      if (read2 === length3) {
        queue.end();
      }
      yield buf2;
    }
  }
  return yieldFileContent;
};
const directoryContent = (cid, node2, unixfs, path2, resolve2, depth, blockstore) => {
  async function* yieldDirectoryContent(options = {}) {
    const offset = options.offset || 0;
    const length3 = options.length || node2.Links.length;
    const links2 = node2.Links.slice(offset, length3);
    for (const link of links2) {
      const result = await resolve2(link.Hash, link.Name || "", `${path2}/${link.Name || ""}`, [], depth + 1, blockstore, options);
      if (result.entry) {
        yield result.entry;
      }
    }
  }
  return yieldDirectoryContent;
};
const hamtShardedDirectoryContent = (cid, node2, unixfs, path2, resolve2, depth, blockstore) => {
  function yieldHamtDirectoryContent(options = {}) {
    return listDirectory(node2, path2, resolve2, depth, blockstore, options);
  }
  return yieldHamtDirectoryContent;
};
async function* listDirectory(node2, path2, resolve2, depth, blockstore, options) {
  const links2 = node2.Links;
  for (const link of links2) {
    const name2 = link.Name != null ? link.Name.substring(2) : null;
    if (name2) {
      const result = await resolve2(link.Hash, name2, `${path2}/${name2}`, [], depth + 1, blockstore, options);
      yield result.entry;
    } else {
      const block = await blockstore.get(link.Hash);
      node2 = decode$i(block);
      for await (const file of listDirectory(node2, path2, resolve2, depth, blockstore, options)) {
        yield file;
      }
    }
  }
}
const findLinkCid = (node2, name2) => {
  const link = node2.Links.find((link2) => link2.Name === name2);
  return link && link.Hash;
};
const contentExporters = {
  raw: fileContent,
  file: fileContent,
  directory: directoryContent,
  "hamt-sharded-directory": hamtShardedDirectoryContent,
  metadata: (cid, node2, unixfs, path2, resolve2, depth, blockstore) => {
    return () => [];
  },
  symlink: (cid, node2, unixfs, path2, resolve2, depth, blockstore) => {
    return () => [];
  }
};
const unixFsResolver = async (cid, name2, path2, toResolve, resolve2, depth, blockstore, options) => {
  const block = await blockstore.get(cid, options);
  const node2 = decode$i(block);
  let unixfs;
  let next;
  if (!name2) {
    name2 = cid.toString();
  }
  if (node2.Data == null) {
    throw errCode(new Error("no data in PBNode"), "ERR_NOT_UNIXFS");
  }
  try {
    unixfs = UnixFS.unmarshal(node2.Data);
  } catch (err2) {
    throw errCode(err2, "ERR_NOT_UNIXFS");
  }
  if (!path2) {
    path2 = name2;
  }
  if (toResolve.length) {
    let linkCid;
    if (unixfs && unixfs.type === "hamt-sharded-directory") {
      linkCid = await findShardCid(node2, toResolve[0], blockstore);
    } else {
      linkCid = findLinkCid(node2, toResolve[0]);
    }
    if (!linkCid) {
      throw errCode(new Error("file does not exist"), "ERR_NOT_FOUND");
    }
    const nextName = toResolve.shift();
    const nextPath = `${path2}/${nextName}`;
    next = {
      cid: linkCid,
      toResolve,
      name: nextName || "",
      path: nextPath
    };
  }
  return {
    entry: {
      type: unixfs.isDirectory() ? "directory" : "file",
      name: name2,
      path: path2,
      cid,
      content: contentExporters[unixfs.type](cid, node2, unixfs, path2, resolve2, depth, blockstore),
      unixfs,
      depth,
      node: node2,
      size: unixfs.fileSize()
    },
    next
  };
};
const rawContent$1 = (node2) => {
  async function* contentGenerator(options = {}) {
    const {
      offset,
      length: length3
    } = validateOffsetAndLength(node2.length, options.offset, options.length);
    yield extractDataFromBlock(node2, 0, offset, offset + length3);
  }
  return contentGenerator;
};
const resolve$4 = async (cid, name2, path2, toResolve, resolve2, depth, blockstore, options) => {
  if (toResolve.length) {
    throw errCode(new Error(`No link named ${path2} found in raw node ${cid}`), "ERR_NOT_FOUND");
  }
  const block = await blockstore.get(cid, options);
  return {
    entry: {
      type: "raw",
      name: name2,
      path: path2,
      cid,
      content: rawContent$1(block),
      depth,
      size: block.length,
      node: block
    }
  };
};
const resolve$3 = async (cid, name2, path2, toResolve, resolve2, depth, blockstore, options) => {
  const block = await blockstore.get(cid);
  const object = decode$g(block);
  let subObject = object;
  let subPath = path2;
  while (toResolve.length) {
    const prop = toResolve[0];
    if (prop in subObject) {
      toResolve.shift();
      subPath = `${subPath}/${prop}`;
      const subObjectCid = CID.asCID(subObject[prop]);
      if (subObjectCid) {
        return {
          entry: {
            type: "object",
            name: name2,
            path: path2,
            cid,
            node: block,
            depth,
            size: block.length,
            content: async function* () {
              yield object;
            }
          },
          next: {
            cid: subObjectCid,
            name: prop,
            path: subPath,
            toResolve
          }
        };
      }
      subObject = subObject[prop];
    } else {
      throw errCode(new Error(`No property named ${prop} found in cbor node ${cid}`), "ERR_NO_PROP");
    }
  }
  return {
    entry: {
      type: "object",
      name: name2,
      path: path2,
      cid,
      node: block,
      depth,
      size: block.length,
      content: async function* () {
        yield object;
      }
    }
  };
};
const rawContent = (node2) => {
  async function* contentGenerator(options = {}) {
    const {
      offset,
      length: length3
    } = validateOffsetAndLength(node2.length, options.offset, options.length);
    yield extractDataFromBlock(node2, 0, offset, offset + length3);
  }
  return contentGenerator;
};
const resolve$2 = async (cid, name2, path2, toResolve, resolve2, depth, blockstore, options) => {
  if (toResolve.length) {
    throw errCode(new Error(`No link named ${path2} found in raw node ${cid}`), "ERR_NOT_FOUND");
  }
  const buf2 = await decode$j(cid.multihash.bytes);
  return {
    entry: {
      type: "identity",
      name: name2,
      path: path2,
      cid,
      content: rawContent(buf2.digest),
      depth,
      size: buf2.digest.length,
      node: buf2.digest
    }
  };
};
const resolvers = {
  [code$8]: unixFsResolver,
  [code$3]: resolve$4,
  [code$7]: resolve$3,
  [identity$5.code]: resolve$2
};
function resolve$1(cid, name2, path2, toResolve, depth, blockstore, options) {
  const resolver = resolvers[cid.code];
  if (!resolver) {
    throw errCode(new Error(`No resolver for code ${cid.code}`), "ERR_NO_RESOLVER");
  }
  return resolver(cid, name2, path2, toResolve, resolve$1, depth, blockstore, options);
}
const toPathComponents$1 = (path2 = "") => {
  return (path2.trim().match(/([^\\^/]|\\\/)+/g) || []).filter(Boolean);
};
const cidAndRest = (path2) => {
  if (path2 instanceof Uint8Array) {
    return {
      cid: CID.decode(path2),
      toResolve: []
    };
  }
  const cid = CID.asCID(path2);
  if (cid) {
    return {
      cid,
      toResolve: []
    };
  }
  if (typeof path2 === "string") {
    if (path2.indexOf("/ipfs/") === 0) {
      path2 = path2.substring(6);
    }
    const output = toPathComponents$1(path2);
    return {
      cid: CID.parse(output[0]),
      toResolve: output.slice(1)
    };
  }
  throw errCode(new Error(`Unknown path type ${path2}`), "ERR_BAD_PATH");
};
async function* walkPath(path2, blockstore, options = {}) {
  let {
    cid,
    toResolve
  } = cidAndRest(path2);
  let name2 = cid.toString();
  let entryPath = name2;
  const startingDepth = toResolve.length;
  while (true) {
    const result = await resolve$1(cid, name2, entryPath, toResolve, startingDepth, blockstore, options);
    if (!result.entry && !result.next) {
      throw errCode(new Error(`Could not resolve ${path2}`), "ERR_NOT_FOUND");
    }
    if (result.entry) {
      yield result.entry;
    }
    if (!result.next) {
      return;
    }
    toResolve = result.next.toResolve;
    cid = result.next.cid;
    name2 = result.next.name;
    entryPath = result.next.path;
  }
}
async function exporter(path2, blockstore, options = {}) {
  const result = await last(walkPath(path2, blockstore, options));
  if (!result) {
    throw errCode(new Error(`Could not resolve ${path2}`), "ERR_NOT_FOUND");
  }
  return result;
}
async function* recursive(path2, blockstore, options = {}) {
  const node2 = await exporter(path2, blockstore, options);
  if (!node2) {
    return;
  }
  yield node2;
  if (node2.type === "directory") {
    for await (const child of recurse(node2, options)) {
      yield child;
    }
  }
  async function* recurse(node3, options2) {
    for await (const file of node3.content(options2)) {
      yield file;
      if (file instanceof Uint8Array) {
        continue;
      }
      if (file.type === "directory") {
        yield* recurse(file, options2);
      }
    }
  }
}
function createCat$1({ repo, preload: preload2 }) {
  async function* cat(ipfsPath2, options = {}) {
    ipfsPath2 = normalizeCidPath(ipfsPath2);
    if (options.preload !== false) {
      const pathComponents = ipfsPath2.split("/");
      preload2(CID.parse(pathComponents[0]));
    }
    const file = await exporter(ipfsPath2, repo.blocks, options);
    if (file.type === "directory") {
      throw new Error("this dag node is a directory");
    }
    if (!file.content) {
      throw new Error("this dag node has no content");
    }
    yield* file.content(options);
  }
  return withTimeoutOption(cat);
}
function compare$1(a, b2) {
  for (let i2 = 0; i2 < a.byteLength; i2++) {
    if (a[i2] < b2[i2]) {
      return -1;
    }
    if (a[i2] > b2[i2]) {
      return 1;
    }
  }
  if (a.byteLength > b2.byteLength) {
    return 1;
  }
  if (a.byteLength < b2.byteLength) {
    return -1;
  }
  return 0;
}
fromString$3("ustar\0", "binary");
fromString$3("ustar ", "binary");
fromString$3(" \0", "binary");
function reader$1(source2) {
  const reader2 = async function* () {
    let bytes2 = yield;
    let bl = new Uint8ArrayList();
    for await (const chunk of source2) {
      if (bytes2 == null) {
        bl.append(chunk);
        bytes2 = yield bl;
        bl = new Uint8ArrayList();
        continue;
      }
      bl.append(chunk);
      while (bl.length >= bytes2) {
        const data = bl.sublist(0, bytes2);
        bl.consume(bytes2);
        bytes2 = yield data;
        if (bytes2 == null) {
          if (bl.length > 0) {
            bytes2 = yield bl;
            bl = new Uint8ArrayList();
          }
          break;
        }
      }
    }
    if (bytes2 != null) {
      throw Object.assign(new Error(`stream ended before ${bytes2} bytes became available`), { code: "ERR_UNDER_READ", buffer: bl });
    }
  }();
  void reader2.next();
  return reader2;
}
var index_browser = {
  "RTLD_LAZY": 1,
  "RTLD_NOW": 2,
  "RTLD_GLOBAL": 8,
  "RTLD_LOCAL": 4,
  "E2BIG": 7,
  "EACCES": 13,
  "EADDRINUSE": 48,
  "EADDRNOTAVAIL": 49,
  "EAFNOSUPPORT": 47,
  "EAGAIN": 35,
  "EALREADY": 37,
  "EBADF": 9,
  "EBADMSG": 94,
  "EBUSY": 16,
  "ECANCELED": 89,
  "ECHILD": 10,
  "ECONNABORTED": 53,
  "ECONNREFUSED": 61,
  "ECONNRESET": 54,
  "EDEADLK": 11,
  "EDESTADDRREQ": 39,
  "EDOM": 33,
  "EDQUOT": 69,
  "EEXIST": 17,
  "EFAULT": 14,
  "EFBIG": 27,
  "EHOSTUNREACH": 65,
  "EIDRM": 90,
  "EILSEQ": 92,
  "EINPROGRESS": 36,
  "EINTR": 4,
  "EINVAL": 22,
  "EIO": 5,
  "EISCONN": 56,
  "EISDIR": 21,
  "ELOOP": 62,
  "EMFILE": 24,
  "EMLINK": 31,
  "EMSGSIZE": 40,
  "EMULTIHOP": 95,
  "ENAMETOOLONG": 63,
  "ENETDOWN": 50,
  "ENETRESET": 52,
  "ENETUNREACH": 51,
  "ENFILE": 23,
  "ENOBUFS": 55,
  "ENODATA": 96,
  "ENODEV": 19,
  "ENOENT": 2,
  "ENOEXEC": 8,
  "ENOLCK": 77,
  "ENOLINK": 97,
  "ENOMEM": 12,
  "ENOMSG": 91,
  "ENOPROTOOPT": 42,
  "ENOSPC": 28,
  "ENOSR": 98,
  "ENOSTR": 99,
  "ENOSYS": 78,
  "ENOTCONN": 57,
  "ENOTDIR": 20,
  "ENOTEMPTY": 66,
  "ENOTSOCK": 38,
  "ENOTSUP": 45,
  "ENOTTY": 25,
  "ENXIO": 6,
  "EOPNOTSUPP": 102,
  "EOVERFLOW": 84,
  "EPERM": 1,
  "EPIPE": 32,
  "EPROTO": 100,
  "EPROTONOSUPPORT": 43,
  "EPROTOTYPE": 41,
  "ERANGE": 34,
  "EROFS": 30,
  "ESPIPE": 29,
  "ESRCH": 3,
  "ESTALE": 70,
  "ETIME": 101,
  "ETIMEDOUT": 60,
  "ETXTBSY": 26,
  "EWOULDBLOCK": 35,
  "EXDEV": 18,
  "PRIORITY_LOW": 19,
  "PRIORITY_BELOW_NORMAL": 10,
  "PRIORITY_NORMAL": 0,
  "PRIORITY_ABOVE_NORMAL": -7,
  "PRIORITY_HIGH": -14,
  "PRIORITY_HIGHEST": -20,
  "SIGHUP": 1,
  "SIGINT": 2,
  "SIGQUIT": 3,
  "SIGILL": 4,
  "SIGTRAP": 5,
  "SIGABRT": 6,
  "SIGIOT": 6,
  "SIGBUS": 10,
  "SIGFPE": 8,
  "SIGKILL": 9,
  "SIGUSR1": 30,
  "SIGSEGV": 11,
  "SIGUSR2": 31,
  "SIGPIPE": 13,
  "SIGALRM": 14,
  "SIGTERM": 15,
  "SIGCHLD": 20,
  "SIGCONT": 19,
  "SIGSTOP": 17,
  "SIGTSTP": 18,
  "SIGTTIN": 21,
  "SIGTTOU": 22,
  "SIGURG": 16,
  "SIGXCPU": 24,
  "SIGXFSZ": 25,
  "SIGVTALRM": 26,
  "SIGPROF": 27,
  "SIGWINCH": 28,
  "SIGIO": 23,
  "SIGINFO": 29,
  "SIGSYS": 12,
  "UV_FS_SYMLINK_DIR": 1,
  "UV_FS_SYMLINK_JUNCTION": 2,
  "O_RDONLY": 0,
  "O_WRONLY": 1,
  "O_RDWR": 2,
  "UV_DIRENT_UNKNOWN": 0,
  "UV_DIRENT_FILE": 1,
  "UV_DIRENT_DIR": 2,
  "UV_DIRENT_LINK": 3,
  "UV_DIRENT_FIFO": 4,
  "UV_DIRENT_SOCKET": 5,
  "UV_DIRENT_CHAR": 6,
  "UV_DIRENT_BLOCK": 7,
  "S_IFMT": 61440,
  "S_IFREG": 32768,
  "S_IFDIR": 16384,
  "S_IFCHR": 8192,
  "S_IFBLK": 24576,
  "S_IFIFO": 4096,
  "S_IFLNK": 40960,
  "S_IFSOCK": 49152,
  "O_CREAT": 512,
  "O_EXCL": 2048,
  "UV_FS_O_FILEMAP": 0,
  "O_NOCTTY": 131072,
  "O_TRUNC": 1024,
  "O_APPEND": 8,
  "O_DIRECTORY": 1048576,
  "O_NOFOLLOW": 256,
  "O_SYNC": 128,
  "O_DSYNC": 4194304,
  "O_SYMLINK": 2097152,
  "O_NONBLOCK": 4,
  "S_IRWXU": 448,
  "S_IRUSR": 256,
  "S_IWUSR": 128,
  "S_IXUSR": 64,
  "S_IRWXG": 56,
  "S_IRGRP": 32,
  "S_IWGRP": 16,
  "S_IXGRP": 8,
  "S_IRWXO": 7,
  "S_IROTH": 4,
  "S_IWOTH": 2,
  "S_IXOTH": 1,
  "F_OK": 0,
  "R_OK": 4,
  "W_OK": 2,
  "X_OK": 1,
  "UV_FS_COPYFILE_EXCL": 1,
  "COPYFILE_EXCL": 1,
  "UV_FS_COPYFILE_FICLONE": 2,
  "COPYFILE_FICLONE": 2,
  "UV_FS_COPYFILE_FICLONE_FORCE": 4,
  "COPYFILE_FICLONE_FORCE": 4,
  "OPENSSL_VERSION_NUMBER": 269488415,
  "SSL_OP_ALL": 2147485780,
  "SSL_OP_ALLOW_NO_DHE_KEX": 1024,
  "SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION": 262144,
  "SSL_OP_CIPHER_SERVER_PREFERENCE": 4194304,
  "SSL_OP_CISCO_ANYCONNECT": 32768,
  "SSL_OP_COOKIE_EXCHANGE": 8192,
  "SSL_OP_CRYPTOPRO_TLSEXT_BUG": 2147483648,
  "SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS": 2048,
  "SSL_OP_EPHEMERAL_RSA": 0,
  "SSL_OP_LEGACY_SERVER_CONNECT": 4,
  "SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER": 0,
  "SSL_OP_MICROSOFT_SESS_ID_BUG": 0,
  "SSL_OP_MSIE_SSLV2_RSA_PADDING": 0,
  "SSL_OP_NETSCAPE_CA_DN_BUG": 0,
  "SSL_OP_NETSCAPE_CHALLENGE_BUG": 0,
  "SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG": 0,
  "SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG": 0,
  "SSL_OP_NO_COMPRESSION": 131072,
  "SSL_OP_NO_ENCRYPT_THEN_MAC": 524288,
  "SSL_OP_NO_QUERY_MTU": 4096,
  "SSL_OP_NO_RENEGOTIATION": 1073741824,
  "SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION": 65536,
  "SSL_OP_NO_SSLv2": 0,
  "SSL_OP_NO_SSLv3": 33554432,
  "SSL_OP_NO_TICKET": 16384,
  "SSL_OP_NO_TLSv1": 67108864,
  "SSL_OP_NO_TLSv1_1": 268435456,
  "SSL_OP_NO_TLSv1_2": 134217728,
  "SSL_OP_NO_TLSv1_3": 536870912,
  "SSL_OP_PKCS1_CHECK_1": 0,
  "SSL_OP_PKCS1_CHECK_2": 0,
  "SSL_OP_PRIORITIZE_CHACHA": 2097152,
  "SSL_OP_SINGLE_DH_USE": 0,
  "SSL_OP_SINGLE_ECDH_USE": 0,
  "SSL_OP_SSLEAY_080_CLIENT_DH_BUG": 0,
  "SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG": 0,
  "SSL_OP_TLS_BLOCK_PADDING_BUG": 0,
  "SSL_OP_TLS_D5_BUG": 0,
  "SSL_OP_TLS_ROLLBACK_BUG": 8388608,
  "ENGINE_METHOD_RSA": 1,
  "ENGINE_METHOD_DSA": 2,
  "ENGINE_METHOD_DH": 4,
  "ENGINE_METHOD_RAND": 8,
  "ENGINE_METHOD_EC": 2048,
  "ENGINE_METHOD_CIPHERS": 64,
  "ENGINE_METHOD_DIGESTS": 128,
  "ENGINE_METHOD_PKEY_METHS": 512,
  "ENGINE_METHOD_PKEY_ASN1_METHS": 1024,
  "ENGINE_METHOD_ALL": 65535,
  "ENGINE_METHOD_NONE": 0,
  "DH_CHECK_P_NOT_SAFE_PRIME": 2,
  "DH_CHECK_P_NOT_PRIME": 1,
  "DH_UNABLE_TO_CHECK_GENERATOR": 4,
  "DH_NOT_SUITABLE_GENERATOR": 8,
  "ALPN_ENABLED": 1,
  "RSA_PKCS1_PADDING": 1,
  "RSA_SSLV23_PADDING": 2,
  "RSA_NO_PADDING": 3,
  "RSA_PKCS1_OAEP_PADDING": 4,
  "RSA_X931_PADDING": 5,
  "RSA_PKCS1_PSS_PADDING": 6,
  "RSA_PSS_SALTLEN_DIGEST": -1,
  "RSA_PSS_SALTLEN_MAX_SIGN": -2,
  "RSA_PSS_SALTLEN_AUTO": -2,
  "defaultCoreCipherList": "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA",
  "TLS1_VERSION": 769,
  "TLS1_1_VERSION": 770,
  "TLS1_2_VERSION": 771,
  "TLS1_3_VERSION": 772,
  "POINT_CONVERSION_COMPRESSED": 2,
  "POINT_CONVERSION_UNCOMPRESSED": 4,
  "POINT_CONVERSION_HYBRID": 6
};
async function toBuffer(stream2) {
  let buffer2 = new Uint8Array(0);
  for await (const buf2 of stream2) {
    buffer2 = concat$1([buffer2, buf2], buffer2.length + buf2.length);
  }
  return buffer2;
}
const ZEROS = "0000000000000000000";
const SEVENS = "7777777777777777777";
const ZERO_OFFSET = "0".charCodeAt(0);
const USTAR_MAGIC = fromString$3("ustar\0", "binary");
const USTAR_VER = fromString$3("00", "binary");
const MASK = parseInt("7777", 8);
const MAGIC_OFFSET = 257;
const VERSION_OFFSET = 263;
const toTypeflag = function(flag) {
  switch (flag) {
    case "file":
      return 0;
    case "link":
      return 1;
    case "symlink":
      return 2;
    case "character-device":
      return 3;
    case "block-device":
      return 4;
    case "directory":
      return 5;
    case "fifo":
      return 6;
    case "contiguous-file":
      return 7;
    case "pax-header":
      return 72;
    default:
      return 0;
  }
};
const cksum = function(block) {
  let sum = 8 * 32;
  for (let i2 = 0; i2 < 148; i2++)
    sum += block[i2];
  for (let j = 156; j < 512; j++)
    sum += block[j];
  return sum;
};
const encodeOct = function(val, n) {
  const str = val.toString(8);
  if (str.length > n) {
    return fromString$3(SEVENS.slice(0, n) + " ");
  }
  return fromString$3(ZEROS.slice(0, n - str.length) + str + " ");
};
const addLength = function(str) {
  const len2 = fromString$3(str).byteLength;
  let digits = Math.floor(Math.log(len2) / Math.log(10)) + 1;
  if (len2 + digits >= Math.pow(10, digits)) {
    digits++;
  }
  return `${len2 + digits}${str}`;
};
function encodePax$1(opts) {
  let result = "";
  if (opts.name != null) {
    result += addLength(" path=" + opts.name + "\n");
  }
  if (opts.linkname != null) {
    result += addLength(" linkpath=" + opts.linkname + "\n");
  }
  const pax = opts.pax;
  if (pax != null) {
    for (const key in pax) {
      if (Object.prototype.hasOwnProperty.call(pax, key)) {
        result += addLength(" " + key + "=" + pax[key] + "\n");
      }
    }
  }
  return fromString$3(result);
}
function encode$b(opts) {
  const buf2 = new Uint8Array(512);
  let name2 = opts.name;
  let prefix = "";
  if (opts.typeflag === 5 && name2[name2.length - 1] !== "/") {
    name2 += "/";
  }
  if (fromString$3(name2).byteLength !== name2.length) {
    return null;
  }
  while (fromString$3(name2).byteLength > 100) {
    const i2 = name2.indexOf("/");
    if (i2 === -1) {
      return null;
    }
    prefix += prefix !== "" ? "/" + name2.slice(0, i2) : name2.slice(0, i2);
    name2 = name2.slice(i2 + 1);
  }
  if (fromString$3(name2).byteLength > 100 || fromString$3(prefix).byteLength > 155) {
    return null;
  }
  if (opts.linkname != null && fromString$3(opts.linkname).byteLength > 100) {
    return null;
  }
  buf2.set(fromString$3(name2), 0);
  buf2.set(encodeOct(opts.mode & MASK, 6), 100);
  buf2.set(encodeOct(opts.uid, 6), 108);
  buf2.set(encodeOct(opts.gid, 6), 116);
  buf2.set(encodeOct(opts.size, 11), 124);
  buf2.set(encodeOct(opts.mtime.getTime() / 1e3 | 0, 11), 136);
  buf2[156] = ZERO_OFFSET + toTypeflag(opts.type);
  if (opts.linkname != null) {
    buf2.set(fromString$3(opts.linkname), 157);
  }
  buf2.set(USTAR_MAGIC, MAGIC_OFFSET);
  buf2.set(USTAR_VER, VERSION_OFFSET);
  if (opts.uname != null) {
    buf2.set(fromString$3(opts.uname), 265);
  }
  if (opts.gname != null) {
    buf2.set(fromString$3(opts.gname), 297);
  }
  buf2.set(encodeOct(opts.devmajor ?? 0, 6), 329);
  buf2.set(encodeOct(opts.devminor ?? 0, 6), 337);
  if (prefix != null) {
    buf2.set(fromString$3(prefix), 345);
  }
  buf2.set(encodeOct(cksum(buf2), 6), 148);
  return buf2;
}
const { S_IFMT, S_IFBLK, S_IFCHR, S_IFDIR, S_IFIFO, S_IFLNK } = index_browser;
const DMODE = parseInt("755", 8);
const FMODE = parseInt("644", 8);
const END_OF_TAR = new Uint8Array(1024);
function modeToType(mode = 0) {
  switch (mode & S_IFMT) {
    case S_IFBLK:
      return "block-device";
    case S_IFCHR:
      return "character-device";
    case S_IFDIR:
      return "directory";
    case S_IFIFO:
      return "fifo";
    case S_IFLNK:
      return "symlink";
    default:
      return "file";
  }
}
function getPadding(size2) {
  size2 &= 511;
  if (size2 !== 0) {
    return END_OF_TAR.subarray(0, 512 - size2);
  }
  return new Uint8Array(0);
}
function encode$a(header) {
  if (header.pax == null) {
    const encoded = encode$b(header);
    if (encoded != null) {
      return encoded;
    }
  }
  return encodePax(header);
}
function encodePax(header) {
  const paxHeader = encodePax$1(header);
  const newHeader = {
    name: "PaxHeader",
    mode: header.mode,
    uid: header.uid,
    gid: header.gid,
    size: paxHeader.length,
    mtime: header.mtime,
    type: "pax-header",
    linkname: header.linkname,
    uname: header.uname,
    gname: header.gname,
    devmajor: header.devmajor,
    devminor: header.devminor
  };
  return new Uint8ArrayList(encode$b(newHeader) ?? new Uint8Array(0), paxHeader, getPadding(paxHeader.length), encode$b({ ...newHeader, size: header.size, type: header.type }) ?? new Uint8Array(0)).subarray();
}
function pack() {
  return async function* (source2) {
    for await (let { header: partialHeader, body } of source2) {
      const header = {
        ...partialHeader,
        size: partialHeader.type === "symlink" ? 0 : partialHeader.size ?? 0,
        type: partialHeader.type ?? modeToType(partialHeader.mode),
        mode: partialHeader.mode ?? (partialHeader.type === "directory" ? DMODE : FMODE),
        uid: partialHeader.uid ?? 0,
        gid: partialHeader.gid ?? 0,
        mtime: partialHeader.mtime ?? new Date()
      };
      if (typeof body === "string") {
        body = fromString$3(body);
      }
      if (body instanceof Uint8Array || isUint8ArrayList(body)) {
        header.size = body.length;
        yield encode$a(header);
        yield isUint8ArrayList(body) ? body.subarray() : body;
        yield getPadding(header.size);
        continue;
      }
      if (header.type === "symlink" && header.linkname == null) {
        if (body == null) {
          throw new Error("type was symlink but no linkname or body specified");
        }
        header.linkname = toString$5(await toBuffer(body));
        yield encode$a(header);
        continue;
      }
      yield encode$a(header);
      if (header.type !== "file" && header.type !== "contiguous-file") {
        continue;
      }
      let written = 0;
      for await (const chunk of body ?? []) {
        written += chunk.length;
        yield isUint8ArrayList(chunk) ? chunk.subarray() : chunk;
      }
      if (written !== header.size) {
        throw new Error(`size mismatch, wrote ${written} of ${header.size} bytes`);
      }
      yield getPadding(header.size);
    }
    yield END_OF_TAR;
  };
}
/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
const Z_FIXED$1 = 4;
const Z_BINARY = 0;
const Z_TEXT = 1;
const Z_UNKNOWN$1 = 2;
function zero$1(buf2) {
  let len2 = buf2.length;
  while (--len2 >= 0) {
    buf2[len2] = 0;
  }
}
const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES = 2;
const MIN_MATCH$1 = 3;
const MAX_MATCH$1 = 258;
const LENGTH_CODES$1 = 29;
const LITERALS$1 = 256;
const L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
const D_CODES$1 = 30;
const BL_CODES$1 = 19;
const HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
const MAX_BITS$1 = 15;
const Buf_size = 16;
const MAX_BL_BITS = 7;
const END_BLOCK = 256;
const REP_3_6 = 16;
const REPZ_3_10 = 17;
const REPZ_11_138 = 18;
const extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
const extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
const extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
const bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
const DIST_CODE_LEN = 512;
const static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
const static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
const _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
const _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
const base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
const base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
let static_l_desc;
let static_d_desc;
let static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
const d_code = (dist) => {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
const put_short = (s2, w) => {
  s2.pending_buf[s2.pending++] = w & 255;
  s2.pending_buf[s2.pending++] = w >>> 8 & 255;
};
const send_bits = (s2, value2, length3) => {
  if (s2.bi_valid > Buf_size - length3) {
    s2.bi_buf |= value2 << s2.bi_valid & 65535;
    put_short(s2, s2.bi_buf);
    s2.bi_buf = value2 >> Buf_size - s2.bi_valid;
    s2.bi_valid += length3 - Buf_size;
  } else {
    s2.bi_buf |= value2 << s2.bi_valid & 65535;
    s2.bi_valid += length3;
  }
};
const send_code = (s2, c, tree2) => {
  send_bits(s2, tree2[c * 2], tree2[c * 2 + 1]);
};
const bi_reverse = (code2, len2) => {
  let res = 0;
  do {
    res |= code2 & 1;
    code2 >>>= 1;
    res <<= 1;
  } while (--len2 > 0);
  return res >>> 1;
};
const bi_flush = (s2) => {
  if (s2.bi_valid === 16) {
    put_short(s2, s2.bi_buf);
    s2.bi_buf = 0;
    s2.bi_valid = 0;
  } else if (s2.bi_valid >= 8) {
    s2.pending_buf[s2.pending++] = s2.bi_buf & 255;
    s2.bi_buf >>= 8;
    s2.bi_valid -= 8;
  }
};
const gen_bitlen = (s2, desc) => {
  const tree2 = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base3 = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits2;
  let xbits;
  let f;
  let overflow = 0;
  for (bits2 = 0; bits2 <= MAX_BITS$1; bits2++) {
    s2.bl_count[bits2] = 0;
  }
  tree2[s2.heap[s2.heap_max] * 2 + 1] = 0;
  for (h = s2.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s2.heap[h];
    bits2 = tree2[tree2[n * 2 + 1] * 2 + 1] + 1;
    if (bits2 > max_length) {
      bits2 = max_length;
      overflow++;
    }
    tree2[n * 2 + 1] = bits2;
    if (n > max_code) {
      continue;
    }
    s2.bl_count[bits2]++;
    xbits = 0;
    if (n >= base3) {
      xbits = extra[n - base3];
    }
    f = tree2[n * 2];
    s2.opt_len += f * (bits2 + xbits);
    if (has_stree) {
      s2.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits2 = max_length - 1;
    while (s2.bl_count[bits2] === 0) {
      bits2--;
    }
    s2.bl_count[bits2]--;
    s2.bl_count[bits2 + 1] += 2;
    s2.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits2 = max_length; bits2 !== 0; bits2--) {
    n = s2.bl_count[bits2];
    while (n !== 0) {
      m = s2.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree2[m * 2 + 1] !== bits2) {
        s2.opt_len += (bits2 - tree2[m * 2 + 1]) * tree2[m * 2];
        tree2[m * 2 + 1] = bits2;
      }
      n--;
    }
  }
};
const gen_codes = (tree2, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1 + 1);
  let code2 = 0;
  let bits2;
  let n;
  for (bits2 = 1; bits2 <= MAX_BITS$1; bits2++) {
    code2 = code2 + bl_count[bits2 - 1] << 1;
    next_code[bits2] = code2;
  }
  for (n = 0; n <= max_code; n++) {
    let len2 = tree2[n * 2 + 1];
    if (len2 === 0) {
      continue;
    }
    tree2[n * 2] = bi_reverse(next_code[len2]++, len2);
  }
};
const tr_static_init = () => {
  let n;
  let bits2;
  let length3;
  let code2;
  let dist;
  const bl_count = new Array(MAX_BITS$1 + 1);
  length3 = 0;
  for (code2 = 0; code2 < LENGTH_CODES$1 - 1; code2++) {
    base_length[code2] = length3;
    for (n = 0; n < 1 << extra_lbits[code2]; n++) {
      _length_code[length3++] = code2;
    }
  }
  _length_code[length3 - 1] = code2;
  dist = 0;
  for (code2 = 0; code2 < 16; code2++) {
    base_dist[code2] = dist;
    for (n = 0; n < 1 << extra_dbits[code2]; n++) {
      _dist_code[dist++] = code2;
    }
  }
  dist >>= 7;
  for (; code2 < D_CODES$1; code2++) {
    base_dist[code2] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code2] - 7; n++) {
      _dist_code[256 + dist++] = code2;
    }
  }
  for (bits2 = 0; bits2 <= MAX_BITS$1; bits2++) {
    bl_count[bits2] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1] = 5;
    static_dtree[n * 2] = bi_reverse(n, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
const init_block = (s2) => {
  let n;
  for (n = 0; n < L_CODES$1; n++) {
    s2.dyn_ltree[n * 2] = 0;
  }
  for (n = 0; n < D_CODES$1; n++) {
    s2.dyn_dtree[n * 2] = 0;
  }
  for (n = 0; n < BL_CODES$1; n++) {
    s2.bl_tree[n * 2] = 0;
  }
  s2.dyn_ltree[END_BLOCK * 2] = 1;
  s2.opt_len = s2.static_len = 0;
  s2.sym_next = s2.matches = 0;
};
const bi_windup = (s2) => {
  if (s2.bi_valid > 8) {
    put_short(s2, s2.bi_buf);
  } else if (s2.bi_valid > 0) {
    s2.pending_buf[s2.pending++] = s2.bi_buf;
  }
  s2.bi_buf = 0;
  s2.bi_valid = 0;
};
const smaller = (tree2, n, m, depth) => {
  const _n2 = n * 2;
  const _m2 = m * 2;
  return tree2[_n2] < tree2[_m2] || tree2[_n2] === tree2[_m2] && depth[n] <= depth[m];
};
const pqdownheap = (s2, tree2, k) => {
  const v = s2.heap[k];
  let j = k << 1;
  while (j <= s2.heap_len) {
    if (j < s2.heap_len && smaller(tree2, s2.heap[j + 1], s2.heap[j], s2.depth)) {
      j++;
    }
    if (smaller(tree2, v, s2.heap[j], s2.depth)) {
      break;
    }
    s2.heap[k] = s2.heap[j];
    k = j;
    j <<= 1;
  }
  s2.heap[k] = v;
};
const compress_block = (s2, ltree, dtree) => {
  let dist;
  let lc;
  let sx = 0;
  let code2;
  let extra;
  if (s2.sym_next !== 0) {
    do {
      dist = s2.pending_buf[s2.sym_buf + sx++] & 255;
      dist += (s2.pending_buf[s2.sym_buf + sx++] & 255) << 8;
      lc = s2.pending_buf[s2.sym_buf + sx++];
      if (dist === 0) {
        send_code(s2, lc, ltree);
      } else {
        code2 = _length_code[lc];
        send_code(s2, code2 + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code2];
        if (extra !== 0) {
          lc -= base_length[code2];
          send_bits(s2, lc, extra);
        }
        dist--;
        code2 = d_code(dist);
        send_code(s2, code2, dtree);
        extra = extra_dbits[code2];
        if (extra !== 0) {
          dist -= base_dist[code2];
          send_bits(s2, dist, extra);
        }
      }
    } while (sx < s2.sym_next);
  }
  send_code(s2, END_BLOCK, ltree);
};
const build_tree = (s2, desc) => {
  const tree2 = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n, m;
  let max_code = -1;
  let node2;
  s2.heap_len = 0;
  s2.heap_max = HEAP_SIZE$1;
  for (n = 0; n < elems; n++) {
    if (tree2[n * 2] !== 0) {
      s2.heap[++s2.heap_len] = max_code = n;
      s2.depth[n] = 0;
    } else {
      tree2[n * 2 + 1] = 0;
    }
  }
  while (s2.heap_len < 2) {
    node2 = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
    tree2[node2 * 2] = 1;
    s2.depth[node2] = 0;
    s2.opt_len--;
    if (has_stree) {
      s2.static_len -= stree[node2 * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n = s2.heap_len >> 1; n >= 1; n--) {
    pqdownheap(s2, tree2, n);
  }
  node2 = elems;
  do {
    n = s2.heap[1];
    s2.heap[1] = s2.heap[s2.heap_len--];
    pqdownheap(s2, tree2, 1);
    m = s2.heap[1];
    s2.heap[--s2.heap_max] = n;
    s2.heap[--s2.heap_max] = m;
    tree2[node2 * 2] = tree2[n * 2] + tree2[m * 2];
    s2.depth[node2] = (s2.depth[n] >= s2.depth[m] ? s2.depth[n] : s2.depth[m]) + 1;
    tree2[n * 2 + 1] = tree2[m * 2 + 1] = node2;
    s2.heap[1] = node2++;
    pqdownheap(s2, tree2, 1);
  } while (s2.heap_len >= 2);
  s2.heap[--s2.heap_max] = s2.heap[1];
  gen_bitlen(s2, desc);
  gen_codes(tree2, max_code, s2.bl_count);
};
const scan_tree = (s2, tree2, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree2[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree2[(max_code + 1) * 2 + 1] = 65535;
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree2[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s2.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s2.bl_tree[curlen * 2]++;
      }
      s2.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s2.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s2.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
const send_tree = (s2, tree2, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree2[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree2[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s2, curlen, s2.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s2, curlen, s2.bl_tree);
        count--;
      }
      send_code(s2, REP_3_6, s2.bl_tree);
      send_bits(s2, count - 3, 2);
    } else if (count <= 10) {
      send_code(s2, REPZ_3_10, s2.bl_tree);
      send_bits(s2, count - 3, 3);
    } else {
      send_code(s2, REPZ_11_138, s2.bl_tree);
      send_bits(s2, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
const build_bl_tree = (s2) => {
  let max_blindex;
  scan_tree(s2, s2.dyn_ltree, s2.l_desc.max_code);
  scan_tree(s2, s2.dyn_dtree, s2.d_desc.max_code);
  build_tree(s2, s2.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s2.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
const send_all_trees = (s2, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits(s2, lcodes - 257, 5);
  send_bits(s2, dcodes - 1, 5);
  send_bits(s2, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s2, s2.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s2, s2.dyn_ltree, lcodes - 1);
  send_tree(s2, s2.dyn_dtree, dcodes - 1);
};
const detect_data_type = (s2) => {
  let block_mask = 4093624447;
  let n;
  for (n = 0; n <= 31; n++, block_mask >>>= 1) {
    if (block_mask & 1 && s2.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s2.dyn_ltree[9 * 2] !== 0 || s2.dyn_ltree[10 * 2] !== 0 || s2.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s2.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
let static_init_done = false;
const _tr_init$1 = (s2) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s2.l_desc = new TreeDesc(s2.dyn_ltree, static_l_desc);
  s2.d_desc = new TreeDesc(s2.dyn_dtree, static_d_desc);
  s2.bl_desc = new TreeDesc(s2.bl_tree, static_bl_desc);
  s2.bi_buf = 0;
  s2.bi_valid = 0;
  init_block(s2);
};
const _tr_stored_block$1 = (s2, buf2, stored_len, last2) => {
  send_bits(s2, (STORED_BLOCK << 1) + (last2 ? 1 : 0), 3);
  bi_windup(s2);
  put_short(s2, stored_len);
  put_short(s2, ~stored_len);
  if (stored_len) {
    s2.pending_buf.set(s2.window.subarray(buf2, buf2 + stored_len), s2.pending);
  }
  s2.pending += stored_len;
};
const _tr_align$1 = (s2) => {
  send_bits(s2, STATIC_TREES << 1, 3);
  send_code(s2, END_BLOCK, static_ltree);
  bi_flush(s2);
};
const _tr_flush_block$1 = (s2, buf2, stored_len, last2) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s2.level > 0) {
    if (s2.strm.data_type === Z_UNKNOWN$1) {
      s2.strm.data_type = detect_data_type(s2);
    }
    build_tree(s2, s2.l_desc);
    build_tree(s2, s2.d_desc);
    max_blindex = build_bl_tree(s2);
    opt_lenb = s2.opt_len + 3 + 7 >>> 3;
    static_lenb = s2.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf2 !== -1) {
    _tr_stored_block$1(s2, buf2, stored_len, last2);
  } else if (s2.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s2, (STATIC_TREES << 1) + (last2 ? 1 : 0), 3);
    compress_block(s2, static_ltree, static_dtree);
  } else {
    send_bits(s2, (DYN_TREES << 1) + (last2 ? 1 : 0), 3);
    send_all_trees(s2, s2.l_desc.max_code + 1, s2.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s2, s2.dyn_ltree, s2.dyn_dtree);
  }
  init_block(s2);
  if (last2) {
    bi_windup(s2);
  }
};
const _tr_tally$1 = (s2, dist, lc) => {
  s2.pending_buf[s2.sym_buf + s2.sym_next++] = dist;
  s2.pending_buf[s2.sym_buf + s2.sym_next++] = dist >> 8;
  s2.pending_buf[s2.sym_buf + s2.sym_next++] = lc;
  if (dist === 0) {
    s2.dyn_ltree[lc * 2]++;
  } else {
    s2.matches++;
    dist--;
    s2.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s2.dyn_dtree[d_code(dist) * 2]++;
  }
  return s2.sym_next === s2.sym_end;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
const adler32 = (adler, buf2, len2, pos) => {
  let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len2 !== 0) {
    n = len2 > 2e3 ? 2e3 : len2;
    len2 -= n;
    do {
      s1 = s1 + buf2[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
const makeTable = () => {
  let c, table2 = [];
  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table2[n] = c;
  }
  return table2;
};
const crcTable = new Uint32Array(makeTable());
const crc32 = (crc, buf2, len2, pos) => {
  const t = crcTable;
  const end2 = pos + len2;
  crc ^= -1;
  for (let i2 = pos; i2 < end2; i2++) {
    crc = crc >>> 8 ^ t[(crc ^ buf2[i2]) & 255];
  }
  return crc ^ -1;
};
var crc32_1 = crc32;
var messages$1 = {
  2: "need dictionary",
  1: "stream end",
  0: "",
  "-1": "file error",
  "-2": "stream error",
  "-3": "data error",
  "-4": "insufficient memory",
  "-5": "buffer error",
  "-6": "incompatible version"
};
var constants$2 = {
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  Z_BINARY: 0,
  Z_TEXT: 1,
  Z_UNKNOWN: 2,
  Z_DEFLATED: 8
};
const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
const {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;
const MAX_MEM_LEVEL = 9;
const MAX_WBITS$1 = 15;
const DEF_MEM_LEVEL = 8;
const LENGTH_CODES = 29;
const LITERALS = 256;
const L_CODES = LITERALS + 1 + LENGTH_CODES;
const D_CODES = 30;
const BL_CODES = 19;
const HEAP_SIZE = 2 * L_CODES + 1;
const MAX_BITS = 15;
const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
const PRESET_DICT = 32;
const INIT_STATE = 42;
const GZIP_STATE = 57;
const EXTRA_STATE = 69;
const NAME_STATE = 73;
const COMMENT_STATE = 91;
const HCRC_STATE = 103;
const BUSY_STATE = 113;
const FINISH_STATE = 666;
const BS_NEED_MORE = 1;
const BS_BLOCK_DONE = 2;
const BS_FINISH_STARTED = 3;
const BS_FINISH_DONE = 4;
const OS_CODE = 3;
const err = (strm, errorCode) => {
  strm.msg = messages$1[errorCode];
  return errorCode;
};
const rank = (f) => {
  return f * 2 - (f > 4 ? 9 : 0);
};
const zero = (buf2) => {
  let len2 = buf2.length;
  while (--len2 >= 0) {
    buf2[len2] = 0;
  }
};
const slide_hash = (s2) => {
  let n, m;
  let p;
  let wsize = s2.w_size;
  n = s2.hash_size;
  p = n;
  do {
    m = s2.head[--p];
    s2.head[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
  n = wsize;
  p = n;
  do {
    m = s2.prev[--p];
    s2.prev[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
};
let HASH_ZLIB = (s2, prev2, data) => (prev2 << s2.hash_shift ^ data) & s2.hash_mask;
let HASH = HASH_ZLIB;
const flush_pending = (strm) => {
  const s2 = strm.state;
  let len2 = s2.pending;
  if (len2 > strm.avail_out) {
    len2 = strm.avail_out;
  }
  if (len2 === 0) {
    return;
  }
  strm.output.set(s2.pending_buf.subarray(s2.pending_out, s2.pending_out + len2), strm.next_out);
  strm.next_out += len2;
  s2.pending_out += len2;
  strm.total_out += len2;
  strm.avail_out -= len2;
  s2.pending -= len2;
  if (s2.pending === 0) {
    s2.pending_out = 0;
  }
};
const flush_block_only = (s2, last2) => {
  _tr_flush_block(s2, s2.block_start >= 0 ? s2.block_start : -1, s2.strstart - s2.block_start, last2);
  s2.block_start = s2.strstart;
  flush_pending(s2.strm);
};
const put_byte = (s2, b2) => {
  s2.pending_buf[s2.pending++] = b2;
};
const putShortMSB = (s2, b2) => {
  s2.pending_buf[s2.pending++] = b2 >>> 8 & 255;
  s2.pending_buf[s2.pending++] = b2 & 255;
};
const read_buf = (strm, buf2, start, size2) => {
  let len2 = strm.avail_in;
  if (len2 > size2) {
    len2 = size2;
  }
  if (len2 === 0) {
    return 0;
  }
  strm.avail_in -= len2;
  buf2.set(strm.input.subarray(strm.next_in, strm.next_in + len2), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf2, len2, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf2, len2, start);
  }
  strm.next_in += len2;
  strm.total_in += len2;
  return len2;
};
const longest_match = (s2, cur_match) => {
  let chain_length = s2.max_chain_length;
  let scan = s2.strstart;
  let match;
  let len2;
  let best_len = s2.prev_length;
  let nice_match = s2.nice_match;
  const limit = s2.strstart > s2.w_size - MIN_LOOKAHEAD ? s2.strstart - (s2.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s2.window;
  const wmask = s2.w_mask;
  const prev2 = s2.prev;
  const strend = s2.strstart + MAX_MATCH;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s2.prev_length >= s2.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s2.lookahead) {
    nice_match = s2.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len2 = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len2 > best_len) {
      s2.match_start = cur_match;
      best_len = len2;
      if (len2 >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev2[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s2.lookahead) {
    return best_len;
  }
  return s2.lookahead;
};
const fill_window = (s2) => {
  const _w_size = s2.w_size;
  let n, more, str;
  do {
    more = s2.window_size - s2.lookahead - s2.strstart;
    if (s2.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s2.window.set(s2.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s2.match_start -= _w_size;
      s2.strstart -= _w_size;
      s2.block_start -= _w_size;
      if (s2.insert > s2.strstart) {
        s2.insert = s2.strstart;
      }
      slide_hash(s2);
      more += _w_size;
    }
    if (s2.strm.avail_in === 0) {
      break;
    }
    n = read_buf(s2.strm, s2.window, s2.strstart + s2.lookahead, more);
    s2.lookahead += n;
    if (s2.lookahead + s2.insert >= MIN_MATCH) {
      str = s2.strstart - s2.insert;
      s2.ins_h = s2.window[str];
      s2.ins_h = HASH(s2, s2.ins_h, s2.window[str + 1]);
      while (s2.insert) {
        s2.ins_h = HASH(s2, s2.ins_h, s2.window[str + MIN_MATCH - 1]);
        s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
        s2.head[s2.ins_h] = str;
        str++;
        s2.insert--;
        if (s2.lookahead + s2.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s2.lookahead < MIN_LOOKAHEAD && s2.strm.avail_in !== 0);
};
const deflate_stored = (s2, flush2) => {
  let min_block = s2.pending_buf_size - 5 > s2.w_size ? s2.w_size : s2.pending_buf_size - 5;
  let len2, left, have, last2 = 0;
  let used = s2.strm.avail_in;
  do {
    len2 = 65535;
    have = s2.bi_valid + 42 >> 3;
    if (s2.strm.avail_out < have) {
      break;
    }
    have = s2.strm.avail_out - have;
    left = s2.strstart - s2.block_start;
    if (len2 > left + s2.strm.avail_in) {
      len2 = left + s2.strm.avail_in;
    }
    if (len2 > have) {
      len2 = have;
    }
    if (len2 < min_block && (len2 === 0 && flush2 !== Z_FINISH$3 || flush2 === Z_NO_FLUSH$2 || len2 !== left + s2.strm.avail_in)) {
      break;
    }
    last2 = flush2 === Z_FINISH$3 && len2 === left + s2.strm.avail_in ? 1 : 0;
    _tr_stored_block(s2, 0, 0, last2);
    s2.pending_buf[s2.pending - 4] = len2;
    s2.pending_buf[s2.pending - 3] = len2 >> 8;
    s2.pending_buf[s2.pending - 2] = ~len2;
    s2.pending_buf[s2.pending - 1] = ~len2 >> 8;
    flush_pending(s2.strm);
    if (left) {
      if (left > len2) {
        left = len2;
      }
      s2.strm.output.set(s2.window.subarray(s2.block_start, s2.block_start + left), s2.strm.next_out);
      s2.strm.next_out += left;
      s2.strm.avail_out -= left;
      s2.strm.total_out += left;
      s2.block_start += left;
      len2 -= left;
    }
    if (len2) {
      read_buf(s2.strm, s2.strm.output, s2.strm.next_out, len2);
      s2.strm.next_out += len2;
      s2.strm.avail_out -= len2;
      s2.strm.total_out += len2;
    }
  } while (last2 === 0);
  used -= s2.strm.avail_in;
  if (used) {
    if (used >= s2.w_size) {
      s2.matches = 2;
      s2.window.set(s2.strm.input.subarray(s2.strm.next_in - s2.w_size, s2.strm.next_in), 0);
      s2.strstart = s2.w_size;
      s2.insert = s2.strstart;
    } else {
      if (s2.window_size - s2.strstart <= used) {
        s2.strstart -= s2.w_size;
        s2.window.set(s2.window.subarray(s2.w_size, s2.w_size + s2.strstart), 0);
        if (s2.matches < 2) {
          s2.matches++;
        }
        if (s2.insert > s2.strstart) {
          s2.insert = s2.strstart;
        }
      }
      s2.window.set(s2.strm.input.subarray(s2.strm.next_in - used, s2.strm.next_in), s2.strstart);
      s2.strstart += used;
      s2.insert += used > s2.w_size - s2.insert ? s2.w_size - s2.insert : used;
    }
    s2.block_start = s2.strstart;
  }
  if (s2.high_water < s2.strstart) {
    s2.high_water = s2.strstart;
  }
  if (last2) {
    return BS_FINISH_DONE;
  }
  if (flush2 !== Z_NO_FLUSH$2 && flush2 !== Z_FINISH$3 && s2.strm.avail_in === 0 && s2.strstart === s2.block_start) {
    return BS_BLOCK_DONE;
  }
  have = s2.window_size - s2.strstart;
  if (s2.strm.avail_in > have && s2.block_start >= s2.w_size) {
    s2.block_start -= s2.w_size;
    s2.strstart -= s2.w_size;
    s2.window.set(s2.window.subarray(s2.w_size, s2.w_size + s2.strstart), 0);
    if (s2.matches < 2) {
      s2.matches++;
    }
    have += s2.w_size;
    if (s2.insert > s2.strstart) {
      s2.insert = s2.strstart;
    }
  }
  if (have > s2.strm.avail_in) {
    have = s2.strm.avail_in;
  }
  if (have) {
    read_buf(s2.strm, s2.window, s2.strstart, have);
    s2.strstart += have;
    s2.insert += have > s2.w_size - s2.insert ? s2.w_size - s2.insert : have;
  }
  if (s2.high_water < s2.strstart) {
    s2.high_water = s2.strstart;
  }
  have = s2.bi_valid + 42 >> 3;
  have = s2.pending_buf_size - have > 65535 ? 65535 : s2.pending_buf_size - have;
  min_block = have > s2.w_size ? s2.w_size : have;
  left = s2.strstart - s2.block_start;
  if (left >= min_block || (left || flush2 === Z_FINISH$3) && flush2 !== Z_NO_FLUSH$2 && s2.strm.avail_in === 0 && left <= have) {
    len2 = left > have ? have : left;
    last2 = flush2 === Z_FINISH$3 && s2.strm.avail_in === 0 && len2 === left ? 1 : 0;
    _tr_stored_block(s2, s2.block_start, len2, last2);
    s2.block_start += len2;
    flush_pending(s2.strm);
  }
  return last2 ? BS_FINISH_STARTED : BS_NEED_MORE;
};
const deflate_fast = (s2, flush2) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s2.lookahead < MIN_LOOKAHEAD) {
      fill_window(s2);
      if (s2.lookahead < MIN_LOOKAHEAD && flush2 === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s2.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s2.lookahead >= MIN_MATCH) {
      s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
      hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
      s2.head[s2.ins_h] = s2.strstart;
    }
    if (hash_head !== 0 && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
      s2.match_length = longest_match(s2, hash_head);
    }
    if (s2.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s2, s2.strstart - s2.match_start, s2.match_length - MIN_MATCH);
      s2.lookahead -= s2.match_length;
      if (s2.match_length <= s2.max_lazy_match && s2.lookahead >= MIN_MATCH) {
        s2.match_length--;
        do {
          s2.strstart++;
          s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        } while (--s2.match_length !== 0);
        s2.strstart++;
      } else {
        s2.strstart += s2.match_length;
        s2.match_length = 0;
        s2.ins_h = s2.window[s2.strstart];
        s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s2, 0, s2.window[s2.strstart]);
      s2.lookahead--;
      s2.strstart++;
    }
    if (bflush) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
  if (flush2 === Z_FINISH$3) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.sym_next) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_slow = (s2, flush2) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s2.lookahead < MIN_LOOKAHEAD) {
      fill_window(s2);
      if (s2.lookahead < MIN_LOOKAHEAD && flush2 === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s2.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s2.lookahead >= MIN_MATCH) {
      s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
      hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
      s2.head[s2.ins_h] = s2.strstart;
    }
    s2.prev_length = s2.match_length;
    s2.prev_match = s2.match_start;
    s2.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s2.prev_length < s2.max_lazy_match && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
      s2.match_length = longest_match(s2, hash_head);
      if (s2.match_length <= 5 && (s2.strategy === Z_FILTERED || s2.match_length === MIN_MATCH && s2.strstart - s2.match_start > 4096)) {
        s2.match_length = MIN_MATCH - 1;
      }
    }
    if (s2.prev_length >= MIN_MATCH && s2.match_length <= s2.prev_length) {
      max_insert = s2.strstart + s2.lookahead - MIN_MATCH;
      bflush = _tr_tally(s2, s2.strstart - 1 - s2.prev_match, s2.prev_length - MIN_MATCH);
      s2.lookahead -= s2.prev_length - 1;
      s2.prev_length -= 2;
      do {
        if (++s2.strstart <= max_insert) {
          s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
      } while (--s2.prev_length !== 0);
      s2.match_available = 0;
      s2.match_length = MIN_MATCH - 1;
      s2.strstart++;
      if (bflush) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s2.match_available) {
      bflush = _tr_tally(s2, 0, s2.window[s2.strstart - 1]);
      if (bflush) {
        flush_block_only(s2, false);
      }
      s2.strstart++;
      s2.lookahead--;
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s2.match_available = 1;
      s2.strstart++;
      s2.lookahead--;
    }
  }
  if (s2.match_available) {
    bflush = _tr_tally(s2, 0, s2.window[s2.strstart - 1]);
    s2.match_available = 0;
  }
  s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
  if (flush2 === Z_FINISH$3) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.sym_next) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_rle = (s2, flush2) => {
  let bflush;
  let prev2;
  let scan, strend;
  const _win = s2.window;
  for (; ; ) {
    if (s2.lookahead <= MAX_MATCH) {
      fill_window(s2);
      if (s2.lookahead <= MAX_MATCH && flush2 === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s2.lookahead === 0) {
        break;
      }
    }
    s2.match_length = 0;
    if (s2.lookahead >= MIN_MATCH && s2.strstart > 0) {
      scan = s2.strstart - 1;
      prev2 = _win[scan];
      if (prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan]) {
        strend = s2.strstart + MAX_MATCH;
        do {
        } while (prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && scan < strend);
        s2.match_length = MAX_MATCH - (strend - scan);
        if (s2.match_length > s2.lookahead) {
          s2.match_length = s2.lookahead;
        }
      }
    }
    if (s2.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s2, 1, s2.match_length - MIN_MATCH);
      s2.lookahead -= s2.match_length;
      s2.strstart += s2.match_length;
      s2.match_length = 0;
    } else {
      bflush = _tr_tally(s2, 0, s2.window[s2.strstart]);
      s2.lookahead--;
      s2.strstart++;
    }
    if (bflush) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s2.insert = 0;
  if (flush2 === Z_FINISH$3) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.sym_next) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_huff = (s2, flush2) => {
  let bflush;
  for (; ; ) {
    if (s2.lookahead === 0) {
      fill_window(s2);
      if (s2.lookahead === 0) {
        if (flush2 === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s2.match_length = 0;
    bflush = _tr_tally(s2, 0, s2.window[s2.strstart]);
    s2.lookahead--;
    s2.strstart++;
    if (bflush) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s2.insert = 0;
  if (flush2 === Z_FINISH$3) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.sym_next) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
const configuration_table = [
  new Config(0, 0, 0, 0, deflate_stored),
  new Config(4, 4, 8, 4, deflate_fast),
  new Config(4, 5, 16, 8, deflate_fast),
  new Config(4, 6, 32, 32, deflate_fast),
  new Config(4, 4, 16, 16, deflate_slow),
  new Config(8, 16, 32, 32, deflate_slow),
  new Config(8, 16, 128, 128, deflate_slow),
  new Config(8, 32, 128, 256, deflate_slow),
  new Config(32, 128, 258, 1024, deflate_slow),
  new Config(32, 258, 258, 4096, deflate_slow)
];
const lm_init = (s2) => {
  s2.window_size = 2 * s2.w_size;
  zero(s2.head);
  s2.max_lazy_match = configuration_table[s2.level].max_lazy;
  s2.good_match = configuration_table[s2.level].good_length;
  s2.nice_match = configuration_table[s2.level].nice_length;
  s2.max_chain_length = configuration_table[s2.level].max_chain;
  s2.strstart = 0;
  s2.block_start = 0;
  s2.lookahead = 0;
  s2.insert = 0;
  s2.match_length = s2.prev_length = MIN_MATCH - 1;
  s2.match_available = 0;
  s2.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
const deflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const s2 = strm.state;
  if (!s2 || s2.strm !== strm || s2.status !== INIT_STATE && s2.status !== GZIP_STATE && s2.status !== EXTRA_STATE && s2.status !== NAME_STATE && s2.status !== COMMENT_STATE && s2.status !== HCRC_STATE && s2.status !== BUSY_STATE && s2.status !== FINISH_STATE) {
    return 1;
  }
  return 0;
};
const deflateResetKeep = (strm) => {
  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s2 = strm.state;
  s2.pending = 0;
  s2.pending_out = 0;
  if (s2.wrap < 0) {
    s2.wrap = -s2.wrap;
  }
  s2.status = s2.wrap === 2 ? GZIP_STATE : s2.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s2.wrap === 2 ? 0 : 1;
  s2.last_flush = -2;
  _tr_init(s2);
  return Z_OK$3;
};
const deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
const deflateSetHeader = (strm, head) => {
  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};
const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap2 = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap2 = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap2 = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap2 !== 1) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s2 = new DeflateState();
  strm.state = s2;
  s2.strm = strm;
  s2.status = INIT_STATE;
  s2.wrap = wrap2;
  s2.gzhead = null;
  s2.w_bits = windowBits;
  s2.w_size = 1 << s2.w_bits;
  s2.w_mask = s2.w_size - 1;
  s2.hash_bits = memLevel + 7;
  s2.hash_size = 1 << s2.hash_bits;
  s2.hash_mask = s2.hash_size - 1;
  s2.hash_shift = ~~((s2.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s2.window = new Uint8Array(s2.w_size * 2);
  s2.head = new Uint16Array(s2.hash_size);
  s2.prev = new Uint16Array(s2.w_size);
  s2.lit_bufsize = 1 << memLevel + 6;
  s2.pending_buf_size = s2.lit_bufsize * 4;
  s2.pending_buf = new Uint8Array(s2.pending_buf_size);
  s2.sym_buf = s2.lit_bufsize;
  s2.sym_end = (s2.lit_bufsize - 1) * 3;
  s2.level = level;
  s2.strategy = strategy;
  s2.method = method;
  return deflateReset(strm);
};
const deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
const deflate$2 = (strm, flush2) => {
  if (deflateStateCheck(strm) || flush2 > Z_BLOCK$1 || flush2 < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s2 = strm.state;
  if (!strm.output || strm.avail_in !== 0 && !strm.input || s2.status === FINISH_STATE && flush2 !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  const old_flush = s2.last_flush;
  s2.last_flush = flush2;
  if (s2.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s2.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 && rank(flush2) <= rank(old_flush) && flush2 !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s2.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s2.status === INIT_STATE && s2.wrap === 0) {
    s2.status = BUSY_STATE;
  }
  if (s2.status === INIT_STATE) {
    let header = Z_DEFLATED$2 + (s2.w_bits - 8 << 4) << 8;
    let level_flags = -1;
    if (s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2) {
      level_flags = 0;
    } else if (s2.level < 6) {
      level_flags = 1;
    } else if (s2.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= level_flags << 6;
    if (s2.strstart !== 0) {
      header |= PRESET_DICT;
    }
    header += 31 - header % 31;
    putShortMSB(s2, header);
    if (s2.strstart !== 0) {
      putShortMSB(s2, strm.adler >>> 16);
      putShortMSB(s2, strm.adler & 65535);
    }
    strm.adler = 1;
    s2.status = BUSY_STATE;
    flush_pending(strm);
    if (s2.pending !== 0) {
      s2.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (s2.status === GZIP_STATE) {
    strm.adler = 0;
    put_byte(s2, 31);
    put_byte(s2, 139);
    put_byte(s2, 8);
    if (!s2.gzhead) {
      put_byte(s2, 0);
      put_byte(s2, 0);
      put_byte(s2, 0);
      put_byte(s2, 0);
      put_byte(s2, 0);
      put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
      put_byte(s2, OS_CODE);
      s2.status = BUSY_STATE;
      flush_pending(strm);
      if (s2.pending !== 0) {
        s2.last_flush = -1;
        return Z_OK$3;
      }
    } else {
      put_byte(
        s2,
        (s2.gzhead.text ? 1 : 0) + (s2.gzhead.hcrc ? 2 : 0) + (!s2.gzhead.extra ? 0 : 4) + (!s2.gzhead.name ? 0 : 8) + (!s2.gzhead.comment ? 0 : 16)
      );
      put_byte(s2, s2.gzhead.time & 255);
      put_byte(s2, s2.gzhead.time >> 8 & 255);
      put_byte(s2, s2.gzhead.time >> 16 & 255);
      put_byte(s2, s2.gzhead.time >> 24 & 255);
      put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
      put_byte(s2, s2.gzhead.os & 255);
      if (s2.gzhead.extra && s2.gzhead.extra.length) {
        put_byte(s2, s2.gzhead.extra.length & 255);
        put_byte(s2, s2.gzhead.extra.length >> 8 & 255);
      }
      if (s2.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending, 0);
      }
      s2.gzindex = 0;
      s2.status = EXTRA_STATE;
    }
  }
  if (s2.status === EXTRA_STATE) {
    if (s2.gzhead.extra) {
      let beg = s2.pending;
      let left = (s2.gzhead.extra.length & 65535) - s2.gzindex;
      while (s2.pending + left > s2.pending_buf_size) {
        let copy = s2.pending_buf_size - s2.pending;
        s2.pending_buf.set(s2.gzhead.extra.subarray(s2.gzindex, s2.gzindex + copy), s2.pending);
        s2.pending = s2.pending_buf_size;
        if (s2.gzhead.hcrc && s2.pending > beg) {
          strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
        }
        s2.gzindex += copy;
        flush_pending(strm);
        if (s2.pending !== 0) {
          s2.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy;
      }
      let gzhead_extra = new Uint8Array(s2.gzhead.extra);
      s2.pending_buf.set(gzhead_extra.subarray(s2.gzindex, s2.gzindex + left), s2.pending);
      s2.pending += left;
      if (s2.gzhead.hcrc && s2.pending > beg) {
        strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
      }
      s2.gzindex = 0;
    }
    s2.status = NAME_STATE;
  }
  if (s2.status === NAME_STATE) {
    if (s2.gzhead.name) {
      let beg = s2.pending;
      let val;
      do {
        if (s2.pending === s2.pending_buf_size) {
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          flush_pending(strm);
          if (s2.pending !== 0) {
            s2.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s2.gzindex < s2.gzhead.name.length) {
          val = s2.gzhead.name.charCodeAt(s2.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s2, val);
      } while (val !== 0);
      if (s2.gzhead.hcrc && s2.pending > beg) {
        strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
      }
      s2.gzindex = 0;
    }
    s2.status = COMMENT_STATE;
  }
  if (s2.status === COMMENT_STATE) {
    if (s2.gzhead.comment) {
      let beg = s2.pending;
      let val;
      do {
        if (s2.pending === s2.pending_buf_size) {
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          flush_pending(strm);
          if (s2.pending !== 0) {
            s2.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s2.gzindex < s2.gzhead.comment.length) {
          val = s2.gzhead.comment.charCodeAt(s2.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s2, val);
      } while (val !== 0);
      if (s2.gzhead.hcrc && s2.pending > beg) {
        strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
      }
    }
    s2.status = HCRC_STATE;
  }
  if (s2.status === HCRC_STATE) {
    if (s2.gzhead.hcrc) {
      if (s2.pending + 2 > s2.pending_buf_size) {
        flush_pending(strm);
        if (s2.pending !== 0) {
          s2.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s2, strm.adler & 255);
      put_byte(s2, strm.adler >> 8 & 255);
      strm.adler = 0;
    }
    s2.status = BUSY_STATE;
    flush_pending(strm);
    if (s2.pending !== 0) {
      s2.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (strm.avail_in !== 0 || s2.lookahead !== 0 || flush2 !== Z_NO_FLUSH$2 && s2.status !== FINISH_STATE) {
    let bstate = s2.level === 0 ? deflate_stored(s2, flush2) : s2.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s2, flush2) : s2.strategy === Z_RLE ? deflate_rle(s2, flush2) : configuration_table[s2.level].func(s2, flush2);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s2.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s2.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush2 === Z_PARTIAL_FLUSH) {
        _tr_align(s2);
      } else if (flush2 !== Z_BLOCK$1) {
        _tr_stored_block(s2, 0, 0, false);
        if (flush2 === Z_FULL_FLUSH$1) {
          zero(s2.head);
          if (s2.lookahead === 0) {
            s2.strstart = 0;
            s2.block_start = 0;
            s2.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s2.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush2 !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s2.wrap <= 0) {
    return Z_STREAM_END$3;
  }
  if (s2.wrap === 2) {
    put_byte(s2, strm.adler & 255);
    put_byte(s2, strm.adler >> 8 & 255);
    put_byte(s2, strm.adler >> 16 & 255);
    put_byte(s2, strm.adler >> 24 & 255);
    put_byte(s2, strm.total_in & 255);
    put_byte(s2, strm.total_in >> 8 & 255);
    put_byte(s2, strm.total_in >> 16 & 255);
    put_byte(s2, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s2, strm.adler >>> 16);
    putShortMSB(s2, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s2.wrap > 0) {
    s2.wrap = -s2.wrap;
  }
  return s2.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
const deflateEnd = (strm) => {
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
const deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const s2 = strm.state;
  const wrap2 = s2.wrap;
  if (wrap2 === 2 || wrap2 === 1 && s2.status !== INIT_STATE || s2.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap2 === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s2.wrap = 0;
  if (dictLength >= s2.w_size) {
    if (wrap2 === 0) {
      zero(s2.head);
      s2.strstart = 0;
      s2.block_start = 0;
      s2.insert = 0;
    }
    let tmpDict = new Uint8Array(s2.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s2.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s2.w_size;
  }
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s2);
  while (s2.lookahead >= MIN_MATCH) {
    let str = s2.strstart;
    let n = s2.lookahead - (MIN_MATCH - 1);
    do {
      s2.ins_h = HASH(s2, s2.ins_h, s2.window[str + MIN_MATCH - 1]);
      s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
      s2.head[s2.ins_h] = str;
      str++;
    } while (--n);
    s2.strstart = str;
    s2.lookahead = MIN_MATCH - 1;
    fill_window(s2);
  }
  s2.strstart += s2.lookahead;
  s2.block_start = s2.strstart;
  s2.insert = s2.lookahead;
  s2.lookahead = 0;
  s2.match_length = s2.prev_length = MIN_MATCH - 1;
  s2.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s2.wrap = wrap2;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
const _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source2 = sources.shift();
    if (!source2) {
      continue;
    }
    if (typeof source2 !== "object") {
      throw new TypeError(source2 + "must be non-object");
    }
    for (const p in source2) {
      if (_has(source2, p)) {
        obj[p] = source2[p];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks) => {
  let len2 = 0;
  for (let i2 = 0, l = chunks.length; i2 < l; i2++) {
    len2 += chunks[i2].length;
  }
  const result = new Uint8Array(len2);
  for (let i2 = 0, pos = 0, l = chunks.length; i2 < l; i2++) {
    let chunk = chunks[i2];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common$1 = {
  assign,
  flattenChunks
};
let STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
const _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf2, c, c2, m_pos, i2, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  buf2 = new Uint8Array(buf_len);
  for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf2[i2++] = c;
    } else if (c < 2048) {
      buf2[i2++] = 192 | c >>> 6;
      buf2[i2++] = 128 | c & 63;
    } else if (c < 65536) {
      buf2[i2++] = 224 | c >>> 12;
      buf2[i2++] = 128 | c >>> 6 & 63;
      buf2[i2++] = 128 | c & 63;
    } else {
      buf2[i2++] = 240 | c >>> 18;
      buf2[i2++] = 128 | c >>> 12 & 63;
      buf2[i2++] = 128 | c >>> 6 & 63;
      buf2[i2++] = 128 | c & 63;
    }
  }
  return buf2;
};
const buf2binstring = (buf2, len2) => {
  if (len2 < 65534) {
    if (buf2.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf2.length === len2 ? buf2 : buf2.subarray(0, len2));
    }
  }
  let result = "";
  for (let i2 = 0; i2 < len2; i2++) {
    result += String.fromCharCode(buf2[i2]);
  }
  return result;
};
var buf2string = (buf2, max) => {
  const len2 = max || buf2.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf2.subarray(0, max));
  }
  let i2, out;
  const utf16buf = new Array(len2 * 2);
  for (out = 0, i2 = 0; i2 < len2; ) {
    let c = buf2[i2++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    let c_len = _utf8len[c];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i2 += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i2 < len2) {
      c = c << 6 | buf2[i2++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf2, max) => {
  max = max || buf2.length;
  if (max > buf2.length) {
    max = buf2.length;
  }
  let pos = max - 1;
  while (pos >= 0 && (buf2[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf2[pos]] > max ? pos : max;
};
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
const toString$1$1 = Object.prototype.toString;
const {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;
function Deflate$1(options) {
  this.options = common$1.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$2) {
    throw new Error(messages$1[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages$1[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
  if (typeof data === "string") {
    strm.input = strings.string2buf(data);
  } else if (toString$1$1.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = common$1.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages$1[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}
var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var constants$1 = constants$2;
var deflate_1$1 = {
  Deflate: Deflate_1$1,
  deflate: deflate_2,
  deflateRaw: deflateRaw_1$1,
  gzip: gzip_1$1,
  constants: constants$1
};
const BAD$1 = 16209;
const TYPE$1 = 16191;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last2;
  let _out;
  let beg;
  let end2;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits2;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len2;
  let dist;
  let from2;
  let from_source;
  let input, output;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last2 = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end2 = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits2 = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits2 < 15) {
        hold += input[_in++] << bits2;
        bits2 += 8;
        hold += input[_in++] << bits2;
        bits2 += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits2 -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len2 = here & 65535;
            op &= 15;
            if (op) {
              if (bits2 < op) {
                hold += input[_in++] << bits2;
                bits2 += 8;
              }
              len2 += hold & (1 << op) - 1;
              hold >>>= op;
              bits2 -= op;
            }
            if (bits2 < 15) {
              hold += input[_in++] << bits2;
              bits2 += 8;
              hold += input[_in++] << bits2;
              bits2 += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits2 -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits2 < op) {
                    hold += input[_in++] << bits2;
                    bits2 += 8;
                    if (bits2 < op) {
                      hold += input[_in++] << bits2;
                      bits2 += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits2 -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from2 = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from2 += wsize - op;
                      if (op < len2) {
                        len2 -= op;
                        do {
                          output[_out++] = s_window[from2++];
                        } while (--op);
                        from2 = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from2 += wsize + wnext - op;
                      op -= wnext;
                      if (op < len2) {
                        len2 -= op;
                        do {
                          output[_out++] = s_window[from2++];
                        } while (--op);
                        from2 = 0;
                        if (wnext < len2) {
                          op = wnext;
                          len2 -= op;
                          do {
                            output[_out++] = s_window[from2++];
                          } while (--op);
                          from2 = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from2 += wnext - op;
                      if (op < len2) {
                        len2 -= op;
                        do {
                          output[_out++] = s_window[from2++];
                        } while (--op);
                        from2 = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len2 > 2) {
                      output[_out++] = from_source[from2++];
                      output[_out++] = from_source[from2++];
                      output[_out++] = from_source[from2++];
                      len2 -= 3;
                    }
                    if (len2) {
                      output[_out++] = from_source[from2++];
                      if (len2 > 1) {
                        output[_out++] = from_source[from2++];
                      }
                    }
                  } else {
                    from2 = _out - dist;
                    do {
                      output[_out++] = output[from2++];
                      output[_out++] = output[from2++];
                      output[_out++] = output[from2++];
                      len2 -= 3;
                    } while (len2 > 2);
                    if (len2) {
                      output[_out++] = output[from2++];
                      if (len2 > 1) {
                        output[_out++] = output[from2++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last2 && _out < end2);
  len2 = bits2 >> 3;
  _in -= len2;
  bits2 -= len2 << 3;
  hold &= (1 << bits2) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last2 ? 5 + (last2 - _in) : 5 - (_in - last2);
  strm.avail_out = _out < end2 ? 257 + (end2 - _out) : 257 - (_out - end2);
  state.hold = hold;
  state.bits = bits2;
  return;
};
const MAXBITS = 15;
const ENOUGH_LENS$1 = 852;
const ENOUGH_DISTS$1 = 592;
const CODES$1 = 0;
const LENS$1 = 1;
const DISTS$1 = 2;
const lbase = new Uint16Array([
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
const lext = new Uint8Array([
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
const dbase = new Uint16Array([
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
const dext = new Uint8Array([
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
const inflate_table = (type, lens, lens_index, codes2, table2, table_index, work, opts) => {
  const bits2 = opts.bits;
  let len2 = 0;
  let sym = 0;
  let min = 0, max = 0;
  let root = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask;
  let next;
  let base3 = null;
  let match;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let here_bits, here_op, here_val;
  for (len2 = 0; len2 <= MAXBITS; len2++) {
    count[len2] = 0;
  }
  for (sym = 0; sym < codes2; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits2;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {
    table2[table_index++] = 1 << 24 | 64 << 16 | 0;
    table2[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }
  left = 1;
  for (len2 = 1; len2 <= MAXBITS; len2++) {
    left <<= 1;
    left -= count[len2];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES$1 || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len2 = 1; len2 < MAXBITS; len2++) {
    offs[len2 + 1] = offs[len2] + count[len2];
  }
  for (sym = 0; sym < codes2; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$1) {
    base3 = extra = work;
    match = 20;
  } else if (type === LENS$1) {
    base3 = lbase;
    extra = lext;
    match = 257;
  } else {
    base3 = dbase;
    extra = dext;
    match = 0;
  }
  huff = 0;
  sym = 0;
  len2 = min;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len2 - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base3[work[sym] - match];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len2 - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table2[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len2 - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len2] === 0) {
      if (len2 === max) {
        break;
      }
      len2 = lens[lens_index + work[sym]];
    }
    if (len2 > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min;
      curr = len2 - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table2[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table2[next + huff] = len2 - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var inftrees = inflate_table;
const CODES = 0;
const LENS = 1;
const DISTS = 2;
const {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;
const HEAD = 16180;
const FLAGS = 16181;
const TIME = 16182;
const OS = 16183;
const EXLEN = 16184;
const EXTRA = 16185;
const NAME = 16186;
const COMMENT = 16187;
const HCRC = 16188;
const DICTID = 16189;
const DICT = 16190;
const TYPE = 16191;
const TYPEDO = 16192;
const STORED = 16193;
const COPY_ = 16194;
const COPY = 16195;
const TABLE = 16196;
const LENLENS = 16197;
const CODELENS = 16198;
const LEN_ = 16199;
const LEN = 16200;
const LENEXT = 16201;
const DIST = 16202;
const DISTEXT = 16203;
const MATCH = 16204;
const LIT = 16205;
const CHECK = 16206;
const LENGTH = 16207;
const DONE = 16208;
const BAD = 16209;
const MEM = 16210;
const SYNC = 16211;
const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
const MAX_WBITS = 15;
const DEF_WBITS = MAX_WBITS;
const zswap32 = (q) => {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
};
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
const inflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};
const inflateResetKeep = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
};
const inflateReset = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
const inflateReset2 = (strm, windowBits) => {
  let wrap2;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap2 = 0;
    windowBits = -windowBits;
  } else {
    wrap2 = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap2;
  state.wbits = windowBits;
  return inflateReset(strm);
};
const inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState();
  strm.state = state;
  state.strm = strm;
  state.window = null;
  state.mode = HEAD;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
const inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
let virgin = true;
let lenfix, distfix;
const fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
const updatewindow = (strm, src2, end2, copy) => {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy >= state.wsize) {
    state.window.set(src2.subarray(end2 - state.wsize, end2), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    state.window.set(src2.subarray(end2 - copy, end2 - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      state.window.set(src2.subarray(end2 - copy, end2), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
const inflate$2 = (strm, flush2) => {
  let state;
  let input, output;
  let next;
  let put;
  let have, left;
  let hold;
  let bits2;
  let _in, _out;
  let copy;
  let from2;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len2;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n;
  const order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits2 = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits2 < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            if (state.wbits === 0) {
              state.wbits = 15;
            }
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits2 = 0;
            state.mode = FLAGS;
            break;
          }
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits2 -= 4;
          len2 = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len2;
          }
          if (len2 > 15 || len2 > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << state.wbits;
          state.flags = 0;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits2 = 0;
          break;
        case FLAGS:
          while (bits2 < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits2 = 0;
          state.mode = TIME;
        case TIME:
          while (bits2 < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits2 = 0;
          state.mode = OS;
        case OS:
          while (bits2 < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits2 = 0;
          state.mode = EXLEN;
        case EXLEN:
          if (state.flags & 1024) {
            while (bits2 < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits2 = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        case EXTRA:
          if (state.flags & 1024) {
            copy = state.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state.head) {
                len2 = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next,
                    next + copy
                  ),
                  len2
                );
              }
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              state.length -= copy;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len2 = input[next + copy++];
              if (state.head && len2 && state.length < 65536) {
                state.head.name += String.fromCharCode(len2);
              }
            } while (len2 && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len2) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len2 = input[next + copy++];
              if (state.head && len2 && state.length < 65536) {
                state.head.comment += String.fromCharCode(len2);
              }
            } while (len2 && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len2) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        case HCRC:
          if (state.flags & 512) {
            while (bits2 < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            if (state.wrap & 4 && hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits2 = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits2 < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits2 = 0;
          state.mode = DICT;
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits2;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        case TYPE:
          if (flush2 === Z_BLOCK || flush2 === Z_TREES) {
            break inf_leave;
          }
        case TYPEDO:
          if (state.last) {
            hold >>>= bits2 & 7;
            bits2 -= bits2 & 7;
            state.mode = CHECK;
            break;
          }
          while (bits2 < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits2 -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush2 === Z_TREES) {
                hold >>>= 2;
                bits2 -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits2 -= 2;
          break;
        case STORED:
          hold >>>= bits2 & 7;
          bits2 -= bits2 & 7;
          while (bits2 < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits2 = 0;
          state.mode = COPY_;
          if (flush2 === Z_TREES) {
            break inf_leave;
          }
        case COPY_:
          state.mode = COPY;
        case COPY:
          copy = state.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            output.set(input.subarray(next, next + copy), put);
            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits2 < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits2 -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits2 -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits2 -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits2 < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits2 -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits2) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits2 -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits2 < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits2;
                  bits2 += 8;
                }
                hold >>>= here_bits;
                bits2 -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len2 = state.lens[state.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits2 -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits2 < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits2;
                  bits2 += 8;
                }
                hold >>>= here_bits;
                bits2 -= here_bits;
                len2 = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits2 -= 3;
              } else {
                n = here_bits + 7;
                while (bits2 < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits2;
                  bits2 += 8;
                }
                hold >>>= here_bits;
                bits2 -= here_bits;
                len2 = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits2 -= 7;
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len2;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush2 === Z_TREES) {
            break inf_leave;
          }
        case LEN_:
          state.mode = LEN;
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits2;
            inffast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits2 = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits2) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits2) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            hold >>>= last_bits;
            bits2 -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits2 -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        case LENEXT:
          if (state.extra) {
            n = state.extra;
            while (bits2 < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits2 -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits2) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits2) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            hold >>>= last_bits;
            bits2 -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits2 -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        case DISTEXT:
          if (state.extra) {
            n = state.extra;
            while (bits2 < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits2 -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH;
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state.offset > copy) {
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from2 = state.wsize - copy;
            } else {
              from2 = state.wnext - copy;
            }
            if (copy > state.length) {
              copy = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from2 = put - state.offset;
            copy = state.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state.length -= copy;
          do {
            output[put++] = from_source[from2++];
          } while (--copy);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits2 < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits2;
              bits2 += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap & 4 && _out) {
              strm.adler = state.check = state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
            }
            _out = left;
            if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits2 = 0;
          }
          state.mode = LENGTH;
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits2 < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits2 = 0;
          }
          state.mode = DONE;
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits2;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush2 !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
      ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap & 4 && _out) {
    strm.adler = state.check = state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush2 === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
const inflateEnd = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
const inflateGetHeader = (strm, head) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1;
};
const inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
const toString$3 = Object.prototype.toString;
const {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(options) {
  this.options = common$1.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(messages$1[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString$3.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages$1[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended)
    return false;
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString$3.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail)
            strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0)
      continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common$1.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);
  if (inflator.err)
    throw inflator.msg || messages$1[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants = constants$2;
var inflate_1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2,
  inflateRaw: inflateRaw_1$1,
  ungzip: ungzip$1,
  constants
};
const { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;
const { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
var Deflate_1 = Deflate;
var deflate_1 = deflate;
var deflateRaw_1 = deflateRaw;
var gzip_1 = gzip;
var Inflate_1 = Inflate;
var inflate_1 = inflate;
var inflateRaw_1 = inflateRaw;
var ungzip_1 = ungzip;
var constants_1 = constants$2;
var pako = {
  Deflate: Deflate_1,
  deflate: deflate_1,
  deflateRaw: deflateRaw_1,
  gzip: gzip_1,
  Inflate: Inflate_1,
  inflate: inflate_1,
  inflateRaw: inflateRaw_1,
  ungzip: ungzip_1,
  constants: constants_1
};
const DEFAULT_COMPRESSION_LEVEL = 6;
function createGet$8({ repo, preload: preload2 }) {
  async function* get3(ipfsPath2, options = {}) {
    if (options.compressionLevel != null && (options.compressionLevel < -1 || options.compressionLevel > 9)) {
      throw errCode(new Error("Compression level must be between -1 and 9"), "ERR_INVALID_PARAMS");
    }
    if (options.preload !== false) {
      let pathComponents;
      try {
        pathComponents = normalizeCidPath(ipfsPath2).split("/");
      } catch (err2) {
        throw errCode(err2, "ERR_INVALID_PATH");
      }
      preload2(CID.parse(pathComponents[0]));
    }
    const ipfsPathOrCid = CID.asCID(ipfsPath2) || ipfsPath2;
    const file = await exporter(ipfsPathOrCid, repo.blocks, options);
    if (file.type === "file" || file.type === "raw") {
      const args = [];
      if (!options.compress || options.archive === true) {
        args.push(
          [{
            header: {
              name: file.path,
              mode: file.type === "file" && file.unixfs.mode,
              mtime: file.type === "file" && file.unixfs.mtime ? new Date(file.unixfs.mtime.secs * 1e3) : void 0,
              size: file.size,
              type: "file"
            },
            body: file.content()
          }],
          pack()
        );
      } else {
        args.push(
          file.content
        );
      }
      if (options.compress) {
        args.push(
          async function* (source2) {
            const buf2 = await toBuffer(source2);
            yield pako.gzip(buf2, {
              level: options.compressionLevel || DEFAULT_COMPRESSION_LEVEL
            });
          }
        );
      }
      yield* pipe(...args);
      return;
    }
    if (file.type === "directory") {
      const args = [
        recursive(ipfsPathOrCid, repo.blocks, options),
        async function* (source2) {
          for await (const entry of source2) {
            const output = {
              header: {
                name: entry.path,
                size: entry.size
              }
            };
            if (entry.type === "file") {
              output.header.type = "file";
              output.header.mode = entry.unixfs.mode != null ? entry.unixfs.mode : void 0;
              output.header.mtime = entry.unixfs.mtime ? new Date(entry.unixfs.mtime.secs * 1e3) : void 0;
              output.body = entry.content();
            } else if (entry.type === "raw") {
              output.header.type = "file";
              output.body = entry.content();
            } else if (entry.type === "directory") {
              output.header.type = "directory";
              output.header.mode = entry.unixfs.mode != null ? entry.unixfs.mode : void 0;
              output.header.mtime = entry.unixfs.mtime ? new Date(entry.unixfs.mtime.secs * 1e3) : void 0;
            } else {
              throw errCode(new Error("Not a UnixFS node"), "ERR_NOT_UNIXFS");
            }
            yield output;
          }
        },
        pack()
      ];
      if (options.compress) {
        if (!options.archive) {
          throw errCode(new Error("file is not regular"), "ERR_INVALID_PATH");
        }
        if (options.compress) {
          args.push(
            async function* (source2) {
              const buf2 = await toBuffer(source2);
              yield pako.gzip(buf2, {
                level: options.compressionLevel || DEFAULT_COMPRESSION_LEVEL
              });
            }
          );
        }
      }
      yield* pipe(...args);
      return;
    }
    throw errCode(new Error("Not a UnixFS node"), "ERR_NOT_UNIXFS");
  }
  return withTimeoutOption(get3);
}
function createLs$8({ repo, preload: preload2 }) {
  async function* ls(ipfsPath2, options = {}) {
    const legacyPath = normalizeCidPath(ipfsPath2);
    const pathComponents = legacyPath.split("/");
    if (options.preload !== false) {
      preload2(CID.parse(pathComponents[0]));
    }
    const ipfsPathOrCid = CID.asCID(legacyPath) || legacyPath;
    const file = await exporter(ipfsPathOrCid, repo.blocks, options);
    if (file.type === "file") {
      yield mapFile(file);
      return;
    }
    if (file.type === "directory") {
      for await (const child of file.content()) {
        yield mapFile(child);
      }
      return;
    }
    throw errCode(new Error(`Unknown UnixFS type ${file.type}`), "ERR_UNKNOWN_UNIXFS_TYPE");
  }
  return withTimeoutOption(ls);
}
class RootAPI {
  constructor({ preload: preload2, repo, hashers, options }) {
    const addAll = createAddAll$2({
      preload: preload2,
      repo,
      options,
      hashers
    });
    this.addAll = addAll;
    this.add = createAdd$5({ addAll });
    this.cat = createCat$1({ repo, preload: preload2 });
    this.get = createGet$8({ repo, preload: preload2 });
    this.ls = createLs$8({ repo, preload: preload2 });
  }
}
const ipfsCore = "0.17.0";
const commit = "e8b7b66bfa98c2a1c0d0bfc19f698d7d00b6c888";
const interfaceIpfsCore = "^0.157.0";
function createVersion$3({ repo }) {
  async function version2(_options = {}) {
    const repoVersion2 = await repo.version.get();
    return {
      version: ipfsCore,
      commit,
      repo: `${repoVersion2}`,
      "ipfs-core": ipfsCore,
      "interface-ipfs-core": interfaceIpfsCore
    };
  }
  return withTimeoutOption(version2);
}
const log$1p = logger$1("ipfs:components:id");
function createId$1({ peerId, network }) {
  async function id(options = {}) {
    const net = network.try();
    if (!net) {
      if (options.peerId) {
        throw new NotStartedError();
      }
      if (peerId.publicKey == null) {
        throw errCode(new Error("Public key missing"), "ERR_MISSING_PUBLIC_KEY");
      }
      return {
        id: peerId,
        publicKey: toString$5(peerId.publicKey, "base64pad"),
        addresses: [],
        agentVersion: `js-ipfs/${ipfsCore}`,
        protocolVersion: "9000",
        protocols: []
      };
    }
    const { libp2p } = net;
    const peerIdToId = options.peerId ? options.peerId : peerId;
    const peer = await findPeer(peerIdToId, libp2p, options);
    const agentVersion = toString$5(peer.metadata.get("AgentVersion") || new Uint8Array());
    const protocolVersion = toString$5(peer.metadata.get("ProtocolVersion") || new Uint8Array());
    const idStr = peer.id.toString();
    const publicKeyStr = peer.publicKey ? toString$5(peer.publicKey, "base64pad") : "";
    return {
      id: peerIdToId,
      publicKey: publicKeyStr,
      addresses: (peer.addresses || []).map((ma) => {
        const str = ma.toString();
        if (str.endsWith(`/p2p/${idStr}`)) {
          return str;
        }
        return `${str}/p2p/${idStr}`;
      }).sort().map((ma) => multiaddr(ma)),
      agentVersion,
      protocolVersion,
      protocols: (peer.protocols || []).sort()
    };
  }
  return withTimeoutOption(id);
}
async function findPeer(peerId, libp2p, options) {
  let peer = await libp2p.peerStore.get(peerId);
  if (!peer) {
    peer = await findPeerOnDht(peerId, libp2p, options);
  }
  let publicKey = peerId.publicKey ? peerId.publicKey : await libp2p.peerStore.keyBook.get(peerId);
  if (publicKey == null) {
    try {
      publicKey = await libp2p.getPublicKey(peerId, options);
    } catch (err2) {
      log$1p.error("Could not load public key for", peerId.toString(), err2);
    }
  }
  return {
    ...peer,
    publicKey,
    metadata: peer.metadata || /* @__PURE__ */ new Map(),
    addresses: peer.addresses.map((addr) => addr.multiaddr)
  };
}
async function findPeerOnDht(peerId, libp2p, options) {
  if (libp2p.dht == null) {
    throw errCode(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
  }
  for await (const event of libp2p.dht.findPeer(peerId, options)) {
    if (event.name === "FINAL_PEER") {
      break;
    }
  }
  const peer = await libp2p.peerStore.get(peerId);
  if (!peer) {
    throw errCode(new Error("Could not find peer"), "ERR_NOT_FOUND");
  }
  return peer;
}
var objectSafeSet = set;
function set(obj, propsArg, value2) {
  var props, lastProp;
  if (Array.isArray(propsArg)) {
    props = propsArg.slice(0);
  }
  if (typeof propsArg == "string") {
    props = propsArg.split(".");
  }
  if (typeof propsArg == "symbol") {
    props = [propsArg];
  }
  if (!Array.isArray(props)) {
    throw new Error("props arg must be an array, a string or a symbol");
  }
  lastProp = props.pop();
  if (!lastProp) {
    return false;
  }
  prototypeCheck(lastProp);
  var thisProp;
  while (thisProp = props.shift()) {
    prototypeCheck(thisProp);
    if (typeof obj[thisProp] == "undefined") {
      obj[thisProp] = {};
    }
    obj = obj[thisProp];
    if (!obj || typeof obj != "object") {
      return false;
    }
  }
  obj[lastProp] = value2;
  return true;
}
function prototypeCheck(prop) {
  if (prop == "__proto__" || prop == "constructor" || prop == "prototype") {
    throw new Error("setting of prototype values not supported");
  }
}
const profiles = {
  server: {
    description: "Recommended for nodes with public IPv4 address (servers, VPSes, etc.), disables host and content discovery and UPnP in local networks.",
    transform: (config2) => {
      objectSafeSet(config2, "Discovery.MDNS.Enabled", false);
      objectSafeSet(config2, "Discovery.webRTCStar.Enabled", false);
      config2.Swarm = {
        ...config2.Swarm || {},
        DisableNatPortMap: true
      };
      return config2;
    }
  },
  "local-discovery": {
    description: "Sets default values to fields affected by `server` profile, enables discovery and UPnP in local networks.",
    transform: (config2) => {
      objectSafeSet(config2, "Discovery.MDNS.Enabled", true);
      objectSafeSet(config2, "Discovery.webRTCStar.Enabled", true);
      objectSafeSet(config2, "Swarm", {
        ...config2.Swarm || {},
        DisableNatPortMap: false
      });
      return config2;
    }
  },
  test: {
    description: "Reduces external interference, useful for running ipfs in test environments. Note that with these settings node won't be able to talk to the rest of the network without manual bootstrap.",
    transform: (config2) => {
      const defaultConfig = getDefaultConfig();
      objectSafeSet(config2, "Addresses.API", defaultConfig.Addresses.API ? "/ip4/127.0.0.1/tcp/0" : "");
      objectSafeSet(config2, "Addresses.Gateway", defaultConfig.Addresses.Gateway ? "/ip4/127.0.0.1/tcp/0" : "");
      objectSafeSet(config2, "Addresses.Swarm", defaultConfig.Addresses.Swarm.length ? ["/ip4/127.0.0.1/tcp/0"] : []);
      objectSafeSet(config2, "Addresses.Delegates", []);
      objectSafeSet(config2, "Bootstrap", []);
      objectSafeSet(config2, "Discovery.MDNS.Enabled", false);
      objectSafeSet(config2, "Discovery.webRTCStar.Enabled", false);
      objectSafeSet(config2, "Swarm", {
        ...config2.Swarm || {},
        DisableNatPortMap: true
      });
      return config2;
    }
  },
  "default-networking": {
    description: "Restores default network settings. Inverse profile of the `test` profile.",
    transform: (config2) => {
      const defaultConfig = getDefaultConfig();
      objectSafeSet(config2, "Addresses.API", defaultConfig.Addresses.API);
      objectSafeSet(config2, "Addresses.Gateway", defaultConfig.Addresses.Gateway);
      objectSafeSet(config2, "Addresses.Swarm", defaultConfig.Addresses.Swarm);
      objectSafeSet(config2, "Addresses.Delegates", defaultConfig.Addresses.Delegates);
      objectSafeSet(config2, "Bootstrap", defaultConfig.Bootstrap);
      objectSafeSet(config2, "Discovery.MDNS.Enabled", defaultConfig.Discovery.MDNS.Enabled);
      objectSafeSet(config2, "Discovery.webRTCStar.Enabled", defaultConfig.Discovery.webRTCStar.Enabled);
      objectSafeSet(config2, "Swarm", {
        ...config2.Swarm || {},
        DisableNatPortMap: false
      });
      return config2;
    }
  },
  lowpower: {
    description: "Reduces daemon overhead on the system. May affect node functionality,performance of content discovery and data fetching may be degraded. Recommended for low power systems.",
    transform: (config2) => {
      const Swarm = config2.Swarm || {};
      const ConnMgr = Swarm.ConnMgr || {};
      ConnMgr.LowWater = 20;
      ConnMgr.HighWater = 40;
      Swarm.ConnMgr = ConnMgr;
      config2.Swarm = Swarm;
      return config2;
    }
  },
  "default-power": {
    description: 'Inverse of "lowpower" profile.',
    transform: (config2) => {
      const defaultConfig = getDefaultConfig();
      config2.Swarm = defaultConfig.Swarm;
      return config2;
    }
  }
};
const log$1o = logger$1("ipfs:core:config");
function createConfig$1({ repo }) {
  return {
    getAll: withTimeoutOption(getAll),
    get: withTimeoutOption(get3),
    set: withTimeoutOption(set2),
    replace: withTimeoutOption(replace),
    profiles: {
      apply: withTimeoutOption(applyProfile),
      list: withTimeoutOption(listProfiles)
    }
  };
  async function getAll(options = {}) {
    return repo.config.getAll(options);
  }
  async function get3(key, options) {
    if (!key) {
      return Promise.reject(new Error("key argument is required"));
    }
    return repo.config.get(key, options);
  }
  async function set2(key, value2, options) {
    return repo.config.set(key, value2, options);
  }
  async function replace(value2, options) {
    return repo.config.replace(value2, options);
  }
  async function applyProfile(profileName, options = { dryRun: false }) {
    const { dryRun } = options;
    const profile = profiles[profileName];
    if (!profile) {
      throw new Error(`No profile with name '${profileName}' exists`);
    }
    try {
      const oldCfg = await repo.config.getAll(options);
      let newCfg = JSON.parse(JSON.stringify(oldCfg));
      newCfg = profile.transform(newCfg);
      if (!dryRun) {
        await repo.config.replace(newCfg, options);
      }
      delete oldCfg.Identity.PrivKey;
      delete newCfg.Identity.PrivKey;
      return { original: oldCfg, updated: newCfg };
    } catch (err2) {
      log$1o(err2);
      throw new Error(`Could not apply profile '${profileName}' to config: ${err2.message}`);
    }
  }
}
async function listProfiles(_options) {
  return Object.keys(profiles).map((name2) => ({
    name: name2,
    description: profiles[name2].description
  }));
}
function readonly({ enumerable = true, configurable = false } = {}) {
  return { enumerable, configurable, writable: false };
}
function* linksWithin(path2, value2) {
  if (value2 != null && typeof value2 === "object") {
    if (Array.isArray(value2)) {
      for (const [index, element] of value2.entries()) {
        const elementPath = [...path2, index];
        const cid = CID.asCID(element);
        if (cid) {
          yield [elementPath.join("/"), cid];
        } else if (typeof element === "object") {
          yield* links(element, elementPath);
        }
      }
    } else {
      const cid = CID.asCID(value2);
      if (cid) {
        yield [path2.join("/"), cid];
      } else {
        yield* links(value2, path2);
      }
    }
  }
}
function* links(source2, base3) {
  if (source2 == null || source2 instanceof Uint8Array) {
    return;
  }
  for (const [key, value2] of Object.entries(source2)) {
    const path2 = [...base3, key];
    yield* linksWithin(path2, value2);
  }
}
function* treeWithin(path2, value2) {
  if (Array.isArray(value2)) {
    for (const [index, element] of value2.entries()) {
      const elementPath = [...path2, index];
      yield elementPath.join("/");
      if (typeof element === "object" && !CID.asCID(element)) {
        yield* tree(element, elementPath);
      }
    }
  } else {
    yield* tree(value2, path2);
  }
}
function* tree(source2, base3) {
  if (source2 == null || typeof source2 !== "object") {
    return;
  }
  for (const [key, value2] of Object.entries(source2)) {
    const path2 = [...base3, key];
    yield path2.join("/");
    if (value2 != null && !(value2 instanceof Uint8Array) && typeof value2 === "object" && !CID.asCID(value2)) {
      yield* treeWithin(path2, value2);
    }
  }
}
function get$1(source2, path2) {
  let node2 = source2;
  for (const [index, key] of path2.entries()) {
    node2 = node2[key];
    if (node2 == null) {
      throw new Error(`Object has no property at ${path2.slice(0, index + 1).map((part) => `[${JSON.stringify(part)}]`).join("")}`);
    }
    const cid = CID.asCID(node2);
    if (cid) {
      return { value: cid, remaining: path2.slice(index + 1).join("/") };
    }
  }
  return { value: node2 };
}
class Block {
  constructor({ cid, bytes: bytes2, value: value2 }) {
    if (!cid || !bytes2 || typeof value2 === "undefined") {
      throw new Error("Missing required argument");
    }
    this.cid = cid;
    this.bytes = bytes2;
    this.value = value2;
    this.asBlock = this;
    Object.defineProperties(this, {
      cid: readonly(),
      bytes: readonly(),
      value: readonly(),
      asBlock: readonly()
    });
  }
  links() {
    return links(this.value, []);
  }
  tree() {
    return tree(this.value, []);
  }
  get(path2 = "/") {
    return get$1(this.value, path2.split("/").filter(Boolean));
  }
}
function createUnsafe({ bytes: bytes2, cid, value: maybeValue, codec }) {
  const value2 = maybeValue !== void 0 ? maybeValue : codec && codec.decode(bytes2);
  if (value2 === void 0)
    throw new Error('Missing required argument, must either provide "value" or "codec"');
  return new Block({
    cid,
    bytes: bytes2,
    value: value2
  });
}
function createHeader(roots2) {
  const headerBytes = encode$m({ version: 1, roots: roots2 });
  const varintBytes = varint$3.encode(headerBytes.length);
  const header = new Uint8Array(varintBytes.length + headerBytes.length);
  header.set(varintBytes, 0);
  header.set(headerBytes, varintBytes.length);
  return header;
}
function createEncoder(writer2) {
  return {
    async setRoots(roots2) {
      const bytes2 = createHeader(roots2);
      await writer2.write(bytes2);
    },
    async writeBlock(block) {
      const { cid, bytes: bytes2 } = block;
      await writer2.write(new Uint8Array(varint$3.encode(cid.bytes.length + bytes2.length)));
      await writer2.write(cid.bytes);
      if (bytes2.length) {
        await writer2.write(bytes2);
      }
    },
    async close() {
      await writer2.end();
    }
  };
}
function noop$5() {
}
function create$4() {
  const chunkQueue = [];
  let drainer = null;
  let drainerResolver = noop$5;
  let ended = false;
  let outWait = null;
  let outWaitResolver = noop$5;
  const makeDrainer = () => {
    if (!drainer) {
      drainer = new Promise((resolve2) => {
        drainerResolver = () => {
          drainer = null;
          drainerResolver = noop$5;
          resolve2();
        };
      });
    }
    return drainer;
  };
  const writer2 = {
    write(chunk) {
      chunkQueue.push(chunk);
      const drainer2 = makeDrainer();
      outWaitResolver();
      return drainer2;
    },
    async end() {
      ended = true;
      const drainer2 = makeDrainer();
      outWaitResolver();
      await drainer2;
    }
  };
  const iterator2 = {
    async next() {
      const chunk = chunkQueue.shift();
      if (chunk) {
        if (chunkQueue.length === 0) {
          drainerResolver();
        }
        return { done: false, value: chunk };
      }
      if (ended) {
        drainerResolver();
        return { done: true, value: void 0 };
      }
      if (!outWait) {
        outWait = new Promise((resolve2) => {
          outWaitResolver = () => {
            outWait = null;
            outWaitResolver = noop$5;
            return resolve2(iterator2.next());
          };
        });
      }
      return outWait;
    }
  };
  return { writer: writer2, iterator: iterator2 };
}
const Kinds = {
  Null: (obj) => obj === null,
  Int: (obj) => Number.isInteger(obj),
  Float: (obj) => typeof obj === "number" && Number.isFinite(obj),
  String: (obj) => typeof obj === "string",
  Bool: (obj) => typeof obj === "boolean",
  Bytes: (obj) => obj instanceof Uint8Array,
  Link: (obj) => !Kinds.Null(obj) && typeof obj === "object" && obj.asCID === obj,
  List: (obj) => Array.isArray(obj),
  Map: (obj) => !Kinds.Null(obj) && typeof obj === "object" && obj.asCID !== obj && !Kinds.List(obj) && !Kinds.Bytes(obj)
};
const Types = {
  Int: Kinds.Int,
  "CarHeader > version": (obj) => Types.Int(obj),
  "CarHeader > roots (anon) > valueType (anon)": Kinds.Link,
  "CarHeader > roots (anon)": (obj) => Kinds.List(obj) && Array.prototype.every.call(obj, Types["CarHeader > roots (anon) > valueType (anon)"]),
  "CarHeader > roots": (obj) => Types["CarHeader > roots (anon)"](obj),
  CarHeader: (obj) => {
    const keys = obj && Object.keys(obj);
    return Kinds.Map(obj) && ["version"].every((k) => keys.includes(k)) && Object.entries(obj).every(([name2, value2]) => Types["CarHeader > " + name2] && Types["CarHeader > " + name2](value2));
  }
};
const CarHeader = Types.CarHeader;
const CIDV0_BYTES = {
  SHA2_256: 18,
  LENGTH: 32,
  DAG_PB: 112
};
const V2_HEADER_LENGTH = 16 + 8 + 8 + 8;
async function readVarint(reader2) {
  const bytes2 = await reader2.upTo(8);
  if (!bytes2.length) {
    throw new Error("Unexpected end of data");
  }
  const i2 = varint$3.decode(bytes2);
  reader2.seek(varint$3.decode.bytes);
  return i2;
}
async function readV2Header(reader2) {
  const bytes2 = await reader2.exactly(V2_HEADER_LENGTH);
  const dv = new DataView(bytes2.buffer, bytes2.byteOffset, bytes2.byteLength);
  let offset = 0;
  const header = {
    version: 2,
    characteristics: [
      dv.getBigUint64(offset, true),
      dv.getBigUint64(offset += 8, true)
    ],
    dataOffset: Number(dv.getBigUint64(offset += 8, true)),
    dataSize: Number(dv.getBigUint64(offset += 8, true)),
    indexOffset: Number(dv.getBigUint64(offset += 8, true))
  };
  reader2.seek(V2_HEADER_LENGTH);
  return header;
}
async function readHeader$1(reader2, strictVersion) {
  const length3 = await readVarint(reader2);
  if (length3 === 0) {
    throw new Error("Invalid CAR header (zero length)");
  }
  const header = await reader2.exactly(length3);
  reader2.seek(length3);
  const block = decode$g(header);
  if (!CarHeader(block)) {
    throw new Error("Invalid CAR header format");
  }
  if (block.version !== 1 && block.version !== 2 || strictVersion !== void 0 && block.version !== strictVersion) {
    throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== void 0 ? ` (expected ${strictVersion})` : ""}`);
  }
  const hasRoots = Array.isArray(block.roots);
  if (block.version === 1 && !hasRoots || block.version === 2 && hasRoots) {
    throw new Error("Invalid CAR header format");
  }
  if (block.version === 1) {
    return block;
  }
  const v2Header = await readV2Header(reader2);
  reader2.seek(v2Header.dataOffset - reader2.pos);
  const v1Header = await readHeader$1(reader2, 1);
  return Object.assign(v1Header, v2Header);
}
async function readMultihash(reader2) {
  const bytes2 = await reader2.upTo(8);
  varint$3.decode(bytes2);
  const codeLength = varint$3.decode.bytes;
  const length3 = varint$3.decode(bytes2.subarray(varint$3.decode.bytes));
  const lengthLength = varint$3.decode.bytes;
  const mhLength = codeLength + lengthLength + length3;
  const multihash = await reader2.exactly(mhLength);
  reader2.seek(mhLength);
  return multihash;
}
async function readCid(reader2) {
  const first2 = await reader2.exactly(2);
  if (first2[0] === CIDV0_BYTES.SHA2_256 && first2[1] === CIDV0_BYTES.LENGTH) {
    const bytes3 = await reader2.exactly(34);
    reader2.seek(34);
    const multihash2 = decode$j(bytes3);
    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash2);
  }
  const version2 = await readVarint(reader2);
  if (version2 !== 1) {
    throw new Error(`Unexpected CID version (${version2})`);
  }
  const codec = await readVarint(reader2);
  const bytes2 = await readMultihash(reader2);
  const multihash = decode$j(bytes2);
  return CID.create(version2, codec, multihash);
}
async function readBlockHead(reader2) {
  const start = reader2.pos;
  let length3 = await readVarint(reader2);
  if (length3 === 0) {
    throw new Error("Invalid CAR section (zero length)");
  }
  length3 += reader2.pos - start;
  const cid = await readCid(reader2);
  const blockLength = length3 - Number(reader2.pos - start);
  return { cid, length: length3, blockLength };
}
async function readBlock(reader2) {
  const { cid, blockLength } = await readBlockHead(reader2);
  const bytes2 = await reader2.exactly(blockLength);
  reader2.seek(blockLength);
  return { bytes: bytes2, cid };
}
async function readBlockIndex(reader2) {
  const offset = reader2.pos;
  const { cid, length: length3, blockLength } = await readBlockHead(reader2);
  const index = { cid, length: length3, blockLength, offset, blockOffset: reader2.pos };
  reader2.seek(index.blockLength);
  return index;
}
function createDecoder(reader2) {
  const headerPromise = (async () => {
    const header = await readHeader$1(reader2);
    if (header.version === 2) {
      const v1length = reader2.pos - header.dataOffset;
      reader2 = limitReader(reader2, header.dataSize - v1length);
    }
    return header;
  })();
  return {
    header: () => headerPromise,
    async *blocks() {
      await headerPromise;
      while ((await reader2.upTo(8)).length > 0) {
        yield await readBlock(reader2);
      }
    },
    async *blocksIndex() {
      await headerPromise;
      while ((await reader2.upTo(8)).length > 0) {
        yield await readBlockIndex(reader2);
      }
    }
  };
}
function bytesReader(bytes2) {
  let pos = 0;
  return {
    async upTo(length3) {
      return bytes2.subarray(pos, pos + Math.min(length3, bytes2.length - pos));
    },
    async exactly(length3) {
      if (length3 > bytes2.length - pos) {
        throw new Error("Unexpected end of data");
      }
      return bytes2.subarray(pos, pos + length3);
    },
    seek(length3) {
      pos += length3;
    },
    get pos() {
      return pos;
    }
  };
}
function chunkReader(readChunk) {
  let pos = 0;
  let have = 0;
  let offset = 0;
  let currentChunk = new Uint8Array(0);
  const read2 = async (length3) => {
    have = currentChunk.length - offset;
    const bufa = [currentChunk.subarray(offset)];
    while (have < length3) {
      const chunk = await readChunk();
      if (chunk == null) {
        break;
      }
      if (have < 0) {
        if (chunk.length > have) {
          bufa.push(chunk.subarray(-have));
        }
      } else {
        bufa.push(chunk);
      }
      have += chunk.length;
    }
    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));
    let off2 = 0;
    for (const b2 of bufa) {
      currentChunk.set(b2, off2);
      off2 += b2.length;
    }
    offset = 0;
  };
  return {
    async upTo(length3) {
      if (currentChunk.length - offset < length3) {
        await read2(length3);
      }
      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length3));
    },
    async exactly(length3) {
      if (currentChunk.length - offset < length3) {
        await read2(length3);
      }
      if (currentChunk.length - offset < length3) {
        throw new Error("Unexpected end of data");
      }
      return currentChunk.subarray(offset, offset + length3);
    },
    seek(length3) {
      pos += length3;
      offset += length3;
    },
    get pos() {
      return pos;
    }
  };
}
function asyncIterableReader(asyncIterable) {
  const iterator2 = asyncIterable[Symbol.asyncIterator]();
  async function readChunk() {
    const next = await iterator2.next();
    if (next.done) {
      return null;
    }
    return next.value;
  }
  return chunkReader(readChunk);
}
function limitReader(reader2, byteLimit) {
  let bytesRead = 0;
  return {
    async upTo(length3) {
      let bytes2 = await reader2.upTo(length3);
      if (bytes2.length + bytesRead > byteLimit) {
        bytes2 = bytes2.subarray(0, byteLimit - bytesRead);
      }
      return bytes2;
    },
    async exactly(length3) {
      const bytes2 = await reader2.exactly(length3);
      if (bytes2.length + bytesRead > byteLimit) {
        throw new Error("Unexpected end of data");
      }
      return bytes2;
    },
    seek(length3) {
      bytesRead += length3;
      reader2.seek(length3);
    },
    get pos() {
      return reader2.pos;
    }
  };
}
class CarWriter {
  constructor(roots2, encoder2) {
    this._encoder = encoder2;
    this._mutex = encoder2.setRoots(roots2);
    this._ended = false;
  }
  async put(block) {
    if (!(block.bytes instanceof Uint8Array) || !block.cid) {
      throw new TypeError("Can only write {cid, bytes} objects");
    }
    if (this._ended) {
      throw new Error("Already closed");
    }
    const cid = CID.asCID(block.cid);
    if (!cid) {
      throw new TypeError("Can only write {cid, bytes} objects");
    }
    this._mutex = this._mutex.then(() => this._encoder.writeBlock({ cid, bytes: block.bytes }));
    return this._mutex;
  }
  async close() {
    if (this._ended) {
      throw new Error("Already closed");
    }
    await this._mutex;
    this._ended = true;
    return this._encoder.close();
  }
  static create(roots2) {
    roots2 = toRoots(roots2);
    const { encoder: encoder2, iterator: iterator2 } = encodeWriter();
    const writer2 = new CarWriter(roots2, encoder2);
    const out = new CarWriterOut(iterator2);
    return { writer: writer2, out };
  }
  static createAppender() {
    const { encoder: encoder2, iterator: iterator2 } = encodeWriter();
    encoder2.setRoots = () => Promise.resolve();
    const writer2 = new CarWriter([], encoder2);
    const out = new CarWriterOut(iterator2);
    return { writer: writer2, out };
  }
  static async updateRootsInBytes(bytes2, roots2) {
    const reader2 = bytesReader(bytes2);
    await readHeader$1(reader2);
    const newHeader = createHeader(roots2);
    if (Number(reader2.pos) !== newHeader.length) {
      throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${reader2.pos} bytes, new header is ${newHeader.length} bytes)`);
    }
    bytes2.set(newHeader, 0);
    return bytes2;
  }
}
class CarWriterOut {
  constructor(iterator2) {
    this._iterator = iterator2;
  }
  [Symbol.asyncIterator]() {
    if (this._iterating) {
      throw new Error("Multiple iterator not supported");
    }
    this._iterating = true;
    return this._iterator;
  }
}
function encodeWriter() {
  const iw = create$4();
  const { writer: writer2, iterator: iterator2 } = iw;
  const encoder2 = createEncoder(writer2);
  return { encoder: encoder2, iterator: iterator2 };
}
function toRoots(roots2) {
  if (roots2 === void 0) {
    return [];
  }
  if (!Array.isArray(roots2)) {
    const cid = CID.asCID(roots2);
    if (!cid) {
      throw new TypeError("roots must be a single CID or an array of CIDs");
    }
    return [cid];
  }
  const _roots = [];
  for (const root of roots2) {
    const _root = CID.asCID(root);
    if (!_root) {
      throw new TypeError("roots must be a single CID or an array of CIDs");
    }
    _roots.push(_root);
  }
  return _roots;
}
const walk = async ({ cid, load, seen }) => {
  seen = seen || /* @__PURE__ */ new Set();
  const b58Cid = cid.toString(base58btc$1);
  if (seen.has(b58Cid)) {
    return;
  }
  const block = await load(cid);
  seen.add(b58Cid);
  if (block === null) {
    return;
  }
  for (const [, cid2] of block.links()) {
    await walk({ cid: cid2, load, seen });
  }
};
const log$1n = logger$1("ipfs:components:dag:import");
const NO_LINKS_CODECS = [
  code$3,
  code$2
];
function createExport$3({ repo, preload: preload2, codecs: codecs2 }) {
  async function* dagExport(root, options = {}) {
    if (options.preload !== false) {
      preload2(root);
    }
    const cid = CID.asCID(root);
    if (!cid) {
      throw new Error(`Unexpected error converting CID type: ${root}`);
    }
    log$1n(`Exporting ${cid} as car`);
    const { writer: writer2, out } = await CarWriter.create([cid]);
    let err2 = null;
    (async () => {
      try {
        const load = makeLoader(repo, writer2, {
          signal: options.signal,
          timeout: options.timeout
        }, codecs2);
        await walk({ cid, load });
      } catch (e) {
        err2 = e;
      } finally {
        writer2.close();
      }
    })();
    for await (const chunk of out) {
      if (err2) {
        break;
      }
      yield chunk;
    }
    if (err2) {
      throw err2;
    }
  }
  return withTimeoutOption(dagExport);
}
function makeLoader(repo, writer2, options, codecs2) {
  return async (cid) => {
    const codec = await codecs2.getCodec(cid.code);
    if (!codec) {
      throw new Error(`Can't decode links in block with codec 0x${cid.code.toString(16)} to form complete DAG`);
    }
    const bytes2 = await repo.blocks.get(cid, options);
    log$1n(`Adding block ${cid} to car`);
    await writer2.put({ cid, bytes: bytes2 });
    if (NO_LINKS_CODECS.includes(cid.code)) {
      return null;
    }
    return createUnsafe({ bytes: bytes2, cid, codec });
  };
}
async function first$1(source2) {
  for await (const entry of source2) {
    return entry;
  }
  return void 0;
}
function createGet$7({ codecs: codecs2, repo, preload: preload2 }) {
  const get3 = async function get4(cid, options = {}) {
    if (options.preload !== false) {
      preload2(cid);
    }
    if (options.path) {
      const entry = options.localResolve ? await first$1(resolve$5(cid, options.path, codecs2, repo, options)) : await last(resolve$5(cid, options.path, codecs2, repo, options));
      const result = entry;
      if (!result) {
        throw errCode(new Error("Not found"), "ERR_NOT_FOUND");
      }
      return result;
    }
    const codec = await codecs2.getCodec(cid.code);
    const block = await repo.blocks.get(cid, options);
    const node2 = codec.decode(block);
    return {
      value: node2,
      remainderPath: ""
    };
  };
  return withTimeoutOption(get3);
}
class CarIteratorBase {
  constructor(version2, roots2, iterable) {
    this._version = version2;
    this._roots = roots2;
    this._iterable = iterable;
    this._decoded = false;
  }
  get version() {
    return this._version;
  }
  async getRoots() {
    return this._roots;
  }
}
class CarBlockIterator extends CarIteratorBase {
  [Symbol.asyncIterator]() {
    if (this._decoded) {
      throw new Error("Cannot decode more than once");
    }
    if (!this._iterable) {
      throw new Error("Block iterable not found");
    }
    this._decoded = true;
    return this._iterable[Symbol.asyncIterator]();
  }
  static async fromBytes(bytes2) {
    const { version: version2, roots: roots2, iterator: iterator2 } = await fromBytes(bytes2);
    return new CarBlockIterator(version2, roots2, iterator2);
  }
  static async fromIterable(asyncIterable) {
    const { version: version2, roots: roots2, iterator: iterator2 } = await fromIterable(asyncIterable);
    return new CarBlockIterator(version2, roots2, iterator2);
  }
}
async function fromBytes(bytes2) {
  if (!(bytes2 instanceof Uint8Array)) {
    throw new TypeError("fromBytes() requires a Uint8Array");
  }
  return decodeIterator(bytesReader(bytes2));
}
async function fromIterable(asyncIterable) {
  if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === "function")) {
    throw new TypeError("fromIterable() requires an async iterable");
  }
  return decodeIterator(asyncIterableReader(asyncIterable));
}
async function decodeIterator(reader2) {
  const decoder = createDecoder(reader2);
  const { version: version2, roots: roots2 } = await decoder.header();
  return { version: version2, roots: roots2, iterator: decoder.blocks() };
}
const log$1m = logger$1("ipfs:components:dag:import");
function createImport$3({ repo }) {
  async function* dagImport(sources, options = {}) {
    const release = await repo.gcLock.readLock();
    try {
      const abortOptions = { signal: options.signal, timeout: options.timeout };
      const peekable = peekableIterator(sources);
      const { value: value2, done } = await peekable.peek();
      if (done) {
        return;
      }
      if (value2) {
        peekable.push(value2);
      }
      let cars;
      if (value2 instanceof Uint8Array) {
        cars = [peekable];
      } else {
        cars = peekable;
      }
      for await (const car of cars) {
        const roots2 = await importCar(repo, abortOptions, car);
        if (options.pinRoots !== false) {
          for (const cid of roots2) {
            let pinErrorMsg = "";
            try {
              if (await repo.blocks.has(cid)) {
                log$1m(`Pinning root ${cid}`);
                await repo.pins.pinRecursively(cid);
              } else {
                pinErrorMsg = "blockstore: block not found";
              }
            } catch (err2) {
              pinErrorMsg = err2.message;
            }
            yield { root: { cid, pinErrorMsg } };
          }
        }
      }
    } finally {
      release();
    }
  }
  return withTimeoutOption(dagImport);
}
async function importCar(repo, options, source2) {
  const reader2 = await CarBlockIterator.fromIterable(source2);
  const roots2 = await reader2.getRoots();
  await drain(
    repo.blocks.putMany(
      map$3(reader2, ({ cid: key, bytes: value2 }) => {
        log$1m(`Import block ${key}`);
        return { key, value: value2 };
      }),
      { signal: options.signal }
    )
  );
  return roots2;
}
function createPut$5({ repo, codecs: codecs2, hashers, preload: preload2 }) {
  async function put(dagNode, options = {}) {
    const release = options.pin ? await repo.gcLock.readLock() : null;
    try {
      const storeCodec = await codecs2.getCodec(options.storeCodec || "dag-cbor");
      if (!storeCodec) {
        throw new Error(`Unknown storeCodec ${options.storeCodec}, please configure additional BlockCodecs for this IPFS instance`);
      }
      if (options.inputCodec) {
        if (!(dagNode instanceof Uint8Array)) {
          throw new Error("Can only inputCodec on raw bytes that can be decoded");
        }
        const inputCodec = await codecs2.getCodec(options.inputCodec);
        if (!inputCodec) {
          throw new Error(`Unknown inputCodec ${options.inputCodec}, please configure additional BlockCodecs for this IPFS instance`);
        }
        dagNode = inputCodec.decode(dagNode);
      }
      const cidVersion = options.version != null ? options.version : 1;
      const hasher = await hashers.getHasher(options.hashAlg || "sha2-256");
      if (!hasher) {
        throw new Error(`Unknown hash algorithm ${options.hashAlg}, please configure additional MultihashHashers for this IPFS instance`);
      }
      const buf2 = storeCodec.encode(dagNode);
      const hash2 = await hasher.digest(buf2);
      const cid = CID.create(cidVersion, storeCodec.code, hash2);
      await repo.blocks.put(cid, buf2, {
        signal: options.signal
      });
      if (options.pin) {
        await repo.pins.pinRecursively(cid);
      }
      if (options.preload !== false) {
        preload2(cid);
      }
      return cid;
    } finally {
      if (release) {
        release();
      }
    }
  }
  return withTimeoutOption(put);
}
function createResolve$3({ repo, codecs: codecs2, preload: preload2 }) {
  async function dagResolve(ipfsPath2, options = {}) {
    const {
      cid
    } = toCidAndPath(ipfsPath2);
    if (options.preload !== false) {
      preload2(cid);
    }
    return resolvePath$1(repo, codecs2, ipfsPath2, options);
  }
  return withTimeoutOption(dagResolve);
}
class DagAPI {
  constructor({ repo, codecs: codecs2, hashers, preload: preload2 }) {
    this.export = createExport$3({ repo, preload: preload2, codecs: codecs2 });
    this.get = createGet$7({ codecs: codecs2, repo, preload: preload2 });
    this.import = createImport$3({ repo });
    this.resolve = createResolve$3({ repo, codecs: codecs2, preload: preload2 });
    this.put = createPut$5({ repo, codecs: codecs2, hashers, preload: preload2 });
  }
}
const reduceValue = (_, v) => v;
const tcpUri = (str, port, parts2, opts) => {
  if (opts != null && opts.assumeHttp === false)
    return `tcp://${str}:${port}`;
  let protocol2 = "tcp";
  let explicitPort = `:${port}`;
  const last2 = parts2[parts2.length - 1];
  if (last2.protocol === "tcp") {
    protocol2 = port === "443" ? "https" : "http";
    explicitPort = port === "443" || port === "80" ? "" : explicitPort;
  }
  return `${protocol2}://${str}${explicitPort}`;
};
const Reducers = {
  ip4: reduceValue,
  ip6: (str, content, i2, parts2) => parts2.length === 1 && parts2[0].protocol === "ip6" ? content : `[${content}]`,
  tcp: (str, content, i2, parts2, opts) => parts2.some((p) => ["http", "https", "ws", "wss"].includes(p.protocol)) ? `${str}:${content}` : tcpUri(str, content, parts2, opts),
  udp: (str, content) => `udp://${str}:${content}`,
  dnsaddr: reduceValue,
  dns4: reduceValue,
  dns6: reduceValue,
  ipfs: (str, content) => `${str}/ipfs/${content}`,
  p2p: (str, content) => `${str}/p2p/${content}`,
  http: (str) => `http://${str}`,
  https: (str) => `https://${str}`,
  ws: (str) => `ws://${str}`,
  wss: (str) => `wss://${str}`,
  "p2p-websocket-star": (str) => `${str}/p2p-websocket-star`,
  "p2p-webrtc-star": (str) => `${str}/p2p-webrtc-star`,
  "p2p-webrtc-direct": (str) => `${str}/p2p-webrtc-direct`
};
function multiaddrToUri(input, opts) {
  const ma = multiaddr(input);
  const parts2 = ma.toString().split("/").slice(1);
  return ma.tuples().map((tuple) => ({
    protocol: parts2.shift() ?? "",
    content: tuple[1] != null ? parts2.shift() ?? "" : ""
  })).reduce((str, part, i2, parts3) => {
    const reduce2 = Reducers[part.protocol];
    if (reduce2 == null) {
      throw new Error(`Unsupported protocol ${part.protocol}`);
    }
    return reduce2(str, part.content, i2, parts3, opts);
  }, "");
}
function arrayShuffle(array) {
  if (!Array.isArray(array)) {
    throw new TypeError(`Expected an array, got ${typeof array}`);
  }
  array = [...array];
  for (let index = array.length - 1; index > 0; index--) {
    const newIndex = Math.floor(Math.random() * (index + 1));
    [array[index], array[newIndex]] = [array[newIndex], array[index]];
  }
  return array;
}
const log$1l = logger$1("ipfs:preload");
const Queue$2 = PQueue.default ? PQueue.default : PQueue;
const httpQueue = new Queue$2({ concurrency: 4 });
function preload(url2, options = {}) {
  log$1l(url2);
  return httpQueue.add(async () => {
    const res = await http.post(url2, { signal: options.signal });
    const reader2 = res.body.getReader();
    try {
      while (true) {
        const { done } = await reader2.read();
        if (done)
          return;
      }
    } finally {
      reader2.releaseLock();
    }
  });
}
const log$1k = logger$1("ipfs:preload");
function createPreloader(options = {}) {
  options.enabled = Boolean(options.enabled);
  options.addresses = options.addresses || [];
  options.cache = options.cache || 1e3;
  if (!options.enabled || !options.addresses.length) {
    log$1k("preload disabled");
    const api3 = () => {
    };
    return Object.assign(api3, {
      start: () => {
      },
      stop: () => {
      }
    });
  }
  let stopped = true;
  let requests = [];
  const apiUris = options.addresses.map((str) => multiaddrToUri(str));
  const cache2 = hashlru(options.cache);
  const api2 = async (cid) => {
    try {
      if (stopped) {
        throw new Error(`preload ${cid} but preloader is not started`);
      }
      const path2 = cid.toString();
      if (cache2.has(path2)) {
        return;
      }
      cache2.set(path2, true);
      const fallbackApiUris = arrayShuffle(apiUris);
      let success = false;
      const now = Date.now();
      for (const uri of fallbackApiUris) {
        if (stopped)
          throw new Error(`preload aborted for ${path2}`);
        let controller;
        try {
          controller = new AbortController();
          requests = requests.concat(controller);
          await preload(`${uri}/api/v0/refs?r=true&arg=${encodeURIComponent(path2)}`, { signal: controller.signal });
          success = true;
        } catch (err2) {
          if (err2.type !== "aborted")
            log$1k.error(err2);
        } finally {
          requests = requests.filter((r) => r !== controller);
        }
        if (success)
          break;
      }
      log$1k(`${success ? "" : "un"}successfully preloaded ${path2} in ${Date.now() - now}ms`);
    } catch (err2) {
      log$1k.error(err2);
    }
  };
  api2.start = () => {
    stopped = false;
  };
  api2.stop = () => {
    stopped = true;
    log$1k(`aborting ${requests.length} pending preload request(s)`);
    requests.forEach((r) => r.abort());
    requests = [];
  };
  return api2;
}
const log$1j = logger$1("ipfs:mfs-preload");
function createMfsPreloader({ preload: preload2, files, options = {} }) {
  options.interval = options.interval || 30 * 1e3;
  if (!options.enabled) {
    log$1j("MFS preload disabled");
    const noop2 = async () => {
    };
    return { start: noop2, stop: noop2 };
  }
  let rootCid = "";
  let timeoutId;
  const preloadMfs = async () => {
    try {
      const stats = await files.stat("/");
      const nextRootCid = stats.cid.toString();
      if (rootCid !== nextRootCid) {
        log$1j(`preloading updated MFS root ${rootCid} -> ${stats.cid}`);
        await preload2(stats.cid);
        rootCid = nextRootCid;
      }
    } catch (err2) {
      log$1j.error("failed to preload MFS root", err2);
    } finally {
      timeoutId = setTimeout(preloadMfs, options.interval);
    }
  };
  return {
    async start() {
      const stats = await files.stat("/");
      rootCid = stats.cid.toString();
      log$1j(`monitoring MFS root ${stats.cid}`);
      timeoutId = setTimeout(preloadMfs, options.interval);
    },
    stop() {
      clearTimeout(timeoutId);
    }
  };
}
class TimeoutError extends Error {
  constructor(message2) {
    super(message2);
    this.name = "TimeoutError";
  }
}
class AbortError$2 extends Error {
  constructor(message2) {
    super();
    this.name = "AbortError";
    this.message = message2;
  }
}
const getDOMException = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError$2(errorMessage) : new DOMException(errorMessage);
const getAbortedReason = (signal) => {
  const reason = signal.reason === void 0 ? getDOMException("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException(reason);
};
function pTimeout(promise2, options) {
  const {
    milliseconds,
    fallback,
    message: message2,
    customTimers = { setTimeout, clearTimeout }
  } = options;
  let timer;
  const cancelablePromise = new Promise((resolve2, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      resolve2(promise2);
      return;
    }
    if (options.signal) {
      const { signal } = options;
      if (signal.aborted) {
        reject(getAbortedReason(signal));
      }
      signal.addEventListener("abort", () => {
        reject(getAbortedReason(signal));
      });
    }
    timer = customTimers.setTimeout.call(void 0, () => {
      if (fallback) {
        try {
          resolve2(fallback());
        } catch (error2) {
          reject(error2);
        }
        return;
      }
      const errorMessage = typeof message2 === "string" ? message2 : `Promise timed out after ${milliseconds} milliseconds`;
      const timeoutError2 = message2 instanceof Error ? message2 : new TimeoutError(errorMessage);
      if (typeof promise2.cancel === "function") {
        promise2.cancel();
      }
      reject(timeoutError2);
    }, milliseconds);
    (async () => {
      try {
        resolve2(await promise2);
      } catch (error2) {
        reject(error2);
      } finally {
        customTimers.clearTimeout.call(void 0, timer);
      }
    })();
  });
  cancelablePromise.clear = () => {
    customTimers.clearTimeout.call(void 0, timer);
    timer = void 0;
  };
  return cancelablePromise;
}
const WORKER_REQUEST_READ_LOCK = "lock:worker:request-read";
const WORKER_RELEASE_READ_LOCK = "lock:worker:release-read";
const MASTER_GRANT_READ_LOCK = "lock:master:grant-read";
const WORKER_REQUEST_WRITE_LOCK = "lock:worker:request-write";
const WORKER_RELEASE_WRITE_LOCK = "lock:worker:release-write";
const MASTER_GRANT_WRITE_LOCK = "lock:master:grant-write";
const events$1 = {};
const observable = (worker) => {
  worker.addEventListener("message", (event) => {
    observable.dispatchEvent("message", worker, event);
  });
  if (worker.port != null) {
    worker.port.addEventListener("message", (event) => {
      observable.dispatchEvent("message", worker, event);
    });
  }
};
observable.addEventListener = (type, fn) => {
  if (events$1[type] == null) {
    events$1[type] = [];
  }
  events$1[type].push(fn);
};
observable.removeEventListener = (type, fn) => {
  if (events$1[type] == null) {
    return;
  }
  events$1[type] = events$1[type].filter((listener) => listener === fn);
};
observable.dispatchEvent = function(type, worker, event) {
  if (events$1[type] == null) {
    return;
  }
  events$1[type].forEach((fn) => fn(worker, event));
};
const handleWorkerLockRequest = (emitter, masterEvent, requestType, releaseType, grantType) => {
  return (worker, event) => {
    if (event.data.type !== requestType) {
      return;
    }
    const requestEvent = {
      type: event.data.type,
      name: event.data.name,
      identifier: event.data.identifier
    };
    emitter.dispatchEvent(new MessageEvent(masterEvent, {
      data: {
        name: requestEvent.name,
        handler: async () => {
          worker.postMessage({
            type: grantType,
            name: requestEvent.name,
            identifier: requestEvent.identifier
          });
          return await new Promise((resolve2) => {
            const releaseEventListener = (event2) => {
              if (event2 == null || event2.data == null) {
                return;
              }
              const releaseEvent = {
                type: event2.data.type,
                name: event2.data.name,
                identifier: event2.data.identifier
              };
              if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {
                worker.removeEventListener("message", releaseEventListener);
                resolve2();
              }
            };
            worker.addEventListener("message", releaseEventListener);
          });
        }
      }
    }));
  };
};
const makeWorkerLockRequest = (name2, requestType, grantType, releaseType) => {
  return async () => {
    const id = nanoid();
    globalThis.postMessage({
      type: requestType,
      identifier: id,
      name: name2
    });
    return await new Promise((resolve2) => {
      const listener = (event) => {
        if (event == null || event.data == null) {
          return;
        }
        const responseEvent = {
          type: event.data.type,
          identifier: event.data.identifier
        };
        if (responseEvent.type === grantType && responseEvent.identifier === id) {
          globalThis.removeEventListener("message", listener);
          resolve2(() => {
            globalThis.postMessage({
              type: releaseType,
              identifier: id,
              name: name2
            });
          });
        }
      };
      globalThis.addEventListener("message", listener);
    });
  };
};
const defaultOptions$j = {
  singleProcess: false
};
const impl = (options) => {
  options = Object.assign({}, defaultOptions$j, options);
  const isPrimary = Boolean(globalThis.document) || options.singleProcess;
  if (isPrimary) {
    const emitter = new EventTarget();
    observable.addEventListener("message", handleWorkerLockRequest(emitter, "requestReadLock", WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK));
    observable.addEventListener("message", handleWorkerLockRequest(emitter, "requestWriteLock", WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK));
    return emitter;
  }
  return {
    isWorker: true,
    readLock: (name2) => makeWorkerLockRequest(name2, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),
    writeLock: (name2) => makeWorkerLockRequest(name2, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)
  };
};
const mutexes = {};
let implementation;
async function createReleaseable(queue, options) {
  let res;
  const p = new Promise((resolve2) => {
    res = resolve2;
  });
  void queue.add(async () => await pTimeout((async () => {
    return await new Promise((resolve2) => {
      res(() => {
        resolve2();
      });
    });
  })(), {
    milliseconds: options.timeout
  }));
  return await p;
}
const createMutex = (name2, options) => {
  if (implementation.isWorker === true) {
    return {
      readLock: implementation.readLock(name2, options),
      writeLock: implementation.writeLock(name2, options)
    };
  }
  const masterQueue = new PQueue({ concurrency: 1 });
  let readQueue;
  return {
    async readLock() {
      if (readQueue != null) {
        return await createReleaseable(readQueue, options);
      }
      readQueue = new PQueue({
        concurrency: options.concurrency,
        autoStart: false
      });
      const localReadQueue = readQueue;
      const readPromise = createReleaseable(readQueue, options);
      void masterQueue.add(async () => {
        localReadQueue.start();
        return await localReadQueue.onIdle().then(() => {
          if (readQueue === localReadQueue) {
            readQueue = null;
          }
        });
      });
      return await readPromise;
    },
    async writeLock() {
      readQueue = null;
      return await createReleaseable(masterQueue, options);
    }
  };
};
const defaultOptions$i = {
  name: "lock",
  concurrency: Infinity,
  timeout: 846e5,
  singleProcess: false
};
function createMortice(options) {
  const opts = Object.assign({}, defaultOptions$i, options);
  if (implementation == null) {
    implementation = impl(opts);
    if (implementation.isWorker !== true) {
      implementation.addEventListener("requestReadLock", (event) => {
        if (mutexes[event.data.name] == null) {
          return;
        }
        void mutexes[event.data.name].readLock().then(async (release) => await event.data.handler().finally(() => release()));
      });
      implementation.addEventListener("requestWriteLock", async (event) => {
        if (mutexes[event.data.name] == null) {
          return;
        }
        void mutexes[event.data.name].writeLock().then(async (release) => await event.data.handler().finally(() => release()));
      });
    }
  }
  if (mutexes[opts.name] == null) {
    mutexes[opts.name] = createMutex(opts.name, opts);
  }
  return mutexes[opts.name];
}
let lock$1;
function createLock(repoOwner = false) {
  if (lock$1) {
    return lock$1;
  }
  const mutex = createMortice({
    singleProcess: repoOwner
  });
  lock$1 = {
    readLock: (func) => {
      return async (...args) => {
        const releaseLock = await mutex.readLock();
        try {
          return await func.apply(null, args);
        } finally {
          releaseLock();
        }
      };
    },
    writeLock: (func) => {
      return async (...args) => {
        const releaseLock = await mutex.writeLock();
        try {
          return await func.apply(null, args);
        } finally {
          releaseLock();
        }
      };
    }
  };
  return lock$1;
}
const log$1i = logger$1("ipfs:mfs:utils:with-mfs-root");
async function loadMfsRoot(context, options) {
  if (options && options.signal && options.signal.aborted) {
    throw errCode(new Error("Request aborted"), "ERR_ABORTED", { name: "Aborted" });
  }
  await context.repo.datastore.open();
  let cid;
  try {
    const buf2 = await context.repo.datastore.get(MFS_ROOT_KEY$2);
    cid = CID.decode(buf2);
  } catch (err2) {
    if (err2.code !== "ERR_NOT_FOUND") {
      throw err2;
    }
    log$1i("Creating new MFS root");
    const buf2 = encode$o({
      Data: new UnixFS({ type: "directory" }).marshal(),
      Links: []
    });
    const hash2 = await sha256$3.digest(buf2);
    cid = CID.createV0(hash2);
    await context.repo.blocks.put(cid, buf2);
    if (options && options.signal && options.signal.aborted) {
      throw errCode(new Error("Request aborted"), "ERR_ABORTED", { name: "Aborted" });
    }
    await context.repo.datastore.put(MFS_ROOT_KEY$2, cid.bytes);
  }
  log$1i(`Loaded MFS root /ipfs/${cid}`);
  return cid;
}
function toPathComponents(path2 = "") {
  return (path2.trim().match(/([^\\^/]|\\\/)+/g) || []).filter(Boolean);
}
const IPFS_PREFIX = "ipfs";
const toMfsPath = async (context, path2, options) => {
  const root = await loadMfsRoot(context, options);
  let output = {
    entryType: "file"
  };
  let ipfsPath2 = "";
  if (CID.asCID(path2)) {
    ipfsPath2 = `/ipfs/${path2}`;
  } else {
    ipfsPath2 = path2.toString();
  }
  ipfsPath2 = ipfsPath2.trim();
  ipfsPath2 = ipfsPath2.replace(/(\/\/+)/g, "/");
  if (ipfsPath2.endsWith("/") && ipfsPath2.length > 1) {
    ipfsPath2 = ipfsPath2.substring(0, ipfsPath2.length - 1);
  }
  if (!ipfsPath2) {
    throw errCode(new Error("paths must not be empty"), "ERR_NO_PATH");
  }
  if (ipfsPath2.substring(0, 1) !== "/") {
    throw errCode(new Error("paths must start with a leading slash"), "ERR_INVALID_PATH");
  }
  if (ipfsPath2.substring(ipfsPath2.length - 1) === "/") {
    ipfsPath2 = ipfsPath2.substring(0, ipfsPath2.length - 1);
  }
  const pathComponents = toPathComponents(ipfsPath2);
  if (pathComponents[0] === IPFS_PREFIX) {
    let mfsDirectory;
    if (pathComponents.length === 2) {
      mfsDirectory = `/${pathComponents.join("/")}`;
    } else {
      mfsDirectory = `/${pathComponents.slice(0, pathComponents.length - 1).join("/")}`;
    }
    output = {
      type: "ipfs",
      depth: pathComponents.length - 2,
      entryType: "file",
      mfsPath: `/${pathComponents.join("/")}`,
      mfsDirectory,
      parts: pathComponents,
      path: `/${pathComponents.join("/")}`,
      name: pathComponents[pathComponents.length - 1]
    };
  } else {
    const mfsPath = `/${IPFS_PREFIX}/${root}${pathComponents.length ? "/" + pathComponents.join("/") : ""}`;
    const mfsDirectory = `/${IPFS_PREFIX}/${root}/${pathComponents.slice(0, pathComponents.length - 1).join("/")}`;
    output = {
      type: "mfs",
      depth: pathComponents.length,
      entryType: "file",
      mfsDirectory,
      mfsPath,
      parts: pathComponents,
      path: `/${pathComponents.join("/")}`,
      name: pathComponents[pathComponents.length - 1]
    };
  }
  const cidPath = output.type === "mfs" ? output.mfsPath : output.path;
  try {
    const res = await exporter(cidPath, context.repo.blocks, options);
    output.cid = res.cid;
    output.mfsPath = `/ipfs/${res.path}`;
    output.entryType = res.type;
    output.content = res.content;
    if ((output.entryType === "file" || output.entryType === "directory") && (res.type === "file" || res.type === "directory")) {
      output.unixfs = res.unixfs;
    }
  } catch (err2) {
    if (err2.code !== "ERR_NOT_FOUND") {
      throw err2;
    }
  }
  output.exists = Boolean(output.cid);
  return output;
};
const mergeOptions$c = mergeOptions$g.bind({ ignoreUndefined: true });
const log$1h = logger$1("ipfs:mfs:stat");
const defaultOptions$h = {
  withLocal: false
};
function createStat$7(context) {
  async function mfsStat(path2, options = {}) {
    options = mergeOptions$c(defaultOptions$h, options);
    log$1h(`Fetching stats for ${path2}`);
    const {
      type,
      cid,
      mfsPath
    } = await toMfsPath(context, path2, options);
    const exportPath = type === "ipfs" && cid ? cid : mfsPath;
    let file;
    try {
      file = await exporter(exportPath, context.repo.blocks);
    } catch (err2) {
      if (err2.code === "ERR_NOT_FOUND") {
        throw errCode(new Error(`${path2} does not exist`), "ERR_NOT_FOUND");
      }
      throw err2;
    }
    if (!statters[file.type]) {
      throw new Error(`Cannot stat codec ${file.cid.code}`);
    }
    return statters[file.type](file);
  }
  return withTimeoutOption(mfsStat);
}
const statters = {
  raw: (file) => {
    return {
      cid: file.cid,
      size: file.node.length,
      cumulativeSize: file.node.length,
      blocks: 0,
      type: "file",
      local: void 0,
      sizeLocal: void 0,
      withLocality: false
    };
  },
  file: (file) => {
    const stat = {
      cid: file.cid,
      type: "file",
      size: file.unixfs.fileSize(),
      cumulativeSize: encode$o(file.node).length + (file.node.Links || []).reduce((acc, curr) => acc + (curr.Tsize || 0), 0),
      blocks: file.unixfs.blockSizes.length,
      local: void 0,
      sizeLocal: void 0,
      withLocality: false,
      mode: file.unixfs.mode
    };
    if (file.unixfs.mtime) {
      stat.mtime = file.unixfs.mtime;
    }
    return stat;
  },
  directory: (file) => {
    const stat = {
      cid: file.cid,
      type: "directory",
      size: 0,
      cumulativeSize: encode$o(file.node).length + (file.node.Links || []).reduce((acc, curr) => acc + (curr.Tsize || 0), 0),
      blocks: file.node.Links.length,
      local: void 0,
      sizeLocal: void 0,
      withLocality: false,
      mode: file.unixfs.mode
    };
    if (file.unixfs.mtime) {
      stat.mtime = file.unixfs.mtime;
    }
    return stat;
  },
  object: (file) => {
    return {
      cid: file.cid,
      size: file.node.length,
      cumulativeSize: file.node.length,
      type: "file",
      blocks: 0,
      local: void 0,
      sizeLocal: void 0,
      withLocality: false
    };
  },
  identity: (file) => {
    return {
      cid: file.cid,
      size: file.node.length,
      cumulativeSize: file.node.length,
      blocks: 0,
      type: "file",
      local: void 0,
      sizeLocal: void 0,
      withLocality: false
    };
  }
};
const log$1g = logger$1("ipfs:mfs:utils:to-trail");
async function toTrail(context, path2) {
  log$1g(`Creating trail for path ${path2}`);
  const output = [];
  for await (const fsEntry of walkPath(path2, context.repo.blocks)) {
    output.push({
      name: fsEntry.name,
      cid: fsEntry.cid,
      size: fsEntry.size,
      type: fsEntry.type
    });
  }
  return output;
}
const persist = async (buffer2, blockstore, options) => {
  if (!options.codec) {
    options.codec = dagPB;
  }
  if (!options.hasher) {
    options.hasher = sha256$3;
  }
  if (options.cidVersion === void 0) {
    options.cidVersion = 1;
  }
  if (options.codec === dagPB && options.hasher !== sha256$3) {
    options.cidVersion = 1;
  }
  const multihash = await options.hasher.digest(buffer2);
  const cid = CID.create(options.cidVersion, options.codec.code, multihash);
  if (!options.onlyHash) {
    await blockstore.put(cid, buffer2, {
      signal: options.signal
    });
  }
  return cid;
};
const hamtHashCode = murmur3128.code;
const hamtBucketBits = 8;
async function hamtHashFn(buf2) {
  return (await murmur3128.encode(buf2)).subarray(0, 8).reverse();
}
class Dir {
  constructor(props, options) {
    this.options = options || {};
    this.root = props.root;
    this.dir = props.dir;
    this.path = props.path;
    this.dirty = props.dirty;
    this.flat = props.flat;
    this.parent = props.parent;
    this.parentKey = props.parentKey;
    this.unixfs = props.unixfs;
    this.mode = props.mode;
    this.mtime = props.mtime;
    this.cid = void 0;
    this.size = void 0;
  }
  async put(name2, value2) {
  }
  get(name2) {
    return Promise.resolve(this);
  }
  async *eachChildSeries() {
  }
  async *flush(blockstore) {
  }
}
class DirSharded extends Dir {
  constructor(props, options) {
    super(props, options);
    this._bucket = createHAMT({
      hashFn: hamtHashFn,
      bits: hamtBucketBits
    });
  }
  async put(name2, value2) {
    await this._bucket.put(name2, value2);
  }
  get(name2) {
    return this._bucket.get(name2);
  }
  childCount() {
    return this._bucket.leafCount();
  }
  directChildrenCount() {
    return this._bucket.childrenCount();
  }
  onlyChild() {
    return this._bucket.onlyChild();
  }
  async *eachChildSeries() {
    for await (const { key, value: value2 } of this._bucket.eachLeafSeries()) {
      yield {
        key,
        child: value2
      };
    }
  }
  async *flush(blockstore) {
    yield* flush(this._bucket, blockstore, this, this.options);
  }
}
async function* flush(bucket, blockstore, shardRoot, options) {
  const children = bucket._children;
  const links2 = [];
  let childrenSize = 0;
  for (let i2 = 0; i2 < children.length; i2++) {
    const child = children.get(i2);
    if (!child) {
      continue;
    }
    const labelPrefix = i2.toString(16).toUpperCase().padStart(2, "0");
    if (child instanceof Bucket) {
      let shard;
      for await (const subShard of await flush(child, blockstore, null, options)) {
        shard = subShard;
      }
      if (!shard) {
        throw new Error("Could not flush sharded directory, no subshard found");
      }
      links2.push({
        Name: labelPrefix,
        Tsize: shard.size,
        Hash: shard.cid
      });
      childrenSize += shard.size;
    } else if (typeof child.value.flush === "function") {
      const dir2 = child.value;
      let flushedDir;
      for await (const entry of dir2.flush(blockstore)) {
        flushedDir = entry;
        yield flushedDir;
      }
      const label = labelPrefix + child.key;
      links2.push({
        Name: label,
        Tsize: flushedDir.size,
        Hash: flushedDir.cid
      });
      childrenSize += flushedDir.size;
    } else {
      const value2 = child.value;
      if (!value2.cid) {
        continue;
      }
      const label = labelPrefix + child.key;
      const size3 = value2.size;
      links2.push({
        Name: label,
        Tsize: size3,
        Hash: value2.cid
      });
      childrenSize += size3;
    }
  }
  const data = Uint8Array.from(children.bitField().reverse());
  const dir = new UnixFS({
    type: "hamt-sharded-directory",
    data,
    fanout: bucket.tableSize(),
    hashType: hamtHashCode,
    mtime: shardRoot && shardRoot.mtime,
    mode: shardRoot && shardRoot.mode
  });
  const node2 = {
    Data: dir.marshal(),
    Links: links2
  };
  const buffer2 = encode$o(prepare(node2));
  const cid = await persist(buffer2, blockstore, options);
  const size2 = buffer2.length + childrenSize;
  yield {
    cid,
    node: node2,
    size: size2
  };
}
const log$1f = logger$1("ipfs:mfs:core:utils:hamt-utils");
const updateHamtDirectory = async (context, links2, bucket, options) => {
  if (!options.parent.Data) {
    throw new Error("Could not update HAMT directory because parent had no data");
  }
  const data = Uint8Array.from(bucket._children.bitField().reverse());
  const node2 = UnixFS.unmarshal(options.parent.Data);
  const dir = new UnixFS({
    type: "hamt-sharded-directory",
    data,
    fanout: bucket.tableSize(),
    hashType: hamtHashCode,
    mode: node2.mode,
    mtime: node2.mtime
  });
  const hasher = await context.hashers.getHasher(options.hashAlg);
  const parent2 = {
    Data: dir.marshal(),
    Links: links2.sort((a, b2) => (a.Name || "").localeCompare(b2.Name || ""))
  };
  const buf2 = encode$o(parent2);
  const hash2 = await hasher.digest(buf2);
  const cid = CID.create(options.cidVersion, code$8, hash2);
  if (options.flush) {
    await context.repo.blocks.put(cid, buf2);
  }
  return {
    node: parent2,
    cid,
    size: links2.reduce((sum, link) => sum + (link.Tsize || 0), buf2.length)
  };
};
const recreateHamtLevel = async (context, links2, rootBucket, parentBucket, positionAtParent) => {
  const bucket = new Bucket({
    hash: rootBucket._options.hash,
    bits: rootBucket._options.bits
  }, parentBucket, positionAtParent);
  parentBucket._putObjectAt(positionAtParent, bucket);
  await addLinksToHamtBucket(context, links2, bucket, rootBucket);
  return bucket;
};
const recreateInitialHamtLevel = async (links2) => {
  const bucket = createHAMT({
    hashFn: hamtHashFn,
    bits: hamtBucketBits
  });
  await Promise.all(
    links2.map(async (link) => {
      const linkName = link.Name || "";
      if (linkName.length === 2) {
        const pos = parseInt(linkName, 16);
        const subBucket = new Bucket({
          hash: bucket._options.hash,
          bits: bucket._options.bits
        }, bucket, pos);
        bucket._putObjectAt(pos, subBucket);
        return Promise.resolve();
      }
      return bucket.put(linkName.substring(2), {
        size: link.Tsize,
        cid: link.Hash
      });
    })
  );
  return bucket;
};
const addLinksToHamtBucket = async (context, links2, bucket, rootBucket) => {
  await Promise.all(
    links2.map(async (link) => {
      const linkName = link.Name || "";
      if (linkName.length === 2) {
        log$1f("Populating sub bucket", linkName);
        const pos = parseInt(linkName, 16);
        const block = await context.repo.blocks.get(link.Hash);
        const node2 = decode$i(block);
        const subBucket = new Bucket({
          hash: rootBucket._options.hash,
          bits: rootBucket._options.bits
        }, bucket, pos);
        bucket._putObjectAt(pos, subBucket);
        await addLinksToHamtBucket(context, node2.Links, subBucket, rootBucket);
        return Promise.resolve();
      }
      return rootBucket.put(linkName.substring(2), {
        size: link.Tsize,
        cid: link.Hash
      });
    })
  );
};
const toPrefix = (position) => {
  return position.toString(16).toUpperCase().padStart(2, "0").substring(0, 2);
};
const generatePath = async (context, fileName, rootNode) => {
  const rootBucket = await recreateInitialHamtLevel(rootNode.Links);
  const position = await rootBucket._findNewBucketAndPos(fileName);
  const path2 = [{
    bucket: position.bucket,
    prefix: toPrefix(position.pos)
  }];
  let currentBucket = position.bucket;
  while (currentBucket !== rootBucket) {
    path2.push({
      bucket: currentBucket,
      prefix: toPrefix(currentBucket._posAtParent)
    });
    currentBucket = currentBucket._parent;
  }
  path2.reverse();
  path2[0].node = rootNode;
  for (let i2 = 0; i2 < path2.length; i2++) {
    const segment = path2[i2];
    if (!segment.node) {
      throw new Error("Could not generate HAMT path");
    }
    const link = segment.node.Links.filter((link2) => (link2.Name || "").substring(0, 2) === segment.prefix).pop();
    if (!link) {
      log$1f(`Link ${segment.prefix}${fileName} will be added`);
      continue;
    }
    if (link.Name === `${segment.prefix}${fileName}`) {
      log$1f(`Link ${segment.prefix}${fileName} will be replaced`);
      continue;
    }
    log$1f(`Found subshard ${segment.prefix}`);
    const block = await context.repo.blocks.get(link.Hash);
    const node2 = decode$i(block);
    if (!path2[i2 + 1]) {
      log$1f(`Loaded new subshard ${segment.prefix}`);
      await recreateHamtLevel(context, node2.Links, rootBucket, segment.bucket, parseInt(segment.prefix, 16));
      const position2 = await rootBucket._findNewBucketAndPos(fileName);
      path2.push({
        bucket: position2.bucket,
        prefix: toPrefix(position2.pos),
        node: node2
      });
      continue;
    }
    const nextSegment = path2[i2 + 1];
    await addLinksToHamtBucket(context, node2.Links, nextSegment.bucket, rootBucket);
    nextSegment.node = node2;
  }
  await rootBucket.put(fileName, true);
  path2.reverse();
  return {
    rootBucket,
    path: path2
  };
};
const createShard = async (context, contents, options = {}) => {
  const shard = new DirSharded({
    root: true,
    dir: true,
    parent: void 0,
    parentKey: void 0,
    path: "",
    dirty: true,
    flat: false,
    mtime: options.mtime,
    mode: options.mode
  }, options);
  for (let i2 = 0; i2 < contents.length; i2++) {
    await shard._bucket.put(contents[i2].name, {
      size: contents[i2].size,
      cid: contents[i2].cid
    });
  }
  const res = await last(shard.flush(context.repo.blocks));
  if (!res) {
    throw new Error("Flushing shard yielded no result");
  }
  return res;
};
const log$1e = logger$1("ipfs:mfs:core:utils:add-link");
async function addLink(context, options) {
  let parent2 = options.parent;
  if (options.parentCid) {
    const parentCid = CID.asCID(options.parentCid);
    if (parentCid === null) {
      throw errCode(new Error("Invalid CID passed to addLink"), "EINVALIDPARENTCID");
    }
    if (parentCid.code !== code$8) {
      throw errCode(new Error("Unsupported codec. Only DAG-PB is supported"), "EINVALIDPARENTCID");
    }
    log$1e(`Loading parent node ${parentCid}`);
    const block = await context.repo.blocks.get(parentCid);
    parent2 = decode$i(block);
  }
  if (!parent2) {
    throw errCode(new Error("No parent node or CID passed to addLink"), "EINVALIDPARENT");
  }
  if (!options.cid) {
    throw errCode(new Error("No child cid passed to addLink"), "EINVALIDCHILDCID");
  }
  if (!options.name) {
    throw errCode(new Error("No child name passed to addLink"), "EINVALIDCHILDNAME");
  }
  if (!options.size && options.size !== 0) {
    throw errCode(new Error("No child size passed to addLink"), "EINVALIDCHILDSIZE");
  }
  if (!parent2.Data) {
    throw errCode(new Error("Parent node with no data passed to addLink"), "ERR_INVALID_PARENT");
  }
  const meta = UnixFS.unmarshal(parent2.Data);
  if (meta.type === "hamt-sharded-directory") {
    log$1e("Adding link to sharded directory");
    return addToShardedDirectory(context, {
      ...options,
      parent: parent2
    });
  }
  if (parent2.Links.length >= options.shardSplitThreshold) {
    log$1e("Converting directory to sharded directory");
    return convertToShardedDirectory(context, {
      ...options,
      parent: parent2,
      mtime: meta.mtime,
      mode: meta.mode
    });
  }
  log$1e(`Adding ${options.name} (${options.cid}) to regular directory`);
  return addToDirectory(context, {
    ...options,
    parent: parent2
  });
}
const convertToShardedDirectory = async (context, options) => {
  const result = await createShard(context, options.parent.Links.map((link) => ({
    name: link.Name || "",
    size: link.Tsize || 0,
    cid: link.Hash
  })).concat({
    name: options.name,
    size: options.size,
    cid: options.cid
  }), options);
  log$1e(`Converted directory to sharded directory ${result.cid}`);
  return result;
};
const addToDirectory = async (context, options) => {
  const parentLinks = options.parent.Links.filter((link) => {
    return link.Name !== options.name;
  });
  parentLinks.push({
    Name: options.name,
    Tsize: options.size,
    Hash: options.cid
  });
  if (!options.parent.Data) {
    throw errCode(new Error("Parent node with no data passed to addToDirectory"), "ERR_INVALID_PARENT");
  }
  const node2 = UnixFS.unmarshal(options.parent.Data);
  let data;
  if (node2.mtime) {
    const ms2 = Date.now();
    const secs = Math.floor(ms2 / 1e3);
    node2.mtime = {
      secs,
      nsecs: (ms2 - secs * 1e3) * 1e3
    };
    data = node2.marshal();
  } else {
    data = options.parent.Data;
  }
  options.parent = prepare({
    Data: data,
    Links: parentLinks
  });
  const hasher = await context.hashers.getHasher(options.hashAlg);
  const buf2 = encode$o(options.parent);
  const hash2 = await hasher.digest(buf2);
  const cid = CID.create(options.cidVersion, code$8, hash2);
  if (options.flush) {
    await context.repo.blocks.put(cid, buf2);
  }
  return {
    node: options.parent,
    cid,
    size: buf2.length
  };
};
const addToShardedDirectory = async (context, options) => {
  const {
    shard,
    path: path2
  } = await addFileToShardedDirectory(context, options);
  const result = await last(shard.flush(context.repo.blocks));
  if (!result) {
    throw new Error("No result from flushing shard");
  }
  const block = await context.repo.blocks.get(result.cid);
  const node2 = decode$i(block);
  const parentLinks = options.parent.Links.filter((link) => {
    return (link.Name || "").substring(0, 2) !== path2[0].prefix;
  });
  const newLink = node2.Links.find((link) => (link.Name || "").substring(0, 2) === path2[0].prefix);
  if (!newLink) {
    throw new Error(`No link found with prefix ${path2[0].prefix}`);
  }
  parentLinks.push(newLink);
  return updateHamtDirectory(context, parentLinks, path2[0].bucket, options);
};
const addFileToShardedDirectory = async (context, options) => {
  const file = {
    name: options.name,
    cid: options.cid,
    size: options.size
  };
  if (!options.parent.Data) {
    throw errCode(new Error("Parent node with no data passed to addFileToShardedDirectory"), "ERR_INVALID_PARENT");
  }
  const rootBucket = await recreateInitialHamtLevel(options.parent.Links);
  const node2 = UnixFS.unmarshal(options.parent.Data);
  const shard = new DirSharded({
    root: true,
    dir: true,
    parent: void 0,
    parentKey: void 0,
    path: "",
    dirty: true,
    flat: false,
    mode: node2.mode
  }, options);
  shard._bucket = rootBucket;
  if (node2.mtime) {
    shard.mtime = {
      secs: Math.round(Date.now() / 1e3)
    };
  }
  const position = await rootBucket._findNewBucketAndPos(file.name);
  const path2 = toBucketPath(position);
  path2[0].node = options.parent;
  let index = 0;
  while (index < path2.length) {
    const segment = path2[index];
    index++;
    const node3 = segment.node;
    if (!node3) {
      throw new Error("Segment had no node");
    }
    const link = node3.Links.find((link2) => (link2.Name || "").substring(0, 2) === segment.prefix);
    if (!link) {
      log$1e(`Link ${segment.prefix}${file.name} will be added`);
      index = path2.length;
      break;
    }
    if (link.Name === `${segment.prefix}${file.name}`) {
      log$1e(`Link ${segment.prefix}${file.name} will be replaced`);
      index = path2.length;
      break;
    }
    if ((link.Name || "").length > 2) {
      log$1e(`Link ${link.Name} ${link.Hash} will be replaced with a subshard`);
      index = path2.length;
      break;
    }
    log$1e(`Found subshard ${segment.prefix}`);
    const block = await context.repo.blocks.get(link.Hash);
    const subShard = decode$i(block);
    if (!path2[index]) {
      log$1e(`Loaded new subshard ${segment.prefix}`);
      await recreateHamtLevel(context, subShard.Links, rootBucket, segment.bucket, parseInt(segment.prefix, 16));
      const position2 = await rootBucket._findNewBucketAndPos(file.name);
      path2.push({
        bucket: position2.bucket,
        prefix: toPrefix(position2.pos),
        node: subShard
      });
      break;
    }
    const nextSegment = path2[index];
    await addLinksToHamtBucket(context, subShard.Links, nextSegment.bucket, rootBucket);
    nextSegment.node = subShard;
  }
  await shard._bucket.put(file.name, {
    size: file.size,
    cid: file.cid
  });
  return {
    shard,
    path: path2
  };
};
const toBucketPath = (position) => {
  const path2 = [{
    bucket: position.bucket,
    prefix: toPrefix(position.pos)
  }];
  let bucket = position.bucket._parent;
  let positionInBucket = position.bucket._posAtParent;
  while (bucket) {
    path2.push({
      bucket,
      prefix: toPrefix(positionInBucket)
    });
    positionInBucket = bucket._posAtParent;
    bucket = bucket._parent;
  }
  path2.reverse();
  return path2;
};
const log$1d = logger$1("ipfs:mfs:utils:update-tree");
const defaultOptions$g = {
  shardSplitThreshold: 1e3
};
async function updateTree(context, trail, options) {
  options = Object.assign({}, defaultOptions$g, options);
  log$1d("Trail", trail);
  trail = trail.slice().reverse();
  let index = 0;
  let child;
  for await (const block of context.repo.blocks.getMany(trail.map((node2) => node2.cid))) {
    const node2 = decode$i(block);
    const cid2 = trail[index].cid;
    const name2 = trail[index].name;
    index++;
    if (!child) {
      child = {
        cid: cid2,
        name: name2,
        size: block.length
      };
      continue;
    }
    const result = await addLink(context, {
      parent: node2,
      name: child.name,
      cid: child.cid,
      size: child.size,
      flush: options.flush,
      shardSplitThreshold: options.shardSplitThreshold,
      hashAlg: options.hashAlg,
      cidVersion: options.cidVersion
    });
    child = {
      cid: result.cid,
      name: name2,
      size: result.size
    };
  }
  const { cid } = child;
  log$1d(`Final CID ${cid}`);
  return cid;
}
const log$1c = logger$1("ipfs:mfs:utils:update-mfs-root");
async function updateMfsRoot(context, cid, options) {
  if (options && options.signal && options.signal.aborted) {
    throw errCode(new Error("Request aborted"), "ERR_ABORTED", { name: "Aborted" });
  }
  log$1c(`New MFS root will be ${cid}`);
  await context.repo.datastore.put(MFS_ROOT_KEY$2, cid.bytes);
  return cid;
}
async function createNode$1(context, type, options) {
  const metadata = new UnixFS({
    type,
    mode: options.mode,
    mtime: options.mtime
  });
  const hasher = await context.hashers.getHasher(options.hashAlg);
  const node2 = {
    Data: metadata.marshal(),
    Links: []
  };
  const buf2 = encode$o(node2);
  const hash2 = await hasher.digest(buf2);
  const cid = CID.create(options.cidVersion, code$8, hash2);
  if (options.flush) {
    await context.repo.blocks.put(cid, buf2);
  }
  return {
    cid,
    node: node2
  };
}
const mergeOptions$b = mergeOptions$g.bind({ ignoreUndefined: true });
const log$1b = logger$1("ipfs:mfs:mkdir");
const defaultOptions$f = {
  parents: false,
  hashAlg: "sha2-256",
  cidVersion: 0,
  shardSplitThreshold: 1e3,
  flush: true
};
function createMkdir$1(context) {
  async function mfsMkdir(path2, options = {}) {
    const opts = mergeOptions$b(defaultOptions$f, options);
    if (!path2) {
      throw new Error("no path given to Mkdir");
    }
    path2 = path2.trim();
    if (path2 === "/") {
      if (opts.parents) {
        return;
      }
      throw errCode(new Error("cannot create directory '/': Already exists"), "ERR_INVALID_PATH");
    }
    if (path2.substring(0, 1) !== "/") {
      throw errCode(new Error("paths must start with a leading slash"), "ERR_INVALID_PATH");
    }
    log$1b(`Creating ${path2}`);
    const pathComponents = toPathComponents(path2);
    if (pathComponents[0] === "ipfs") {
      throw errCode(new Error("path cannot have the prefix 'ipfs'"), "ERR_INVALID_PATH");
    }
    const root = await loadMfsRoot(context, opts);
    let parent2;
    const trail = [];
    const emptyDir = await createNode$1(context, "directory", opts);
    for (let i2 = 0; i2 <= pathComponents.length; i2++) {
      const subPathComponents = pathComponents.slice(0, i2);
      const subPath = `/ipfs/${root}/${subPathComponents.join("/")}`;
      try {
        parent2 = await exporter(subPath, context.repo.blocks);
        if (parent2.type !== "file" && parent2.type !== "directory") {
          throw errCode(new Error(`${path2} was not a UnixFS node`), "ERR_NOT_UNIXFS");
        }
        if (i2 === pathComponents.length) {
          if (opts.parents) {
            return;
          }
          throw errCode(new Error("file already exists"), "ERR_ALREADY_EXISTS");
        }
        trail.push({
          name: parent2.name,
          cid: parent2.cid
        });
      } catch (err2) {
        if (err2.code === "ERR_NOT_FOUND") {
          if (i2 < pathComponents.length && !opts.parents) {
            throw errCode(new Error(`Intermediate directory path ${subPath} does not exist, use the -p flag to create it`), "ERR_NOT_FOUND");
          }
          await addEmptyDir$1(context, subPathComponents[subPathComponents.length - 1], emptyDir, trail[trail.length - 1], trail, opts);
        } else {
          throw err2;
        }
      }
    }
    const newRootCid = await updateTree(context, trail, opts);
    await updateMfsRoot(context, newRootCid, opts);
  }
  return withTimeoutOption(mfsMkdir);
}
const addEmptyDir$1 = async (context, childName, emptyDir, parent2, trail, options) => {
  log$1b(`Adding empty dir called ${childName} to ${parent2.cid}`);
  const result = await addLink(context, {
    parent: parent2.node,
    parentCid: parent2.cid,
    size: 0,
    cid: emptyDir.cid,
    name: childName,
    hashAlg: options.hashAlg,
    cidVersion: options.cidVersion,
    flush: options.flush,
    shardSplitThreshold: options.shardSplitThreshold
  });
  trail[trail.length - 1].cid = result.cid;
  trail.push({
    name: childName,
    cid: emptyDir.cid
  });
};
const mergeOptions$a = mergeOptions$g.bind({ ignoreUndefined: true });
const log$1a = logger$1("ipfs:mfs:cp");
const defaultOptions$e = {
  parents: false,
  flush: true,
  hashAlg: "sha2-256",
  cidVersion: 0,
  shardSplitThreshold: 1e3
};
function createCp$1(context) {
  async function mfsCp(from2, to, opts = {}) {
    const options = mergeOptions$a(defaultOptions$e, opts);
    if (!Array.isArray(from2)) {
      from2 = [from2];
    }
    const sources = await Promise.all(
      from2.map((path2) => toMfsPath(context, path2, options))
    );
    let destination = await toMfsPath(context, to, options);
    if (!sources.length || !destination) {
      throw errCode(new Error("Please supply at least one source"), "ERR_INVALID_PARAMS");
    }
    const missing = sources.find((source2) => !source2.exists);
    if (missing) {
      throw errCode(new Error(`${missing.path} does not exist`), "ERR_INVALID_PARAMS");
    }
    const destinationIsDirectory = isDirectory(destination);
    if (destination.exists) {
      log$1a("Destination exists");
      if (sources.length === 1 && !destinationIsDirectory) {
        throw errCode(new Error("directory already has entry by that name"), "ERR_ALREADY_EXISTS");
      }
    } else {
      log$1a("Destination does not exist");
      if (sources.length > 1) {
        if (!options.parents) {
          throw errCode(new Error("destination did not exist, pass -p to create intermediate directories"), "ERR_INVALID_PARAMS");
        }
        await createMkdir$1(context)(destination.path, options);
        destination = await toMfsPath(context, destination.path, options);
      } else if (destination.parts.length > 1) {
        const parentFolder = `/${destination.parts.slice(0, -1).join("/")}`;
        try {
          await createStat$7(context)(parentFolder, options);
        } catch (err2) {
          if (err2.code !== "ERR_NOT_FOUND") {
            throw err2;
          }
          if (!options.parents) {
            throw errCode(new Error("destination did not exist, pass -p to create intermediate directories"), "ERR_INVALID_PARAMS");
          }
          await createMkdir$1(context)(parentFolder, options);
          destination = await toMfsPath(context, destination.path, options);
        }
      }
    }
    const destinationPath = isDirectory(destination) ? destination.mfsPath : destination.mfsDirectory;
    const trail = await toTrail(context, destinationPath);
    if (sources.length === 1) {
      const source2 = sources.pop();
      if (!source2) {
        throw errCode(new Error("could not find source"), "ERR_INVALID_PARAMS");
      }
      const destinationName = destinationIsDirectory ? source2.name : destination.name;
      log$1a(`Only one source, copying to destination ${destinationIsDirectory ? "directory" : "file"} ${destinationName}`);
      return copyToFile(context, source2, destinationName, trail, options);
    }
    log$1a("Multiple sources, wrapping in a directory");
    return copyToDirectory(context, sources, destination, trail, options);
  }
  return withTimeoutOption(mfsCp);
}
const isDirectory = (destination) => {
  return destination.unixfs && destination.unixfs.type && destination.unixfs.type.includes("directory");
};
const copyToFile = async (context, source2, destination, destinationTrail, options) => {
  let parent2 = destinationTrail.pop();
  if (!parent2) {
    throw errCode(new Error("destination had no parent"), "ERR_INVALID_PARAMS");
  }
  parent2 = await addSourceToParent(context, source2, destination, parent2, options);
  destinationTrail.push(parent2);
  const newRootCid = await updateTree(context, destinationTrail, options);
  await updateMfsRoot(context, newRootCid, options);
};
const copyToDirectory = async (context, sources, destination, destinationTrail, options) => {
  for (let i2 = 0; i2 < sources.length; i2++) {
    const source2 = sources[i2];
    destination = await addSourceToParent(context, source2, source2.name, destination, options);
  }
  destinationTrail[destinationTrail.length - 1] = destination;
  const newRootCid = await updateTree(context, destinationTrail, options);
  await updateMfsRoot(context, newRootCid, options);
};
const addSourceToParent = async (context, source2, childName, parent2, options) => {
  const sourceBlock = await context.repo.blocks.get(source2.cid);
  const {
    node: node2,
    cid,
    size: size2
  } = await addLink(context, {
    parentCid: parent2.cid,
    size: sourceBlock.length,
    cid: source2.cid,
    name: childName,
    hashAlg: options.hashAlg,
    cidVersion: options.cidVersion,
    flush: options.flush,
    shardSplitThreshold: options.shardSplitThreshold
  });
  parent2.node = node2;
  parent2.cid = cid;
  parent2.size = size2;
  return parent2;
};
const log$19 = logger$1("ipfs:mfs:core:utils:remove-link");
async function removeLink(context, options) {
  let parent2 = options.parent;
  if (options.parentCid) {
    const parentCid = CID.asCID(options.parentCid);
    if (parentCid === null) {
      throw errCode(new Error("Invalid CID passed to removeLink"), "EINVALIDPARENTCID");
    }
    log$19(`Loading parent node ${parentCid}`);
    const block = await context.repo.blocks.get(parentCid);
    parent2 = decode$i(block);
  }
  if (!parent2) {
    throw errCode(new Error("No parent node or CID passed to removeLink"), "EINVALIDPARENT");
  }
  if (!options.name) {
    throw errCode(new Error("No child name passed to removeLink"), "EINVALIDCHILDNAME");
  }
  if (!parent2.Data) {
    throw errCode(new Error("Parent node had no data"), "ERR_INVALID_NODE");
  }
  const meta = UnixFS.unmarshal(parent2.Data);
  if (meta.type === "hamt-sharded-directory") {
    log$19(`Removing ${options.name} from sharded directory`);
    return removeFromShardedDirectory(context, {
      ...options,
      parent: parent2
    });
  }
  log$19(`Removing link ${options.name} regular directory`);
  return removeFromDirectory(context, {
    ...options,
    parent: parent2
  });
}
const removeFromDirectory = async (context, options) => {
  options.parent.Links = options.parent.Links.filter((link) => {
    return link.Name !== options.name;
  });
  const parentBlock = await encode$o(options.parent);
  const hasher = await context.hashers.getHasher(options.hashAlg);
  const hash2 = await hasher.digest(parentBlock);
  const parentCid = CID.create(options.cidVersion, code$8, hash2);
  await context.repo.blocks.put(parentCid, parentBlock);
  log$19(`Updated regular directory ${parentCid}`);
  return {
    node: options.parent,
    cid: parentCid
  };
};
const removeFromShardedDirectory = async (context, options) => {
  const {
    rootBucket,
    path: path2
  } = await generatePath(context, options.name, options.parent);
  await rootBucket.del(options.name);
  const {
    node: node2
  } = await updateShard(context, path2, options.name, options);
  return updateHamtDirectory(context, node2.Links, rootBucket, options);
};
const updateShard = async (context, positions, name2, options) => {
  const last2 = positions.pop();
  if (!last2) {
    throw errCode(new Error("Could not find parent"), "EINVALIDPARENT");
  }
  const {
    bucket,
    prefix,
    node: node2
  } = last2;
  if (!node2) {
    throw errCode(new Error("Could not find parent"), "EINVALIDPARENT");
  }
  const link = node2.Links.find((link2) => (link2.Name || "").substring(0, 2) === prefix);
  if (!link) {
    throw errCode(new Error(`No link found with prefix ${prefix} for file ${name2}`), "ERR_NOT_FOUND");
  }
  if (link.Name === `${prefix}${name2}`) {
    log$19(`Removing existing link ${link.Name}`);
    const links2 = node2.Links.filter((nodeLink) => {
      return nodeLink.Name !== link.Name;
    });
    await bucket.del(name2);
    return updateHamtDirectory(context, links2, bucket, options);
  }
  log$19(`Descending into sub-shard ${link.Name} for ${prefix}${name2}`);
  const result = await updateShard(context, positions, name2, options);
  let cid = result.cid;
  let size2 = result.size;
  let newName = prefix;
  if (result.node.Links.length === 1) {
    log$19(`Removing subshard for ${prefix}`);
    const link2 = result.node.Links[0];
    newName = `${prefix}${(link2.Name || "").substring(2)}`;
    cid = link2.Hash;
    size2 = link2.Tsize || 0;
  }
  log$19(`Updating shard ${prefix} with name ${newName}`);
  return updateShardParent(context, bucket, node2, prefix, newName, size2, cid, options);
};
const updateShardParent = (context, bucket, parent2, oldName, newName, size2, cid, options) => {
  const parentLinks = parent2.Links.filter((link) => {
    return link.Name !== oldName;
  });
  parentLinks.push({
    Name: newName,
    Tsize: size2,
    Hash: cid
  });
  return updateHamtDirectory(context, parentLinks, bucket, options);
};
const mergeOptions$9 = mergeOptions$g.bind({ ignoreUndefined: true });
const defaultOptions$d = {
  recursive: false,
  cidVersion: 0,
  hashAlg: "sha2-256",
  flush: true,
  shardSplitThreshold: 1e3
};
function createRm$8(context) {
  async function mfsRm(paths, opts = {}) {
    const options = mergeOptions$9(defaultOptions$d, opts);
    if (!Array.isArray(paths)) {
      paths = [paths];
    }
    const sources = await Promise.all(
      paths.map((path2) => toMfsPath(context, path2, options))
    );
    if (!sources.length) {
      throw errCode(new Error("Please supply at least one path to remove"), "ERR_INVALID_PARAMS");
    }
    sources.forEach((source2) => {
      if (source2.path === "/") {
        throw errCode(new Error("Cannot delete root"), "ERR_INVALID_PARAMS");
      }
    });
    for (const source2 of sources) {
      await removePath(context, source2.path, options);
    }
  }
  return withTimeoutOption(mfsRm);
}
const removePath = async (context, path2, options) => {
  const mfsPath = await toMfsPath(context, path2, options);
  const trail = await toTrail(context, mfsPath.mfsPath);
  const child = trail[trail.length - 1];
  trail.pop();
  const parent2 = trail[trail.length - 1];
  if (!parent2) {
    throw errCode(new Error(`${path2} does not exist`), "ERR_NOT_FOUND");
  }
  if (child.type === "directory" && !options.recursive) {
    throw errCode(new Error(`${path2} is a directory, use -r to remove directories`), "ERR_WAS_DIR");
  }
  const {
    cid
  } = await removeLink(context, {
    parentCid: parent2.cid,
    name: child.name,
    hashAlg: options.hashAlg,
    cidVersion: options.cidVersion,
    flush: options.flush,
    shardSplitThreshold: options.shardSplitThreshold
  });
  parent2.cid = cid;
  const newRootCid = await updateTree(context, trail, options);
  await updateMfsRoot(context, newRootCid, options);
};
const mergeOptions$8 = mergeOptions$g.bind({ ignoreUndefined: true });
const log$18 = logger$1("ipfs:mfs:touch");
const defaultOptions$c = {
  flush: true,
  shardSplitThreshold: 1e3,
  hashAlg: "sha2-256",
  cidVersion: 0,
  recursive: false
};
function calculateModification(mode, originalMode, isDirectory2) {
  let modification = 0;
  if (mode.includes("x") || mode.includes("X") && (isDirectory2 || (originalMode & 1 || originalMode & 8 || originalMode & 64))) {
    modification += 1;
  }
  if (mode.includes("w")) {
    modification += 2;
  }
  if (mode.includes("r")) {
    modification += 4;
  }
  return modification;
}
function calculateUGO(references, modification) {
  let ugo = 0;
  if (references.includes("u")) {
    ugo += modification << 6;
  }
  if (references.includes("g")) {
    ugo += modification << 3;
  }
  if (references.includes("o")) {
    ugo += modification;
  }
  return ugo;
}
function calculateSpecial(references, mode, modification) {
  if (mode.includes("t")) {
    modification += parseInt("1000", 8);
  }
  if (mode.includes("s")) {
    if (references.includes("u")) {
      modification += parseInt("4000", 8);
    }
    if (references.includes("g")) {
      modification += parseInt("2000", 8);
    }
  }
  return modification;
}
function parseSymbolicMode(input, originalMode, isDirectory2) {
  if (!originalMode) {
    originalMode = 0;
  }
  const match = input.match(/^(u?g?o?a?)(-?\+?=?)?(r?w?x?X?s?t?)$/);
  if (!match) {
    throw new Error(`Invalid file mode: ${input}`);
  }
  let [
    ,
    references,
    operator,
    mode
  ] = match;
  if (references === "a" || !references) {
    references = "ugo";
  }
  let modification = calculateModification(mode, originalMode, isDirectory2);
  modification = calculateUGO(references, modification);
  modification = calculateSpecial(references, mode, modification);
  if (operator === "=") {
    if (references.includes("u")) {
      originalMode = originalMode & parseInt("7077", 8);
      originalMode = originalMode | modification;
    }
    if (references.includes("g")) {
      originalMode = originalMode & parseInt("7707", 8);
      originalMode = originalMode | modification;
    }
    if (references.includes("o")) {
      originalMode = originalMode & parseInt("7770", 8);
      originalMode = originalMode | modification;
    }
    return originalMode;
  }
  if (operator === "+") {
    return modification | originalMode;
  }
  if (operator === "-") {
    return modification ^ originalMode;
  }
  return originalMode;
}
function calculateMode(mode, metadata) {
  if (mode instanceof String || typeof mode === "string") {
    const strMode = `${mode}`;
    if (strMode.match(/^\d+$/g)) {
      mode = parseInt(strMode, 8);
    } else {
      mode = 0 + strMode.split(",").reduce((curr, acc) => {
        return parseSymbolicMode(acc, curr, metadata.isDirectory());
      }, metadata.mode || 0);
    }
  }
  return mode;
}
function createChmod$1(context) {
  async function mfsChmod(path2, mode, options = {}) {
    const opts = mergeOptions$8(defaultOptions$c, options);
    log$18(`Fetching stats for ${path2}`);
    const {
      cid,
      mfsDirectory,
      name: name2
    } = await toMfsPath(context, path2, opts);
    if (cid.code !== code$8) {
      throw errCode(new Error(`${path2} was not a UnixFS node`), "ERR_NOT_UNIXFS");
    }
    if (opts.recursive) {
      const root = await pipe(
        async function* () {
          for await (const entry of recursive(cid, context.repo.blocks)) {
            if (entry.type !== "file" && entry.type !== "directory") {
              throw errCode(new Error(`${path2} was not a UnixFS node`), "ERR_NOT_UNIXFS");
            }
            entry.unixfs.mode = calculateMode(mode, entry.unixfs);
            const node3 = prepare({
              Data: entry.unixfs.marshal(),
              Links: entry.node.Links
            });
            yield {
              path: entry.path,
              content: node3
            };
          }
        },
        (source2) => importer(source2, context.repo.blocks, {
          ...opts,
          pin: false,
          dagBuilder: async function* (source3, block2, opts2) {
            for await (const entry of source3) {
              yield async function() {
                const node3 = entry.content;
                const buf2 = encode$o(node3);
                const cid2 = await persist(buf2, block2, opts2);
                if (!node3.Data) {
                  throw errCode(new Error(`${cid2} had no data`), "ERR_INVALID_NODE");
                }
                const unixfs = UnixFS.unmarshal(node3.Data);
                return {
                  cid: cid2,
                  size: buf2.length,
                  path: entry.path,
                  unixfs
                };
              };
            }
          }
        }),
        (nodes) => last(nodes)
      );
      if (!root) {
        throw errCode(new Error(`Could not chmod ${path2}`), "ERR_COULD_NOT_CHMOD");
      }
      await createRm$8(context)(path2, opts);
      await createCp$1(context)(`/ipfs/${root.cid}`, path2, opts);
      return;
    }
    const block = await context.repo.blocks.get(cid);
    const node2 = decode$i(block);
    if (!node2.Data) {
      throw errCode(new Error(`${cid} had no data`), "ERR_INVALID_NODE");
    }
    const metadata = UnixFS.unmarshal(node2.Data);
    metadata.mode = calculateMode(mode, metadata);
    const updatedBlock = encode$o({
      Data: metadata.marshal(),
      Links: node2.Links
    });
    const hashAlg = opts.hashAlg || defaultOptions$c.hashAlg;
    const hasher = await context.hashers.getHasher(hashAlg);
    const hash2 = await hasher.digest(updatedBlock);
    const updatedCid = CID.create(opts.cidVersion, code$8, hash2);
    if (opts.flush) {
      await context.repo.blocks.put(updatedCid, updatedBlock);
    }
    const trail = await toTrail(context, mfsDirectory);
    const parent2 = trail[trail.length - 1];
    const parentCid = CID.decode(parent2.cid.bytes);
    const parentBlock = await context.repo.blocks.get(parentCid);
    const parentNode = decode$i(parentBlock);
    const result = await addLink(context, {
      parent: parentNode,
      name: name2,
      cid: updatedCid,
      size: updatedBlock.length,
      flush: opts.flush,
      hashAlg,
      cidVersion: cid.version,
      shardSplitThreshold: Infinity
    });
    parent2.cid = result.cid;
    const newRootCid = await updateTree(context, trail, opts);
    await updateMfsRoot(context, newRootCid, opts);
  }
  return withTimeoutOption(mfsChmod);
}
const mergeOptions$7 = mergeOptions$g.bind({ ignoreUndefined: true });
const defaultOptions$b = {};
function createFlush$1(context) {
  async function mfsFlush(path2, options = {}) {
    options = mergeOptions$7(defaultOptions$b, options);
    const { cid } = await createStat$7(context)(path2, options);
    return cid;
  }
  return withTimeoutOption(mfsFlush);
}
const mergeOptions$6 = mergeOptions$g.bind({ ignoreUndefined: true });
const defaultOptions$a = {
  parents: false,
  flush: true,
  cidVersion: 0,
  hashAlg: "sha2-256",
  shardSplitThreshold: 1e3
};
function createMv$1(context) {
  async function mfsMv(from2, to, options = {}) {
    const opts = mergeOptions$6(defaultOptions$a, options);
    await createCp$1(context)(from2, to, opts);
    await createRm$8(context)(from2, {
      ...opts,
      recursive: true
    });
  }
  return withTimeoutOption(mfsMv);
}
const mergeOptions$5 = mergeOptions$g.bind({ ignoreUndefined: true });
const log$17 = logger$1("ipfs:mfs:touch");
const defaultOptions$9 = {
  flush: true,
  shardSplitThreshold: 1e3,
  cidVersion: 0,
  hashAlg: "sha2-256"
};
function createTouch$1(context) {
  async function mfsTouch(path2, options = {}) {
    const settings = mergeOptions$5(defaultOptions$9, options);
    settings.mtime = settings.mtime || new Date();
    log$17(`Touching ${path2} mtime: ${settings.mtime}`);
    const {
      cid,
      mfsDirectory,
      name: name2,
      exists: exists2
    } = await toMfsPath(context, path2, settings);
    const hashAlg = options.hashAlg || defaultOptions$9.hashAlg;
    const hasher = await context.hashers.getHasher(hashAlg);
    let updatedBlock;
    let updatedCid;
    let cidVersion = settings.cidVersion;
    if (!exists2) {
      const metadata = new UnixFS({
        type: "file",
        mtime: settings.mtime
      });
      updatedBlock = encode$o({ Data: metadata.marshal(), Links: [] });
      const hash2 = await hasher.digest(updatedBlock);
      updatedCid = CID.create(settings.cidVersion, code$8, hash2);
      if (settings.flush) {
        await context.repo.blocks.put(updatedCid, updatedBlock);
      }
    } else {
      if (cid.code !== code$8) {
        throw errCode(new Error(`${path2} was not a UnixFS node`), "ERR_NOT_UNIXFS");
      }
      cidVersion = cid.version;
      const block = await context.repo.blocks.get(cid);
      const node2 = decode$i(block);
      if (!node2.Data) {
        throw errCode(new Error(`${path2} had no data`), "ERR_INVALID_NODE");
      }
      const metadata = UnixFS.unmarshal(node2.Data);
      metadata.mtime = settings.mtime;
      updatedBlock = encode$o({
        Data: metadata.marshal(),
        Links: node2.Links
      });
      const hash2 = await hasher.digest(updatedBlock);
      updatedCid = CID.create(settings.cidVersion, code$8, hash2);
      if (settings.flush) {
        await context.repo.blocks.put(updatedCid, updatedBlock);
      }
    }
    const trail = await toTrail(context, mfsDirectory);
    const parent2 = trail[trail.length - 1];
    const parentCid = parent2.cid;
    const parentBlock = await context.repo.blocks.get(parentCid);
    const parentNode = decode$i(parentBlock);
    const result = await addLink(context, {
      parent: parentNode,
      name: name2,
      cid: updatedCid,
      size: updatedBlock.length,
      flush: settings.flush,
      shardSplitThreshold: settings.shardSplitThreshold,
      hashAlg: settings.hashAlg,
      cidVersion
    });
    parent2.cid = result.cid;
    const newRootCid = await updateTree(context, trail, settings);
    await updateMfsRoot(context, newRootCid, settings);
  }
  return withTimeoutOption(mfsTouch);
}
const mergeOptions$4 = mergeOptions$g.bind({ ignoreUndefined: true });
const defaultOptions$8 = {
  offset: 0,
  length: Infinity
};
function createRead$1(context) {
  function mfsRead(path2, options = {}) {
    options = mergeOptions$4(defaultOptions$8, options);
    return {
      [Symbol.asyncIterator]: async function* read2() {
        const mfsPath = await toMfsPath(context, path2, options);
        const result = await exporter(mfsPath.mfsPath, context.repo.blocks);
        if (result.type !== "file") {
          throw errCode(new Error(`${path2} was not a file`), "ERR_NOT_FILE");
        }
        if (!result.content) {
          throw errCode(new Error(`Could not load content stream from ${path2}`), "ERR_NO_CONTENT");
        }
        for await (const buf2 of result.content({
          offset: options.offset,
          length: options.length
        })) {
          yield buf2;
        }
      }
    };
  }
  return withTimeoutOption(mfsRead);
}
const log$16 = logger$1("ipfs:mfs:utils:to-async-iterator");
function toAsyncIterator(content) {
  if (!content) {
    throw errCode(new Error("paths must start with a leading slash"), "ERR_INVALID_PATH");
  }
  if (typeof content === "string" || content instanceof String) {
    log$16("Content was a string");
    content = fromString$3(content.toString());
  }
  if (content.length) {
    log$16("Content was array-like");
    return {
      [Symbol.asyncIterator]: function* bufferContent() {
        yield content;
      }
    };
  }
  if (content[Symbol.asyncIterator]) {
    log$16("Content was an async iterator");
    return content;
  }
  if (content[Symbol.iterator]) {
    log$16("Content was an iterator");
    return content;
  }
  if (globalThis.Blob && content instanceof globalThis.Blob) {
    log$16("Content was an HTML5 Blob");
    let index = 0;
    const iterator2 = {
      next: () => {
        if (index > content.size) {
          return {
            done: true
          };
        }
        return new Promise((resolve2, reject) => {
          const chunk = content.slice(index, MFS_MAX_CHUNK_SIZE);
          index += MFS_MAX_CHUNK_SIZE;
          const reader2 = new globalThis.FileReader();
          const handleLoad = (ev) => {
            reader2.removeEventListener("loadend", handleLoad, false);
            if (ev.error) {
              return reject(ev.error);
            }
            resolve2({
              done: false,
              value: new Uint8Array(reader2.result)
            });
          };
          reader2.addEventListener("loadend", handleLoad);
          reader2.readAsArrayBuffer(chunk);
        });
      }
    };
    return {
      [Symbol.asyncIterator]: () => {
        return iterator2;
      }
    };
  }
  throw errCode(new Error(`Don't know how to convert ${content} into an async iterator`), "ERR_INVALID_PARAMS");
}
const mergeOptions$3 = mergeOptions$g.bind({ ignoreUndefined: true });
const log$15 = logger$1("ipfs:mfs:write");
const defaultOptions$7 = {
  offset: 0,
  length: Infinity,
  create: false,
  truncate: false,
  rawLeaves: false,
  reduceSingleLeafToSelf: false,
  cidVersion: 0,
  hashAlg: "sha2-256",
  parents: false,
  progress: (bytes2, path2) => {
  },
  strategy: "trickle",
  flush: true,
  leafType: "raw",
  shardSplitThreshold: 1e3
};
function createWrite$1(context) {
  async function mfsWrite(path2, content, opts = {}) {
    const options = mergeOptions$3(defaultOptions$7, opts);
    let source2;
    let destination;
    let parent2;
    log$15("Reading source, destination and parent");
    await createLock().readLock(async () => {
      source2 = await toAsyncIterator(content);
      destination = await toMfsPath(context, path2, options);
      parent2 = await toMfsPath(context, destination.mfsDirectory, options);
    })();
    log$15("Read source, destination and parent");
    if (!options.parents && !parent2.exists) {
      throw errCode(new Error("directory does not exist"), "ERR_NO_EXIST");
    }
    if (source2 == null) {
      throw errCode(new Error("could not create source"), "ERR_NO_SOURCE");
    }
    if (destination == null) {
      throw errCode(new Error("could not create destination"), "ERR_NO_DESTINATION");
    }
    if (!options.create && !destination.exists) {
      throw errCode(new Error("file does not exist"), "ERR_NO_EXIST");
    }
    if (destination.entryType !== "file") {
      throw errCode(new Error("not a file"), "ERR_NOT_A_FILE");
    }
    return updateOrImport(context, path2, source2, destination, options);
  }
  return withTimeoutOption(mfsWrite);
}
const updateOrImport = async (context, path2, source2, destination, options) => {
  const child = await write$1(context, source2, destination, options);
  await createLock().writeLock(async () => {
    const pathComponents = toPathComponents(path2);
    const fileName = pathComponents.pop();
    if (fileName == null) {
      throw errCode(new Error("source does not exist"), "ERR_NO_EXIST");
    }
    let parentExists = false;
    try {
      await createStat$7(context)(`/${pathComponents.join("/")}`, options);
      parentExists = true;
    } catch (err2) {
      if (err2.code !== "ERR_NOT_FOUND") {
        throw err2;
      }
    }
    if (!parentExists) {
      await createMkdir$1(context)(`/${pathComponents.join("/")}`, options);
    }
    const updatedPath = await toMfsPath(context, path2, options);
    const trail = await toTrail(context, updatedPath.mfsDirectory);
    const parent2 = trail[trail.length - 1];
    if (!parent2) {
      throw errCode(new Error("directory does not exist"), "ERR_NO_EXIST");
    }
    if (!parent2.type || !parent2.type.includes("directory")) {
      throw errCode(new Error(`cannot write to ${parent2.name}: Not a directory`), "ERR_NOT_A_DIRECTORY");
    }
    const parentBlock = await context.repo.blocks.get(parent2.cid);
    const parentNode = decode$i(parentBlock);
    const result = await addLink(context, {
      parent: parentNode,
      name: fileName,
      cid: child.cid,
      size: child.size,
      flush: options.flush,
      shardSplitThreshold: options.shardSplitThreshold,
      hashAlg: options.hashAlg,
      cidVersion: options.cidVersion
    });
    parent2.cid = result.cid;
    const newRootCid = await updateTree(context, trail, options);
    await updateMfsRoot(context, newRootCid, options);
  })();
};
const write$1 = async (context, source2, destination, options) => {
  if (destination.exists) {
    log$15(`Overwriting file ${destination.cid} offset ${options.offset} length ${options.length}`);
  } else {
    log$15(`Writing file offset ${options.offset} length ${options.length}`);
  }
  const sources = [];
  if (options.offset > 0) {
    if (destination.unixfs) {
      log$15(`Writing first ${options.offset} bytes of original file`);
      sources.push(
        () => {
          return destination.content({
            offset: 0,
            length: options.offset
          });
        }
      );
      if (destination.unixfs.fileSize() < options.offset) {
        const extra = options.offset - destination.unixfs.fileSize();
        log$15(`Writing zeros for extra ${extra} bytes`);
        sources.push(
          asyncZeroes(extra)
        );
      }
    } else {
      log$15(`Writing zeros for first ${options.offset} bytes`);
      sources.push(
        asyncZeroes(options.offset)
      );
    }
  }
  sources.push(
    limitAsyncStreamBytes(source2, options.length)
  );
  const content = countBytesStreamed(catAsyncIterators(sources), (bytesWritten) => {
    if (destination.unixfs && !options.truncate) {
      const fileSize = destination.unixfs.fileSize();
      if (fileSize > bytesWritten) {
        log$15(`Writing last ${fileSize - bytesWritten} of ${fileSize} bytes from original file starting at offset ${bytesWritten}`);
        return destination.content({
          offset: bytesWritten
        });
      } else {
        log$15("Not writing last bytes from original file");
      }
    }
    return {
      [Symbol.asyncIterator]: async function* () {
      }
    };
  });
  let mode;
  if (options.mode !== void 0 && options.mode !== null) {
    mode = parseMode(options.mode);
  } else if (destination && destination.unixfs) {
    mode = destination.unixfs.mode;
  }
  let mtime;
  if (options.mtime != null) {
    mtime = parseMtime$1(options.mtime);
  } else if (destination && destination.unixfs) {
    mtime = destination.unixfs.mtime;
  }
  const hasher = await context.hashers.getHasher(options.hashAlg);
  const result = await last(importer([{
    content,
    mode,
    mtime
  }], context.repo.blocks, {
    progress: options.progress,
    hasher,
    cidVersion: options.cidVersion,
    strategy: options.strategy,
    rawLeaves: options.rawLeaves,
    reduceSingleLeafToSelf: options.reduceSingleLeafToSelf,
    leafType: options.leafType
  }));
  if (!result) {
    throw errCode(new Error(`cannot write to ${parent.name}`), "ERR_COULD_NOT_WRITE");
  }
  log$15(`Wrote ${result.cid}`);
  return {
    cid: result.cid,
    size: result.size
  };
};
const limitAsyncStreamBytes = (stream2, limit) => {
  return async function* _limitAsyncStreamBytes() {
    let emitted = 0;
    for await (const buf2 of stream2) {
      emitted += buf2.length;
      if (emitted > limit) {
        yield buf2.subarray(0, limit - emitted);
        return;
      }
      yield buf2;
    }
  };
};
const asyncZeroes = (count, chunkSize = MFS_MAX_CHUNK_SIZE) => {
  const buf2 = new Uint8Array(chunkSize);
  async function* _asyncZeroes() {
    while (true) {
      yield buf2;
    }
  }
  return limitAsyncStreamBytes(_asyncZeroes(), count);
};
const catAsyncIterators = async function* (sources) {
  for (let i2 = 0; i2 < sources.length; i2++) {
    yield* sources[i2]();
  }
};
const countBytesStreamed = async function* (source2, notify) {
  let wrote = 0;
  for await (const buf2 of source2) {
    wrote += buf2.length;
    yield buf2;
  }
  for await (const buf2 of notify(wrote)) {
    wrote += buf2.length;
    yield buf2;
  }
};
const toOutput = (fsEntry) => {
  const output = {
    cid: fsEntry.cid,
    name: fsEntry.name,
    type: fsEntry.type === "directory" ? "directory" : "file",
    size: fsEntry.size
  };
  if (fsEntry.type === "file" || fsEntry.type === "directory") {
    output.mode = fsEntry.unixfs.mode;
    output.mtime = fsEntry.unixfs.mtime;
  }
  return output;
};
function createLs$7(context) {
  async function* mfsLs(path2, options = {}) {
    const mfsPath = await toMfsPath(context, path2, options);
    const fsEntry = await exporter(mfsPath.mfsPath, context.repo.blocks);
    if (fsEntry.type === "directory") {
      yield* map$3(fsEntry.content(options), toOutput);
      return;
    }
    yield toOutput(fsEntry);
  }
  return withTimeoutOption(mfsLs);
}
const readOperations = {
  stat: createStat$7
};
const writeOperations = {
  chmod: createChmod$1,
  cp: createCp$1,
  flush: createFlush$1,
  mkdir: createMkdir$1,
  mv: createMv$1,
  rm: createRm$8,
  touch: createTouch$1
};
const unwrappedOperations = {
  write: createWrite$1,
  read: createRead$1,
  ls: createLs$7
};
const wrap = ({
  options,
  mfs,
  operations,
  lock: lock2
}) => {
  Object.keys(operations).forEach((key) => {
    mfs[key] = lock2(operations[key](options));
  });
};
const defaultOptions$6 = {
  repoOwner: true,
  repo: null
};
function createMfs(options) {
  const {
    repoOwner
  } = Object.assign({}, defaultOptions$6 || {}, options);
  const lock2 = createLock(repoOwner);
  const readLock = (operation) => {
    return lock2.readLock(operation);
  };
  const writeLock = (operation) => {
    return lock2.writeLock(operation);
  };
  const mfs = {};
  wrap({
    options,
    mfs,
    operations: readOperations,
    lock: readLock
  });
  wrap({
    options,
    mfs,
    operations: writeOperations,
    lock: writeLock
  });
  Object.keys(unwrappedOperations).forEach((key) => {
    mfs[key] = unwrappedOperations[key](options);
  });
  return mfs;
}
function createFiles$1({ repo, preload: preload2, hashers, options: constructorOptions }) {
  const methods2 = createMfs({
    repo,
    repoOwner: constructorOptions.repoOwner !== false,
    hashers
  });
  const withPreload = (fn) => {
    const wrapped = (...args) => {
      const paths = args.filter((arg) => ipfsPath$1(arg) || isCID(arg));
      if (paths.length) {
        const options = args[args.length - 1];
        if (options && options.preload !== false) {
          paths.forEach((path2) => preload2(path2));
        }
      }
      return fn(...args);
    };
    return wrapped;
  };
  return {
    ...methods2,
    chmod: methods2.chmod,
    cp: withPreload(methods2.cp),
    mkdir: methods2.mkdir,
    stat: withPreload(methods2.stat),
    rm: methods2.rm,
    read: withPreload(methods2.read),
    touch: methods2.touch,
    write: methods2.write,
    mv: withPreload(methods2.mv),
    flush: methods2.flush,
    ls: withPreload(async function* (...args) {
      for await (const file of methods2.ls(...args)) {
        yield { ...file, size: file.size || 0 };
      }
    })
  };
}
function createExport$2({ keychain }) {
  const exportKey2 = (name2, password) => keychain.exportKey(name2, password);
  return withTimeoutOption(exportKey2);
}
const DEFAULT_KEY_TYPE = "Ed25519";
const DEFAULT_KEY_SIZE = 2048;
function createGen$1({ keychain }) {
  const gen = (name2, options = { type: DEFAULT_KEY_TYPE, size: DEFAULT_KEY_SIZE }) => {
    return keychain.createKey(name2, options.type || DEFAULT_KEY_TYPE, options.size || DEFAULT_KEY_SIZE);
  };
  return withTimeoutOption(gen);
}
function createImport$2({ keychain }) {
  const importKey2 = (name2, pem2, password) => {
    return keychain.importKey(name2, pem2, password);
  };
  return withTimeoutOption(importKey2);
}
function createInfo$1({ keychain }) {
  const info = (name2) => keychain.findKeyByName(name2);
  return withTimeoutOption(info);
}
function createList$3({ keychain }) {
  const list = () => keychain.listKeys();
  return withTimeoutOption(list);
}
function createRename$1({ keychain }) {
  const rename = async (oldName, newName) => {
    const key = await keychain.renameKey(oldName, newName);
    return {
      was: oldName,
      now: key.name,
      id: key.id,
      overwrite: false
    };
  };
  return withTimeoutOption(rename);
}
function createRm$7({ keychain }) {
  const rm = (name2) => keychain.removeKey(name2);
  return withTimeoutOption(rm);
}
class KeyAPI {
  constructor({ keychain }) {
    this.gen = createGen$1({ keychain });
    this.list = createList$3({ keychain });
    this.rm = createRm$7({ keychain });
    this.rename = createRename$1({ keychain });
    this.export = createExport$2({ keychain });
    this.import = createImport$2({ keychain });
    this.info = createInfo$1({ keychain });
  }
}
function createGet$6({ repo, preload: preload2 }) {
  async function get3(cid, options = {}) {
    if (options.preload !== false) {
      preload2(cid);
    }
    const block = await repo.blocks.get(cid, options);
    return decode$i(block);
  }
  return withTimeoutOption(get3);
}
function createData$1({ repo, preload: preload2 }) {
  const get3 = createGet$6({ repo, preload: preload2 });
  async function data(multihash, options = {}) {
    const node2 = await get3(multihash, options);
    return node2.Data || new Uint8Array(0);
  }
  return withTimeoutOption(data);
}
function findLinks(node2, links2 = []) {
  for (const key in node2) {
    const val = node2[key];
    if (key === "/" && Object.keys(node2).length === 1) {
      try {
        links2.push({
          Name: "",
          Tsize: 0,
          Hash: CID.parse(val)
        });
        continue;
      } catch (_) {
      }
    }
    const cid = CID.asCID(val);
    if (cid) {
      links2.push({
        Name: "",
        Tsize: 0,
        Hash: cid
      });
      continue;
    }
    if (Array.isArray(val)) {
      findLinks(val, links2);
    }
    if (val && typeof val === "object") {
      findLinks(val, links2);
    }
  }
  return links2;
}
function createLinks$1({ repo, codecs: codecs2 }) {
  async function links2(cid, options = {}) {
    const codec = await codecs2.getCodec(cid.code);
    const block = await repo.blocks.get(cid, options);
    const node2 = codec.decode(block);
    switch (cid.code) {
      case code$3:
        return [];
      case code$8:
        return node2.Links;
      case code$7:
      case code$6:
        return findLinks(node2);
      default:
        throw new Error(`Cannot resolve links from codec ${cid.code}`);
    }
  }
  return withTimeoutOption(links2);
}
function createNew$1({ repo, preload: preload2 }) {
  async function _new(options = {}) {
    let data;
    if (options.template) {
      if (options.template === "unixfs-dir") {
        data = new UnixFS({ type: "directory" }).marshal();
      } else {
        throw new Error("unknown template");
      }
    }
    const buf2 = encode$o({
      Data: data,
      Links: []
    });
    const hash2 = await sha256$3.digest(buf2);
    const cid = CID.createV0(hash2);
    await repo.blocks.put(cid, buf2, {
      signal: options.signal
    });
    if (options.preload !== false) {
      preload2(cid);
    }
    return cid;
  }
  return withTimeoutOption(_new);
}
function createPut$4({ repo, preload: preload2 }) {
  async function put(obj, options = {}) {
    const release = await repo.gcLock.readLock();
    try {
      const buf2 = encode$o(obj);
      const hash2 = await sha256$3.digest(buf2);
      const cid = CID.createV1(code$8, hash2);
      await repo.blocks.put(cid, buf2, {
        signal: options.signal
      });
      if (options.preload !== false) {
        preload2(cid);
      }
      if (options.pin) {
        await repo.pins.pinRecursively(cid, {
          signal: options.signal
        });
      }
      return cid;
    } finally {
      release();
    }
  }
  return withTimeoutOption(put);
}
function createStat$6({ repo, preload: preload2 }) {
  const get3 = createGet$6({ repo, preload: preload2 });
  async function stat(cid, options = {}) {
    const node2 = await get3(cid, options);
    const serialized = encode$o(node2);
    const blockSize = serialized.length;
    const linkLength = node2.Links.reduce((a, l) => a + (l.Tsize || 0), 0);
    return {
      Hash: cid,
      NumLinks: node2.Links.length,
      BlockSize: blockSize,
      LinksSize: blockSize - (node2.Data || []).length,
      DataSize: (node2.Data || []).length,
      CumulativeSize: blockSize + linkLength
    };
  }
  return withTimeoutOption(stat);
}
function createAddLink$1({ repo, preload: preload2 }) {
  const get3 = createGet$6({ repo, preload: preload2 });
  const put = createPut$4({ repo, preload: preload2 });
  async function addLink2(cid, link, options = {}) {
    const node2 = await get3(cid, options);
    return put({
      ...node2,
      Links: node2.Links.concat([link])
    }, options);
  }
  return withTimeoutOption(addLink2);
}
function createAppendData$1({ repo, preload: preload2 }) {
  const get3 = createGet$6({ repo, preload: preload2 });
  const put = createPut$4({ repo, preload: preload2 });
  async function appendData(cid, data, options = {}) {
    const node2 = await get3(cid, options);
    const newData = concat$1([node2.Data || [], data]);
    return put({
      ...node2,
      Data: newData
    }, options);
  }
  return withTimeoutOption(appendData);
}
function createRmLink$1({ repo, preload: preload2 }) {
  const get3 = createGet$6({ repo, preload: preload2 });
  const put = createPut$4({ repo, preload: preload2 });
  async function rmLink(cid, link, options = {}) {
    const node2 = await get3(cid, options);
    const name2 = (typeof link === "string" ? link : link.Name) || "";
    node2.Links = node2.Links.filter((l) => l.Name !== name2);
    return put(node2, options);
  }
  return withTimeoutOption(rmLink);
}
function createSetData$1({ repo, preload: preload2 }) {
  const get3 = createGet$6({ repo, preload: preload2 });
  const put = createPut$4({ repo, preload: preload2 });
  async function setData(cid, data, options = {}) {
    const node2 = await get3(cid, options);
    return put({
      ...node2,
      Data: data
    }, options);
  }
  return withTimeoutOption(setData);
}
class ObjectPatchAPI {
  constructor({ repo, preload: preload2 }) {
    this.addLink = createAddLink$1({ repo, preload: preload2 });
    this.appendData = createAppendData$1({ repo, preload: preload2 });
    this.rmLink = createRmLink$1({ repo, preload: preload2 });
    this.setData = createSetData$1({ repo, preload: preload2 });
  }
}
class ObjectAPI {
  constructor({ repo, codecs: codecs2, preload: preload2 }) {
    this.data = createData$1({ repo, preload: preload2 });
    this.get = createGet$6({ repo, preload: preload2 });
    this.links = createLinks$1({ repo, codecs: codecs2 });
    this.new = createNew$1({ repo, preload: preload2 });
    this.put = createPut$4({ repo, preload: preload2 });
    this.stat = createStat$6({ repo, preload: preload2 });
    this.patch = new ObjectPatchAPI({ repo, preload: preload2 });
  }
}
const log$14 = logger$1("ipfs:repo:gc");
function createGc$1({ repo, hashers }) {
  async function* gc2(options = {}) {
    const start = Date.now();
    let mfsRootCid;
    try {
      mfsRootCid = await loadMfsRoot({
        repo,
        hashers
      }, options);
      await repo.pins.pinRecursively(mfsRootCid);
      yield* repo.gc();
    } finally {
      if (mfsRootCid) {
        await repo.pins.unpin(mfsRootCid);
      }
    }
    log$14(`Complete (${Date.now() - start}ms)`);
  }
  return withTimeoutOption(gc2);
}
function createStat$5({ repo }) {
  async function stat(options = {}) {
    const stats = await repo.stat();
    return {
      numObjects: BigInt(stats.numObjects.toString()),
      repoSize: BigInt(stats.repoSize.toString()),
      repoPath: stats.repoPath,
      version: `${stats.version}`,
      storageMax: BigInt(stats.storageMax.toString())
    };
  }
  return withTimeoutOption(stat);
}
const repoVersion = 12;
function createVersion$2({ repo }) {
  async function version2(options = {}) {
    try {
      await repo._checkInitialized(options);
    } catch (err2) {
      const match = [
        /Key not found in database \[\/version\]/,
        /ENOENT/,
        /repo is not initialized yet/
      ].some((m) => {
        return m.test(err2.message);
      });
      if (match) {
        return repoVersion;
      }
      throw err2;
    }
    return repo.version.get();
  }
  return withTimeoutOption(version2);
}
class RepoAPI {
  constructor({ repo, hashers }) {
    this.gc = createGc$1({ repo, hashers });
    this.stat = createStat$5({ repo });
    this.version = createVersion$2({ repo });
    this.setApiAddr = (addr) => repo.apiAddr.set(addr);
  }
}
function getBandwidthStats(libp2p, opts) {
  let stats;
  if (!libp2p.metrics) {
    stats = void 0;
  } else if (opts.peer) {
    stats = libp2p.metrics.forPeer(opts.peer);
  } else if (opts.proto) {
    stats = libp2p.metrics.forProtocol(opts.proto);
  } else {
    stats = libp2p.metrics.getGlobal();
  }
  if (!stats) {
    return {
      totalIn: BigInt(0),
      totalOut: BigInt(0),
      rateIn: 0,
      rateOut: 0
    };
  }
  const movingAverages = stats.getMovingAverages();
  const snapshot = stats.getSnapshot();
  return {
    totalIn: snapshot.dataReceived,
    totalOut: snapshot.dataSent,
    rateIn: movingAverages.dataReceived[6e4].movingAverage / 60,
    rateOut: movingAverages.dataSent[6e4].movingAverage / 60
  };
}
function createBw$1({ network }) {
  const bw = async function* (options = {}) {
    const { libp2p } = await network.use(options);
    if (!options.poll) {
      yield getBandwidthStats(libp2p, options);
      return;
    }
    const interval = options.interval || 1e3;
    let ms2 = -1;
    try {
      ms2 = typeof interval === "string" ? parse$3(interval) || -1 : interval;
      if (!ms2 || ms2 < 0)
        throw new Error("invalid duration");
    } catch (err2) {
      throw errCode(err2, "ERR_INVALID_POLL_INTERVAL");
    }
    let timeoutId;
    try {
      while (true) {
        yield getBandwidthStats(libp2p, options);
        await new Promise((resolve2) => {
          timeoutId = setTimeout(resolve2, ms2);
        });
      }
    } finally {
      clearTimeout(timeoutId);
    }
  };
  return withTimeoutOption(bw);
}
class StatsAPI {
  constructor({ repo, network }) {
    this.repo = createStat$5({ repo });
    this.bw = createBw$1({ network });
    this.bitswap = createStat$9({ network });
  }
}
var objectSafeGet = get;
function get(obj, propsArg, defaultValue) {
  if (!obj) {
    return defaultValue;
  }
  var props, prop;
  if (Array.isArray(propsArg)) {
    props = propsArg.slice(0);
  }
  if (typeof propsArg == "string") {
    props = propsArg.split(".");
  }
  if (typeof propsArg == "symbol") {
    props = [propsArg];
  }
  if (!Array.isArray(props)) {
    throw new Error("props arg must be an array, a string or a symbol");
  }
  while (props.length) {
    prop = props.shift();
    if (!obj) {
      return defaultValue;
    }
    obj = obj[prop];
    if (obj === void 0) {
      return defaultValue;
    }
  }
  return obj;
}
async function length$3(iterator2) {
  let count = 0;
  for await (const _ of iterator2) {
    count++;
  }
  return count;
}
const log$13 = debug("ipfs:repo:migrator:migration-8");
function unwrap$1(blockstore) {
  if (blockstore.child) {
    return unwrap$1(blockstore.child);
  }
  return blockstore;
}
function keyToMultihash$1(key) {
  try {
    const buf2 = base32$2.decode(`b${key.toString().toLowerCase().slice(1)}`);
    const multihash = CID.decode(buf2).multihash.bytes;
    const multihashStr = base32$2.encode(multihash).slice(1).toUpperCase();
    return new Key(`/${multihashStr}`, false);
  } catch (err2) {
    return key;
  }
}
function keyToCid$1(key) {
  try {
    const buf2 = base32$2.decode(`b${key.toString().toLowerCase().slice(1)}`);
    const digest2 = decode$j(buf2);
    const multihash = base32$2.encode(CID.createV1(code$3, digest2).bytes).slice(1);
    return new Key(`/${multihash.toUpperCase()}`, false);
  } catch {
    return key;
  }
}
async function process$3(backends, onProgress, keyFunction) {
  const blockstore = backends.blocks;
  await blockstore.open();
  const unwrapped = unwrap$1(blockstore);
  const blockCount = await length$3(unwrapped.queryKeys({
    filters: [(key) => {
      const newKey = keyFunction(key);
      return newKey.toString() !== key.toString();
    }]
  }));
  try {
    let counter2 = 0;
    for await (const block of unwrapped.query({})) {
      const newKey = keyFunction(block.key);
      if (newKey.toString() !== block.key.toString()) {
        counter2 += 1;
        log$13(`Migrating Block from ${block.key} to ${newKey}`, await unwrapped.has(block.key));
        await unwrapped.delete(block.key);
        await unwrapped.put(newKey, block.value);
        onProgress(counter2 / blockCount * 100, `Migrated Block from ${block.key} to ${newKey}`);
      }
    }
  } finally {
    await blockstore.close();
  }
}
const migration$4 = {
  version: 8,
  description: "Transforms key names into base32 encoding and converts Block store to use bare multihashes encoded as base32",
  migrate: (backends, onProgress = () => {
  }) => {
    return process$3(backends, onProgress, keyToMultihash$1);
  },
  revert: (backends, onProgress = () => {
  }) => {
    return process$3(backends, onProgress, keyToCid$1);
  }
};
const $Reader$6 = $protobuf.Reader, $Writer$6 = $protobuf.Writer;
$protobuf.util;
const $root$6 = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
const ipfs$1 = $root$6.ipfs = (() => {
  const ipfs2 = {};
  ipfs2.pin = function() {
    const pin = {};
    pin.Set = function() {
      function Set2(p) {
        if (p) {
          for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
            if (p[ks[i2]] != null)
              this[ks[i2]] = p[ks[i2]];
        }
      }
      Set2.prototype.version = 0;
      Set2.prototype.fanout = 0;
      Set2.prototype.seed = 0;
      Set2.encode = function encode3(m, w) {
        if (!w)
          w = $Writer$6.create();
        if (m.version != null && Object.hasOwnProperty.call(m, "version"))
          w.uint32(8).uint32(m.version);
        if (m.fanout != null && Object.hasOwnProperty.call(m, "fanout"))
          w.uint32(16).uint32(m.fanout);
        if (m.seed != null && Object.hasOwnProperty.call(m, "seed"))
          w.uint32(29).fixed32(m.seed);
        return w;
      };
      Set2.decode = function decode3(r, l) {
        if (!(r instanceof $Reader$6))
          r = $Reader$6.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root$6.ipfs.pin.Set();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.version = r.uint32();
              break;
            case 2:
              m.fanout = r.uint32();
              break;
            case 3:
              m.seed = r.fixed32();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      Set2.fromObject = function fromObject(d) {
        if (d instanceof $root$6.ipfs.pin.Set)
          return d;
        var m = new $root$6.ipfs.pin.Set();
        if (d.version != null) {
          m.version = d.version >>> 0;
        }
        if (d.fanout != null) {
          m.fanout = d.fanout >>> 0;
        }
        if (d.seed != null) {
          m.seed = d.seed >>> 0;
        }
        return m;
      };
      Set2.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          d.version = 0;
          d.fanout = 0;
          d.seed = 0;
        }
        if (m.version != null && m.hasOwnProperty("version")) {
          d.version = m.version;
        }
        if (m.fanout != null && m.hasOwnProperty("fanout")) {
          d.fanout = m.fanout;
        }
        if (m.seed != null && m.hasOwnProperty("seed")) {
          d.seed = m.seed;
        }
        return d;
      };
      Set2.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return Set2;
    }();
    return pin;
  }();
  return ipfs2;
})();
var fnv1a$1 = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  hash2.BASE = 2166136261;
  function hash2(s2, h = hash2.BASE) {
    const l = s2.length;
    for (let i2 = 0; i2 < l; i2++) {
      h ^= s2.charCodeAt(i2);
      h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24);
    }
    return h >>> 0;
  }
  exports.default = hash2;
  module.exports = hash2;
})(fnv1a$1, fnv1a$1.exports);
const fnv1a = /* @__PURE__ */ getDefaultExportFromCjs(fnv1a$1.exports);
const PIN_DS_KEY = new Key("/local/pins");
const DEFAULT_FANOUT = 256;
const MAX_ITEMS = 8192;
const EMPTY_KEY = CID.parse("QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n");
const PinTypes = {
  direct: "direct",
  recursive: "recursive"
};
function cidToKey$2(cid) {
  return new Key(`/${base32$2.encode(cid.multihash.bytes).toUpperCase().substring(1)}`);
}
const PinSet = ipfs$1.pin.Set;
function readHeader(rootNode) {
  const rootData = rootNode.Data;
  if (!rootData) {
    throw new Error("No data present");
  }
  const hdrLength = varint$3.decode(rootData);
  const vBytes = varint$3.decode.bytes;
  if (vBytes <= 0) {
    throw new Error("Invalid Set header length");
  }
  if (vBytes + hdrLength > rootData.length) {
    throw new Error("Impossibly large set header length");
  }
  const hdrSlice = rootData.slice(vBytes, hdrLength + vBytes);
  const header = PinSet.toObject(PinSet.decode(hdrSlice), {
    defaults: false,
    arrays: true,
    longs: Number,
    objects: false
  });
  if (header.version !== 1) {
    throw new Error(`Unsupported Set version: ${header.version}`);
  }
  if (header.fanout > rootNode.Links.length) {
    throw new Error("Impossibly large fanout");
  }
  return {
    header,
    data: rootData.slice(hdrLength + vBytes)
  };
}
function hash$1(seed2, key) {
  const buffer2 = new Uint8Array(4);
  const dataView2 = new DataView(buffer2.buffer);
  dataView2.setUint32(0, seed2, true);
  const encodedKey = fromString$3(key.toString());
  const data = concat$1([buffer2, encodedKey], buffer2.byteLength + encodedKey.byteLength);
  return fnv1a(toString$5(data));
}
async function* walkItems(blockstore, node2) {
  const pbh = readHeader(node2);
  let idx = 0;
  for (const link of node2.Links) {
    if (idx < pbh.header.fanout) {
      const linkHash = link.Hash;
      if (!EMPTY_KEY.equals(linkHash)) {
        const buf2 = await blockstore.get(linkHash);
        const node3 = decode$i(buf2);
        yield* walkItems(blockstore, node3);
      }
    } else {
      yield link.Hash;
    }
    idx++;
  }
}
async function* loadSet(blockstore, rootNode, name2) {
  const link = rootNode.Links.find((l) => l.Name === name2);
  if (!link) {
    throw new Error("No link found with name " + name2);
  }
  const buf2 = await blockstore.get(link.Hash);
  const node2 = decode$i(buf2);
  yield* walkItems(blockstore, node2);
}
function storeItems(blockstore, items) {
  return storePins(items, 0);
  async function storePins(pins, depth) {
    const pbHeader = PinSet.encode({
      version: 1,
      fanout: DEFAULT_FANOUT,
      seed: depth
    }).finish();
    const header = varint$3.encode(pbHeader.length);
    const headerBuf = concat$1([header, pbHeader]);
    const fanoutLinks = [];
    for (let i2 = 0; i2 < DEFAULT_FANOUT; i2++) {
      fanoutLinks.push({
        Name: "",
        Tsize: 1,
        Hash: EMPTY_KEY
      });
    }
    if (pins.length <= MAX_ITEMS) {
      const nodes = pins.map((item) => {
        return {
          link: {
            Name: "",
            Tsize: 1,
            Hash: item.key
          },
          data: item.data || new Uint8Array()
        };
      }).sort((a, b2) => {
        return compare$1(a.link.Hash.bytes, b2.link.Hash.bytes);
      });
      const rootLinks = fanoutLinks.concat(nodes.map((item) => item.link));
      const rootData = concat$1([headerBuf, ...nodes.map((item) => item.data)]);
      return {
        Data: rootData,
        Links: rootLinks
      };
    } else {
      const bins = pins.reduce((bins2, pin) => {
        const n = hash$1(depth, pin.key) % DEFAULT_FANOUT;
        bins2[n] = n in bins2 ? bins2[n].concat([pin]) : [pin];
        return bins2;
      }, []);
      let idx = 0;
      for (const bin of bins) {
        const child = await storePins(bin, depth + 1);
        await storeChild(child, idx);
        idx++;
      }
      return {
        Data: headerBuf,
        Links: fanoutLinks
      };
    }
    async function storeChild(child, binIdx) {
      const buf2 = encode$o(child);
      const digest2 = await sha256$3.digest(buf2);
      const cid = CID.createV0(digest2);
      await blockstore.put(cid, buf2);
      const size2 = child.Links.reduce((acc, curr) => acc + (curr.Tsize || 0), 0) + buf2.length;
      fanoutLinks[binIdx] = {
        Name: "",
        Tsize: size2,
        Hash: cid
      };
    }
  }
}
async function storeSet(blockstore, type, cids) {
  const rootNode = await storeItems(blockstore, cids.map((cid2) => {
    return {
      key: cid2
    };
  }));
  const buf2 = encode$o(rootNode);
  const digest2 = await sha256$3.digest(buf2);
  const cid = CID.createV0(digest2);
  await blockstore.put(cid, buf2);
  const size2 = rootNode.Links.reduce((acc, curr) => acc + curr.Tsize, 0) + buf2.length;
  return {
    Name: type,
    Tsize: size2,
    Hash: cid
  };
}
async function pinsToDatastore(blockstore, datastore, pinstore, onProgress) {
  if (!await datastore.has(PIN_DS_KEY)) {
    return;
  }
  const mh = await datastore.get(PIN_DS_KEY);
  const cid = CID.decode(mh);
  const pinRootBuf = await blockstore.get(cid);
  const pinRoot = decode$i(pinRootBuf);
  let counter2 = 0;
  const pinCount = await length$3(loadSet(blockstore, pinRoot, PinTypes.recursive)) + await length$3(loadSet(blockstore, pinRoot, PinTypes.direct));
  for await (const cid2 of loadSet(blockstore, pinRoot, PinTypes.recursive)) {
    counter2++;
    const pin = {
      depth: Infinity
    };
    if (cid2.version !== 0) {
      pin.version = cid2.version;
    }
    if (cid2.code !== code$8) {
      pin.codec = cid2.code;
    }
    await pinstore.put(cidToKey$2(cid2), encode$n(pin));
    onProgress(counter2 / pinCount * 100, `Migrated recursive pin ${cid2}`);
  }
  for await (const cid2 of loadSet(blockstore, pinRoot, PinTypes.direct)) {
    counter2++;
    const pin = {
      depth: 0
    };
    if (cid2.version !== 0) {
      pin.version = cid2.version;
    }
    if (cid2.code !== code$8) {
      pin.codec = cid2.code;
    }
    await pinstore.put(cidToKey$2(cid2), encode$n(pin));
    onProgress(counter2 / pinCount * 100, `Migrated direct pin ${cid2}`);
  }
  await blockstore.delete(cid);
  await datastore.delete(PIN_DS_KEY);
}
async function pinsToDAG(blockstore, datastore, pinstore, onProgress) {
  const recursivePins = [];
  const directPins = [];
  let counter2 = 0;
  const pinCount = await length$3(pinstore.queryKeys({}));
  for await (const { key, value: value2 } of pinstore.query({})) {
    counter2++;
    const pin = decode$h(value2);
    const cid2 = CID.create(
      pin.version || 0,
      pin.codec || code$8,
      decode$j(base32$2.decode("b" + key.toString().toLowerCase().split("/").pop()))
    );
    if (pin.depth === 0) {
      onProgress(counter2 / pinCount * 100, `Reverted direct pin ${cid2}`);
      directPins.push(cid2);
    } else {
      onProgress(counter2 / pinCount * 100, `Reverted recursive pin ${cid2}`);
      recursivePins.push(cid2);
    }
  }
  onProgress(100, "Updating pin root");
  const pinRoot = {
    Links: [
      await storeSet(blockstore, PinTypes.direct, directPins),
      await storeSet(blockstore, PinTypes.recursive, recursivePins)
    ]
  };
  const buf2 = encode$o(pinRoot);
  const digest2 = await sha256$3.digest(buf2);
  const cid = CID.createV0(digest2);
  await blockstore.put(cid, buf2);
  await datastore.put(PIN_DS_KEY, cid.bytes);
}
async function process$2(backends, onProgress, fn) {
  const blockstore = backends.blocks;
  const datastore = backends.datastore;
  const pinstore = backends.pins;
  await blockstore.open();
  await datastore.open();
  await pinstore.open();
  try {
    await fn(blockstore, datastore, pinstore, onProgress);
  } finally {
    await pinstore.close();
    await datastore.close();
    await blockstore.close();
  }
}
const migration$3 = {
  version: 9,
  description: "Migrates pins to datastore",
  migrate: (backends, onProgress = () => {
  }) => {
    return process$2(backends, onProgress, pinsToDatastore);
  },
  revert: (backends, onProgress = () => {
  }) => {
    return process$2(backends, onProgress, pinsToDAG);
  }
};
const CONFIG_KEY = new Key("/config");
const VERSION_KEY = new Key("/version");
function findLevelJs$1(store) {
  let db = store;
  while (db.db || db.child) {
    db = db.db || db.child;
    if (db.type === "level-js" || db.constructor.name === "Level") {
      return db;
    }
  }
}
async function hasWithFallback$1(key, has, store) {
  const result = await has(key);
  if (result) {
    return result;
  }
  const levelJs = findLevelJs$1(store);
  if (!levelJs) {
    return false;
  }
  return new Promise((resolve2, reject) => {
    const req = levelJs.store("readonly").get(key.toString());
    req.transaction.onabort = () => {
      reject(req.transaction.error);
    };
    req.transaction.oncomplete = () => {
      resolve2(Boolean(req.result));
    };
  });
}
async function getWithFallback$1(key, get3, has, store) {
  if (await has(key)) {
    return get3(key);
  }
  const levelJs = findLevelJs$1(store);
  if (!levelJs) {
    throw notFoundError$1();
  }
  return new Promise((resolve2, reject) => {
    const req = levelJs.store("readonly").get(key.toString());
    req.transaction.onabort = () => {
      reject(req.transaction.error);
    };
    req.transaction.oncomplete = () => {
      if (req.result) {
        return resolve2(req.result);
      }
      reject(notFoundError$1());
    };
  });
}
function wrapStore(store) {
  const originalGet = store.get.bind(store);
  const originalHas = store.has.bind(store);
  store.get = (key) => getWithFallback$1(key, originalGet, originalHas, store);
  store.has = (key) => hasWithFallback$1(key, originalHas, store);
  return store;
}
function wrapBackends(backends) {
  return {
    ...backends,
    root: wrapStore(backends.root),
    datastore: wrapStore(backends.datastore),
    pins: wrapStore(backends.pins),
    keys: wrapStore(backends.keys)
  };
}
async function keysToBinary(name2, store, onProgress = () => {
}) {
  const db = findLevelJs$1(store);
  if (!db) {
    onProgress(`${name2} did not need an upgrade`);
    return;
  }
  onProgress(`Upgrading ${name2}`);
  const upgrade = (key, value2) => {
    return [
      { type: "del", key },
      { type: "put", key: fromString$3(key), value: value2 }
    ];
  };
  await withEach(db, upgrade);
}
async function keysToStrings(name2, store, onProgress = () => {
}) {
  const db = findLevelJs$1(store);
  if (!db) {
    onProgress(`${name2} did not need a downgrade`);
    return;
  }
  onProgress(`Downgrading ${name2}`);
  const downgrade = (key, value2) => {
    return [
      { type: "del", key },
      { type: "put", key: toString$5(key), value: value2 }
    ];
  };
  await withEach(db, downgrade);
}
function unwrap(store) {
  if (store.child) {
    return unwrap(store.child);
  }
  return store;
}
async function process$1(backends, onProgress, fn) {
  const datastores = Object.entries(backends).map(([key, backend]) => ({ key, backend: unwrap(backend) })).filter(({ key, backend }) => backend.constructor.name === "LevelDatastore").map(({ key, backend }) => ({
    name: key,
    store: backend
  }));
  onProgress(0, `Migrating ${datastores.length} dbs`);
  let migrated = 0;
  const progress = (message2) => {
    onProgress(Math.round(migrated / datastores.length * 100), message2);
  };
  for (const { name: name2, store } of datastores) {
    await store.open();
    try {
      await fn(name2, store, progress);
    } finally {
      migrated++;
      await store.close();
    }
  }
  onProgress(100, `Migrated ${datastores.length} dbs`);
}
const migration$2 = {
  version: 10,
  description: "Migrates datastore-level keys to binary",
  migrate: (backends, onProgress = () => {
  }) => {
    return process$1(backends, onProgress, keysToBinary);
  },
  revert: (backends, onProgress = () => {
  }) => {
    return process$1(backends, onProgress, keysToStrings);
  }
};
function withEach(db, fn) {
  function batch2(operations, next) {
    const store = db.store("readwrite");
    const transaction = store.transaction;
    let index = 0;
    let error2;
    transaction.onabort = () => next(error2 || transaction.error || new Error("aborted by user"));
    transaction.oncomplete = () => next();
    function loop() {
      const op = operations[index++];
      const key = op.key;
      let req;
      try {
        req = op.type === "del" ? store.delete(key) : store.put(op.value, key);
      } catch (err2) {
        error2 = err2;
        transaction.abort();
        return;
      }
      if (index < operations.length) {
        req.onsuccess = loop;
      }
    }
    loop();
  }
  return new Promise((resolve2, reject) => {
    const it = db.iterator();
    const id = (data) => data;
    it._deserializeKey = it._deserializeValue = id;
    next();
    function next() {
      const handleNext = (err2, key, value2) => {
        if (err2 || key === void 0) {
          const handleEnd = (err22) => {
            if (err22) {
              reject(err22);
              return;
            }
            resolve2();
          };
          it.end(handleEnd);
          return;
        }
        batch2(fn(key, value2), next);
      };
      it.next(handleNext);
    }
  });
}
const MFS_ROOT_KEY$1 = new Key("/local/filesroot");
async function storeMfsRootInDatastore(backends, onProgress = () => {
}) {
  onProgress(100, "Migrating MFS root to repo datastore");
  await backends.root.open();
  await backends.datastore.open();
  if (await backends.root.has(MFS_ROOT_KEY$1)) {
    const root = await backends.root.get(MFS_ROOT_KEY$1);
    await backends.datastore.put(MFS_ROOT_KEY$1, root);
    await backends.root.delete(MFS_ROOT_KEY$1);
  }
  await backends.datastore.close();
  await backends.root.close();
  onProgress(100, "Stored MFS root in repo datastore");
}
async function storeMfsRootInRoot(backends, onProgress = () => {
}) {
  onProgress(100, "Migrating MFS root to repo root datastore");
  await backends.root.open();
  await backends.datastore.open();
  if (await backends.datastore.has(MFS_ROOT_KEY$1)) {
    const root = await backends.datastore.get(MFS_ROOT_KEY$1);
    await backends.root.put(MFS_ROOT_KEY$1, root);
    await backends.datastore.delete(MFS_ROOT_KEY$1);
  }
  await backends.datastore.close();
  await backends.root.close();
  onProgress(100, "Stored MFS root in repo root datastore");
}
const migration$1 = {
  version: 11,
  description: "Store mfs root in the datastore",
  migrate: storeMfsRootInDatastore,
  revert: storeMfsRootInRoot
};
const $Reader$5 = $protobuf.Reader, $Writer$5 = $protobuf.Writer, $util$5 = $protobuf.util;
const $root$5 = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
const Protocols = $root$5.Protocols = (() => {
  function Protocols2(p) {
    this.protocols = [];
    if (p) {
      for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
        if (p[ks[i2]] != null)
          this[ks[i2]] = p[ks[i2]];
    }
  }
  Protocols2.prototype.protocols = $util$5.emptyArray;
  Protocols2.encode = function encode3(m, w) {
    if (!w)
      w = $Writer$5.create();
    if (m.protocols != null && m.protocols.length) {
      for (var i2 = 0; i2 < m.protocols.length; ++i2)
        w.uint32(10).string(m.protocols[i2]);
    }
    return w;
  };
  Protocols2.decode = function decode3(r, l) {
    if (!(r instanceof $Reader$5))
      r = $Reader$5.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root$5.Protocols();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          if (!(m.protocols && m.protocols.length))
            m.protocols = [];
          m.protocols.push(r.string());
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Protocols2.fromObject = function fromObject(d) {
    if (d instanceof $root$5.Protocols)
      return d;
    var m = new $root$5.Protocols();
    if (d.protocols) {
      if (!Array.isArray(d.protocols))
        throw TypeError(".Protocols.protocols: array expected");
      m.protocols = [];
      for (var i2 = 0; i2 < d.protocols.length; ++i2) {
        m.protocols[i2] = String(d.protocols[i2]);
      }
    }
    return m;
  };
  Protocols2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.protocols = [];
    }
    if (m.protocols && m.protocols.length) {
      d.protocols = [];
      for (var j = 0; j < m.protocols.length; ++j) {
        d.protocols[j] = m.protocols[j];
      }
    }
    return d;
  };
  Protocols2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };
  return Protocols2;
})();
const $Reader$4 = $protobuf.Reader, $Writer$4 = $protobuf.Writer, $util$4 = $protobuf.util;
const $root$4 = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
const Addresses = $root$4.Addresses = (() => {
  function Addresses2(p) {
    this.addrs = [];
    if (p) {
      for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
        if (p[ks[i2]] != null)
          this[ks[i2]] = p[ks[i2]];
    }
  }
  Addresses2.prototype.addrs = $util$4.emptyArray;
  Addresses2.prototype.certifiedRecord = null;
  Addresses2.encode = function encode3(m, w) {
    if (!w)
      w = $Writer$4.create();
    if (m.addrs != null && m.addrs.length) {
      for (var i2 = 0; i2 < m.addrs.length; ++i2)
        $root$4.Addresses.Address.encode(m.addrs[i2], w.uint32(10).fork()).ldelim();
    }
    if (m.certifiedRecord != null && Object.hasOwnProperty.call(m, "certifiedRecord"))
      $root$4.Addresses.CertifiedRecord.encode(m.certifiedRecord, w.uint32(18).fork()).ldelim();
    return w;
  };
  Addresses2.decode = function decode3(r, l) {
    if (!(r instanceof $Reader$4))
      r = $Reader$4.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root$4.Addresses();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          if (!(m.addrs && m.addrs.length))
            m.addrs = [];
          m.addrs.push($root$4.Addresses.Address.decode(r, r.uint32()));
          break;
        case 2:
          m.certifiedRecord = $root$4.Addresses.CertifiedRecord.decode(r, r.uint32());
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Addresses2.fromObject = function fromObject(d) {
    if (d instanceof $root$4.Addresses)
      return d;
    var m = new $root$4.Addresses();
    if (d.addrs) {
      if (!Array.isArray(d.addrs))
        throw TypeError(".Addresses.addrs: array expected");
      m.addrs = [];
      for (var i2 = 0; i2 < d.addrs.length; ++i2) {
        if (typeof d.addrs[i2] !== "object")
          throw TypeError(".Addresses.addrs: object expected");
        m.addrs[i2] = $root$4.Addresses.Address.fromObject(d.addrs[i2]);
      }
    }
    if (d.certifiedRecord != null) {
      if (typeof d.certifiedRecord !== "object")
        throw TypeError(".Addresses.certifiedRecord: object expected");
      m.certifiedRecord = $root$4.Addresses.CertifiedRecord.fromObject(d.certifiedRecord);
    }
    return m;
  };
  Addresses2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.addrs = [];
    }
    if (o.defaults) {
      d.certifiedRecord = null;
    }
    if (m.addrs && m.addrs.length) {
      d.addrs = [];
      for (var j = 0; j < m.addrs.length; ++j) {
        d.addrs[j] = $root$4.Addresses.Address.toObject(m.addrs[j], o);
      }
    }
    if (m.certifiedRecord != null && m.hasOwnProperty("certifiedRecord")) {
      d.certifiedRecord = $root$4.Addresses.CertifiedRecord.toObject(m.certifiedRecord, o);
    }
    return d;
  };
  Addresses2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };
  Addresses2.Address = function() {
    function Address2(p) {
      if (p) {
        for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
          if (p[ks[i2]] != null)
            this[ks[i2]] = p[ks[i2]];
      }
    }
    Address2.prototype.multiaddr = $util$4.newBuffer([]);
    Address2.prototype.isCertified = null;
    let $oneOfFields;
    Object.defineProperty(Address2.prototype, "_isCertified", {
      get: $util$4.oneOfGetter($oneOfFields = ["isCertified"]),
      set: $util$4.oneOfSetter($oneOfFields)
    });
    Address2.encode = function encode3(m, w) {
      if (!w)
        w = $Writer$4.create();
      if (m.multiaddr != null && Object.hasOwnProperty.call(m, "multiaddr"))
        w.uint32(10).bytes(m.multiaddr);
      if (m.isCertified != null && Object.hasOwnProperty.call(m, "isCertified"))
        w.uint32(16).bool(m.isCertified);
      return w;
    };
    Address2.decode = function decode3(r, l) {
      if (!(r instanceof $Reader$4))
        r = $Reader$4.create(r);
      var c = l === void 0 ? r.len : r.pos + l, m = new $root$4.Addresses.Address();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1:
            m.multiaddr = r.bytes();
            break;
          case 2:
            m.isCertified = r.bool();
            break;
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    Address2.fromObject = function fromObject(d) {
      if (d instanceof $root$4.Addresses.Address)
        return d;
      var m = new $root$4.Addresses.Address();
      if (d.multiaddr != null) {
        if (typeof d.multiaddr === "string")
          $util$4.base64.decode(d.multiaddr, m.multiaddr = $util$4.newBuffer($util$4.base64.length(d.multiaddr)), 0);
        else if (d.multiaddr.length)
          m.multiaddr = d.multiaddr;
      }
      if (d.isCertified != null) {
        m.isCertified = Boolean(d.isCertified);
      }
      return m;
    };
    Address2.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.defaults) {
        if (o.bytes === String)
          d.multiaddr = "";
        else {
          d.multiaddr = [];
          if (o.bytes !== Array)
            d.multiaddr = $util$4.newBuffer(d.multiaddr);
        }
      }
      if (m.multiaddr != null && m.hasOwnProperty("multiaddr")) {
        d.multiaddr = o.bytes === String ? $util$4.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;
      }
      if (m.isCertified != null && m.hasOwnProperty("isCertified")) {
        d.isCertified = m.isCertified;
        if (o.oneofs)
          d._isCertified = "isCertified";
      }
      return d;
    };
    Address2.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return Address2;
  }();
  Addresses2.CertifiedRecord = function() {
    function CertifiedRecord(p) {
      if (p) {
        for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
          if (p[ks[i2]] != null)
            this[ks[i2]] = p[ks[i2]];
      }
    }
    CertifiedRecord.prototype.seq = $util$4.Long ? $util$4.Long.fromBits(0, 0, true) : 0;
    CertifiedRecord.prototype.raw = $util$4.newBuffer([]);
    CertifiedRecord.encode = function encode3(m, w) {
      if (!w)
        w = $Writer$4.create();
      if (m.seq != null && Object.hasOwnProperty.call(m, "seq"))
        w.uint32(8).uint64(m.seq);
      if (m.raw != null && Object.hasOwnProperty.call(m, "raw"))
        w.uint32(18).bytes(m.raw);
      return w;
    };
    CertifiedRecord.decode = function decode3(r, l) {
      if (!(r instanceof $Reader$4))
        r = $Reader$4.create(r);
      var c = l === void 0 ? r.len : r.pos + l, m = new $root$4.Addresses.CertifiedRecord();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1:
            m.seq = r.uint64();
            break;
          case 2:
            m.raw = r.bytes();
            break;
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    CertifiedRecord.fromObject = function fromObject(d) {
      if (d instanceof $root$4.Addresses.CertifiedRecord)
        return d;
      var m = new $root$4.Addresses.CertifiedRecord();
      if (d.seq != null) {
        if ($util$4.Long)
          (m.seq = $util$4.Long.fromValue(d.seq)).unsigned = true;
        else if (typeof d.seq === "string")
          m.seq = parseInt(d.seq, 10);
        else if (typeof d.seq === "number")
          m.seq = d.seq;
        else if (typeof d.seq === "object")
          m.seq = new $util$4.LongBits(d.seq.low >>> 0, d.seq.high >>> 0).toNumber(true);
      }
      if (d.raw != null) {
        if (typeof d.raw === "string")
          $util$4.base64.decode(d.raw, m.raw = $util$4.newBuffer($util$4.base64.length(d.raw)), 0);
        else if (d.raw.length)
          m.raw = d.raw;
      }
      return m;
    };
    CertifiedRecord.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.defaults) {
        if ($util$4.Long) {
          var n = new $util$4.Long(0, 0, true);
          d.seq = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
        } else
          d.seq = o.longs === String ? "0" : 0;
        if (o.bytes === String)
          d.raw = "";
        else {
          d.raw = [];
          if (o.bytes !== Array)
            d.raw = $util$4.newBuffer(d.raw);
        }
      }
      if (m.seq != null && m.hasOwnProperty("seq")) {
        if (typeof m.seq === "number")
          d.seq = o.longs === String ? String(m.seq) : m.seq;
        else
          d.seq = o.longs === String ? $util$4.Long.prototype.toString.call(m.seq) : o.longs === Number ? new $util$4.LongBits(m.seq.low >>> 0, m.seq.high >>> 0).toNumber(true) : m.seq;
      }
      if (m.raw != null && m.hasOwnProperty("raw")) {
        d.raw = o.bytes === String ? $util$4.base64.encode(m.raw, 0, m.raw.length) : o.bytes === Array ? Array.prototype.slice.call(m.raw) : m.raw;
      }
      return d;
    };
    CertifiedRecord.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return CertifiedRecord;
  }();
  return Addresses2;
})();
const $Reader$3 = $protobuf.Reader, $Writer$3 = $protobuf.Writer, $util$3 = $protobuf.util;
const $root$3 = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
const Peer$1 = $root$3.Peer = (() => {
  function Peer2(p) {
    this.addresses = [];
    this.protocols = [];
    this.metadata = [];
    if (p) {
      for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
        if (p[ks[i2]] != null)
          this[ks[i2]] = p[ks[i2]];
    }
  }
  Peer2.prototype.addresses = $util$3.emptyArray;
  Peer2.prototype.protocols = $util$3.emptyArray;
  Peer2.prototype.metadata = $util$3.emptyArray;
  Peer2.prototype.pubKey = null;
  Peer2.prototype.peerRecordEnvelope = null;
  let $oneOfFields;
  Object.defineProperty(Peer2.prototype, "_pubKey", {
    get: $util$3.oneOfGetter($oneOfFields = ["pubKey"]),
    set: $util$3.oneOfSetter($oneOfFields)
  });
  Object.defineProperty(Peer2.prototype, "_peerRecordEnvelope", {
    get: $util$3.oneOfGetter($oneOfFields = ["peerRecordEnvelope"]),
    set: $util$3.oneOfSetter($oneOfFields)
  });
  Peer2.encode = function encode3(m, w) {
    if (!w)
      w = $Writer$3.create();
    if (m.addresses != null && m.addresses.length) {
      for (var i2 = 0; i2 < m.addresses.length; ++i2)
        $root$3.Address.encode(m.addresses[i2], w.uint32(10).fork()).ldelim();
    }
    if (m.protocols != null && m.protocols.length) {
      for (var i2 = 0; i2 < m.protocols.length; ++i2)
        w.uint32(18).string(m.protocols[i2]);
    }
    if (m.metadata != null && m.metadata.length) {
      for (var i2 = 0; i2 < m.metadata.length; ++i2)
        $root$3.Metadata.encode(m.metadata[i2], w.uint32(26).fork()).ldelim();
    }
    if (m.pubKey != null && Object.hasOwnProperty.call(m, "pubKey"))
      w.uint32(34).bytes(m.pubKey);
    if (m.peerRecordEnvelope != null && Object.hasOwnProperty.call(m, "peerRecordEnvelope"))
      w.uint32(42).bytes(m.peerRecordEnvelope);
    return w;
  };
  Peer2.decode = function decode3(r, l) {
    if (!(r instanceof $Reader$3))
      r = $Reader$3.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root$3.Peer();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          if (!(m.addresses && m.addresses.length))
            m.addresses = [];
          m.addresses.push($root$3.Address.decode(r, r.uint32()));
          break;
        case 2:
          if (!(m.protocols && m.protocols.length))
            m.protocols = [];
          m.protocols.push(r.string());
          break;
        case 3:
          if (!(m.metadata && m.metadata.length))
            m.metadata = [];
          m.metadata.push($root$3.Metadata.decode(r, r.uint32()));
          break;
        case 4:
          m.pubKey = r.bytes();
          break;
        case 5:
          m.peerRecordEnvelope = r.bytes();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Peer2.fromObject = function fromObject(d) {
    if (d instanceof $root$3.Peer)
      return d;
    var m = new $root$3.Peer();
    if (d.addresses) {
      if (!Array.isArray(d.addresses))
        throw TypeError(".Peer.addresses: array expected");
      m.addresses = [];
      for (var i2 = 0; i2 < d.addresses.length; ++i2) {
        if (typeof d.addresses[i2] !== "object")
          throw TypeError(".Peer.addresses: object expected");
        m.addresses[i2] = $root$3.Address.fromObject(d.addresses[i2]);
      }
    }
    if (d.protocols) {
      if (!Array.isArray(d.protocols))
        throw TypeError(".Peer.protocols: array expected");
      m.protocols = [];
      for (var i2 = 0; i2 < d.protocols.length; ++i2) {
        m.protocols[i2] = String(d.protocols[i2]);
      }
    }
    if (d.metadata) {
      if (!Array.isArray(d.metadata))
        throw TypeError(".Peer.metadata: array expected");
      m.metadata = [];
      for (var i2 = 0; i2 < d.metadata.length; ++i2) {
        if (typeof d.metadata[i2] !== "object")
          throw TypeError(".Peer.metadata: object expected");
        m.metadata[i2] = $root$3.Metadata.fromObject(d.metadata[i2]);
      }
    }
    if (d.pubKey != null) {
      if (typeof d.pubKey === "string")
        $util$3.base64.decode(d.pubKey, m.pubKey = $util$3.newBuffer($util$3.base64.length(d.pubKey)), 0);
      else if (d.pubKey.length)
        m.pubKey = d.pubKey;
    }
    if (d.peerRecordEnvelope != null) {
      if (typeof d.peerRecordEnvelope === "string")
        $util$3.base64.decode(d.peerRecordEnvelope, m.peerRecordEnvelope = $util$3.newBuffer($util$3.base64.length(d.peerRecordEnvelope)), 0);
      else if (d.peerRecordEnvelope.length)
        m.peerRecordEnvelope = d.peerRecordEnvelope;
    }
    return m;
  };
  Peer2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.addresses = [];
      d.protocols = [];
      d.metadata = [];
    }
    if (m.addresses && m.addresses.length) {
      d.addresses = [];
      for (var j = 0; j < m.addresses.length; ++j) {
        d.addresses[j] = $root$3.Address.toObject(m.addresses[j], o);
      }
    }
    if (m.protocols && m.protocols.length) {
      d.protocols = [];
      for (var j = 0; j < m.protocols.length; ++j) {
        d.protocols[j] = m.protocols[j];
      }
    }
    if (m.metadata && m.metadata.length) {
      d.metadata = [];
      for (var j = 0; j < m.metadata.length; ++j) {
        d.metadata[j] = $root$3.Metadata.toObject(m.metadata[j], o);
      }
    }
    if (m.pubKey != null && m.hasOwnProperty("pubKey")) {
      d.pubKey = o.bytes === String ? $util$3.base64.encode(m.pubKey, 0, m.pubKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.pubKey) : m.pubKey;
      if (o.oneofs)
        d._pubKey = "pubKey";
    }
    if (m.peerRecordEnvelope != null && m.hasOwnProperty("peerRecordEnvelope")) {
      d.peerRecordEnvelope = o.bytes === String ? $util$3.base64.encode(m.peerRecordEnvelope, 0, m.peerRecordEnvelope.length) : o.bytes === Array ? Array.prototype.slice.call(m.peerRecordEnvelope) : m.peerRecordEnvelope;
      if (o.oneofs)
        d._peerRecordEnvelope = "peerRecordEnvelope";
    }
    return d;
  };
  Peer2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };
  return Peer2;
})();
$root$3.Address = (() => {
  function Address2(p) {
    if (p) {
      for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
        if (p[ks[i2]] != null)
          this[ks[i2]] = p[ks[i2]];
    }
  }
  Address2.prototype.multiaddr = $util$3.newBuffer([]);
  Address2.prototype.isCertified = null;
  let $oneOfFields;
  Object.defineProperty(Address2.prototype, "_isCertified", {
    get: $util$3.oneOfGetter($oneOfFields = ["isCertified"]),
    set: $util$3.oneOfSetter($oneOfFields)
  });
  Address2.encode = function encode3(m, w) {
    if (!w)
      w = $Writer$3.create();
    if (m.multiaddr != null && Object.hasOwnProperty.call(m, "multiaddr"))
      w.uint32(10).bytes(m.multiaddr);
    if (m.isCertified != null && Object.hasOwnProperty.call(m, "isCertified"))
      w.uint32(16).bool(m.isCertified);
    return w;
  };
  Address2.decode = function decode3(r, l) {
    if (!(r instanceof $Reader$3))
      r = $Reader$3.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root$3.Address();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.multiaddr = r.bytes();
          break;
        case 2:
          m.isCertified = r.bool();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Address2.fromObject = function fromObject(d) {
    if (d instanceof $root$3.Address)
      return d;
    var m = new $root$3.Address();
    if (d.multiaddr != null) {
      if (typeof d.multiaddr === "string")
        $util$3.base64.decode(d.multiaddr, m.multiaddr = $util$3.newBuffer($util$3.base64.length(d.multiaddr)), 0);
      else if (d.multiaddr.length)
        m.multiaddr = d.multiaddr;
    }
    if (d.isCertified != null) {
      m.isCertified = Boolean(d.isCertified);
    }
    return m;
  };
  Address2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      if (o.bytes === String)
        d.multiaddr = "";
      else {
        d.multiaddr = [];
        if (o.bytes !== Array)
          d.multiaddr = $util$3.newBuffer(d.multiaddr);
      }
    }
    if (m.multiaddr != null && m.hasOwnProperty("multiaddr")) {
      d.multiaddr = o.bytes === String ? $util$3.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;
    }
    if (m.isCertified != null && m.hasOwnProperty("isCertified")) {
      d.isCertified = m.isCertified;
      if (o.oneofs)
        d._isCertified = "isCertified";
    }
    return d;
  };
  Address2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };
  return Address2;
})();
$root$3.Metadata = (() => {
  function Metadata2(p) {
    if (p) {
      for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
        if (p[ks[i2]] != null)
          this[ks[i2]] = p[ks[i2]];
    }
  }
  Metadata2.prototype.key = "";
  Metadata2.prototype.value = $util$3.newBuffer([]);
  Metadata2.encode = function encode3(m, w) {
    if (!w)
      w = $Writer$3.create();
    if (m.key != null && Object.hasOwnProperty.call(m, "key"))
      w.uint32(10).string(m.key);
    if (m.value != null && Object.hasOwnProperty.call(m, "value"))
      w.uint32(18).bytes(m.value);
    return w;
  };
  Metadata2.decode = function decode3(r, l) {
    if (!(r instanceof $Reader$3))
      r = $Reader$3.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root$3.Metadata();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.key = r.string();
          break;
        case 2:
          m.value = r.bytes();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Metadata2.fromObject = function fromObject(d) {
    if (d instanceof $root$3.Metadata)
      return d;
    var m = new $root$3.Metadata();
    if (d.key != null) {
      m.key = String(d.key);
    }
    if (d.value != null) {
      if (typeof d.value === "string")
        $util$3.base64.decode(d.value, m.value = $util$3.newBuffer($util$3.base64.length(d.value)), 0);
      else if (d.value.length)
        m.value = d.value;
    }
    return m;
  };
  Metadata2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      d.key = "";
      if (o.bytes === String)
        d.value = "";
      else {
        d.value = [];
        if (o.bytes !== Array)
          d.value = $util$3.newBuffer(d.value);
      }
    }
    if (m.key != null && m.hasOwnProperty("key")) {
      d.key = m.key;
    }
    if (m.value != null && m.hasOwnProperty("value")) {
      d.value = o.bytes === String ? $util$3.base64.encode(m.value, 0, m.value.length) : o.bytes === Array ? Array.prototype.slice.call(m.value) : m.value;
    }
    return d;
  };
  Metadata2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };
  return Metadata2;
})();
const $Reader$2 = $protobuf.Reader, $Writer$2 = $protobuf.Writer, $util$2 = $protobuf.util;
const $root$2 = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
const Envelope$1 = $root$2.Envelope = (() => {
  function Envelope2(p) {
    if (p) {
      for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
        if (p[ks[i2]] != null)
          this[ks[i2]] = p[ks[i2]];
    }
  }
  Envelope2.prototype.publicKey = $util$2.newBuffer([]);
  Envelope2.prototype.payloadType = $util$2.newBuffer([]);
  Envelope2.prototype.payload = $util$2.newBuffer([]);
  Envelope2.prototype.signature = $util$2.newBuffer([]);
  Envelope2.encode = function encode3(m, w) {
    if (!w)
      w = $Writer$2.create();
    if (m.publicKey != null && Object.hasOwnProperty.call(m, "publicKey"))
      w.uint32(10).bytes(m.publicKey);
    if (m.payloadType != null && Object.hasOwnProperty.call(m, "payloadType"))
      w.uint32(18).bytes(m.payloadType);
    if (m.payload != null && Object.hasOwnProperty.call(m, "payload"))
      w.uint32(26).bytes(m.payload);
    if (m.signature != null && Object.hasOwnProperty.call(m, "signature"))
      w.uint32(42).bytes(m.signature);
    return w;
  };
  Envelope2.decode = function decode3(r, l) {
    if (!(r instanceof $Reader$2))
      r = $Reader$2.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root$2.Envelope();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.publicKey = r.bytes();
          break;
        case 2:
          m.payloadType = r.bytes();
          break;
        case 3:
          m.payload = r.bytes();
          break;
        case 5:
          m.signature = r.bytes();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Envelope2.fromObject = function fromObject(d) {
    if (d instanceof $root$2.Envelope)
      return d;
    var m = new $root$2.Envelope();
    if (d.publicKey != null) {
      if (typeof d.publicKey === "string")
        $util$2.base64.decode(d.publicKey, m.publicKey = $util$2.newBuffer($util$2.base64.length(d.publicKey)), 0);
      else if (d.publicKey.length)
        m.publicKey = d.publicKey;
    }
    if (d.payloadType != null) {
      if (typeof d.payloadType === "string")
        $util$2.base64.decode(d.payloadType, m.payloadType = $util$2.newBuffer($util$2.base64.length(d.payloadType)), 0);
      else if (d.payloadType.length)
        m.payloadType = d.payloadType;
    }
    if (d.payload != null) {
      if (typeof d.payload === "string")
        $util$2.base64.decode(d.payload, m.payload = $util$2.newBuffer($util$2.base64.length(d.payload)), 0);
      else if (d.payload.length)
        m.payload = d.payload;
    }
    if (d.signature != null) {
      if (typeof d.signature === "string")
        $util$2.base64.decode(d.signature, m.signature = $util$2.newBuffer($util$2.base64.length(d.signature)), 0);
      else if (d.signature.length)
        m.signature = d.signature;
    }
    return m;
  };
  Envelope2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      if (o.bytes === String)
        d.publicKey = "";
      else {
        d.publicKey = [];
        if (o.bytes !== Array)
          d.publicKey = $util$2.newBuffer(d.publicKey);
      }
      if (o.bytes === String)
        d.payloadType = "";
      else {
        d.payloadType = [];
        if (o.bytes !== Array)
          d.payloadType = $util$2.newBuffer(d.payloadType);
      }
      if (o.bytes === String)
        d.payload = "";
      else {
        d.payload = [];
        if (o.bytes !== Array)
          d.payload = $util$2.newBuffer(d.payload);
      }
      if (o.bytes === String)
        d.signature = "";
      else {
        d.signature = [];
        if (o.bytes !== Array)
          d.signature = $util$2.newBuffer(d.signature);
      }
    }
    if (m.publicKey != null && m.hasOwnProperty("publicKey")) {
      d.publicKey = o.bytes === String ? $util$2.base64.encode(m.publicKey, 0, m.publicKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.publicKey) : m.publicKey;
    }
    if (m.payloadType != null && m.hasOwnProperty("payloadType")) {
      d.payloadType = o.bytes === String ? $util$2.base64.encode(m.payloadType, 0, m.payloadType.length) : o.bytes === Array ? Array.prototype.slice.call(m.payloadType) : m.payloadType;
    }
    if (m.payload != null && m.hasOwnProperty("payload")) {
      d.payload = o.bytes === String ? $util$2.base64.encode(m.payload, 0, m.payload.length) : o.bytes === Array ? Array.prototype.slice.call(m.payload) : m.payload;
    }
    if (m.signature != null && m.hasOwnProperty("signature")) {
      d.signature = o.bytes === String ? $util$2.base64.encode(m.signature, 0, m.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m.signature) : m.signature;
    }
    return d;
  };
  Envelope2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };
  return Envelope2;
})();
const $Reader$1 = $protobuf.Reader, $Writer$1 = $protobuf.Writer, $util$1 = $protobuf.util;
const $root$1 = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
const PeerRecord$2 = $root$1.PeerRecord = (() => {
  function PeerRecord2(p) {
    this.addresses = [];
    if (p) {
      for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
        if (p[ks[i2]] != null)
          this[ks[i2]] = p[ks[i2]];
    }
  }
  PeerRecord2.prototype.peerId = $util$1.newBuffer([]);
  PeerRecord2.prototype.seq = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0;
  PeerRecord2.prototype.addresses = $util$1.emptyArray;
  PeerRecord2.encode = function encode3(m, w) {
    if (!w)
      w = $Writer$1.create();
    if (m.peerId != null && Object.hasOwnProperty.call(m, "peerId"))
      w.uint32(10).bytes(m.peerId);
    if (m.seq != null && Object.hasOwnProperty.call(m, "seq"))
      w.uint32(16).uint64(m.seq);
    if (m.addresses != null && m.addresses.length) {
      for (var i2 = 0; i2 < m.addresses.length; ++i2)
        $root$1.PeerRecord.AddressInfo.encode(m.addresses[i2], w.uint32(26).fork()).ldelim();
    }
    return w;
  };
  PeerRecord2.decode = function decode3(r, l) {
    if (!(r instanceof $Reader$1))
      r = $Reader$1.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root$1.PeerRecord();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.peerId = r.bytes();
          break;
        case 2:
          m.seq = r.uint64();
          break;
        case 3:
          if (!(m.addresses && m.addresses.length))
            m.addresses = [];
          m.addresses.push($root$1.PeerRecord.AddressInfo.decode(r, r.uint32()));
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  PeerRecord2.fromObject = function fromObject(d) {
    if (d instanceof $root$1.PeerRecord)
      return d;
    var m = new $root$1.PeerRecord();
    if (d.peerId != null) {
      if (typeof d.peerId === "string")
        $util$1.base64.decode(d.peerId, m.peerId = $util$1.newBuffer($util$1.base64.length(d.peerId)), 0);
      else if (d.peerId.length)
        m.peerId = d.peerId;
    }
    if (d.seq != null) {
      if ($util$1.Long)
        (m.seq = $util$1.Long.fromValue(d.seq)).unsigned = true;
      else if (typeof d.seq === "string")
        m.seq = parseInt(d.seq, 10);
      else if (typeof d.seq === "number")
        m.seq = d.seq;
      else if (typeof d.seq === "object")
        m.seq = new $util$1.LongBits(d.seq.low >>> 0, d.seq.high >>> 0).toNumber(true);
    }
    if (d.addresses) {
      if (!Array.isArray(d.addresses))
        throw TypeError(".PeerRecord.addresses: array expected");
      m.addresses = [];
      for (var i2 = 0; i2 < d.addresses.length; ++i2) {
        if (typeof d.addresses[i2] !== "object")
          throw TypeError(".PeerRecord.addresses: object expected");
        m.addresses[i2] = $root$1.PeerRecord.AddressInfo.fromObject(d.addresses[i2]);
      }
    }
    return m;
  };
  PeerRecord2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.addresses = [];
    }
    if (o.defaults) {
      if (o.bytes === String)
        d.peerId = "";
      else {
        d.peerId = [];
        if (o.bytes !== Array)
          d.peerId = $util$1.newBuffer(d.peerId);
      }
      if ($util$1.Long) {
        var n = new $util$1.Long(0, 0, true);
        d.seq = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.seq = o.longs === String ? "0" : 0;
    }
    if (m.peerId != null && m.hasOwnProperty("peerId")) {
      d.peerId = o.bytes === String ? $util$1.base64.encode(m.peerId, 0, m.peerId.length) : o.bytes === Array ? Array.prototype.slice.call(m.peerId) : m.peerId;
    }
    if (m.seq != null && m.hasOwnProperty("seq")) {
      if (typeof m.seq === "number")
        d.seq = o.longs === String ? String(m.seq) : m.seq;
      else
        d.seq = o.longs === String ? $util$1.Long.prototype.toString.call(m.seq) : o.longs === Number ? new $util$1.LongBits(m.seq.low >>> 0, m.seq.high >>> 0).toNumber(true) : m.seq;
    }
    if (m.addresses && m.addresses.length) {
      d.addresses = [];
      for (var j = 0; j < m.addresses.length; ++j) {
        d.addresses[j] = $root$1.PeerRecord.AddressInfo.toObject(m.addresses[j], o);
      }
    }
    return d;
  };
  PeerRecord2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };
  PeerRecord2.AddressInfo = function() {
    function AddressInfo(p) {
      if (p) {
        for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
          if (p[ks[i2]] != null)
            this[ks[i2]] = p[ks[i2]];
      }
    }
    AddressInfo.prototype.multiaddr = $util$1.newBuffer([]);
    AddressInfo.encode = function encode3(m, w) {
      if (!w)
        w = $Writer$1.create();
      if (m.multiaddr != null && Object.hasOwnProperty.call(m, "multiaddr"))
        w.uint32(10).bytes(m.multiaddr);
      return w;
    };
    AddressInfo.decode = function decode3(r, l) {
      if (!(r instanceof $Reader$1))
        r = $Reader$1.create(r);
      var c = l === void 0 ? r.len : r.pos + l, m = new $root$1.PeerRecord.AddressInfo();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1:
            m.multiaddr = r.bytes();
            break;
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    AddressInfo.fromObject = function fromObject(d) {
      if (d instanceof $root$1.PeerRecord.AddressInfo)
        return d;
      var m = new $root$1.PeerRecord.AddressInfo();
      if (d.multiaddr != null) {
        if (typeof d.multiaddr === "string")
          $util$1.base64.decode(d.multiaddr, m.multiaddr = $util$1.newBuffer($util$1.base64.length(d.multiaddr)), 0);
        else if (d.multiaddr.length)
          m.multiaddr = d.multiaddr;
      }
      return m;
    };
    AddressInfo.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.defaults) {
        if (o.bytes === String)
          d.multiaddr = "";
        else {
          d.multiaddr = [];
          if (o.bytes !== Array)
            d.multiaddr = $util$1.newBuffer(d.multiaddr);
        }
      }
      if (m.multiaddr != null && m.hasOwnProperty("multiaddr")) {
        d.multiaddr = o.bytes === String ? $util$1.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;
      }
      return d;
    };
    AddressInfo.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return AddressInfo;
  }();
  return PeerRecord2;
})();
$protobuf.util.Long = void 0;
$protobuf.configure();
async function storePeerUnderSingleDatastoreKey(backends, onProgress = () => {
}) {
  onProgress(0, "Storing each peerstore key under a single datastore key");
  await backends.datastore.open();
  const peers = {};
  const keys = [];
  for await (const { key, value: value2 } of backends.datastore.query({
    prefix: "/peers"
  })) {
    keys.push(key);
    const keyStr = key.toString();
    const [, prefix, type, peerId, metadataKey] = keyStr.split("/");
    if (prefix !== "peers") {
      continue;
    }
    if (!["protos", "addrs", "metadata", "keys"].includes(type)) {
      continue;
    }
    if (!peerId) {
      continue;
    }
    peers[peerId] = peers[peerId] || {
      addresses: [],
      protocols: [],
      metadata: []
    };
    if (type === "protos") {
      const protos = Protocols.decode(value2);
      peers[peerId].protocols = protos.protocols.sort();
    } else if (type === "addrs") {
      const addrs = Addresses.decode(value2);
      peers[peerId].addresses = addrs.addrs.sort((a, b2) => {
        return multiaddr(a.multiaddr).toString().localeCompare(multiaddr(b2.multiaddr).toString());
      });
      if (addrs.certifiedRecord && addrs.certifiedRecord.raw) {
        peers[peerId].peerRecordEnvelope = addrs.certifiedRecord.raw;
      }
    } else if (type === "metadata") {
      peers[peerId].metadata.push({ key: metadataKey, value: value2 });
    } else if (type === "keys") {
      peers[peerId].pubKey = value2;
    }
  }
  onProgress(33, "Read peer data from store");
  for (const key of keys) {
    await backends.datastore.delete(key);
  }
  onProgress(66, "Removed existing peer data from store");
  for (const peerId of Object.keys(peers)) {
    const peer = peers[peerId];
    peer.metadata = peer.metadata.sort((a, b2) => a.key.localeCompare(b2.key));
    const data = Peer$1.encode(peer).finish();
    await backends.datastore.put(new Key(`/peers/${peerId}`), data);
  }
  await backends.datastore.close();
  onProgress(100, "Stored each peerstore key under a single datastore key");
}
async function storePeerUnderMultipleDatastoreKeys(backends, onProgress = () => {
}) {
  onProgress(0, "Storing each peerstore key under a multiple datastore keys");
  await backends.datastore.open();
  const peers = {};
  const keys = [];
  for await (const { key, value: value2 } of backends.datastore.query({
    prefix: "/peers"
  })) {
    keys.push(key);
    const keyStr = key.toString();
    const [, , peerId] = keyStr.split("/");
    peers[peerId] = Peer$1.decode(value2);
  }
  onProgress(33, "Read peer data from store");
  for (const key of keys) {
    await backends.datastore.delete(key);
  }
  onProgress(66, "Removed existing peer data from store");
  for (const [peerId, peer] of Object.entries(peers)) {
    if (peer.protocols && peer.protocols.length > 0) {
      await backends.datastore.put(new Key(`/peers/protos/${peerId}`), Protocols.encode({
        protocols: peer.protocols
      }).finish());
    }
    if (peer.addresses && peer.addresses.length > 0) {
      const peerRecordEnvelope = peer.peerRecordEnvelope;
      let certifiedRecord;
      if (peerRecordEnvelope) {
        const envelope = Envelope$1.decode(peerRecordEnvelope);
        const record = PeerRecord$2.decode(envelope.payload);
        certifiedRecord = {
          raw: peerRecordEnvelope,
          seq: record.seq
        };
      }
      await backends.datastore.put(new Key(`/peers/addrs/${peerId}`), Addresses.encode({
        addrs: peer.addresses,
        certifiedRecord
      }).finish());
    }
    if (peer.metadata && peer.metadata.length > 0) {
      for (const { key, value: value2 } of peer.metadata) {
        await backends.datastore.put(new Key(`/peers/metadata/${peerId}/${key}`), value2);
      }
    }
    if (peer.pubKey) {
      await backends.datastore.put(new Key(`/peers/keys/${peerId}`), peer.pubKey);
    }
  }
  await backends.datastore.close();
  onProgress(100, "Stored each peerstore key under multiple datastore keys");
}
const migration = {
  version: 12,
  description: "Store each peerstore peer under a single datastore key",
  migrate: storePeerUnderSingleDatastoreKey,
  revert: storePeerUnderMultipleDatastoreKeys
};
const emptyMigration = {
  description: "Empty migration.",
  migrate: () => {
  },
  revert: () => {
  },
  empty: true
};
const defaultMigrations = [
  Object.assign({ version: 1 }, emptyMigration),
  Object.assign({ version: 2 }, emptyMigration),
  Object.assign({ version: 3 }, emptyMigration),
  Object.assign({ version: 4 }, emptyMigration),
  Object.assign({ version: 5 }, emptyMigration),
  Object.assign({ version: 6 }, emptyMigration),
  Object.assign({ version: 7 }, emptyMigration),
  migration$4,
  migration$3,
  migration$2,
  migration$1,
  migration
];
class NonReversibleMigrationError extends Error {
  constructor(message2) {
    super(message2);
    this.name = "NonReversibleMigrationError";
    this.code = NonReversibleMigrationError.code;
    this.message = message2;
  }
}
NonReversibleMigrationError.code = "ERR_NON_REVERSIBLE_MIGRATION";
class NotInitializedRepoError extends Error {
  constructor(message2) {
    super(message2);
    this.name = "NotInitializedRepoError";
    this.code = NotInitializedRepoError.code;
    this.message = message2;
  }
}
NotInitializedRepoError.code = "ERR_NOT_INITIALIZED_REPO";
class RequiredParameterError extends Error {
  constructor(message2) {
    super(message2);
    this.name = "RequiredParameterError";
    this.code = RequiredParameterError.code;
    this.message = message2;
  }
}
RequiredParameterError.code = "ERR_REQUIRED_PARAMETER";
class InvalidValueError extends Error {
  constructor(message2) {
    super(message2);
    this.name = "InvalidValueError";
    this.code = InvalidValueError.code;
    this.message = message2;
  }
}
InvalidValueError.code = "ERR_INVALID_VALUE";
class MissingRepoOptionsError extends Error {
  constructor(message2) {
    super(message2);
    this.name = "MissingRepoOptionsError";
    this.code = MissingRepoOptionsError.code;
    this.message = message2;
  }
}
MissingRepoOptionsError.code = "ERR_MISSING_REPO_OPTIONS";
const Errors = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NonReversibleMigrationError,
  NotInitializedRepoError,
  RequiredParameterError,
  InvalidValueError,
  MissingRepoOptionsError
}, Symbol.toStringTag, { value: "Module" }));
const log$12 = debug("ipfs:repo:migrator:repo:init");
async function isRepoInitialized(backends) {
  if (!backends) {
    throw new MissingRepoOptionsError("Please pass repo options when trying to open a repo");
  }
  const root = backends.root;
  try {
    await root.open();
    const versionCheck = await root.has(VERSION_KEY);
    const configCheck = await root.has(CONFIG_KEY);
    if (!versionCheck || !configCheck) {
      log$12(`Version entry present: ${versionCheck}`);
      log$12(`Config entry present: ${configCheck}`);
      return false;
    }
    return true;
  } catch (e) {
    log$12("While checking if repo is initialized error was thrown: " + e.message);
    return false;
  } finally {
    if (root !== void 0) {
      try {
        await root.close();
      } catch {
      }
    }
  }
}
async function getVersion(backends) {
  if (!await isRepoInitialized(backends)) {
    throw new NotInitializedRepoError("Repo is not initialized!");
  }
  const store = backends.root;
  await store.open();
  try {
    return parseInt(toString$5(await store.get(VERSION_KEY)));
  } finally {
    await store.close();
  }
}
async function setVersion(version2, backends) {
  if (!backends) {
    throw new MissingRepoOptionsError("Please pass repo options when trying to open a repo");
  }
  const store = backends.root;
  await store.open();
  await store.put(VERSION_KEY, fromString$3(String(version2)));
  await store.close();
}
const log$11 = debug("ipfs:repo:migrator");
function getLatestMigrationVersion(migrations) {
  migrations = migrations || defaultMigrations;
  if (!Array.isArray(migrations) || migrations.length === 0) {
    return 0;
  }
  return migrations[migrations.length - 1].version;
}
async function migrate(path2, backends, repoOptions, toVersion, options = {}) {
  const ignoreLock = options.ignoreLock ?? false;
  const onProgress = options.onProgress;
  const isDryRun = options.isDryRun ?? false;
  const migrations = options.migrations ?? defaultMigrations;
  if (!path2) {
    throw new errors.RequiredParameterError("Path argument is required!");
  }
  if (!repoOptions) {
    throw new errors.RequiredParameterError("repoOptions argument is required!");
  }
  if (!toVersion) {
    throw new errors.RequiredParameterError("toVersion argument is required!");
  }
  if (!Number.isInteger(toVersion) || toVersion <= 0) {
    throw new errors.InvalidValueError("Version has to be positive integer!");
  }
  backends = wrapBackends(backends);
  const currentVersion = await getVersion(backends);
  if (currentVersion === toVersion) {
    log$11("Nothing to migrate.");
    return;
  }
  if (currentVersion > toVersion) {
    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is higher then toVersion (${toVersion}), you probably wanted to revert it?`);
  }
  verifyAvailableMigrations(migrations, currentVersion, toVersion);
  let lock2;
  if (!isDryRun && !ignoreLock) {
    lock2 = await repoOptions.repoLock.lock(path2);
  }
  try {
    for (const migration2 of migrations) {
      if (toVersion !== void 0 && migration2.version > toVersion) {
        break;
      }
      if (migration2.version <= currentVersion) {
        continue;
      }
      log$11(`Migrating version ${migration2.version}`);
      try {
        if (!isDryRun) {
          let progressCallback = () => {
          };
          if (onProgress) {
            progressCallback = (percent, message2) => onProgress(migration2.version, percent.toFixed(2), message2);
          }
          await migration2.migrate(backends, progressCallback);
        }
      } catch (e) {
        const lastSuccessfullyMigratedVersion = migration2.version - 1;
        log$11(`An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: ${lastSuccessfullyMigratedVersion}`);
        await setVersion(lastSuccessfullyMigratedVersion, backends);
        throw new Error(`During migration to version ${migration2.version} exception was raised: ${e.stack || e.message || e}`);
      }
      log$11(`Migrating to version ${migration2.version} finished`);
    }
    if (!isDryRun) {
      await setVersion(toVersion || getLatestMigrationVersion(migrations), backends);
    }
    log$11("Repo successfully migrated", toVersion !== void 0 ? `to version ${toVersion}!` : "to latest version!");
  } finally {
    if (!isDryRun && !ignoreLock && lock2) {
      await lock2.close();
    }
  }
}
async function revert(path2, backends, repoOptions, toVersion, options = {}) {
  const ignoreLock = options.ignoreLock ?? false;
  const onProgress = options.onProgress;
  const isDryRun = options.isDryRun ?? false;
  const migrations = options.migrations ?? defaultMigrations;
  if (!path2) {
    throw new errors.RequiredParameterError("Path argument is required!");
  }
  if (!repoOptions) {
    throw new errors.RequiredParameterError("repoOptions argument is required!");
  }
  if (!toVersion) {
    throw new errors.RequiredParameterError("When reverting migrations, you have to specify to which version to revert!");
  }
  if (!Number.isInteger(toVersion) || toVersion <= 0) {
    throw new errors.InvalidValueError("Version has to be positive integer!");
  }
  backends = wrapBackends(backends);
  const currentVersion = await getVersion(backends);
  if (currentVersion === toVersion) {
    log$11("Nothing to revert.");
    return;
  }
  if (currentVersion < toVersion) {
    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is lower then toVersion (${toVersion}), you probably wanted to migrate it?`);
  }
  verifyAvailableMigrations(migrations, toVersion, currentVersion, true);
  let lock2;
  if (!isDryRun && !ignoreLock) {
    lock2 = await repoOptions.repoLock.lock(path2);
  }
  log$11(`Reverting from version ${currentVersion} to ${toVersion}`);
  try {
    const reversedMigrationArray = migrations.slice().reverse();
    for (const migration2 of reversedMigrationArray) {
      if (migration2.version <= toVersion) {
        break;
      }
      if (migration2.version > currentVersion) {
        continue;
      }
      log$11(`Reverting migration version ${migration2.version}`);
      try {
        if (!isDryRun) {
          let progressCallback = () => {
          };
          if (onProgress) {
            progressCallback = (percent, message2) => onProgress(migration2.version, percent.toFixed(2), message2);
          }
          await migration2.revert(backends, progressCallback);
        }
      } catch (e) {
        const lastSuccessfullyRevertedVersion = migration2.version;
        log$11(`An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: ${lastSuccessfullyRevertedVersion}`);
        await setVersion(lastSuccessfullyRevertedVersion, backends);
        e.message = `During reversion to version ${migration2.version} exception was raised: ${e.message}`;
        throw e;
      }
      log$11(`Reverting to version ${migration2.version} finished`);
    }
    if (!isDryRun) {
      await setVersion(toVersion, backends);
    }
    log$11(`All migrations successfully reverted to version ${toVersion}!`);
  } finally {
    if (!isDryRun && !ignoreLock && lock2) {
      await lock2.close();
    }
  }
}
function verifyAvailableMigrations(migrations, fromVersion, toVersion, checkReversibility = false) {
  let migrationCounter = 0;
  for (const migration2 of migrations) {
    if (migration2.version > toVersion) {
      break;
    }
    if (migration2.version > fromVersion) {
      if (checkReversibility && !migration2.revert) {
        throw new errors.NonReversibleMigrationError(`It is not possible to revert to version ${fromVersion} because migration version ${migration2.version} is not reversible. Cancelling reversion.`);
      }
      migrationCounter++;
    }
  }
  if (migrationCounter !== toVersion - fromVersion) {
    throw new errors.InvalidValueError(`The ipfs-repo-migrations package does not have all migration to migrate from version ${fromVersion} to ${toVersion}`);
  }
}
const errors = Errors;
var bytes$1 = { exports: {} };
/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */
bytes$1.exports = bytes;
bytes$1.exports.format = format;
bytes$1.exports.parse = parse$2;
var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
var map$2 = {
  b: 1,
  kb: 1 << 10,
  mb: 1 << 20,
  gb: 1 << 30,
  tb: Math.pow(1024, 4),
  pb: Math.pow(1024, 5)
};
var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
function bytes(value2, options) {
  if (typeof value2 === "string") {
    return parse$2(value2);
  }
  if (typeof value2 === "number") {
    return format(value2, options);
  }
  return null;
}
function format(value2, options) {
  if (!Number.isFinite(value2)) {
    return null;
  }
  var mag = Math.abs(value2);
  var thousandsSeparator = options && options.thousandsSeparator || "";
  var unitSeparator = options && options.unitSeparator || "";
  var decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2;
  var fixedDecimals = Boolean(options && options.fixedDecimals);
  var unit = options && options.unit || "";
  if (!unit || !map$2[unit.toLowerCase()]) {
    if (mag >= map$2.pb) {
      unit = "PB";
    } else if (mag >= map$2.tb) {
      unit = "TB";
    } else if (mag >= map$2.gb) {
      unit = "GB";
    } else if (mag >= map$2.mb) {
      unit = "MB";
    } else if (mag >= map$2.kb) {
      unit = "KB";
    } else {
      unit = "B";
    }
  }
  var val = value2 / map$2[unit.toLowerCase()];
  var str = val.toFixed(decimalPlaces);
  if (!fixedDecimals) {
    str = str.replace(formatDecimalsRegExp, "$1");
  }
  if (thousandsSeparator) {
    str = str.split(".").map(function(s2, i2) {
      return i2 === 0 ? s2.replace(formatThousandsRegExp, thousandsSeparator) : s2;
    }).join(".");
  }
  return str + unitSeparator + unit;
}
function parse$2(val) {
  if (typeof val === "number" && !isNaN(val)) {
    return val;
  }
  if (typeof val !== "string") {
    return null;
  }
  var results = parseRegExp.exec(val);
  var floatValue;
  var unit = "b";
  if (!results) {
    floatValue = parseInt(val, 10);
    unit = "b";
  } else {
    floatValue = parseFloat(results[1]);
    unit = results[4].toLowerCase();
  }
  if (isNaN(floatValue)) {
    return null;
  }
  return Math.floor(map$2[unit] * floatValue);
}
class LockExistsError extends Error {
  constructor(message2) {
    super(message2);
    this.name = "LockExistsError";
    this.code = LockExistsError.code;
  }
}
LockExistsError.code = "ERR_LOCK_EXISTS";
class NotFoundError extends Error {
  constructor(message2) {
    super(message2);
    this.name = "NotFoundError";
    this.code = NotFoundError.code;
  }
}
NotFoundError.code = "ERR_NOT_FOUND";
class InvalidRepoVersionError extends Error {
  constructor(message2) {
    super(message2);
    this.name = "InvalidRepoVersionError";
    this.code = InvalidRepoVersionError.code;
  }
}
InvalidRepoVersionError.code = "ERR_INVALID_REPO_VERSION";
const ERR_REPO_NOT_INITIALIZED = "ERR_REPO_NOT_INITIALIZED";
const ERR_REPO_ALREADY_OPEN = "ERR_REPO_ALREADY_OPEN";
const ERR_REPO_ALREADY_CLOSED = "ERR_REPO_ALREADY_CLOSED";
async function hasWithFallback(key, has, store) {
  const result = await has(key);
  if (result) {
    return result;
  }
  const levelJs = findLevelJs(store);
  if (!levelJs) {
    return false;
  }
  return new Promise((resolve2, reject) => {
    const req = levelJs.store("readonly").get(key.toString());
    req.transaction.onabort = () => {
      reject(req.transaction.error);
    };
    req.transaction.oncomplete = () => {
      resolve2(Boolean(req.result));
    };
  });
}
async function getWithFallback(key, get3, has, store) {
  if (await has(key)) {
    return get3(key);
  }
  const levelJs = findLevelJs(store);
  if (!levelJs) {
    throw new NotFoundError();
  }
  return new Promise((resolve2, reject) => {
    const req = levelJs.store("readonly").get(key.toString());
    req.transaction.onabort = () => {
      reject(req.transaction.error);
    };
    req.transaction.oncomplete = () => {
      if (req.result) {
        return resolve2(req.result);
      }
      reject(new NotFoundError());
    };
  });
}
function findLevelJs(store) {
  let db = store;
  while (db.db || db.child) {
    db = db.db || db.child;
    if (db.type === "level-js" || db.constructor.name === "Level") {
      return db;
    }
  }
}
const log$10 = debug("ipfs:repo:version");
const versionKey = new Key("version");
function version$1(store) {
  return {
    async exists() {
      return hasWithFallback(versionKey, store.has.bind(store), store);
    },
    async get() {
      const buf2 = await getWithFallback(versionKey, store.get.bind(store), store.has.bind(store), store);
      return parseInt(toString$5(buf2), 10);
    },
    set(version2) {
      return store.put(versionKey, fromString$3(String(version2)));
    },
    async check(expected) {
      const version2 = await this.get();
      log$10("comparing version: %s and %s", version2, expected);
      const compatibleVersion = version2 === 6 && expected === 7 || expected === 6 && version2 === 7;
      return version2 === expected || compatibleVersion;
    }
  };
}
const Queue$1 = PQueue.default ? PQueue.default : PQueue;
const configKey = new Key("config");
function config(store) {
  const setQueue = new Queue$1({ concurrency: 1 });
  const configStore = {
    async getAll(options = {}) {
      const encodedValue = await getWithFallback(configKey, store.get.bind(store), store.has.bind(store), store);
      return JSON.parse(toString$5(encodedValue));
    },
    async get(key, options = {}) {
      if (key == null) {
        throw new NotFoundError(`Key ${key} does not exist in config`);
      }
      const config2 = await this.getAll(options);
      const value2 = objectSafeGet(config2, key);
      if (value2 === void 0) {
        throw new NotFoundError(`Key ${key} does not exist in config`);
      }
      return value2;
    },
    set(key, value2, options = {}) {
      if (typeof key !== "string" && !(key instanceof String)) {
        throw errCode(new Error("Invalid key type: " + typeof key), "ERR_INVALID_KEY");
      }
      if (value2 === void 0 || value2 instanceof Uint8Array) {
        throw errCode(new Error("Invalid value type: " + typeof value2), "ERR_INVALID_VALUE");
      }
      return setQueue.add(() => _maybeDoSet({
        key,
        value: value2
      }, options.signal));
    },
    replace(value2, options = {}) {
      if (!value2 || value2 instanceof Uint8Array) {
        throw errCode(new Error("Invalid value type: " + typeof value2), "ERR_INVALID_VALUE");
      }
      return setQueue.add(() => _maybeDoSet({
        key: void 0,
        value: value2
      }, options.signal));
    },
    async exists() {
      return hasWithFallback(configKey, store.has.bind(store), store);
    }
  };
  return configStore;
  async function _maybeDoSet(m, signal) {
    if (signal && signal.aborted) {
      return;
    }
    const key = m.key;
    const value2 = m.value;
    if (key) {
      const config2 = await configStore.getAll();
      if (typeof config2 === "object" && config2 !== null) {
        objectSafeSet(config2, key, value2);
      }
      return _saveAll(config2);
    }
    return _saveAll(value2);
  }
  function _saveAll(config2) {
    const buf2 = fromString$3(JSON.stringify(config2, null, 2));
    return store.put(configKey, buf2);
  }
}
function isPlainObject(value2) {
  if (typeof value2 !== "object" || value2 === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value2);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value2) && !(Symbol.iterator in value2);
}
function sortKeys(object, options = {}) {
  if (!isPlainObject(object) && !Array.isArray(object)) {
    throw new TypeError("Expected a plain object or array");
  }
  const { deep, compare: compare2 } = options;
  const seenInput = [];
  const seenOutput = [];
  const deepSortArray = (array) => {
    const seenIndex = seenInput.indexOf(array);
    if (seenIndex !== -1) {
      return seenOutput[seenIndex];
    }
    const result = [];
    seenInput.push(array);
    seenOutput.push(result);
    result.push(...array.map((item) => {
      if (Array.isArray(item)) {
        return deepSortArray(item);
      }
      if (isPlainObject(item)) {
        return _sortKeys(item);
      }
      return item;
    }));
    return result;
  };
  const _sortKeys = (object2) => {
    const seenIndex = seenInput.indexOf(object2);
    if (seenIndex !== -1) {
      return seenOutput[seenIndex];
    }
    const result = {};
    const keys = Object.keys(object2).sort(compare2);
    seenInput.push(object2);
    seenOutput.push(result);
    for (const key of keys) {
      const value2 = object2[key];
      let newValue;
      if (deep && Array.isArray(value2)) {
        newValue = deepSortArray(value2);
      } else {
        newValue = deep && isPlainObject(value2) ? _sortKeys(value2) : value2;
      }
      Object.defineProperty(result, key, {
        ...Object.getOwnPropertyDescriptor(object2, key),
        value: newValue
      });
    }
    return result;
  };
  if (Array.isArray(object)) {
    return deep ? deepSortArray(object) : object.slice();
  }
  return _sortKeys(object);
}
const specKey = new Key("datastore_spec");
function spec(store) {
  return {
    exists() {
      return store.has(specKey);
    },
    async get() {
      const buf2 = await store.get(specKey);
      return JSON.parse(toString$5(buf2));
    },
    async set(spec2) {
      return store.put(specKey, fromString$3(JSON.stringify(sortKeys(spec2, { deep: true }))));
    }
  };
}
const apiFile = new Key("api");
function apiAddr(store) {
  return {
    async get() {
      const value2 = await store.get(apiFile);
      return value2 && value2.toString();
    },
    set(value2) {
      return store.put(apiFile, fromString$3(value2.toString()));
    },
    delete() {
      return store.delete(apiFile);
    }
  };
}
function createIdStore(store) {
  return {
    open() {
      return store.open();
    },
    close() {
      return store.close();
    },
    query(query, options) {
      return store.query(query, options);
    },
    queryKeys(query, options) {
      return store.queryKeys(query, options);
    },
    async get(cid, options) {
      const extracted = extractContents(cid);
      if (extracted.isIdentity) {
        return Promise.resolve(extracted.digest);
      }
      return store.get(cid, options);
    },
    async *getMany(cids, options) {
      for await (const cid of cids) {
        yield this.get(cid, options);
      }
    },
    async put(cid, buf2, options) {
      const { isIdentity } = extractContents(cid);
      if (isIdentity) {
        return;
      }
      await store.put(cid, buf2, options);
    },
    async *putMany(pairs, options) {
      const output = pushable({
        objectMode: true
      });
      const runner = globalThis.process && globalThis.process.nextTick ? globalThis.process.nextTick : globalThis.setImmediate || globalThis.setTimeout;
      runner(async () => {
        try {
          await drain(store.putMany(async function* () {
            for await (const { key, value: value2 } of pairs) {
              if (!extractContents(key).isIdentity) {
                yield { key, value: value2 };
              }
              output.push({ key, value: value2 });
            }
          }()));
          output.end();
        } catch (err2) {
          output.end(err2);
        }
      });
      yield* output;
    },
    has(cid, options) {
      const { isIdentity } = extractContents(cid);
      if (isIdentity) {
        return Promise.resolve(true);
      }
      return store.has(cid, options);
    },
    delete(cid, options) {
      const { isIdentity } = extractContents(cid);
      if (isIdentity) {
        return Promise.resolve();
      }
      return store.delete(cid, options);
    },
    deleteMany(cids, options) {
      return store.deleteMany(filter$1(cids, (cid) => !extractContents(cid).isIdentity), options);
    },
    batch() {
      const batch2 = store.batch();
      return {
        put(cid, buf2) {
          const { isIdentity } = extractContents(cid);
          if (isIdentity) {
            return;
          }
          batch2.put(cid, buf2);
        },
        delete(cid) {
          const { isIdentity } = extractContents(cid);
          if (isIdentity) {
            return;
          }
          batch2.delete(cid);
        },
        commit: (options) => {
          return batch2.commit(options);
        }
      };
    }
  };
}
function extractContents(k) {
  const cid = CID.asCID(k);
  if (cid == null) {
    throw errCode(new Error("Not a valid cid"), "ERR_INVALID_CID");
  }
  if (cid.multihash.code !== identity$5.code) {
    return {
      isIdentity: false
    };
  }
  return {
    isIdentity: true,
    digest: cid.multihash.digest
  };
}
const log$$ = debug("ipfs:repo:lock:memory");
const lockFile = "repo.lock";
const LOCKS = {};
async function lock(dir) {
  const file = dir + "/" + lockFile;
  log$$("locking %s", file);
  if (LOCKS[file] === true) {
    throw new LockExistsError(`Lock already being held for file: ${file}`);
  }
  LOCKS[file] = true;
  const closer = {
    async close() {
      if (LOCKS[file]) {
        delete LOCKS[file];
      }
    }
  };
  return closer;
}
async function locked(dir) {
  const file = dir + "/" + lockFile;
  log$$(`checking lock: ${file}`);
  return Boolean(LOCKS[file]);
}
const MemoryLock = {
  lock,
  locked
};
const defaultOptions$5 = {
  autoMigrate: true,
  onMigrationProgress: () => {
  },
  repoOwner: true,
  repoLock: MemoryLock
};
const defaultDatastore = {
  Spec: {
    type: "mount",
    mounts: [
      {
        mountpoint: "/blocks",
        type: "measure",
        prefix: "flatfs.datastore",
        child: {
          type: "flatfs",
          path: "blocks",
          sync: true,
          shardFunc: "/repo/flatfs/shard/v1/next-to-last/2"
        }
      },
      {
        mountpoint: "/",
        type: "measure",
        prefix: "leveldb.datastore",
        child: {
          type: "levelds",
          path: "datastore",
          compression: "none"
        }
      }
    ]
  }
};
function cidToKey$1(c) {
  const cid = CID.asCID(c);
  if (cid == null) {
    throw errCode(new Error("Not a valid cid"), "ERR_INVALID_CID");
  }
  const encoded = base32$2.encode(cid.multihash.bytes);
  return new Key("/" + encoded.slice(1).toUpperCase(), false);
}
function keyToMultihash(key) {
  return decode$j(base32$2.decode(`b${key.toString().toLowerCase().substring(1)}`));
}
const log$_ = debug("ipfs:repo:utils:walk-dag");
async function* walkDag(cid, blockstore, loadCodec, options) {
  try {
    const bytes2 = await blockstore.get(cid, options);
    const codec = await loadCodec(cid.code);
    const block = createUnsafe({ bytes: bytes2, cid, codec });
    for (const [, childCid] of block.links()) {
      yield childCid;
      yield* walkDag(childCid, blockstore, loadCodec, options);
    }
  } catch (err2) {
    log$_("Could not walk DAG for CID", cid.toString(), err2);
    throw err2;
  }
}
class QuickLRU extends Map {
  constructor(options = {}) {
    super();
    if (!(options.maxSize && options.maxSize > 0)) {
      throw new TypeError("`maxSize` must be a number greater than 0");
    }
    if (typeof options.maxAge === "number" && options.maxAge === 0) {
      throw new TypeError("`maxAge` must be a number greater than 0");
    }
    this.maxSize = options.maxSize;
    this.maxAge = options.maxAge || Number.POSITIVE_INFINITY;
    this.onEviction = options.onEviction;
    this.cache = /* @__PURE__ */ new Map();
    this.oldCache = /* @__PURE__ */ new Map();
    this._size = 0;
  }
  _emitEvictions(cache2) {
    if (typeof this.onEviction !== "function") {
      return;
    }
    for (const [key, item] of cache2) {
      this.onEviction(key, item.value);
    }
  }
  _deleteIfExpired(key, item) {
    if (typeof item.expiry === "number" && item.expiry <= Date.now()) {
      if (typeof this.onEviction === "function") {
        this.onEviction(key, item.value);
      }
      return this.delete(key);
    }
    return false;
  }
  _getOrDeleteIfExpired(key, item) {
    const deleted = this._deleteIfExpired(key, item);
    if (deleted === false) {
      return item.value;
    }
  }
  _getItemValue(key, item) {
    return item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;
  }
  _peek(key, cache2) {
    const item = cache2.get(key);
    return this._getItemValue(key, item);
  }
  _set(key, value2) {
    this.cache.set(key, value2);
    this._size++;
    if (this._size >= this.maxSize) {
      this._size = 0;
      this._emitEvictions(this.oldCache);
      this.oldCache = this.cache;
      this.cache = /* @__PURE__ */ new Map();
    }
  }
  _moveToRecent(key, item) {
    this.oldCache.delete(key);
    this._set(key, item);
  }
  *_entriesAscending() {
    for (const item of this.oldCache) {
      const [key, value2] = item;
      if (!this.cache.has(key)) {
        const deleted = this._deleteIfExpired(key, value2);
        if (deleted === false) {
          yield item;
        }
      }
    }
    for (const item of this.cache) {
      const [key, value2] = item;
      const deleted = this._deleteIfExpired(key, value2);
      if (deleted === false) {
        yield item;
      }
    }
  }
  get(key) {
    if (this.cache.has(key)) {
      const item = this.cache.get(key);
      return this._getItemValue(key, item);
    }
    if (this.oldCache.has(key)) {
      const item = this.oldCache.get(key);
      if (this._deleteIfExpired(key, item) === false) {
        this._moveToRecent(key, item);
        return item.value;
      }
    }
  }
  set(key, value2, { maxAge = this.maxAge } = {}) {
    const expiry = typeof maxAge === "number" && maxAge !== Number.POSITIVE_INFINITY ? Date.now() + maxAge : void 0;
    if (this.cache.has(key)) {
      this.cache.set(key, {
        value: value2,
        expiry
      });
    } else {
      this._set(key, { value: value2, expiry });
    }
  }
  has(key) {
    if (this.cache.has(key)) {
      return !this._deleteIfExpired(key, this.cache.get(key));
    }
    if (this.oldCache.has(key)) {
      return !this._deleteIfExpired(key, this.oldCache.get(key));
    }
    return false;
  }
  peek(key) {
    if (this.cache.has(key)) {
      return this._peek(key, this.cache);
    }
    if (this.oldCache.has(key)) {
      return this._peek(key, this.oldCache);
    }
  }
  delete(key) {
    const deleted = this.cache.delete(key);
    if (deleted) {
      this._size--;
    }
    return this.oldCache.delete(key) || deleted;
  }
  clear() {
    this.cache.clear();
    this.oldCache.clear();
    this._size = 0;
  }
  resize(newSize) {
    if (!(newSize && newSize > 0)) {
      throw new TypeError("`maxSize` must be a number greater than 0");
    }
    const items = [...this._entriesAscending()];
    const removeCount = items.length - newSize;
    if (removeCount < 0) {
      this.cache = new Map(items);
      this.oldCache = /* @__PURE__ */ new Map();
      this._size = items.length;
    } else {
      if (removeCount > 0) {
        this._emitEvictions(items.slice(0, removeCount));
      }
      this.oldCache = new Map(items.slice(removeCount));
      this.cache = /* @__PURE__ */ new Map();
      this._size = 0;
    }
    this.maxSize = newSize;
  }
  *keys() {
    for (const [key] of this) {
      yield key;
    }
  }
  *values() {
    for (const [, value2] of this) {
      yield value2;
    }
  }
  *[Symbol.iterator]() {
    for (const item of this.cache) {
      const [key, value2] = item;
      const deleted = this._deleteIfExpired(key, value2);
      if (deleted === false) {
        yield [key, value2.value];
      }
    }
    for (const item of this.oldCache) {
      const [key, value2] = item;
      if (!this.cache.has(key)) {
        const deleted = this._deleteIfExpired(key, value2);
        if (deleted === false) {
          yield [key, value2.value];
        }
      }
    }
  }
  *entriesDescending() {
    let items = [...this.cache];
    for (let i2 = items.length - 1; i2 >= 0; --i2) {
      const item = items[i2];
      const [key, value2] = item;
      const deleted = this._deleteIfExpired(key, value2);
      if (deleted === false) {
        yield [key, value2.value];
      }
    }
    items = [...this.oldCache];
    for (let i2 = items.length - 1; i2 >= 0; --i2) {
      const item = items[i2];
      const [key, value2] = item;
      if (!this.cache.has(key)) {
        const deleted = this._deleteIfExpired(key, value2);
        if (deleted === false) {
          yield [key, value2.value];
        }
      }
    }
  }
  *entriesAscending() {
    for (const [key, value2] of this._entriesAscending()) {
      yield [key, value2.value];
    }
  }
  get size() {
    if (!this._size) {
      return this.oldCache.size;
    }
    let oldCacheSize = 0;
    for (const key of this.oldCache.keys()) {
      if (!this.cache.has(key)) {
        oldCacheSize++;
      }
    }
    return Math.min(this._size + oldCacheSize, this.maxSize);
  }
  entries() {
    return this.entriesAscending();
  }
  forEach(callbackFunction, thisArgument = this) {
    for (const [key, value2] of this.entriesAscending()) {
      callbackFunction.call(thisArgument, value2, key, this);
    }
  }
  get [Symbol.toStringTag]() {
    return JSON.stringify([...this.entriesAscending()]);
  }
}
const CID_CACHE_MAX_SIZE = 2048;
function invalidPinTypeErr(type) {
  const errMsg = `Invalid type '${type}', must be one of {direct, indirect, recursive, all}`;
  return errCode(new Error(errMsg), "ERR_INVALID_PIN_TYPE");
}
class PinManager {
  constructor({ pinstore, blockstore, loadCodec }) {
    this.pinstore = pinstore;
    this.blockstore = blockstore;
    this.loadCodec = loadCodec;
    this.log = debug("ipfs:repo:pin");
    this.directPins = /* @__PURE__ */ new Set();
    this.recursivePins = /* @__PURE__ */ new Set();
  }
  async pinDirectly(cid, options = {}) {
    await this.blockstore.get(cid, options);
    const pin = {
      depth: 0
    };
    if (cid.version !== 0) {
      pin.version = cid.version;
    }
    if (cid.code !== code$8) {
      pin.codec = cid.code;
    }
    if (options.metadata) {
      pin.metadata = options.metadata;
    }
    return this.pinstore.put(cidToKey$1(cid), encode$n(pin));
  }
  unpin(cid, options) {
    return this.pinstore.delete(cidToKey$1(cid), options);
  }
  async pinRecursively(cid, options = {}) {
    await this.fetchCompleteDag(cid, options);
    const pin = {
      depth: Infinity
    };
    if (cid.version !== 0) {
      pin.version = cid.version;
    }
    if (cid.code !== code$8) {
      pin.codec = cid.code;
    }
    if (options.metadata) {
      pin.metadata = options.metadata;
    }
    await this.pinstore.put(cidToKey$1(cid), encode$n(pin));
  }
  async *directKeys(options) {
    for await (const entry of this.pinstore.query({
      filters: [(entry2) => {
        const pin = decode$h(entry2.value);
        return pin.depth === 0;
      }]
    })) {
      const pin = decode$h(entry.value);
      const version2 = pin.version || 0;
      const codec = pin.codec != null ? pin.codec : code$8;
      const multihash = keyToMultihash(entry.key);
      yield {
        cid: CID.create(version2, codec, multihash),
        metadata: pin.metadata
      };
    }
  }
  async *recursiveKeys(options) {
    for await (const entry of this.pinstore.query({
      filters: [(entry2) => {
        const pin = decode$h(entry2.value);
        return pin.depth === Infinity;
      }]
    })) {
      const pin = decode$h(entry.value);
      const version2 = pin.version || 0;
      const codec = pin.codec != null ? pin.codec : code$8;
      const multihash = keyToMultihash(entry.key);
      yield {
        cid: CID.create(version2, codec, multihash),
        metadata: pin.metadata
      };
    }
  }
  async *indirectKeys(options) {
    for await (const { cid } of this.recursiveKeys()) {
      for await (const childCid of walkDag(cid, this.blockstore, this.loadCodec, options)) {
        const types2 = [
          PinTypes$1.recursive
        ];
        const result = await this.isPinnedWithType(childCid, types2);
        if (result.pinned) {
          continue;
        }
        yield childCid;
      }
    }
  }
  async isPinnedWithType(cid, types2, options) {
    if (!Array.isArray(types2)) {
      types2 = [types2];
    }
    const all2 = types2.includes(PinTypes$1.all);
    const direct = types2.includes(PinTypes$1.direct);
    const recursive2 = types2.includes(PinTypes$1.recursive);
    const indirect = types2.includes(PinTypes$1.indirect);
    if (recursive2 || direct || all2) {
      const result = await first$1(this.pinstore.query({
        prefix: cidToKey$1(cid).toString(),
        filters: [(entry) => {
          if (all2) {
            return true;
          }
          const pin = decode$h(entry.value);
          return types2.includes(pin.depth === 0 ? PinTypes$1.direct : PinTypes$1.recursive);
        }],
        limit: 1
      }));
      if (result) {
        const pin = decode$h(result.value);
        return {
          cid,
          pinned: true,
          reason: pin.depth === 0 ? PinTypes$1.direct : PinTypes$1.recursive,
          metadata: pin.metadata
        };
      }
    }
    const self2 = this;
    async function* findChild(key, source2) {
      for await (const { cid: parentCid } of source2) {
        for await (const childCid of walkDag(parentCid, self2.blockstore, self2.loadCodec)) {
          if (childCid.equals(key)) {
            yield parentCid;
            return;
          }
        }
      }
    }
    if (all2 || indirect) {
      const parentCid = await first$1(findChild(cid, this.recursiveKeys()));
      if (parentCid) {
        return {
          cid,
          pinned: true,
          reason: PinTypes$1.indirect,
          parent: parentCid
        };
      }
    }
    return {
      cid,
      pinned: false
    };
  }
  async fetchCompleteDag(cid, options = {}) {
    const seen = new QuickLRU({ maxSize: options.cidCacheMaxSize ?? CID_CACHE_MAX_SIZE });
    const walkDag2 = async (cid2, options2) => {
      if (seen.has(cid2.toString())) {
        return;
      }
      seen.set(cid2.toString(), true);
      const bytes2 = await this.blockstore.get(cid2, options2);
      const codec = await this.loadCodec(cid2.code);
      const block = createUnsafe({ bytes: bytes2, cid: cid2, codec });
      await Promise.all(
        [...block.links()].map(([, childCid]) => walkDag2(childCid, options2))
      );
    };
    await walkDag2(cid, options);
  }
  static checkPinType(type) {
    if (typeof type !== "string" || !Object.keys(PinTypes$1).includes(type)) {
      throw invalidPinTypeErr(type);
    }
    return true;
  }
}
function createPinnedBlockstore(pins, store) {
  return {
    open() {
      return store.open();
    },
    close() {
      return store.close();
    },
    query(query, options) {
      return store.query(query, options);
    },
    queryKeys(query, options) {
      return store.queryKeys(query, options);
    },
    async get(cid, options) {
      return store.get(cid, options);
    },
    async *getMany(cids, options) {
      yield* store.getMany(cids, options);
    },
    async put(cid, buf2, options) {
      await store.put(cid, buf2, options);
    },
    async *putMany(pairs, options) {
      yield* store.putMany(pairs, options);
    },
    has(cid, options) {
      return store.has(cid, options);
    },
    async delete(cid, options) {
      await ensureNotPinned(cid, pins);
      return store.delete(cid, options);
    },
    deleteMany(cids, options) {
      return store.deleteMany(map$3(cids, async (cid) => {
        await ensureNotPinned(cid, pins);
        return cid;
      }), options);
    },
    batch() {
      return store.batch();
    }
  };
}
async function ensureNotPinned(cid, pins) {
  const { pinned, reason } = await pins.isPinnedWithType(cid, PinTypes$1.all);
  if (pinned) {
    throw errCode(new Error(`pinned: ${reason}`), "ERR_BLOCK_PINNED");
  }
}
const log$Z = debug("ipfs:repo:gc");
const ERR_NOT_FOUND = notFoundError$1().code;
const BLOCK_RM_CONCURRENCY = 256;
const MFS_ROOT_KEY = new Key("/local/filesroot");
function gc({ gcLock, pins, blockstore, root, loadCodec }) {
  async function* gc2() {
    const start = Date.now();
    log$Z("Creating set of marked blocks");
    const release = await gcLock.writeLock();
    try {
      const markedSet = await createMarkedSet({ pins, blockstore, root, loadCodec });
      const blockKeys = blockstore.queryKeys({});
      yield* deleteUnmarkedBlocks({ blockstore }, markedSet, blockKeys);
      log$Z(`Complete (${Date.now() - start}ms)`);
    } finally {
      release();
    }
  }
  return gc2;
}
async function createMarkedSet({ pins, blockstore, loadCodec, root }) {
  const mfsSource = async function* () {
    let mh;
    try {
      mh = await root.get(MFS_ROOT_KEY);
    } catch (err2) {
      if (err2.code === ERR_NOT_FOUND) {
        log$Z("No blocks in MFS");
        return;
      }
      throw err2;
    }
    const rootCid = CID.decode(mh);
    yield rootCid;
    yield* walkDag(rootCid, blockstore, loadCodec);
  }();
  const pinsSource = merge$1(
    map$3(pins.recursiveKeys(), ({ cid }) => cid),
    pins.indirectKeys(),
    map$3(pins.directKeys(), ({ cid }) => cid),
    mfsSource
  );
  const output = /* @__PURE__ */ new Set();
  for await (const cid of merge$1(pinsSource, mfsSource)) {
    output.add(base32$2.encode(cid.multihash.bytes));
  }
  return output;
}
async function* deleteUnmarkedBlocks({ blockstore }, markedSet, blockKeys) {
  let blocksCount = 0;
  let removedBlocksCount = 0;
  const removeBlock = async (cid) => {
    return async function remove2() {
      blocksCount++;
      try {
        const b32 = base32$2.encode(cid.multihash.bytes);
        if (markedSet.has(b32)) {
          return null;
        }
        try {
          await blockstore.delete(cid);
          removedBlocksCount++;
        } catch (err2) {
          return {
            err: new Error(`Could not delete block with CID ${cid}: ${err2.message}`)
          };
        }
        return { cid };
      } catch (err2) {
        const msg = `Could delete block with CID ${cid}`;
        log$Z(msg, err2);
        return { err: new Error(msg + `: ${err2.message}`) };
      }
    };
  };
  yield* pipe(
    parallelBatch(map$3(blockKeys, removeBlock), BLOCK_RM_CONCURRENCY),
    (source2) => filter$1(source2, Boolean)
  );
  log$Z(`Marked set has ${markedSet.size} unique blocks. Blockstore has ${blocksCount} blocks. Deleted ${removedBlocksCount} blocks.`);
}
const log$Y = debug("ipfs:repo");
const noLimit = Number.MAX_SAFE_INTEGER;
const AUTO_MIGRATE_CONFIG_KEY = "repoAutoMigrate";
class Repo {
  constructor(path2, loadCodec, backends, options) {
    if (typeof path2 !== "string") {
      throw new Error("missing repo path");
    }
    if (typeof loadCodec !== "function") {
      throw new Error("missing codec loader");
    }
    this.options = mergeOptions$g(defaultOptions$5, options);
    this.closed = true;
    this.path = path2;
    this.root = backends.root;
    this.datastore = backends.datastore;
    this.keys = backends.keys;
    const blockstore = backends.blocks;
    const pinstore = backends.pins;
    this.pins = new PinManager({ pinstore, blockstore, loadCodec });
    const pinnedBlockstore = createPinnedBlockstore(this.pins, blockstore);
    this.blocks = createIdStore(pinnedBlockstore);
    this.version = version$1(this.root);
    this.config = config(this.root);
    this.spec = spec(this.root);
    this.apiAddr = apiAddr(this.root);
    this.gcLock = createMortice({
      name: path2,
      singleProcess: this.options.repoOwner !== false
    });
    this.gc = gc({ gcLock: this.gcLock, pins: this.pins, blockstore: this.blocks, root: this.root, loadCodec });
  }
  async init(config2) {
    log$Y("initializing at: %s", this.path);
    await this._openRoot();
    await this.config.replace(buildConfig(config2));
    await this.spec.set(buildDatastoreSpec(config2));
    await this.version.set(repoVersion);
  }
  async isInitialized() {
    if (!this.closed) {
      return true;
    }
    try {
      await this._openRoot();
      await this._checkInitialized();
      await this.root.close();
      return true;
    } catch (err2) {
      return false;
    }
  }
  async open() {
    if (!this.closed) {
      throw errCode(new Error("repo is already open"), ERR_REPO_ALREADY_OPEN);
    }
    log$Y("opening at: %s", this.path);
    try {
      await this._openRoot();
      await this._checkInitialized();
      this._lockfile = await this._openLock();
      log$Y("acquired repo.lock");
      const isCompatible = await this.version.check(repoVersion);
      if (!isCompatible) {
        if (await this._isAutoMigrationEnabled()) {
          await this._migrate(repoVersion, {
            root: this.root,
            datastore: this.datastore,
            pins: this.pins.pinstore,
            blocks: this.pins.blockstore,
            keys: this.keys
          });
        } else {
          throw new InvalidRepoVersionError("Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.");
        }
      }
      log$Y("creating datastore");
      await this.datastore.open();
      log$Y("creating blocks");
      await this.blocks.open();
      log$Y("creating keystore");
      await this.keys.open();
      log$Y("creating pins");
      await this.pins.pinstore.open();
      this.closed = false;
      log$Y("all opened");
    } catch (err2) {
      if (this._lockfile) {
        try {
          await this._closeLock();
          this._lockfile = null;
        } catch (err22) {
          log$Y("error removing lock", err22);
        }
      }
      throw err2;
    }
  }
  async _openRoot() {
    try {
      await this.root.open();
    } catch (err2) {
      if (err2.message !== "Already open") {
        throw err2;
      }
    }
  }
  async _openLock() {
    const lockfile = await this.options.repoLock.lock(this.path);
    if (typeof lockfile.close !== "function") {
      throw errCode(new Error("Locks must have a close method"), "ERR_NO_CLOSE_FUNCTION");
    }
    return lockfile;
  }
  _closeLock() {
    return this._lockfile && this._lockfile.close();
  }
  async _checkInitialized() {
    log$Y("init check");
    let config2;
    try {
      [config2] = await Promise.all([
        this.config.exists(),
        this.spec.exists(),
        this.version.exists()
      ]);
    } catch (err2) {
      if (err2.code === "ERR_NOT_FOUND") {
        throw errCode(new Error("repo is not initialized yet"), ERR_REPO_NOT_INITIALIZED, {
          path: this.path
        });
      }
      throw err2;
    }
    if (!config2) {
      throw errCode(new Error("repo is not initialized yet"), ERR_REPO_NOT_INITIALIZED, {
        path: this.path
      });
    }
  }
  async close() {
    if (this.closed) {
      throw errCode(new Error("repo is already closed"), ERR_REPO_ALREADY_CLOSED);
    }
    log$Y("closing at: %s", this.path);
    try {
      await this.apiAddr.delete();
    } catch (err2) {
      if (err2.code !== ERR_REPO_NOT_INITIALIZED && !err2.message.startsWith("ENOENT")) {
        throw err2;
      }
    }
    await Promise.all([
      this.root,
      this.blocks,
      this.keys,
      this.datastore,
      this.pins.pinstore
    ].map((store) => store && store.close()));
    log$Y("unlocking");
    this.closed = true;
    await this._closeLock();
  }
  exists() {
    return this.version.exists();
  }
  async stat() {
    if (this.datastore && this.keys) {
      const [storageMax, blocks, version2, datastore, keys] = await Promise.all([
        this._storageMaxStat(),
        this._blockStat(),
        this.version.get(),
        getSize(this.datastore),
        getSize(this.keys)
      ]);
      const size2 = blocks.size + datastore + keys;
      return {
        repoPath: this.path,
        storageMax,
        version: version2,
        numObjects: blocks.count,
        repoSize: size2
      };
    }
    throw errCode(new Error("repo is not initialized yet"), ERR_REPO_NOT_INITIALIZED, {
      path: this.path
    });
  }
  async _isAutoMigrationEnabled() {
    if (this.options.autoMigrate !== void 0) {
      return this.options.autoMigrate;
    }
    let autoMigrateConfig;
    try {
      autoMigrateConfig = await this.config.get(AUTO_MIGRATE_CONFIG_KEY);
    } catch (e) {
      if (e.code === NotFoundError.code) {
        autoMigrateConfig = true;
      } else {
        throw e;
      }
    }
    return autoMigrateConfig;
  }
  async _migrate(toVersion, backends) {
    const currentRepoVersion = await this.version.get();
    if (currentRepoVersion > toVersion) {
      log$Y(`reverting to version ${toVersion}`);
      return revert(this.path, backends, this.options, toVersion, {
        ignoreLock: true,
        onProgress: this.options.onMigrationProgress
      });
    } else {
      log$Y(`migrating to version ${toVersion}`);
      return migrate(this.path, backends, this.options, toVersion, {
        ignoreLock: true,
        onProgress: this.options.onMigrationProgress
      });
    }
  }
  async _storageMaxStat() {
    try {
      const max = await this.config.get("Datastore.StorageMax");
      return BigInt(bytes$1.exports(max));
    } catch (err2) {
      return BigInt(noLimit);
    }
  }
  async _blockStat() {
    let count = BigInt(0);
    let size2 = BigInt(0);
    if (this.blocks) {
      for await (const { key, value: value2 } of this.blocks.query({})) {
        count += BigInt(1);
        size2 += BigInt(value2.byteLength);
        size2 += BigInt(key.bytes.byteLength);
      }
    }
    return { count, size: size2 };
  }
}
async function getSize(datastore) {
  let sum = BigInt(0);
  for await (const block of datastore.query({})) {
    sum += BigInt(block.value.byteLength);
    sum += BigInt(block.key.uint8Array().byteLength);
  }
  return sum;
}
function createRepo$2(path2, loadCodec, backends, options) {
  return new Repo(path2, loadCodec, backends, options);
}
function buildConfig(_config) {
  _config.Datastore = Object.assign({}, defaultDatastore, objectSafeGet(_config, "datastore"));
  return _config;
}
function buildDatastoreSpec(_config) {
  const spec2 = {
    ...defaultDatastore.Spec,
    ...objectSafeGet(_config, "Datastore.Spec")
  };
  return {
    type: spec2.type,
    mounts: spec2.mounts.map((mounting) => ({
      mountpoint: mounting.mountpoint,
      type: mounting.child.type,
      path: mounting.child.path,
      shardFunc: mounting.child.shardFunc
    }))
  };
}
async function* take(source2, limit) {
  let items = 0;
  if (limit < 1) {
    return;
  }
  for await (const entry of source2) {
    yield entry;
    items++;
    if (items === limit) {
      return;
    }
  }
}
async function* sort(source2, sorter) {
  const arr = await all$1(source2);
  yield* arr.sort(sorter);
}
var browserLevel = {};
var abstractLevel$1 = {};
var abstractLevel = {};
var levelSupports = {};
levelSupports.supports = function supports2(...manifests) {
  const manifest = manifests.reduce((acc, m) => Object.assign(acc, m), {});
  return Object.assign(manifest, {
    snapshots: manifest.snapshots || false,
    permanence: manifest.permanence || false,
    seek: manifest.seek || false,
    clear: manifest.clear || false,
    getMany: manifest.getMany || false,
    keyIterator: manifest.keyIterator || false,
    valueIterator: manifest.valueIterator || false,
    iteratorNextv: manifest.iteratorNextv || false,
    iteratorAll: manifest.iteratorAll || false,
    status: manifest.status || false,
    createIfMissing: manifest.createIfMissing || false,
    errorIfExists: manifest.errorIfExists || false,
    deferredOpen: manifest.deferredOpen || false,
    promises: manifest.promises || false,
    streams: manifest.streams || false,
    encodings: Object.assign({}, manifest.encodings),
    events: Object.assign({}, manifest.events),
    additionalMethods: Object.assign({}, manifest.additionalMethods)
  });
};
var levelTranscoder = {};
var moduleError = class ModuleError2 extends Error {
  constructor(message2, options) {
    super(message2 || "");
    if (typeof options === "object" && options !== null) {
      if (options.code)
        this.code = String(options.code);
      if (options.expected)
        this.expected = true;
      if (options.transient)
        this.transient = true;
      if (options.cause)
        this.cause = options.cause;
    }
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};
var encodings$1 = {};
var buffer = {};
var base64Js = {};
base64Js.byteLength = byteLength$1;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup$3 = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$1 = 0, len = code$1.length; i$1 < len; ++i$1) {
  lookup$3[i$1] = code$1[i$1];
  revLookup[code$1.charCodeAt(i$1)] = i$1;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len2 = b64.length;
  if (len2 % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len2;
  var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength$1(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i2;
  for (i2 = 0; i2 < len2; i2 += 4) {
    tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup$3[num >> 18 & 63] + lookup$3[num >> 12 & 63] + lookup$3[num >> 6 & 63] + lookup$3[num & 63];
}
function encodeChunk(uint8, start, end2) {
  var tmp;
  var output = [];
  for (var i2 = start; i2 < end2; i2 += 3) {
    tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len2 = uint8.length;
  var extraBytes = len2 % 3;
  var parts2 = [];
  var maxChunkLength = 16383;
  for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
    parts2.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len2 - 1];
    parts2.push(
      lookup$3[tmp >> 2] + lookup$3[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
    parts2.push(
      lookup$3[tmp >> 10] + lookup$3[tmp >> 4 & 63] + lookup$3[tmp << 2 & 63] + "="
    );
  }
  return parts2.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i2 = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s2 = buffer2[offset + i2];
  i2 += d;
  e = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer2[offset + i2], i2 += d, nBits -= 8) {
  }
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer2[offset + i2], i2 += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);
};
ieee754.write = function(buffer2, value2, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i2 = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s2 = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
  value2 = Math.abs(value2);
  if (isNaN(value2) || value2 === Infinity) {
    m = isNaN(value2) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value2) / Math.LN2);
    if (value2 * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value2 += rt / c;
    } else {
      value2 += rt * Math.pow(2, 1 - eBias);
    }
    if (value2 * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value2 * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i2] = m & 255, i2 += d, m /= 256, mLen -= 8) {
  }
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i2] = e & 255, i2 += d, e /= 256, eLen -= 8) {
  }
  buffer2[offset + i2 - d] |= s2 * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports) {
  const base642 = base64Js;
  const ieee754$1 = ieee754;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports.Buffer = Buffer2;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length3) {
    if (length3 > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length3 + '" is invalid for option "size"');
    }
    const buf2 = new Uint8Array(length3);
    Object.setPrototypeOf(buf2, Buffer2.prototype);
    return buf2;
  }
  function Buffer2(arg, encodingOrOffset, length3) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe2(arg);
    }
    return from2(arg, encodingOrOffset, length3);
  }
  Buffer2.poolSize = 8192;
  function from2(value2, encodingOrOffset, length3) {
    if (typeof value2 === "string") {
      return fromString2(value2, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value2)) {
      return fromArrayView(value2);
    }
    if (value2 == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2
      );
    }
    if (isInstance(value2, ArrayBuffer) || value2 && isInstance(value2.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value2, encodingOrOffset, length3);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value2, SharedArrayBuffer) || value2 && isInstance(value2.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value2, encodingOrOffset, length3);
    }
    if (typeof value2 === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf = value2.valueOf && value2.valueOf();
    if (valueOf != null && valueOf !== value2) {
      return Buffer2.from(valueOf, encodingOrOffset, length3);
    }
    const b2 = fromObject(value2);
    if (b2)
      return b2;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value2[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value2[Symbol.toPrimitive]("string"), encodingOrOffset, length3);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2
    );
  }
  Buffer2.from = function(value2, encodingOrOffset, length3) {
    return from2(value2, encodingOrOffset, length3);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size2 < 0) {
      throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
    }
  }
  function alloc3(size2, fill, encoding2) {
    assertSize(size2);
    if (size2 <= 0) {
      return createBuffer(size2);
    }
    if (fill !== void 0) {
      return typeof encoding2 === "string" ? createBuffer(size2).fill(fill, encoding2) : createBuffer(size2).fill(fill);
    }
    return createBuffer(size2);
  }
  Buffer2.alloc = function(size2, fill, encoding2) {
    return alloc3(size2, fill, encoding2);
  };
  function allocUnsafe2(size2) {
    assertSize(size2);
    return createBuffer(size2 < 0 ? 0 : checked(size2) | 0);
  }
  Buffer2.allocUnsafe = function(size2) {
    return allocUnsafe2(size2);
  };
  Buffer2.allocUnsafeSlow = function(size2) {
    return allocUnsafe2(size2);
  };
  function fromString2(string2, encoding2) {
    if (typeof encoding2 !== "string" || encoding2 === "") {
      encoding2 = "utf8";
    }
    if (!Buffer2.isEncoding(encoding2)) {
      throw new TypeError("Unknown encoding: " + encoding2);
    }
    const length3 = byteLength2(string2, encoding2) | 0;
    let buf2 = createBuffer(length3);
    const actual = buf2.write(string2, encoding2);
    if (actual !== length3) {
      buf2 = buf2.slice(0, actual);
    }
    return buf2;
  }
  function fromArrayLike(array) {
    const length3 = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf2 = createBuffer(length3);
    for (let i2 = 0; i2 < length3; i2 += 1) {
      buf2[i2] = array[i2] & 255;
    }
    return buf2;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length3) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length3 || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf2;
    if (byteOffset === void 0 && length3 === void 0) {
      buf2 = new Uint8Array(array);
    } else if (length3 === void 0) {
      buf2 = new Uint8Array(array, byteOffset);
    } else {
      buf2 = new Uint8Array(array, byteOffset, length3);
    }
    Object.setPrototypeOf(buf2, Buffer2.prototype);
    return buf2;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      const len2 = checked(obj.length) | 0;
      const buf2 = createBuffer(len2);
      if (buf2.length === 0) {
        return buf2;
      }
      obj.copy(buf2, 0, 0, len2);
      return buf2;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length3) {
    if (length3 >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length3 | 0;
  }
  function SlowBuffer(length3) {
    if (+length3 != length3) {
      length3 = 0;
    }
    return Buffer2.alloc(+length3);
  }
  Buffer2.isBuffer = function isBuffer2(b2) {
    return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
  };
  Buffer2.compare = function compare2(a, b2) {
    if (isInstance(a, Uint8Array))
      a = Buffer2.from(a, a.offset, a.byteLength);
    if (isInstance(b2, Uint8Array))
      b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b2)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a === b2)
      return 0;
    let x = a.length;
    let y = b2.length;
    for (let i2 = 0, len2 = Math.min(x, y); i2 < len2; ++i2) {
      if (a[i2] !== b2[i2]) {
        x = a[i2];
        y = b2[i2];
        break;
      }
    }
    if (x < y)
      return -1;
    if (y < x)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding2) {
    switch (String(encoding2).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat2(list, length3) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    let i2;
    if (length3 === void 0) {
      length3 = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        length3 += list[i2].length;
      }
    }
    const buffer2 = Buffer2.allocUnsafe(length3);
    let pos = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      let buf2 = list[i2];
      if (isInstance(buf2, Uint8Array)) {
        if (pos + buf2.length > buffer2.length) {
          if (!Buffer2.isBuffer(buf2))
            buf2 = Buffer2.from(buf2);
          buf2.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(
            buffer2,
            buf2,
            pos
          );
        }
      } else if (!Buffer2.isBuffer(buf2)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf2.copy(buffer2, pos);
      }
      pos += buf2.length;
    }
    return buffer2;
  };
  function byteLength2(string2, encoding2) {
    if (Buffer2.isBuffer(string2)) {
      return string2.length;
    }
    if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
      return string2.byteLength;
    }
    if (typeof string2 !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
      );
    }
    const len2 = string2.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len2 === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding2) {
        case "ascii":
        case "latin1":
        case "binary":
          return len2;
        case "utf8":
        case "utf-8":
          return utf8ToBytes2(string2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len2 * 2;
        case "hex":
          return len2 >>> 1;
        case "base64":
          return base64ToBytes(string2).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes2(string2).length;
          }
          encoding2 = ("" + encoding2).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding2, start, end2) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end2 === void 0 || end2 > this.length) {
      end2 = this.length;
    }
    if (end2 <= 0) {
      return "";
    }
    end2 >>>= 0;
    start >>>= 0;
    if (end2 <= start) {
      return "";
    }
    if (!encoding2)
      encoding2 = "utf8";
    while (true) {
      switch (encoding2) {
        case "hex":
          return hexSlice(this, start, end2);
        case "utf8":
        case "utf-8":
          return utf8Slice2(this, start, end2);
        case "ascii":
          return asciiSlice(this, start, end2);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end2);
        case "base64":
          return base64Slice(this, start, end2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end2);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding2);
          encoding2 = (encoding2 + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b2, n, m) {
    const i2 = b2[n];
    b2[n] = b2[m];
    b2[m] = i2;
  }
  Buffer2.prototype.swap16 = function swap16() {
    const len2 = this.length;
    if (len2 % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i2 = 0; i2 < len2; i2 += 2) {
      swap(this, i2, i2 + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    const len2 = this.length;
    if (len2 % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i2 = 0; i2 < len2; i2 += 4) {
      swap(this, i2, i2 + 3);
      swap(this, i2 + 1, i2 + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    const len2 = this.length;
    if (len2 % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i2 = 0; i2 < len2; i2 += 8) {
      swap(this, i2, i2 + 7);
      swap(this, i2 + 1, i2 + 6);
      swap(this, i2 + 2, i2 + 5);
      swap(this, i2 + 3, i2 + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString2() {
    const length3 = this.length;
    if (length3 === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice2(this, 0, length3);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals2(b2) {
    if (!Buffer2.isBuffer(b2))
      throw new TypeError("Argument must be a Buffer");
    if (this === b2)
      return true;
    return Buffer2.compare(this, b2) === 0;
  };
  Buffer2.prototype.inspect = function inspect2() {
    let str = "";
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare2(target, start, end2, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end2 === void 0) {
      end2 = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end2 > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end2) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end2) {
      return 1;
    }
    start >>>= 0;
    end2 >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x = thisEnd - thisStart;
    let y = end2 - start;
    const len2 = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end2);
    for (let i2 = 0; i2 < len2; ++i2) {
      if (thisCopy[i2] !== targetCopy[i2]) {
        x = thisCopy[i2];
        y = targetCopy[i2];
        break;
      }
    }
    if (x < y)
      return -1;
    if (y < x)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding2, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding2 = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding2);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding2, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding2, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding2, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding2 !== void 0) {
      encoding2 = String(encoding2).toLowerCase();
      if (encoding2 === "ucs2" || encoding2 === "ucs-2" || encoding2 === "utf16le" || encoding2 === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf2, i3) {
      if (indexSize === 1) {
        return buf2[i3];
      } else {
        return buf2.readUInt16BE(i3 * indexSize);
      }
    }
    let i2;
    if (dir) {
      let foundIndex = -1;
      for (i2 = byteOffset; i2 < arrLength; i2++) {
        if (read2(arr, i2) === read2(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i2;
          if (i2 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i2 -= i2 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i2 = byteOffset; i2 >= 0; i2--) {
        let found = true;
        for (let j = 0; j < valLength; j++) {
          if (read2(arr, i2 + j) !== read2(val, j)) {
            found = false;
            break;
          }
        }
        if (found)
          return i2;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding2) {
    return this.indexOf(val, byteOffset, encoding2) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding2) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding2, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding2) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding2, false);
  };
  function hexWrite(buf2, string2, offset, length3) {
    offset = Number(offset) || 0;
    const remaining = buf2.length - offset;
    if (!length3) {
      length3 = remaining;
    } else {
      length3 = Number(length3);
      if (length3 > remaining) {
        length3 = remaining;
      }
    }
    const strLen = string2.length;
    if (length3 > strLen / 2) {
      length3 = strLen / 2;
    }
    let i2;
    for (i2 = 0; i2 < length3; ++i2) {
      const parsed = parseInt(string2.substr(i2 * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i2;
      buf2[offset + i2] = parsed;
    }
    return i2;
  }
  function utf8Write(buf2, string2, offset, length3) {
    return blitBuffer(utf8ToBytes2(string2, buf2.length - offset), buf2, offset, length3);
  }
  function asciiWrite(buf2, string2, offset, length3) {
    return blitBuffer(asciiToBytes(string2), buf2, offset, length3);
  }
  function base64Write(buf2, string2, offset, length3) {
    return blitBuffer(base64ToBytes(string2), buf2, offset, length3);
  }
  function ucs2Write(buf2, string2, offset, length3) {
    return blitBuffer(utf16leToBytes(string2, buf2.length - offset), buf2, offset, length3);
  }
  Buffer2.prototype.write = function write2(string2, offset, length3, encoding2) {
    if (offset === void 0) {
      encoding2 = "utf8";
      length3 = this.length;
      offset = 0;
    } else if (length3 === void 0 && typeof offset === "string") {
      encoding2 = offset;
      length3 = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length3)) {
        length3 = length3 >>> 0;
        if (encoding2 === void 0)
          encoding2 = "utf8";
      } else {
        encoding2 = length3;
        length3 = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset;
    if (length3 === void 0 || length3 > remaining)
      length3 = remaining;
    if (string2.length > 0 && (length3 < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding2)
      encoding2 = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding2) {
        case "hex":
          return hexWrite(this, string2, offset, length3);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string2, offset, length3);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string2, offset, length3);
        case "base64":
          return base64Write(this, string2, offset, length3);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string2, offset, length3);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding2);
          encoding2 = ("" + encoding2).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf2, start, end2) {
    if (start === 0 && end2 === buf2.length) {
      return base642.fromByteArray(buf2);
    } else {
      return base642.fromByteArray(buf2.slice(start, end2));
    }
  }
  function utf8Slice2(buf2, start, end2) {
    end2 = Math.min(buf2.length, end2);
    const res = [];
    let i2 = start;
    while (i2 < end2) {
      const firstByte = buf2[i2];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i2 + bytesPerSequence <= end2) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf2[i2 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf2[i2 + 1];
            thirdByte = buf2[i2 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf2[i2 + 1];
            thirdByte = buf2[i2 + 2];
            fourthByte = buf2[i2 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i2 += bytesPerSequence;
    }
    return decodeCodePointsArray2(res);
  }
  const MAX_ARGUMENTS_LENGTH2 = 4096;
  function decodeCodePointsArray2(codePoints) {
    const len2 = codePoints.length;
    if (len2 <= MAX_ARGUMENTS_LENGTH2) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i2 = 0;
    while (i2 < len2) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH2)
      );
    }
    return res;
  }
  function asciiSlice(buf2, start, end2) {
    let ret = "";
    end2 = Math.min(buf2.length, end2);
    for (let i2 = start; i2 < end2; ++i2) {
      ret += String.fromCharCode(buf2[i2] & 127);
    }
    return ret;
  }
  function latin1Slice(buf2, start, end2) {
    let ret = "";
    end2 = Math.min(buf2.length, end2);
    for (let i2 = start; i2 < end2; ++i2) {
      ret += String.fromCharCode(buf2[i2]);
    }
    return ret;
  }
  function hexSlice(buf2, start, end2) {
    const len2 = buf2.length;
    if (!start || start < 0)
      start = 0;
    if (!end2 || end2 < 0 || end2 > len2)
      end2 = len2;
    let out = "";
    for (let i2 = start; i2 < end2; ++i2) {
      out += hexSliceLookupTable[buf2[i2]];
    }
    return out;
  }
  function utf16leSlice(buf2, start, end2) {
    const bytes2 = buf2.slice(start, end2);
    let res = "";
    for (let i2 = 0; i2 < bytes2.length - 1; i2 += 2) {
      res += String.fromCharCode(bytes2[i2] + bytes2[i2 + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice2(start, end2) {
    const len2 = this.length;
    start = ~~start;
    end2 = end2 === void 0 ? len2 : ~~end2;
    if (start < 0) {
      start += len2;
      if (start < 0)
        start = 0;
    } else if (start > len2) {
      start = len2;
    }
    if (end2 < 0) {
      end2 += len2;
      if (end2 < 0)
        end2 = 0;
    } else if (end2 > len2) {
      end2 = len2;
    }
    if (end2 < start)
      end2 = start;
    const newBuf = this.subarray(start, end2);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length3) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length3)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i2 = 0;
    while (++i2 < byteLength3 && (mul *= 256)) {
      val += this[offset + i2] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    let val = this[offset + --byteLength3];
    let mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength3] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last2 = this[offset + 7];
    if (first2 === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first2 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last2 * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last2 = this[offset + 7];
    if (first2 === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi = first2 * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i2 = 0;
    while (++i2 < byteLength3 && (mul *= 256)) {
      val += this[offset + i2] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let i2 = byteLength3;
    let mul = 1;
    let val = this[offset + --i2];
    while (i2 > 0 && (mul *= 256)) {
      val += this[offset + --i2] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last2 = this[offset + 7];
    if (first2 === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last2 << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first2 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last2 = this[offset + 7];
    if (first2 === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first2 << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, false, 52, 8);
  };
  function checkInt(buf2, value2, offset, ext, max, min) {
    if (!Buffer2.isBuffer(buf2))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value2 > max || value2 < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf2.length)
      throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value2, offset, byteLength3, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value2, offset, byteLength3, maxBytes, 0);
    }
    let mul = 1;
    let i2 = 0;
    this[offset] = value2 & 255;
    while (++i2 < byteLength3 && (mul *= 256)) {
      this[offset + i2] = value2 / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value2, offset, byteLength3, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value2, offset, byteLength3, maxBytes, 0);
    }
    let i2 = byteLength3 - 1;
    let mul = 1;
    this[offset + i2] = value2 & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      this[offset + i2] = value2 / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 1, 255, 0);
    this[offset] = value2 & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 2, 65535, 0);
    this[offset] = value2 & 255;
    this[offset + 1] = value2 >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 2, 65535, 0);
    this[offset] = value2 >>> 8;
    this[offset + 1] = value2 & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 4, 4294967295, 0);
    this[offset + 3] = value2 >>> 24;
    this[offset + 2] = value2 >>> 16;
    this[offset + 1] = value2 >>> 8;
    this[offset] = value2 & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 4, 4294967295, 0);
    this[offset] = value2 >>> 24;
    this[offset + 1] = value2 >>> 16;
    this[offset + 2] = value2 >>> 8;
    this[offset + 3] = value2 & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf2, value2, offset, min, max) {
    checkIntBI(value2, min, max, buf2, offset, 7);
    let lo = Number(value2 & BigInt(4294967295));
    buf2[offset++] = lo;
    lo = lo >> 8;
    buf2[offset++] = lo;
    lo = lo >> 8;
    buf2[offset++] = lo;
    lo = lo >> 8;
    buf2[offset++] = lo;
    let hi = Number(value2 >> BigInt(32) & BigInt(4294967295));
    buf2[offset++] = hi;
    hi = hi >> 8;
    buf2[offset++] = hi;
    hi = hi >> 8;
    buf2[offset++] = hi;
    hi = hi >> 8;
    buf2[offset++] = hi;
    return offset;
  }
  function wrtBigUInt64BE(buf2, value2, offset, min, max) {
    checkIntBI(value2, min, max, buf2, offset, 7);
    let lo = Number(value2 & BigInt(4294967295));
    buf2[offset + 7] = lo;
    lo = lo >> 8;
    buf2[offset + 6] = lo;
    lo = lo >> 8;
    buf2[offset + 5] = lo;
    lo = lo >> 8;
    buf2[offset + 4] = lo;
    let hi = Number(value2 >> BigInt(32) & BigInt(4294967295));
    buf2[offset + 3] = hi;
    hi = hi >> 8;
    buf2[offset + 2] = hi;
    hi = hi >> 8;
    buf2[offset + 1] = hi;
    hi = hi >> 8;
    buf2[offset] = hi;
    return offset + 8;
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value2, offset = 0) {
    return wrtBigUInt64LE(this, value2, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value2, offset = 0) {
    return wrtBigUInt64BE(this, value2, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value2, offset, byteLength3, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value2, offset, byteLength3, limit - 1, -limit);
    }
    let i2 = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value2 & 255;
    while (++i2 < byteLength3 && (mul *= 256)) {
      if (value2 < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value2 / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value2, offset, byteLength3, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value2, offset, byteLength3, limit - 1, -limit);
    }
    let i2 = byteLength3 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i2] = value2 & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      if (value2 < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value2 / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 1, 127, -128);
    if (value2 < 0)
      value2 = 255 + value2 + 1;
    this[offset] = value2 & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 2, 32767, -32768);
    this[offset] = value2 & 255;
    this[offset + 1] = value2 >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 2, 32767, -32768);
    this[offset] = value2 >>> 8;
    this[offset + 1] = value2 & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 4, 2147483647, -2147483648);
    this[offset] = value2 & 255;
    this[offset + 1] = value2 >>> 8;
    this[offset + 2] = value2 >>> 16;
    this[offset + 3] = value2 >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 4, 2147483647, -2147483648);
    if (value2 < 0)
      value2 = 4294967295 + value2 + 1;
    this[offset] = value2 >>> 24;
    this[offset + 1] = value2 >>> 16;
    this[offset + 2] = value2 >>> 8;
    this[offset + 3] = value2 & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value2, offset = 0) {
    return wrtBigUInt64LE(this, value2, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value2, offset = 0) {
    return wrtBigUInt64BE(this, value2, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf2, value2, offset, ext, max, min) {
    if (offset + ext > buf2.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf2, value2, offset, littleEndian, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf2, value2, offset, 4);
    }
    ieee754$1.write(buf2, value2, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value2, offset, noAssert) {
    return writeFloat(this, value2, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value2, offset, noAssert) {
    return writeFloat(this, value2, offset, false, noAssert);
  };
  function writeDouble(buf2, value2, offset, littleEndian, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf2, value2, offset, 8);
    }
    ieee754$1.write(buf2, value2, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value2, offset, noAssert) {
    return writeDouble(this, value2, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value2, offset, noAssert) {
    return writeDouble(this, value2, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy(target, targetStart, start, end2) {
    if (!Buffer2.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end2 && end2 !== 0)
      end2 = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end2 > 0 && end2 < start)
      end2 = start;
    if (end2 === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end2 < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end2 > this.length)
      end2 = this.length;
    if (target.length - targetStart < end2 - start) {
      end2 = target.length - targetStart + start;
    }
    const len2 = end2 - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end2);
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, end2),
        targetStart
      );
    }
    return len2;
  };
  Buffer2.prototype.fill = function fill(val, start, end2, encoding2) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding2 = start;
        start = 0;
        end2 = this.length;
      } else if (typeof end2 === "string") {
        encoding2 = end2;
        end2 = this.length;
      }
      if (encoding2 !== void 0 && typeof encoding2 !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding2 === "string" && !Buffer2.isEncoding(encoding2)) {
        throw new TypeError("Unknown encoding: " + encoding2);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding2 === "utf8" && code2 < 128 || encoding2 === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end2) {
      throw new RangeError("Out of range index");
    }
    if (end2 <= start) {
      return this;
    }
    start = start >>> 0;
    end2 = end2 === void 0 ? this.length : end2 >>> 0;
    if (!val)
      val = 0;
    let i2;
    if (typeof val === "number") {
      for (i2 = start; i2 < end2; ++i2) {
        this[i2] = val;
      }
    } else {
      const bytes2 = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding2);
      const len2 = bytes2.length;
      if (len2 === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i2 = 0; i2 < end2 - start; ++i2) {
        this[i2 + start] = bytes2[i2 % len2];
      }
    }
    return this;
  };
  const errors2 = {};
  function E(sym, getMessage, Base) {
    errors2[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value2) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value: value2,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name2) {
      if (name2) {
        return `${name2} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E(
    "ERR_INVALID_ARG_TYPE",
    function(name2, actual) {
      return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E(
    "ERR_OUT_OF_RANGE",
    function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    },
    RangeError
  );
  function addNumericalSeparator(val) {
    let res = "";
    let i2 = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i2 >= start + 4; i2 -= 3) {
      res = `_${val.slice(i2 - 3, i2)}${res}`;
    }
    return `${val.slice(0, i2)}${res}`;
  }
  function checkBounds(buf2, offset, byteLength3) {
    validateNumber(offset, "offset");
    if (buf2[offset] === void 0 || buf2[offset + byteLength3] === void 0) {
      boundsError(offset, buf2.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value2, min, max, buf2, offset, byteLength3) {
    if (value2 > max || value2 < min) {
      const n = typeof min === "bigint" ? "n" : "";
      let range;
      if (byteLength3 > 3) {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n} and < 2${n} ** ${(byteLength3 + 1) * 8}${n}`;
        } else {
          range = `>= -(2${n} ** ${(byteLength3 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n}`;
        }
      } else {
        range = `>= ${min}${n} and <= ${max}${n}`;
      }
      throw new errors2.ERR_OUT_OF_RANGE("value", range, value2);
    }
    checkBounds(buf2, offset, byteLength3);
  }
  function validateNumber(value2, name2) {
    if (typeof value2 !== "number") {
      throw new errors2.ERR_INVALID_ARG_TYPE(name2, "number", value2);
    }
  }
  function boundsError(value2, length3, type) {
    if (Math.floor(value2) !== value2) {
      validateNumber(value2, type);
      throw new errors2.ERR_OUT_OF_RANGE(type || "offset", "an integer", value2);
    }
    if (length3 < 0) {
      throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors2.ERR_OUT_OF_RANGE(
      type || "offset",
      `>= ${type ? 1 : 0} and <= ${length3}`,
      value2
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes2(string2, units) {
    units = units || Infinity;
    let codePoint;
    const length3 = string2.length;
    let leadSurrogate = null;
    const bytes2 = [];
    for (let i2 = 0; i2 < length3; ++i2) {
      codePoint = string2.charCodeAt(i2);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
            continue;
          } else if (i2 + 1 === length3) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes2.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes2.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes2.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes2.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes2.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes2;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i2 = 0; i2 < str.length; ++i2) {
      byteArray.push(str.charCodeAt(i2) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for (let i2 = 0; i2 < str.length; ++i2) {
      if ((units -= 2) < 0)
        break;
      c = str.charCodeAt(i2);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base642.toByteArray(base64clean(str));
  }
  function blitBuffer(src2, dst, offset, length3) {
    let i2;
    for (i2 = 0; i2 < length3; ++i2) {
      if (i2 + offset >= dst.length || i2 >= src2.length)
        break;
      dst[i2 + offset] = src2[i2];
    }
    return i2;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet2 = "0123456789abcdef";
    const table2 = new Array(256);
    for (let i2 = 0; i2 < 16; ++i2) {
      const i16 = i2 * 16;
      for (let j = 0; j < 16; ++j) {
        table2[i16 + j] = alphabet2[i2] + alphabet2[j];
      }
    }
    return table2;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer);
let lazy = null;
var textEndec$1 = function() {
  if (lazy === null) {
    lazy = {
      textEncoder: new TextEncoder(),
      textDecoder: new TextDecoder()
    };
  }
  return lazy;
};
var formats$2 = {};
var encoding = {};
const ModuleError$8 = moduleError;
const formats$1 = /* @__PURE__ */ new Set(["buffer", "view", "utf8"]);
class Encoding$2 {
  constructor(options) {
    this.encode = options.encode || this.encode;
    this.decode = options.decode || this.decode;
    this.name = options.name || this.name;
    this.format = options.format || this.format;
    if (typeof this.encode !== "function") {
      throw new TypeError("The 'encode' property must be a function");
    }
    if (typeof this.decode !== "function") {
      throw new TypeError("The 'decode' property must be a function");
    }
    this.encode = this.encode.bind(this);
    this.decode = this.decode.bind(this);
    if (typeof this.name !== "string" || this.name === "") {
      throw new TypeError("The 'name' property must be a string");
    }
    if (typeof this.format !== "string" || !formats$1.has(this.format)) {
      throw new TypeError("The 'format' property must be one of 'buffer', 'view', 'utf8'");
    }
    if (options.createViewTranscoder) {
      this.createViewTranscoder = options.createViewTranscoder;
    }
    if (options.createBufferTranscoder) {
      this.createBufferTranscoder = options.createBufferTranscoder;
    }
    if (options.createUTF8Transcoder) {
      this.createUTF8Transcoder = options.createUTF8Transcoder;
    }
  }
  get commonName() {
    return this.name.split("+")[0];
  }
  createBufferTranscoder() {
    throw new ModuleError$8(`Encoding '${this.name}' cannot be transcoded to 'buffer'`, {
      code: "LEVEL_ENCODING_NOT_SUPPORTED"
    });
  }
  createViewTranscoder() {
    throw new ModuleError$8(`Encoding '${this.name}' cannot be transcoded to 'view'`, {
      code: "LEVEL_ENCODING_NOT_SUPPORTED"
    });
  }
  createUTF8Transcoder() {
    throw new ModuleError$8(`Encoding '${this.name}' cannot be transcoded to 'utf8'`, {
      code: "LEVEL_ENCODING_NOT_SUPPORTED"
    });
  }
}
encoding.Encoding = Encoding$2;
const { Buffer: Buffer$3 } = buffer || {};
const { Encoding: Encoding$1 } = encoding;
const textEndec = textEndec$1;
class BufferFormat$2 extends Encoding$1 {
  constructor(options) {
    super({ ...options, format: "buffer" });
  }
  createViewTranscoder() {
    return new ViewFormat$2({
      encode: this.encode,
      decode: (data) => this.decode(
        Buffer$3.from(data.buffer, data.byteOffset, data.byteLength)
      ),
      name: `${this.name}+view`
    });
  }
  createBufferTranscoder() {
    return this;
  }
}
class ViewFormat$2 extends Encoding$1 {
  constructor(options) {
    super({ ...options, format: "view" });
  }
  createBufferTranscoder() {
    return new BufferFormat$2({
      encode: (data) => {
        const view = this.encode(data);
        return Buffer$3.from(view.buffer, view.byteOffset, view.byteLength);
      },
      decode: this.decode,
      name: `${this.name}+buffer`
    });
  }
  createViewTranscoder() {
    return this;
  }
}
class UTF8Format$2 extends Encoding$1 {
  constructor(options) {
    super({ ...options, format: "utf8" });
  }
  createBufferTranscoder() {
    return new BufferFormat$2({
      encode: (data) => Buffer$3.from(this.encode(data), "utf8"),
      decode: (data) => this.decode(data.toString("utf8")),
      name: `${this.name}+buffer`
    });
  }
  createViewTranscoder() {
    const { textEncoder: textEncoder2, textDecoder: textDecoder2 } = textEndec();
    return new ViewFormat$2({
      encode: (data) => textEncoder2.encode(this.encode(data)),
      decode: (data) => this.decode(textDecoder2.decode(data)),
      name: `${this.name}+view`
    });
  }
  createUTF8Transcoder() {
    return this;
  }
}
formats$2.BufferFormat = BufferFormat$2;
formats$2.ViewFormat = ViewFormat$2;
formats$2.UTF8Format = UTF8Format$2;
const { Buffer: Buffer$2 } = buffer || { Buffer: { isBuffer: () => false } };
const { textEncoder: textEncoder$1, textDecoder } = textEndec$1();
const { BufferFormat: BufferFormat$1, ViewFormat: ViewFormat$1, UTF8Format: UTF8Format$1 } = formats$2;
const identity$3 = (v) => v;
encodings$1.utf8 = new UTF8Format$1({
  encode: function(data) {
    return Buffer$2.isBuffer(data) ? data.toString("utf8") : ArrayBuffer.isView(data) ? textDecoder.decode(data) : String(data);
  },
  decode: identity$3,
  name: "utf8",
  createViewTranscoder() {
    return new ViewFormat$1({
      encode: function(data) {
        return ArrayBuffer.isView(data) ? data : textEncoder$1.encode(data);
      },
      decode: function(data) {
        return textDecoder.decode(data);
      },
      name: `${this.name}+view`
    });
  },
  createBufferTranscoder() {
    return new BufferFormat$1({
      encode: function(data) {
        return Buffer$2.isBuffer(data) ? data : ArrayBuffer.isView(data) ? Buffer$2.from(data.buffer, data.byteOffset, data.byteLength) : Buffer$2.from(String(data), "utf8");
      },
      decode: function(data) {
        return data.toString("utf8");
      },
      name: `${this.name}+buffer`
    });
  }
});
encodings$1.json = new UTF8Format$1({
  encode: JSON.stringify,
  decode: JSON.parse,
  name: "json"
});
encodings$1.buffer = new BufferFormat$1({
  encode: function(data) {
    return Buffer$2.isBuffer(data) ? data : ArrayBuffer.isView(data) ? Buffer$2.from(data.buffer, data.byteOffset, data.byteLength) : Buffer$2.from(String(data), "utf8");
  },
  decode: identity$3,
  name: "buffer",
  createViewTranscoder() {
    return new ViewFormat$1({
      encode: function(data) {
        return ArrayBuffer.isView(data) ? data : Buffer$2.from(String(data), "utf8");
      },
      decode: function(data) {
        return Buffer$2.from(data.buffer, data.byteOffset, data.byteLength);
      },
      name: `${this.name}+view`
    });
  }
});
encodings$1.view = new ViewFormat$1({
  encode: function(data) {
    return ArrayBuffer.isView(data) ? data : textEncoder$1.encode(data);
  },
  decode: identity$3,
  name: "view",
  createBufferTranscoder() {
    return new BufferFormat$1({
      encode: function(data) {
        return Buffer$2.isBuffer(data) ? data : ArrayBuffer.isView(data) ? Buffer$2.from(data.buffer, data.byteOffset, data.byteLength) : Buffer$2.from(String(data), "utf8");
      },
      decode: identity$3,
      name: `${this.name}+buffer`
    });
  }
});
encodings$1.hex = new BufferFormat$1({
  encode: function(data) {
    return Buffer$2.isBuffer(data) ? data : Buffer$2.from(String(data), "hex");
  },
  decode: function(buffer2) {
    return buffer2.toString("hex");
  },
  name: "hex"
});
encodings$1.base64 = new BufferFormat$1({
  encode: function(data) {
    return Buffer$2.isBuffer(data) ? data : Buffer$2.from(String(data), "base64");
  },
  decode: function(buffer2) {
    return buffer2.toString("base64");
  },
  name: "base64"
});
const ModuleError$7 = moduleError;
const encodings = encodings$1;
const { Encoding } = encoding;
const { BufferFormat, ViewFormat, UTF8Format } = formats$2;
const kFormats = Symbol("formats");
const kEncodings = Symbol("encodings");
const validFormats = /* @__PURE__ */ new Set(["buffer", "view", "utf8"]);
class Transcoder$1 {
  constructor(formats2) {
    if (!Array.isArray(formats2)) {
      throw new TypeError("The first argument 'formats' must be an array");
    } else if (!formats2.every((f) => validFormats.has(f))) {
      throw new TypeError("Format must be one of 'buffer', 'view', 'utf8'");
    }
    this[kEncodings] = /* @__PURE__ */ new Map();
    this[kFormats] = new Set(formats2);
    for (const k in encodings) {
      try {
        this.encoding(k);
      } catch (err2) {
        if (err2.code !== "LEVEL_ENCODING_NOT_SUPPORTED")
          throw err2;
      }
    }
  }
  encodings() {
    return Array.from(new Set(this[kEncodings].values()));
  }
  encoding(encoding2) {
    let resolved = this[kEncodings].get(encoding2);
    if (resolved === void 0) {
      if (typeof encoding2 === "string" && encoding2 !== "") {
        resolved = lookup$2[encoding2];
        if (!resolved) {
          throw new ModuleError$7(`Encoding '${encoding2}' is not found`, {
            code: "LEVEL_ENCODING_NOT_FOUND"
          });
        }
      } else if (typeof encoding2 !== "object" || encoding2 === null) {
        throw new TypeError("First argument 'encoding' must be a string or object");
      } else {
        resolved = from$2(encoding2);
      }
      const { name: name2, format: format2 } = resolved;
      if (!this[kFormats].has(format2)) {
        if (this[kFormats].has("view")) {
          resolved = resolved.createViewTranscoder();
        } else if (this[kFormats].has("buffer")) {
          resolved = resolved.createBufferTranscoder();
        } else if (this[kFormats].has("utf8")) {
          resolved = resolved.createUTF8Transcoder();
        } else {
          throw new ModuleError$7(`Encoding '${name2}' cannot be transcoded`, {
            code: "LEVEL_ENCODING_NOT_SUPPORTED"
          });
        }
      }
      for (const k of [encoding2, name2, resolved.name, resolved.commonName]) {
        this[kEncodings].set(k, resolved);
      }
    }
    return resolved;
  }
}
levelTranscoder.Transcoder = Transcoder$1;
function from$2(options) {
  if (options instanceof Encoding) {
    return options;
  }
  const maybeType = "type" in options && typeof options.type === "string" ? options.type : void 0;
  const name2 = options.name || maybeType || `anonymous-${anonymousCount++}`;
  switch (detectFormat(options)) {
    case "view":
      return new ViewFormat({ ...options, name: name2 });
    case "utf8":
      return new UTF8Format({ ...options, name: name2 });
    case "buffer":
      return new BufferFormat({ ...options, name: name2 });
    default: {
      throw new TypeError("Format must be one of 'buffer', 'view', 'utf8'");
    }
  }
}
function detectFormat(options) {
  if ("format" in options && options.format !== void 0) {
    return options.format;
  } else if ("buffer" in options && typeof options.buffer === "boolean") {
    return options.buffer ? "buffer" : "utf8";
  } else if ("code" in options && Number.isInteger(options.code)) {
    return "view";
  } else {
    return "buffer";
  }
}
const aliases = {
  binary: encodings.buffer,
  "utf-8": encodings.utf8
};
const lookup$2 = {
  ...encodings,
  ...aliases
};
let anonymousCount = 0;
var events = { exports: {} };
var R = typeof Reflect === "object" ? Reflect : null;
var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === "function") {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning(warning) {
  if (console && console.warn)
    console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value2) {
  return value2 !== value2;
};
function EventEmitter$3() {
  EventEmitter$3.init.call(this);
}
events.exports = EventEmitter$3;
events.exports.once = once;
EventEmitter$3.EventEmitter = EventEmitter$3;
EventEmitter$3.prototype._events = void 0;
EventEmitter$3.prototype._eventsCount = 0;
EventEmitter$3.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(listener) {
  if (typeof listener !== "function") {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}
Object.defineProperty(EventEmitter$3, "defaultMaxListeners", {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
    }
    defaultMaxListeners = arg;
  }
});
EventEmitter$3.init = function() {
  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter$3.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
  }
  this._maxListeners = n;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter$3.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter$3.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter$3.prototype.emit = function emit2(type) {
  var args = [];
  for (var i2 = 1; i2 < arguments.length; i2++)
    args.push(arguments[i2]);
  var doError = type === "error";
  var events2 = this._events;
  if (events2 !== void 0)
    doError = doError && events2.error === void 0;
  else if (!doError)
    return false;
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      throw er;
    }
    var err2 = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
    err2.context = er;
    throw err2;
  }
  var handler = events2[type];
  if (handler === void 0)
    return false;
  if (typeof handler === "function") {
    ReflectApply(handler, this, args);
  } else {
    var len2 = handler.length;
    var listeners2 = arrayClone(handler, len2);
    for (var i2 = 0; i2 < len2; ++i2)
      ReflectApply(listeners2[i2], this, args);
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m;
  var events2;
  var existing;
  checkListener(listener);
  events2 = target._events;
  if (events2 === void 0) {
    events2 = target._events = /* @__PURE__ */ Object.create(null);
    target._eventsCount = 0;
  } else {
    if (events2.newListener !== void 0) {
      target.emit(
        "newListener",
        type,
        listener.listener ? listener.listener : listener
      );
      events2 = target._events;
    }
    existing = events2[type];
  }
  if (existing === void 0) {
    existing = events2[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      w.name = "MaxListenersExceededWarning";
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }
  return target;
}
EventEmitter$3.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter$3.prototype.on = EventEmitter$3.prototype.addListener;
EventEmitter$3.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: void 0, target, type, listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}
EventEmitter$3.prototype.once = function once2(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter$3.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter$3.prototype.removeListener = function removeListener(type, listener) {
  var list, events2, position, i2, originalListener;
  checkListener(listener);
  events2 = this._events;
  if (events2 === void 0)
    return this;
  list = events2[type];
  if (list === void 0)
    return this;
  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = /* @__PURE__ */ Object.create(null);
    else {
      delete events2[type];
      if (events2.removeListener)
        this.emit("removeListener", type, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position = -1;
    for (i2 = list.length - 1; i2 >= 0; i2--) {
      if (list[i2] === listener || list[i2].listener === listener) {
        originalListener = list[i2].listener;
        position = i2;
        break;
      }
    }
    if (position < 0)
      return this;
    if (position === 0)
      list.shift();
    else {
      spliceOne(list, position);
    }
    if (list.length === 1)
      events2[type] = list[0];
    if (events2.removeListener !== void 0)
      this.emit("removeListener", type, originalListener || listener);
  }
  return this;
};
EventEmitter$3.prototype.off = EventEmitter$3.prototype.removeListener;
EventEmitter$3.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners2, events2, i2;
  events2 = this._events;
  if (events2 === void 0)
    return this;
  if (events2.removeListener === void 0) {
    if (arguments.length === 0) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    } else if (events2[type] !== void 0) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else
        delete events2[type];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys = Object.keys(events2);
    var key;
    for (i2 = 0; i2 < keys.length; ++i2) {
      key = keys[i2];
      if (key === "removeListener")
        continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners("removeListener");
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners2 = events2[type];
  if (typeof listeners2 === "function") {
    this.removeListener(type, listeners2);
  } else if (listeners2 !== void 0) {
    for (i2 = listeners2.length - 1; i2 >= 0; i2--) {
      this.removeListener(type, listeners2[i2]);
    }
  }
  return this;
};
function _listeners(target, type, unwrap2) {
  var events2 = target._events;
  if (events2 === void 0)
    return [];
  var evlistener = events2[type];
  if (evlistener === void 0)
    return [];
  if (typeof evlistener === "function")
    return unwrap2 ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap2 ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter$3.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};
EventEmitter$3.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};
EventEmitter$3.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};
EventEmitter$3.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events2 = this._events;
  if (events2 !== void 0) {
    var evlistener = events2[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener !== void 0) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter$3.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i2 = 0; i2 < n; ++i2)
    copy[i2] = arr[i2];
  return copy;
}
function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i2 = 0; i2 < ret.length; ++i2) {
    ret[i2] = arr[i2].listener || arr[i2];
  }
  return ret;
}
function once(emitter, name2) {
  return new Promise(function(resolve2, reject) {
    function errorListener(err2) {
      emitter.removeListener(name2, resolver);
      reject(err2);
    }
    function resolver() {
      if (typeof emitter.removeListener === "function") {
        emitter.removeListener("error", errorListener);
      }
      resolve2([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(emitter, name2, resolver, { once: true });
    if (name2 !== "error") {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === "function") {
    eventTargetAgnosticAddListener(emitter, "error", handler, flags);
  }
}
function eventTargetAgnosticAddListener(emitter, name2, listener, flags) {
  if (typeof emitter.on === "function") {
    if (flags.once) {
      emitter.once(name2, listener);
    } else {
      emitter.on(name2, listener);
    }
  } else if (typeof emitter.addEventListener === "function") {
    emitter.addEventListener(name2, function wrapListener(arg) {
      if (flags.once) {
        emitter.removeEventListener(name2, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
var catering = {};
var nextTickBrowser$1 = typeof queueMicrotask === "function" ? queueMicrotask : (fn) => Promise.resolve().then(fn);
var nextTick$1 = nextTickBrowser$1;
catering.fromCallback = function(callback, symbol2) {
  if (callback === void 0) {
    var promise2 = new Promise(function(resolve2, reject) {
      callback = function(err2, res) {
        if (err2)
          reject(err2);
        else
          resolve2(res);
      };
    });
    callback[symbol2 !== void 0 ? symbol2 : "promise"] = promise2;
  } else if (typeof callback !== "function") {
    throw new TypeError("Callback must be a function");
  }
  return callback;
};
catering.fromPromise = function(promise2, callback) {
  if (callback === void 0)
    return promise2;
  promise2.then(function(res) {
    nextTick$1(() => callback(null, res));
  }).catch(function(err2) {
    nextTick$1(() => callback(err2));
  });
};
var abstractIterator = {};
var common = {};
common.getCallback = function(options, callback) {
  return typeof options === "function" ? options : callback;
};
common.getOptions = function(options, def2) {
  if (typeof options === "object" && options !== null) {
    return options;
  }
  if (def2 !== void 0) {
    return def2;
  }
  return {};
};
const { fromCallback: fromCallback$3 } = catering;
const ModuleError$6 = moduleError;
const { getOptions: getOptions$2, getCallback: getCallback$2 } = common;
const kPromise$3 = Symbol("promise");
const kCallback$1 = Symbol("callback");
const kWorking = Symbol("working");
const kHandleOne$1 = Symbol("handleOne");
const kHandleMany$1 = Symbol("handleMany");
const kAutoClose = Symbol("autoClose");
const kFinishWork = Symbol("finishWork");
const kReturnMany = Symbol("returnMany");
const kClosing = Symbol("closing");
const kHandleClose = Symbol("handleClose");
const kClosed = Symbol("closed");
const kCloseCallbacks$1 = Symbol("closeCallbacks");
const kKeyEncoding$1 = Symbol("keyEncoding");
const kValueEncoding$1 = Symbol("valueEncoding");
const kAbortOnClose = Symbol("abortOnClose");
const kLegacy = Symbol("legacy");
const kKeys = Symbol("keys");
const kValues = Symbol("values");
const kLimit = Symbol("limit");
const kCount = Symbol("count");
const emptyOptions$1 = Object.freeze({});
const noop$4 = () => {
};
let warnedEnd = false;
class CommonIterator {
  constructor(db, options, legacy) {
    if (typeof db !== "object" || db === null) {
      const hint = db === null ? "null" : typeof db;
      throw new TypeError(`The first argument must be an abstract-level database, received ${hint}`);
    }
    if (typeof options !== "object" || options === null) {
      throw new TypeError("The second argument must be an options object");
    }
    this[kClosed] = false;
    this[kCloseCallbacks$1] = [];
    this[kWorking] = false;
    this[kClosing] = false;
    this[kAutoClose] = false;
    this[kCallback$1] = null;
    this[kHandleOne$1] = this[kHandleOne$1].bind(this);
    this[kHandleMany$1] = this[kHandleMany$1].bind(this);
    this[kHandleClose] = this[kHandleClose].bind(this);
    this[kKeyEncoding$1] = options[kKeyEncoding$1];
    this[kValueEncoding$1] = options[kValueEncoding$1];
    this[kLegacy] = legacy;
    this[kLimit] = Number.isInteger(options.limit) && options.limit >= 0 ? options.limit : Infinity;
    this[kCount] = 0;
    this[kAbortOnClose] = !!options.abortOnClose;
    this.db = db;
    this.db.attachResource(this);
    this.nextTick = db.nextTick;
  }
  get count() {
    return this[kCount];
  }
  get limit() {
    return this[kLimit];
  }
  next(callback) {
    let promise2;
    if (callback === void 0) {
      promise2 = new Promise((resolve2, reject) => {
        callback = (err2, key, value2) => {
          if (err2)
            reject(err2);
          else if (!this[kLegacy])
            resolve2(key);
          else if (key === void 0 && value2 === void 0)
            resolve2();
          else
            resolve2([key, value2]);
        };
      });
    } else if (typeof callback !== "function") {
      throw new TypeError("Callback must be a function");
    }
    if (this[kClosing]) {
      this.nextTick(callback, new ModuleError$6("Iterator is not open: cannot call next() after close()", {
        code: "LEVEL_ITERATOR_NOT_OPEN"
      }));
    } else if (this[kWorking]) {
      this.nextTick(callback, new ModuleError$6("Iterator is busy: cannot call next() until previous call has completed", {
        code: "LEVEL_ITERATOR_BUSY"
      }));
    } else {
      this[kWorking] = true;
      this[kCallback$1] = callback;
      if (this[kCount] >= this[kLimit])
        this.nextTick(this[kHandleOne$1], null);
      else
        this._next(this[kHandleOne$1]);
    }
    return promise2;
  }
  _next(callback) {
    this.nextTick(callback);
  }
  nextv(size2, options, callback) {
    callback = getCallback$2(options, callback);
    callback = fromCallback$3(callback, kPromise$3);
    options = getOptions$2(options, emptyOptions$1);
    if (!Number.isInteger(size2)) {
      this.nextTick(callback, new TypeError("The first argument 'size' must be an integer"));
      return callback[kPromise$3];
    }
    if (this[kClosing]) {
      this.nextTick(callback, new ModuleError$6("Iterator is not open: cannot call nextv() after close()", {
        code: "LEVEL_ITERATOR_NOT_OPEN"
      }));
    } else if (this[kWorking]) {
      this.nextTick(callback, new ModuleError$6("Iterator is busy: cannot call nextv() until previous call has completed", {
        code: "LEVEL_ITERATOR_BUSY"
      }));
    } else {
      if (size2 < 1)
        size2 = 1;
      if (this[kLimit] < Infinity)
        size2 = Math.min(size2, this[kLimit] - this[kCount]);
      this[kWorking] = true;
      this[kCallback$1] = callback;
      if (size2 <= 0)
        this.nextTick(this[kHandleMany$1], null, []);
      else
        this._nextv(size2, options, this[kHandleMany$1]);
    }
    return callback[kPromise$3];
  }
  _nextv(size2, options, callback) {
    const acc = [];
    const onnext = (err2, key, value2) => {
      if (err2) {
        return callback(err2);
      } else if (this[kLegacy] ? key === void 0 && value2 === void 0 : key === void 0) {
        return callback(null, acc);
      }
      acc.push(this[kLegacy] ? [key, value2] : key);
      if (acc.length === size2) {
        callback(null, acc);
      } else {
        this._next(onnext);
      }
    };
    this._next(onnext);
  }
  all(options, callback) {
    callback = getCallback$2(options, callback);
    callback = fromCallback$3(callback, kPromise$3);
    options = getOptions$2(options, emptyOptions$1);
    if (this[kClosing]) {
      this.nextTick(callback, new ModuleError$6("Iterator is not open: cannot call all() after close()", {
        code: "LEVEL_ITERATOR_NOT_OPEN"
      }));
    } else if (this[kWorking]) {
      this.nextTick(callback, new ModuleError$6("Iterator is busy: cannot call all() until previous call has completed", {
        code: "LEVEL_ITERATOR_BUSY"
      }));
    } else {
      this[kWorking] = true;
      this[kCallback$1] = callback;
      this[kAutoClose] = true;
      if (this[kCount] >= this[kLimit])
        this.nextTick(this[kHandleMany$1], null, []);
      else
        this._all(options, this[kHandleMany$1]);
    }
    return callback[kPromise$3];
  }
  _all(options, callback) {
    let count = this[kCount];
    const acc = [];
    const nextv = () => {
      const size2 = this[kLimit] < Infinity ? Math.min(1e3, this[kLimit] - count) : 1e3;
      if (size2 <= 0) {
        this.nextTick(callback, null, acc);
      } else {
        this._nextv(size2, emptyOptions$1, onnextv);
      }
    };
    const onnextv = (err2, items) => {
      if (err2) {
        callback(err2);
      } else if (items.length === 0) {
        callback(null, acc);
      } else {
        acc.push.apply(acc, items);
        count += items.length;
        nextv();
      }
    };
    nextv();
  }
  [kFinishWork]() {
    const cb = this[kCallback$1];
    if (this[kAbortOnClose] && cb === null)
      return noop$4;
    this[kWorking] = false;
    this[kCallback$1] = null;
    if (this[kClosing])
      this._close(this[kHandleClose]);
    return cb;
  }
  [kReturnMany](cb, err2, items) {
    if (this[kAutoClose]) {
      this.close(cb.bind(null, err2, items));
    } else {
      cb(err2, items);
    }
  }
  seek(target, options) {
    options = getOptions$2(options, emptyOptions$1);
    if (this[kClosing])
      ;
    else if (this[kWorking]) {
      throw new ModuleError$6("Iterator is busy: cannot call seek() until next() has completed", {
        code: "LEVEL_ITERATOR_BUSY"
      });
    } else {
      const keyEncoding = this.db.keyEncoding(options.keyEncoding || this[kKeyEncoding$1]);
      const keyFormat = keyEncoding.format;
      if (options.keyEncoding !== keyFormat) {
        options = { ...options, keyEncoding: keyFormat };
      }
      const mapped = this.db.prefixKey(keyEncoding.encode(target), keyFormat);
      this._seek(mapped, options);
    }
  }
  _seek(target, options) {
    throw new ModuleError$6("Iterator does not support seek()", {
      code: "LEVEL_NOT_SUPPORTED"
    });
  }
  close(callback) {
    callback = fromCallback$3(callback, kPromise$3);
    if (this[kClosed]) {
      this.nextTick(callback);
    } else if (this[kClosing]) {
      this[kCloseCallbacks$1].push(callback);
    } else {
      this[kClosing] = true;
      this[kCloseCallbacks$1].push(callback);
      if (!this[kWorking]) {
        this._close(this[kHandleClose]);
      } else if (this[kAbortOnClose]) {
        const cb = this[kFinishWork]();
        cb(new ModuleError$6("Aborted on iterator close()", {
          code: "LEVEL_ITERATOR_NOT_OPEN"
        }));
      }
    }
    return callback[kPromise$3];
  }
  _close(callback) {
    this.nextTick(callback);
  }
  [kHandleClose]() {
    this[kClosed] = true;
    this.db.detachResource(this);
    const callbacks = this[kCloseCallbacks$1];
    this[kCloseCallbacks$1] = [];
    for (const cb of callbacks) {
      cb();
    }
  }
  async *[Symbol.asyncIterator]() {
    try {
      let item;
      while ((item = await this.next()) !== void 0) {
        yield item;
      }
    } finally {
      if (!this[kClosed])
        await this.close();
    }
  }
}
class AbstractIterator$3 extends CommonIterator {
  constructor(db, options) {
    super(db, options, true);
    this[kKeys] = options.keys !== false;
    this[kValues] = options.values !== false;
  }
  [kHandleOne$1](err2, key, value2) {
    const cb = this[kFinishWork]();
    if (err2)
      return cb(err2);
    try {
      key = this[kKeys] && key !== void 0 ? this[kKeyEncoding$1].decode(key) : void 0;
      value2 = this[kValues] && value2 !== void 0 ? this[kValueEncoding$1].decode(value2) : void 0;
    } catch (err3) {
      return cb(new IteratorDecodeError("entry", err3));
    }
    if (!(key === void 0 && value2 === void 0)) {
      this[kCount]++;
    }
    cb(null, key, value2);
  }
  [kHandleMany$1](err2, entries) {
    const cb = this[kFinishWork]();
    if (err2)
      return this[kReturnMany](cb, err2);
    try {
      for (const entry of entries) {
        const key = entry[0];
        const value2 = entry[1];
        entry[0] = this[kKeys] && key !== void 0 ? this[kKeyEncoding$1].decode(key) : void 0;
        entry[1] = this[kValues] && value2 !== void 0 ? this[kValueEncoding$1].decode(value2) : void 0;
      }
    } catch (err3) {
      return this[kReturnMany](cb, new IteratorDecodeError("entries", err3));
    }
    this[kCount] += entries.length;
    this[kReturnMany](cb, null, entries);
  }
  end(callback) {
    if (!warnedEnd && typeof console !== "undefined") {
      warnedEnd = true;
      console.warn(new ModuleError$6(
        "The iterator.end() method was renamed to close() and end() is an alias that will be removed in a future version",
        { code: "LEVEL_LEGACY" }
      ));
    }
    return this.close(callback);
  }
}
class AbstractKeyIterator$2 extends CommonIterator {
  constructor(db, options) {
    super(db, options, false);
  }
  [kHandleOne$1](err2, key) {
    const cb = this[kFinishWork]();
    if (err2)
      return cb(err2);
    try {
      key = key !== void 0 ? this[kKeyEncoding$1].decode(key) : void 0;
    } catch (err3) {
      return cb(new IteratorDecodeError("key", err3));
    }
    if (key !== void 0)
      this[kCount]++;
    cb(null, key);
  }
  [kHandleMany$1](err2, keys) {
    const cb = this[kFinishWork]();
    if (err2)
      return this[kReturnMany](cb, err2);
    try {
      for (let i2 = 0; i2 < keys.length; i2++) {
        const key = keys[i2];
        keys[i2] = key !== void 0 ? this[kKeyEncoding$1].decode(key) : void 0;
      }
    } catch (err3) {
      return this[kReturnMany](cb, new IteratorDecodeError("keys", err3));
    }
    this[kCount] += keys.length;
    this[kReturnMany](cb, null, keys);
  }
}
class AbstractValueIterator$2 extends CommonIterator {
  constructor(db, options) {
    super(db, options, false);
  }
  [kHandleOne$1](err2, value2) {
    const cb = this[kFinishWork]();
    if (err2)
      return cb(err2);
    try {
      value2 = value2 !== void 0 ? this[kValueEncoding$1].decode(value2) : void 0;
    } catch (err3) {
      return cb(new IteratorDecodeError("value", err3));
    }
    if (value2 !== void 0)
      this[kCount]++;
    cb(null, value2);
  }
  [kHandleMany$1](err2, values) {
    const cb = this[kFinishWork]();
    if (err2)
      return this[kReturnMany](cb, err2);
    try {
      for (let i2 = 0; i2 < values.length; i2++) {
        const value2 = values[i2];
        values[i2] = value2 !== void 0 ? this[kValueEncoding$1].decode(value2) : void 0;
      }
    } catch (err3) {
      return this[kReturnMany](cb, new IteratorDecodeError("values", err3));
    }
    this[kCount] += values.length;
    this[kReturnMany](cb, null, values);
  }
}
class IteratorDecodeError extends ModuleError$6 {
  constructor(subject, cause) {
    super(`Iterator could not decode ${subject}`, {
      code: "LEVEL_DECODE_ERROR",
      cause
    });
  }
}
for (const k of ["_ended property", "_nexting property", "_end method"]) {
  Object.defineProperty(AbstractIterator$3.prototype, k.split(" ")[0], {
    get() {
      throw new ModuleError$6(`The ${k} has been removed`, { code: "LEVEL_LEGACY" });
    },
    set() {
      throw new ModuleError$6(`The ${k} has been removed`, { code: "LEVEL_LEGACY" });
    }
  });
}
AbstractIterator$3.keyEncoding = kKeyEncoding$1;
AbstractIterator$3.valueEncoding = kValueEncoding$1;
abstractIterator.AbstractIterator = AbstractIterator$3;
abstractIterator.AbstractKeyIterator = AbstractKeyIterator$2;
abstractIterator.AbstractValueIterator = AbstractValueIterator$2;
var defaultKvIterator = {};
const { AbstractKeyIterator: AbstractKeyIterator$1, AbstractValueIterator: AbstractValueIterator$1 } = abstractIterator;
const kIterator = Symbol("iterator");
const kCallback = Symbol("callback");
const kHandleOne = Symbol("handleOne");
const kHandleMany = Symbol("handleMany");
class DefaultKeyIterator$1 extends AbstractKeyIterator$1 {
  constructor(db, options) {
    super(db, options);
    this[kIterator] = db.iterator({ ...options, keys: true, values: false });
    this[kHandleOne] = this[kHandleOne].bind(this);
    this[kHandleMany] = this[kHandleMany].bind(this);
  }
}
class DefaultValueIterator$1 extends AbstractValueIterator$1 {
  constructor(db, options) {
    super(db, options);
    this[kIterator] = db.iterator({ ...options, keys: false, values: true });
    this[kHandleOne] = this[kHandleOne].bind(this);
    this[kHandleMany] = this[kHandleMany].bind(this);
  }
}
for (const Iterator2 of [DefaultKeyIterator$1, DefaultValueIterator$1]) {
  const keys = Iterator2 === DefaultKeyIterator$1;
  const mapEntry = keys ? (entry) => entry[0] : (entry) => entry[1];
  Iterator2.prototype._next = function(callback) {
    this[kCallback] = callback;
    this[kIterator].next(this[kHandleOne]);
  };
  Iterator2.prototype[kHandleOne] = function(err2, key, value2) {
    const callback = this[kCallback];
    if (err2)
      callback(err2);
    else
      callback(null, keys ? key : value2);
  };
  Iterator2.prototype._nextv = function(size2, options, callback) {
    this[kCallback] = callback;
    this[kIterator].nextv(size2, options, this[kHandleMany]);
  };
  Iterator2.prototype._all = function(options, callback) {
    this[kCallback] = callback;
    this[kIterator].all(options, this[kHandleMany]);
  };
  Iterator2.prototype[kHandleMany] = function(err2, entries) {
    const callback = this[kCallback];
    if (err2)
      callback(err2);
    else
      callback(null, entries.map(mapEntry));
  };
  Iterator2.prototype._seek = function(target, options) {
    this[kIterator].seek(target, options);
  };
  Iterator2.prototype._close = function(callback) {
    this[kIterator].close(callback);
  };
}
defaultKvIterator.DefaultKeyIterator = DefaultKeyIterator$1;
defaultKvIterator.DefaultValueIterator = DefaultValueIterator$1;
var deferredIterator = {};
const { AbstractIterator: AbstractIterator$2, AbstractKeyIterator, AbstractValueIterator } = abstractIterator;
const ModuleError$5 = moduleError;
const kNut = Symbol("nut");
const kUndefer$1 = Symbol("undefer");
const kFactory = Symbol("factory");
class DeferredIterator$1 extends AbstractIterator$2 {
  constructor(db, options) {
    super(db, options);
    this[kNut] = null;
    this[kFactory] = () => db.iterator(options);
    this.db.defer(() => this[kUndefer$1]());
  }
}
class DeferredKeyIterator$1 extends AbstractKeyIterator {
  constructor(db, options) {
    super(db, options);
    this[kNut] = null;
    this[kFactory] = () => db.keys(options);
    this.db.defer(() => this[kUndefer$1]());
  }
}
class DeferredValueIterator$1 extends AbstractValueIterator {
  constructor(db, options) {
    super(db, options);
    this[kNut] = null;
    this[kFactory] = () => db.values(options);
    this.db.defer(() => this[kUndefer$1]());
  }
}
for (const Iterator2 of [DeferredIterator$1, DeferredKeyIterator$1, DeferredValueIterator$1]) {
  Iterator2.prototype[kUndefer$1] = function() {
    if (this.db.status === "open") {
      this[kNut] = this[kFactory]();
    }
  };
  Iterator2.prototype._next = function(callback) {
    if (this[kNut] !== null) {
      this[kNut].next(callback);
    } else if (this.db.status === "opening") {
      this.db.defer(() => this._next(callback));
    } else {
      this.nextTick(callback, new ModuleError$5("Iterator is not open: cannot call next() after close()", {
        code: "LEVEL_ITERATOR_NOT_OPEN"
      }));
    }
  };
  Iterator2.prototype._nextv = function(size2, options, callback) {
    if (this[kNut] !== null) {
      this[kNut].nextv(size2, options, callback);
    } else if (this.db.status === "opening") {
      this.db.defer(() => this._nextv(size2, options, callback));
    } else {
      this.nextTick(callback, new ModuleError$5("Iterator is not open: cannot call nextv() after close()", {
        code: "LEVEL_ITERATOR_NOT_OPEN"
      }));
    }
  };
  Iterator2.prototype._all = function(options, callback) {
    if (this[kNut] !== null) {
      this[kNut].all(callback);
    } else if (this.db.status === "opening") {
      this.db.defer(() => this._all(options, callback));
    } else {
      this.nextTick(callback, new ModuleError$5("Iterator is not open: cannot call all() after close()", {
        code: "LEVEL_ITERATOR_NOT_OPEN"
      }));
    }
  };
  Iterator2.prototype._seek = function(target, options) {
    if (this[kNut] !== null) {
      this[kNut]._seek(target, options);
    } else if (this.db.status === "opening") {
      this.db.defer(() => this._seek(target, options));
    }
  };
  Iterator2.prototype._close = function(callback) {
    if (this[kNut] !== null) {
      this[kNut].close(callback);
    } else if (this.db.status === "opening") {
      this.db.defer(() => this._close(callback));
    } else {
      this.nextTick(callback);
    }
  };
}
deferredIterator.DeferredIterator = DeferredIterator$1;
deferredIterator.DeferredKeyIterator = DeferredKeyIterator$1;
deferredIterator.DeferredValueIterator = DeferredValueIterator$1;
var defaultChainedBatch = {};
var abstractChainedBatch = {};
const { fromCallback: fromCallback$2 } = catering;
const ModuleError$4 = moduleError;
const { getCallback: getCallback$1, getOptions: getOptions$1 } = common;
const kPromise$2 = Symbol("promise");
const kStatus$1 = Symbol("status");
const kOperations$1 = Symbol("operations");
const kFinishClose = Symbol("finishClose");
const kCloseCallbacks = Symbol("closeCallbacks");
class AbstractChainedBatch$1 {
  constructor(db) {
    if (typeof db !== "object" || db === null) {
      const hint = db === null ? "null" : typeof db;
      throw new TypeError(`The first argument must be an abstract-level database, received ${hint}`);
    }
    this[kOperations$1] = [];
    this[kCloseCallbacks] = [];
    this[kStatus$1] = "open";
    this[kFinishClose] = this[kFinishClose].bind(this);
    this.db = db;
    this.db.attachResource(this);
    this.nextTick = db.nextTick;
  }
  get length() {
    return this[kOperations$1].length;
  }
  put(key, value2, options) {
    if (this[kStatus$1] !== "open") {
      throw new ModuleError$4("Batch is not open: cannot call put() after write() or close()", {
        code: "LEVEL_BATCH_NOT_OPEN"
      });
    }
    const err2 = this.db._checkKey(key) || this.db._checkValue(value2);
    if (err2)
      throw err2;
    const db = options && options.sublevel != null ? options.sublevel : this.db;
    const original = options;
    const keyEncoding = db.keyEncoding(options && options.keyEncoding);
    const valueEncoding = db.valueEncoding(options && options.valueEncoding);
    const keyFormat = keyEncoding.format;
    options = { ...options, keyEncoding: keyFormat, valueEncoding: valueEncoding.format };
    if (db !== this.db) {
      options.sublevel = null;
    }
    const mappedKey = db.prefixKey(keyEncoding.encode(key), keyFormat);
    const mappedValue = valueEncoding.encode(value2);
    this._put(mappedKey, mappedValue, options);
    this[kOperations$1].push({ ...original, type: "put", key, value: value2 });
    return this;
  }
  _put(key, value2, options) {
  }
  del(key, options) {
    if (this[kStatus$1] !== "open") {
      throw new ModuleError$4("Batch is not open: cannot call del() after write() or close()", {
        code: "LEVEL_BATCH_NOT_OPEN"
      });
    }
    const err2 = this.db._checkKey(key);
    if (err2)
      throw err2;
    const db = options && options.sublevel != null ? options.sublevel : this.db;
    const original = options;
    const keyEncoding = db.keyEncoding(options && options.keyEncoding);
    const keyFormat = keyEncoding.format;
    options = { ...options, keyEncoding: keyFormat };
    if (db !== this.db) {
      options.sublevel = null;
    }
    this._del(db.prefixKey(keyEncoding.encode(key), keyFormat), options);
    this[kOperations$1].push({ ...original, type: "del", key });
    return this;
  }
  _del(key, options) {
  }
  clear() {
    if (this[kStatus$1] !== "open") {
      throw new ModuleError$4("Batch is not open: cannot call clear() after write() or close()", {
        code: "LEVEL_BATCH_NOT_OPEN"
      });
    }
    this._clear();
    this[kOperations$1] = [];
    return this;
  }
  _clear() {
  }
  write(options, callback) {
    callback = getCallback$1(options, callback);
    callback = fromCallback$2(callback, kPromise$2);
    options = getOptions$1(options);
    if (this[kStatus$1] !== "open") {
      this.nextTick(callback, new ModuleError$4("Batch is not open: cannot call write() after write() or close()", {
        code: "LEVEL_BATCH_NOT_OPEN"
      }));
    } else if (this.length === 0) {
      this.close(callback);
    } else {
      this[kStatus$1] = "writing";
      this._write(options, (err2) => {
        this[kStatus$1] = "closing";
        this[kCloseCallbacks].push(() => callback(err2));
        if (!err2)
          this.db.emit("batch", this[kOperations$1]);
        this._close(this[kFinishClose]);
      });
    }
    return callback[kPromise$2];
  }
  _write(options, callback) {
  }
  close(callback) {
    callback = fromCallback$2(callback, kPromise$2);
    if (this[kStatus$1] === "closing") {
      this[kCloseCallbacks].push(callback);
    } else if (this[kStatus$1] === "closed") {
      this.nextTick(callback);
    } else {
      this[kCloseCallbacks].push(callback);
      if (this[kStatus$1] !== "writing") {
        this[kStatus$1] = "closing";
        this._close(this[kFinishClose]);
      }
    }
    return callback[kPromise$2];
  }
  _close(callback) {
    this.nextTick(callback);
  }
  [kFinishClose]() {
    this[kStatus$1] = "closed";
    this.db.detachResource(this);
    const callbacks = this[kCloseCallbacks];
    this[kCloseCallbacks] = [];
    for (const cb of callbacks) {
      cb();
    }
  }
}
abstractChainedBatch.AbstractChainedBatch = AbstractChainedBatch$1;
const { AbstractChainedBatch } = abstractChainedBatch;
const ModuleError$3 = moduleError;
const kEncoded = Symbol("encoded");
class DefaultChainedBatch$1 extends AbstractChainedBatch {
  constructor(db) {
    super(db);
    this[kEncoded] = [];
  }
  _put(key, value2, options) {
    this[kEncoded].push({ ...options, type: "put", key, value: value2 });
  }
  _del(key, options) {
    this[kEncoded].push({ ...options, type: "del", key });
  }
  _clear() {
    this[kEncoded] = [];
  }
  _write(options, callback) {
    if (this.db.status === "opening") {
      this.db.defer(() => this._write(options, callback));
    } else if (this.db.status === "open") {
      if (this[kEncoded].length === 0)
        this.nextTick(callback);
      else
        this.db._batch(this[kEncoded], options, callback);
    } else {
      this.nextTick(callback, new ModuleError$3("Batch is not open: cannot call write() after write() or close()", {
        code: "LEVEL_BATCH_NOT_OPEN"
      }));
    }
  }
}
defaultChainedBatch.DefaultChainedBatch = DefaultChainedBatch$1;
const ModuleError$2 = moduleError;
const hasOwnProperty = Object.prototype.hasOwnProperty;
const rangeOptions$1 = /* @__PURE__ */ new Set(["lt", "lte", "gt", "gte"]);
var rangeOptions_1 = function(options, keyEncoding) {
  const result = {};
  for (const k in options) {
    if (!hasOwnProperty.call(options, k))
      continue;
    if (k === "keyEncoding" || k === "valueEncoding")
      continue;
    if (k === "start" || k === "end") {
      throw new ModuleError$2(`The legacy range option '${k}' has been removed`, {
        code: "LEVEL_LEGACY"
      });
    } else if (k === "encoding") {
      throw new ModuleError$2("The levelup-style 'encoding' alias has been removed, use 'valueEncoding' instead", {
        code: "LEVEL_LEGACY"
      });
    }
    if (rangeOptions$1.has(k)) {
      result[k] = keyEncoding.encode(options[k]);
    } else {
      result[k] = options[k];
    }
  }
  result.reverse = !!result.reverse;
  result.limit = Number.isInteger(result.limit) && result.limit >= 0 ? result.limit : -1;
  return result;
};
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
let promise;
var queueMicrotask_1 = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : globalThis) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err2) => setTimeout(() => {
  throw err2;
}, 0));
var nextTickBrowser;
var hasRequiredNextTickBrowser;
function requireNextTickBrowser() {
  if (hasRequiredNextTickBrowser)
    return nextTickBrowser;
  hasRequiredNextTickBrowser = 1;
  const queueMicrotask2 = queueMicrotask_1;
  nextTickBrowser = function(fn, ...args) {
    if (args.length === 0) {
      queueMicrotask2(fn);
    } else {
      queueMicrotask2(() => fn(...args));
    }
  };
  return nextTickBrowser;
}
var abstractSublevelIterator = {};
var hasRequiredAbstractSublevelIterator;
function requireAbstractSublevelIterator() {
  if (hasRequiredAbstractSublevelIterator)
    return abstractSublevelIterator;
  hasRequiredAbstractSublevelIterator = 1;
  const { AbstractIterator: AbstractIterator2, AbstractKeyIterator: AbstractKeyIterator2, AbstractValueIterator: AbstractValueIterator2 } = abstractIterator;
  const kUnfix = Symbol("unfix");
  const kIterator2 = Symbol("iterator");
  const kHandleOne2 = Symbol("handleOne");
  const kHandleMany2 = Symbol("handleMany");
  const kCallback2 = Symbol("callback");
  class AbstractSublevelIterator extends AbstractIterator2 {
    constructor(db, options, iterator2, unfix) {
      super(db, options);
      this[kIterator2] = iterator2;
      this[kUnfix] = unfix;
      this[kHandleOne2] = this[kHandleOne2].bind(this);
      this[kHandleMany2] = this[kHandleMany2].bind(this);
      this[kCallback2] = null;
    }
    [kHandleOne2](err2, key, value2) {
      const callback = this[kCallback2];
      if (err2)
        return callback(err2);
      if (key !== void 0)
        key = this[kUnfix](key);
      callback(err2, key, value2);
    }
    [kHandleMany2](err2, entries) {
      const callback = this[kCallback2];
      if (err2)
        return callback(err2);
      for (const entry of entries) {
        const key = entry[0];
        if (key !== void 0)
          entry[0] = this[kUnfix](key);
      }
      callback(err2, entries);
    }
  }
  class AbstractSublevelKeyIterator extends AbstractKeyIterator2 {
    constructor(db, options, iterator2, unfix) {
      super(db, options);
      this[kIterator2] = iterator2;
      this[kUnfix] = unfix;
      this[kHandleOne2] = this[kHandleOne2].bind(this);
      this[kHandleMany2] = this[kHandleMany2].bind(this);
      this[kCallback2] = null;
    }
    [kHandleOne2](err2, key) {
      const callback = this[kCallback2];
      if (err2)
        return callback(err2);
      if (key !== void 0)
        key = this[kUnfix](key);
      callback(err2, key);
    }
    [kHandleMany2](err2, keys) {
      const callback = this[kCallback2];
      if (err2)
        return callback(err2);
      for (let i2 = 0; i2 < keys.length; i2++) {
        const key = keys[i2];
        if (key !== void 0)
          keys[i2] = this[kUnfix](key);
      }
      callback(err2, keys);
    }
  }
  class AbstractSublevelValueIterator extends AbstractValueIterator2 {
    constructor(db, options, iterator2) {
      super(db, options);
      this[kIterator2] = iterator2;
    }
  }
  for (const Iterator2 of [AbstractSublevelIterator, AbstractSublevelKeyIterator]) {
    Iterator2.prototype._next = function(callback) {
      this[kCallback2] = callback;
      this[kIterator2].next(this[kHandleOne2]);
    };
    Iterator2.prototype._nextv = function(size2, options, callback) {
      this[kCallback2] = callback;
      this[kIterator2].nextv(size2, options, this[kHandleMany2]);
    };
    Iterator2.prototype._all = function(options, callback) {
      this[kCallback2] = callback;
      this[kIterator2].all(options, this[kHandleMany2]);
    };
  }
  for (const Iterator2 of [AbstractSublevelValueIterator]) {
    Iterator2.prototype._next = function(callback) {
      this[kIterator2].next(callback);
    };
    Iterator2.prototype._nextv = function(size2, options, callback) {
      this[kIterator2].nextv(size2, options, callback);
    };
    Iterator2.prototype._all = function(options, callback) {
      this[kIterator2].all(options, callback);
    };
  }
  for (const Iterator2 of [AbstractSublevelIterator, AbstractSublevelKeyIterator, AbstractSublevelValueIterator]) {
    Iterator2.prototype._seek = function(target, options) {
      this[kIterator2].seek(target, options);
    };
    Iterator2.prototype._close = function(callback) {
      this[kIterator2].close(callback);
    };
  }
  abstractSublevelIterator.AbstractSublevelIterator = AbstractSublevelIterator;
  abstractSublevelIterator.AbstractSublevelKeyIterator = AbstractSublevelKeyIterator;
  abstractSublevelIterator.AbstractSublevelValueIterator = AbstractSublevelValueIterator;
  return abstractSublevelIterator;
}
var abstractSublevel;
var hasRequiredAbstractSublevel;
function requireAbstractSublevel() {
  if (hasRequiredAbstractSublevel)
    return abstractSublevel;
  hasRequiredAbstractSublevel = 1;
  const ModuleError3 = moduleError;
  const { Buffer: Buffer2 } = buffer || {};
  const {
    AbstractSublevelIterator,
    AbstractSublevelKeyIterator,
    AbstractSublevelValueIterator
  } = requireAbstractSublevelIterator();
  const kPrefix = Symbol("prefix");
  const kUpperBound = Symbol("upperBound");
  const kPrefixRange = Symbol("prefixRange");
  const kParent = Symbol("parent");
  const kUnfix = Symbol("unfix");
  const textEncoder2 = new TextEncoder();
  const defaults2 = { separator: "!" };
  abstractSublevel = function({ AbstractLevel: AbstractLevel2 }) {
    class AbstractSublevel2 extends AbstractLevel2 {
      static defaults(options) {
        if (typeof options === "string") {
          throw new ModuleError3("The subleveldown string shorthand for { separator } has been removed", {
            code: "LEVEL_LEGACY"
          });
        } else if (options && options.open) {
          throw new ModuleError3("The subleveldown open option has been removed", {
            code: "LEVEL_LEGACY"
          });
        }
        if (options == null) {
          return defaults2;
        } else if (!options.separator) {
          return { ...options, separator: "!" };
        } else {
          return options;
        }
      }
      constructor(db, name2, options) {
        const { separator, manifest, ...forward } = AbstractSublevel2.defaults(options);
        name2 = trim(name2, separator);
        const reserved = separator.charCodeAt(0) + 1;
        const parent2 = db[kParent] || db;
        if (!textEncoder2.encode(name2).every((x) => x > reserved && x < 127)) {
          throw new ModuleError3(`Prefix must use bytes > ${reserved} < ${127}`, {
            code: "LEVEL_INVALID_PREFIX"
          });
        }
        super(mergeManifests(parent2, manifest), forward);
        const prefix = (db.prefix || "") + separator + name2 + separator;
        const upperBound = prefix.slice(0, -1) + String.fromCharCode(reserved);
        this[kParent] = parent2;
        this[kPrefix] = new MultiFormat(prefix);
        this[kUpperBound] = new MultiFormat(upperBound);
        this[kUnfix] = new Unfixer();
        this.nextTick = parent2.nextTick;
      }
      prefixKey(key, keyFormat) {
        if (keyFormat === "utf8") {
          return this[kPrefix].utf8 + key;
        } else if (key.byteLength === 0) {
          return this[kPrefix][keyFormat];
        } else if (keyFormat === "view") {
          const view = this[kPrefix].view;
          const result = new Uint8Array(view.byteLength + key.byteLength);
          result.set(view, 0);
          result.set(key, view.byteLength);
          return result;
        } else {
          const buffer2 = this[kPrefix].buffer;
          return Buffer2.concat([buffer2, key], buffer2.byteLength + key.byteLength);
        }
      }
      [kPrefixRange](range, keyFormat) {
        if (range.gte !== void 0) {
          range.gte = this.prefixKey(range.gte, keyFormat);
        } else if (range.gt !== void 0) {
          range.gt = this.prefixKey(range.gt, keyFormat);
        } else {
          range.gte = this[kPrefix][keyFormat];
        }
        if (range.lte !== void 0) {
          range.lte = this.prefixKey(range.lte, keyFormat);
        } else if (range.lt !== void 0) {
          range.lt = this.prefixKey(range.lt, keyFormat);
        } else {
          range.lte = this[kUpperBound][keyFormat];
        }
      }
      get prefix() {
        return this[kPrefix].utf8;
      }
      get db() {
        return this[kParent];
      }
      _open(options, callback) {
        this[kParent].open({ passive: true }, callback);
      }
      _put(key, value2, options, callback) {
        this[kParent].put(key, value2, options, callback);
      }
      _get(key, options, callback) {
        this[kParent].get(key, options, callback);
      }
      _getMany(keys, options, callback) {
        this[kParent].getMany(keys, options, callback);
      }
      _del(key, options, callback) {
        this[kParent].del(key, options, callback);
      }
      _batch(operations, options, callback) {
        this[kParent].batch(operations, options, callback);
      }
      _clear(options, callback) {
        this[kPrefixRange](options, options.keyEncoding);
        this[kParent].clear(options, callback);
      }
      _iterator(options) {
        this[kPrefixRange](options, options.keyEncoding);
        const iterator2 = this[kParent].iterator(options);
        const unfix = this[kUnfix].get(this[kPrefix].utf8.length, options.keyEncoding);
        return new AbstractSublevelIterator(this, options, iterator2, unfix);
      }
      _keys(options) {
        this[kPrefixRange](options, options.keyEncoding);
        const iterator2 = this[kParent].keys(options);
        const unfix = this[kUnfix].get(this[kPrefix].utf8.length, options.keyEncoding);
        return new AbstractSublevelKeyIterator(this, options, iterator2, unfix);
      }
      _values(options) {
        this[kPrefixRange](options, options.keyEncoding);
        const iterator2 = this[kParent].values(options);
        return new AbstractSublevelValueIterator(this, options, iterator2);
      }
    }
    return { AbstractSublevel: AbstractSublevel2 };
  };
  const mergeManifests = function(parent2, manifest) {
    return {
      ...parent2.supports,
      createIfMissing: false,
      errorIfExists: false,
      events: {},
      additionalMethods: {},
      ...manifest,
      encodings: {
        utf8: supportsEncoding(parent2, "utf8"),
        buffer: supportsEncoding(parent2, "buffer"),
        view: supportsEncoding(parent2, "view")
      }
    };
  };
  const supportsEncoding = function(parent2, encoding2) {
    return parent2.supports.encodings[encoding2] ? parent2.keyEncoding(encoding2).name === encoding2 : false;
  };
  class MultiFormat {
    constructor(key) {
      this.utf8 = key;
      this.view = textEncoder2.encode(key);
      this.buffer = Buffer2 ? Buffer2.from(this.view.buffer, 0, this.view.byteLength) : {};
    }
  }
  class Unfixer {
    constructor() {
      this.cache = /* @__PURE__ */ new Map();
    }
    get(prefixLength, keyFormat) {
      let unfix = this.cache.get(keyFormat);
      if (unfix === void 0) {
        if (keyFormat === "view") {
          unfix = function(prefixLength2, key) {
            return key.subarray(prefixLength2);
          }.bind(null, prefixLength);
        } else {
          unfix = function(prefixLength2, key) {
            return key.slice(prefixLength2);
          }.bind(null, prefixLength);
        }
        this.cache.set(keyFormat, unfix);
      }
      return unfix;
    }
  }
  const trim = function(str, char) {
    let start = 0;
    let end2 = str.length;
    while (start < end2 && str[start] === char)
      start++;
    while (end2 > start && str[end2 - 1] === char)
      end2--;
    return str.slice(start, end2);
  };
  return abstractSublevel;
}
const { supports } = levelSupports;
const { Transcoder } = levelTranscoder;
const { EventEmitter: EventEmitter$2 } = events.exports;
const { fromCallback: fromCallback$1 } = catering;
const ModuleError$1 = moduleError;
const { AbstractIterator: AbstractIterator$1 } = abstractIterator;
const { DefaultKeyIterator, DefaultValueIterator } = defaultKvIterator;
const { DeferredIterator, DeferredKeyIterator, DeferredValueIterator } = deferredIterator;
const { DefaultChainedBatch } = defaultChainedBatch;
const { getCallback, getOptions } = common;
const rangeOptions = rangeOptions_1;
const kPromise$1 = Symbol("promise");
const kLanded = Symbol("landed");
const kResources = Symbol("resources");
const kCloseResources = Symbol("closeResources");
const kOperations = Symbol("operations");
const kUndefer = Symbol("undefer");
const kDeferOpen = Symbol("deferOpen");
const kOptions$1 = Symbol("options");
const kStatus = Symbol("status");
const kDefaultOptions = Symbol("defaultOptions");
const kTranscoder = Symbol("transcoder");
const kKeyEncoding = Symbol("keyEncoding");
const kValueEncoding = Symbol("valueEncoding");
const noop$3 = () => {
};
class AbstractLevel$1 extends EventEmitter$2 {
  constructor(manifest, options) {
    super();
    if (typeof manifest !== "object" || manifest === null) {
      throw new TypeError("The first argument 'manifest' must be an object");
    }
    options = getOptions(options);
    const { keyEncoding, valueEncoding, passive, ...forward } = options;
    this[kResources] = /* @__PURE__ */ new Set();
    this[kOperations] = [];
    this[kDeferOpen] = true;
    this[kOptions$1] = forward;
    this[kStatus] = "opening";
    this.supports = supports(manifest, {
      status: true,
      promises: true,
      clear: true,
      getMany: true,
      deferredOpen: true,
      snapshots: manifest.snapshots !== false,
      permanence: manifest.permanence !== false,
      keyIterator: true,
      valueIterator: true,
      iteratorNextv: true,
      iteratorAll: true,
      encodings: manifest.encodings || {},
      events: Object.assign({}, manifest.events, {
        opening: true,
        open: true,
        closing: true,
        closed: true,
        put: true,
        del: true,
        batch: true,
        clear: true
      })
    });
    this[kTranscoder] = new Transcoder(formats(this));
    this[kKeyEncoding] = this[kTranscoder].encoding(keyEncoding || "utf8");
    this[kValueEncoding] = this[kTranscoder].encoding(valueEncoding || "utf8");
    for (const encoding2 of this[kTranscoder].encodings()) {
      if (!this.supports.encodings[encoding2.commonName]) {
        this.supports.encodings[encoding2.commonName] = true;
      }
    }
    this[kDefaultOptions] = {
      empty: Object.freeze({}),
      entry: Object.freeze({
        keyEncoding: this[kKeyEncoding].commonName,
        valueEncoding: this[kValueEncoding].commonName
      }),
      key: Object.freeze({
        keyEncoding: this[kKeyEncoding].commonName
      })
    };
    this.nextTick(() => {
      if (this[kDeferOpen]) {
        this.open({ passive: false }, noop$3);
      }
    });
  }
  get status() {
    return this[kStatus];
  }
  keyEncoding(encoding2) {
    return this[kTranscoder].encoding(encoding2 != null ? encoding2 : this[kKeyEncoding]);
  }
  valueEncoding(encoding2) {
    return this[kTranscoder].encoding(encoding2 != null ? encoding2 : this[kValueEncoding]);
  }
  open(options, callback) {
    callback = getCallback(options, callback);
    callback = fromCallback$1(callback, kPromise$1);
    options = { ...this[kOptions$1], ...getOptions(options) };
    options.createIfMissing = options.createIfMissing !== false;
    options.errorIfExists = !!options.errorIfExists;
    const maybeOpened = (err2) => {
      if (this[kStatus] === "closing" || this[kStatus] === "opening") {
        this.once(kLanded, err2 ? () => maybeOpened(err2) : maybeOpened);
      } else if (this[kStatus] !== "open") {
        callback(new ModuleError$1("Database is not open", {
          code: "LEVEL_DATABASE_NOT_OPEN",
          cause: err2
        }));
      } else {
        callback();
      }
    };
    if (options.passive) {
      if (this[kStatus] === "opening") {
        this.once(kLanded, maybeOpened);
      } else {
        this.nextTick(maybeOpened);
      }
    } else if (this[kStatus] === "closed" || this[kDeferOpen]) {
      this[kDeferOpen] = false;
      this[kStatus] = "opening";
      this.emit("opening");
      this._open(options, (err2) => {
        if (err2) {
          this[kStatus] = "closed";
          this[kCloseResources](() => {
            this.emit(kLanded);
            maybeOpened(err2);
          });
          this[kUndefer]();
          return;
        }
        this[kStatus] = "open";
        this[kUndefer]();
        this.emit(kLanded);
        if (this[kStatus] === "open")
          this.emit("open");
        if (this[kStatus] === "open")
          this.emit("ready");
        maybeOpened();
      });
    } else if (this[kStatus] === "open") {
      this.nextTick(maybeOpened);
    } else {
      this.once(kLanded, () => this.open(options, callback));
    }
    return callback[kPromise$1];
  }
  _open(options, callback) {
    this.nextTick(callback);
  }
  close(callback) {
    callback = fromCallback$1(callback, kPromise$1);
    const maybeClosed = (err2) => {
      if (this[kStatus] === "opening" || this[kStatus] === "closing") {
        this.once(kLanded, err2 ? maybeClosed(err2) : maybeClosed);
      } else if (this[kStatus] !== "closed") {
        callback(new ModuleError$1("Database is not closed", {
          code: "LEVEL_DATABASE_NOT_CLOSED",
          cause: err2
        }));
      } else {
        callback();
      }
    };
    if (this[kStatus] === "open") {
      this[kStatus] = "closing";
      this.emit("closing");
      const cancel = (err2) => {
        this[kStatus] = "open";
        this[kUndefer]();
        this.emit(kLanded);
        maybeClosed(err2);
      };
      this[kCloseResources](() => {
        this._close((err2) => {
          if (err2)
            return cancel(err2);
          this[kStatus] = "closed";
          this[kUndefer]();
          this.emit(kLanded);
          if (this[kStatus] === "closed")
            this.emit("closed");
          maybeClosed();
        });
      });
    } else if (this[kStatus] === "closed") {
      this.nextTick(maybeClosed);
    } else {
      this.once(kLanded, () => this.close(callback));
    }
    return callback[kPromise$1];
  }
  [kCloseResources](callback) {
    if (this[kResources].size === 0) {
      return this.nextTick(callback);
    }
    let pending = this[kResources].size;
    let sync = true;
    const next = () => {
      if (--pending === 0) {
        if (sync)
          this.nextTick(callback);
        else
          callback();
      }
    };
    for (const resource of this[kResources]) {
      resource.close(next);
    }
    sync = false;
    this[kResources].clear();
  }
  _close(callback) {
    this.nextTick(callback);
  }
  get(key, options, callback) {
    callback = getCallback(options, callback);
    callback = fromCallback$1(callback, kPromise$1);
    options = getOptions(options, this[kDefaultOptions].entry);
    if (this[kStatus] === "opening") {
      this.defer(() => this.get(key, options, callback));
      return callback[kPromise$1];
    }
    if (maybeError(this, callback)) {
      return callback[kPromise$1];
    }
    const err2 = this._checkKey(key);
    if (err2) {
      this.nextTick(callback, err2);
      return callback[kPromise$1];
    }
    const keyEncoding = this.keyEncoding(options.keyEncoding);
    const valueEncoding = this.valueEncoding(options.valueEncoding);
    const keyFormat = keyEncoding.format;
    const valueFormat = valueEncoding.format;
    if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {
      options = Object.assign({}, options, { keyEncoding: keyFormat, valueEncoding: valueFormat });
    }
    this._get(this.prefixKey(keyEncoding.encode(key), keyFormat), options, (err3, value2) => {
      if (err3) {
        if (err3.code === "LEVEL_NOT_FOUND" || err3.notFound || /NotFound/i.test(err3)) {
          if (!err3.code)
            err3.code = "LEVEL_NOT_FOUND";
          if (!err3.notFound)
            err3.notFound = true;
          if (!err3.status)
            err3.status = 404;
        }
        return callback(err3);
      }
      try {
        value2 = valueEncoding.decode(value2);
      } catch (err4) {
        return callback(new ModuleError$1("Could not decode value", {
          code: "LEVEL_DECODE_ERROR",
          cause: err4
        }));
      }
      callback(null, value2);
    });
    return callback[kPromise$1];
  }
  _get(key, options, callback) {
    this.nextTick(callback, new Error("NotFound"));
  }
  getMany(keys, options, callback) {
    callback = getCallback(options, callback);
    callback = fromCallback$1(callback, kPromise$1);
    options = getOptions(options, this[kDefaultOptions].entry);
    if (this[kStatus] === "opening") {
      this.defer(() => this.getMany(keys, options, callback));
      return callback[kPromise$1];
    }
    if (maybeError(this, callback)) {
      return callback[kPromise$1];
    }
    if (!Array.isArray(keys)) {
      this.nextTick(callback, new TypeError("The first argument 'keys' must be an array"));
      return callback[kPromise$1];
    }
    if (keys.length === 0) {
      this.nextTick(callback, null, []);
      return callback[kPromise$1];
    }
    const keyEncoding = this.keyEncoding(options.keyEncoding);
    const valueEncoding = this.valueEncoding(options.valueEncoding);
    const keyFormat = keyEncoding.format;
    const valueFormat = valueEncoding.format;
    if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {
      options = Object.assign({}, options, { keyEncoding: keyFormat, valueEncoding: valueFormat });
    }
    const mappedKeys = new Array(keys.length);
    for (let i2 = 0; i2 < keys.length; i2++) {
      const key = keys[i2];
      const err2 = this._checkKey(key);
      if (err2) {
        this.nextTick(callback, err2);
        return callback[kPromise$1];
      }
      mappedKeys[i2] = this.prefixKey(keyEncoding.encode(key), keyFormat);
    }
    this._getMany(mappedKeys, options, (err2, values) => {
      if (err2)
        return callback(err2);
      try {
        for (let i2 = 0; i2 < values.length; i2++) {
          if (values[i2] !== void 0) {
            values[i2] = valueEncoding.decode(values[i2]);
          }
        }
      } catch (err3) {
        return callback(new ModuleError$1(`Could not decode one or more of ${values.length} value(s)`, {
          code: "LEVEL_DECODE_ERROR",
          cause: err3
        }));
      }
      callback(null, values);
    });
    return callback[kPromise$1];
  }
  _getMany(keys, options, callback) {
    this.nextTick(callback, null, new Array(keys.length).fill(void 0));
  }
  put(key, value2, options, callback) {
    callback = getCallback(options, callback);
    callback = fromCallback$1(callback, kPromise$1);
    options = getOptions(options, this[kDefaultOptions].entry);
    if (this[kStatus] === "opening") {
      this.defer(() => this.put(key, value2, options, callback));
      return callback[kPromise$1];
    }
    if (maybeError(this, callback)) {
      return callback[kPromise$1];
    }
    const err2 = this._checkKey(key) || this._checkValue(value2);
    if (err2) {
      this.nextTick(callback, err2);
      return callback[kPromise$1];
    }
    const keyEncoding = this.keyEncoding(options.keyEncoding);
    const valueEncoding = this.valueEncoding(options.valueEncoding);
    const keyFormat = keyEncoding.format;
    const valueFormat = valueEncoding.format;
    if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {
      options = Object.assign({}, options, { keyEncoding: keyFormat, valueEncoding: valueFormat });
    }
    const mappedKey = this.prefixKey(keyEncoding.encode(key), keyFormat);
    const mappedValue = valueEncoding.encode(value2);
    this._put(mappedKey, mappedValue, options, (err3) => {
      if (err3)
        return callback(err3);
      this.emit("put", key, value2);
      callback();
    });
    return callback[kPromise$1];
  }
  _put(key, value2, options, callback) {
    this.nextTick(callback);
  }
  del(key, options, callback) {
    callback = getCallback(options, callback);
    callback = fromCallback$1(callback, kPromise$1);
    options = getOptions(options, this[kDefaultOptions].key);
    if (this[kStatus] === "opening") {
      this.defer(() => this.del(key, options, callback));
      return callback[kPromise$1];
    }
    if (maybeError(this, callback)) {
      return callback[kPromise$1];
    }
    const err2 = this._checkKey(key);
    if (err2) {
      this.nextTick(callback, err2);
      return callback[kPromise$1];
    }
    const keyEncoding = this.keyEncoding(options.keyEncoding);
    const keyFormat = keyEncoding.format;
    if (options.keyEncoding !== keyFormat) {
      options = Object.assign({}, options, { keyEncoding: keyFormat });
    }
    this._del(this.prefixKey(keyEncoding.encode(key), keyFormat), options, (err3) => {
      if (err3)
        return callback(err3);
      this.emit("del", key);
      callback();
    });
    return callback[kPromise$1];
  }
  _del(key, options, callback) {
    this.nextTick(callback);
  }
  batch(operations, options, callback) {
    if (!arguments.length) {
      if (this[kStatus] === "opening")
        return new DefaultChainedBatch(this);
      if (this[kStatus] !== "open") {
        throw new ModuleError$1("Database is not open", {
          code: "LEVEL_DATABASE_NOT_OPEN"
        });
      }
      return this._chainedBatch();
    }
    if (typeof operations === "function")
      callback = operations;
    else
      callback = getCallback(options, callback);
    callback = fromCallback$1(callback, kPromise$1);
    options = getOptions(options, this[kDefaultOptions].empty);
    if (this[kStatus] === "opening") {
      this.defer(() => this.batch(operations, options, callback));
      return callback[kPromise$1];
    }
    if (maybeError(this, callback)) {
      return callback[kPromise$1];
    }
    if (!Array.isArray(operations)) {
      this.nextTick(callback, new TypeError("The first argument 'operations' must be an array"));
      return callback[kPromise$1];
    }
    if (operations.length === 0) {
      this.nextTick(callback);
      return callback[kPromise$1];
    }
    const mapped = new Array(operations.length);
    const { keyEncoding: ke, valueEncoding: ve, ...forward } = options;
    for (let i2 = 0; i2 < operations.length; i2++) {
      if (typeof operations[i2] !== "object" || operations[i2] === null) {
        this.nextTick(callback, new TypeError("A batch operation must be an object"));
        return callback[kPromise$1];
      }
      const op = Object.assign({}, operations[i2]);
      if (op.type !== "put" && op.type !== "del") {
        this.nextTick(callback, new TypeError("A batch operation must have a type property that is 'put' or 'del'"));
        return callback[kPromise$1];
      }
      const err2 = this._checkKey(op.key);
      if (err2) {
        this.nextTick(callback, err2);
        return callback[kPromise$1];
      }
      const db = op.sublevel != null ? op.sublevel : this;
      const keyEncoding = db.keyEncoding(op.keyEncoding || ke);
      const keyFormat = keyEncoding.format;
      op.key = db.prefixKey(keyEncoding.encode(op.key), keyFormat);
      op.keyEncoding = keyFormat;
      if (op.type === "put") {
        const valueErr = this._checkValue(op.value);
        if (valueErr) {
          this.nextTick(callback, valueErr);
          return callback[kPromise$1];
        }
        const valueEncoding = db.valueEncoding(op.valueEncoding || ve);
        op.value = valueEncoding.encode(op.value);
        op.valueEncoding = valueEncoding.format;
      }
      if (db !== this) {
        op.sublevel = null;
      }
      mapped[i2] = op;
    }
    this._batch(mapped, forward, (err2) => {
      if (err2)
        return callback(err2);
      this.emit("batch", operations);
      callback();
    });
    return callback[kPromise$1];
  }
  _batch(operations, options, callback) {
    this.nextTick(callback);
  }
  sublevel(name2, options) {
    return this._sublevel(name2, AbstractSublevel.defaults(options));
  }
  _sublevel(name2, options) {
    return new AbstractSublevel(this, name2, options);
  }
  prefixKey(key, keyFormat) {
    return key;
  }
  clear(options, callback) {
    callback = getCallback(options, callback);
    callback = fromCallback$1(callback, kPromise$1);
    options = getOptions(options, this[kDefaultOptions].empty);
    if (this[kStatus] === "opening") {
      this.defer(() => this.clear(options, callback));
      return callback[kPromise$1];
    }
    if (maybeError(this, callback)) {
      return callback[kPromise$1];
    }
    const original = options;
    const keyEncoding = this.keyEncoding(options.keyEncoding);
    options = rangeOptions(options, keyEncoding);
    options.keyEncoding = keyEncoding.format;
    if (options.limit === 0) {
      this.nextTick(callback);
    } else {
      this._clear(options, (err2) => {
        if (err2)
          return callback(err2);
        this.emit("clear", original);
        callback();
      });
    }
    return callback[kPromise$1];
  }
  _clear(options, callback) {
    this.nextTick(callback);
  }
  iterator(options) {
    const keyEncoding = this.keyEncoding(options && options.keyEncoding);
    const valueEncoding = this.valueEncoding(options && options.valueEncoding);
    options = rangeOptions(options, keyEncoding);
    options.keys = options.keys !== false;
    options.values = options.values !== false;
    options[AbstractIterator$1.keyEncoding] = keyEncoding;
    options[AbstractIterator$1.valueEncoding] = valueEncoding;
    options.keyEncoding = keyEncoding.format;
    options.valueEncoding = valueEncoding.format;
    if (this[kStatus] === "opening") {
      return new DeferredIterator(this, options);
    } else if (this[kStatus] !== "open") {
      throw new ModuleError$1("Database is not open", {
        code: "LEVEL_DATABASE_NOT_OPEN"
      });
    }
    return this._iterator(options);
  }
  _iterator(options) {
    return new AbstractIterator$1(this, options);
  }
  keys(options) {
    const keyEncoding = this.keyEncoding(options && options.keyEncoding);
    const valueEncoding = this.valueEncoding(options && options.valueEncoding);
    options = rangeOptions(options, keyEncoding);
    options[AbstractIterator$1.keyEncoding] = keyEncoding;
    options[AbstractIterator$1.valueEncoding] = valueEncoding;
    options.keyEncoding = keyEncoding.format;
    options.valueEncoding = valueEncoding.format;
    if (this[kStatus] === "opening") {
      return new DeferredKeyIterator(this, options);
    } else if (this[kStatus] !== "open") {
      throw new ModuleError$1("Database is not open", {
        code: "LEVEL_DATABASE_NOT_OPEN"
      });
    }
    return this._keys(options);
  }
  _keys(options) {
    return new DefaultKeyIterator(this, options);
  }
  values(options) {
    const keyEncoding = this.keyEncoding(options && options.keyEncoding);
    const valueEncoding = this.valueEncoding(options && options.valueEncoding);
    options = rangeOptions(options, keyEncoding);
    options[AbstractIterator$1.keyEncoding] = keyEncoding;
    options[AbstractIterator$1.valueEncoding] = valueEncoding;
    options.keyEncoding = keyEncoding.format;
    options.valueEncoding = valueEncoding.format;
    if (this[kStatus] === "opening") {
      return new DeferredValueIterator(this, options);
    } else if (this[kStatus] !== "open") {
      throw new ModuleError$1("Database is not open", {
        code: "LEVEL_DATABASE_NOT_OPEN"
      });
    }
    return this._values(options);
  }
  _values(options) {
    return new DefaultValueIterator(this, options);
  }
  defer(fn) {
    if (typeof fn !== "function") {
      throw new TypeError("The first argument must be a function");
    }
    this[kOperations].push(fn);
  }
  [kUndefer]() {
    if (this[kOperations].length === 0) {
      return;
    }
    const operations = this[kOperations];
    this[kOperations] = [];
    for (const op of operations) {
      op();
    }
  }
  attachResource(resource) {
    if (typeof resource !== "object" || resource === null || typeof resource.close !== "function") {
      throw new TypeError("The first argument must be a resource object");
    }
    this[kResources].add(resource);
  }
  detachResource(resource) {
    this[kResources].delete(resource);
  }
  _chainedBatch() {
    return new DefaultChainedBatch(this);
  }
  _checkKey(key) {
    if (key === null || key === void 0) {
      return new ModuleError$1("Key cannot be null or undefined", {
        code: "LEVEL_INVALID_KEY"
      });
    }
  }
  _checkValue(value2) {
    if (value2 === null || value2 === void 0) {
      return new ModuleError$1("Value cannot be null or undefined", {
        code: "LEVEL_INVALID_VALUE"
      });
    }
  }
}
AbstractLevel$1.prototype.nextTick = requireNextTickBrowser();
const { AbstractSublevel } = requireAbstractSublevel()({ AbstractLevel: AbstractLevel$1 });
abstractLevel.AbstractLevel = AbstractLevel$1;
abstractLevel.AbstractSublevel = AbstractSublevel;
const maybeError = function(db, callback) {
  if (db[kStatus] !== "open") {
    db.nextTick(callback, new ModuleError$1("Database is not open", {
      code: "LEVEL_DATABASE_NOT_OPEN"
    }));
    return true;
  }
  return false;
};
const formats = function(db) {
  return Object.keys(db.supports.encodings).filter((k) => !!db.supports.encodings[k]);
};
abstractLevel$1.AbstractLevel = abstractLevel.AbstractLevel;
abstractLevel$1.AbstractSublevel = abstractLevel.AbstractSublevel;
abstractLevel$1.AbstractIterator = abstractIterator.AbstractIterator;
abstractLevel$1.AbstractKeyIterator = abstractIterator.AbstractKeyIterator;
abstractLevel$1.AbstractValueIterator = abstractIterator.AbstractValueIterator;
abstractLevel$1.AbstractChainedBatch = abstractChainedBatch.AbstractChainedBatch;
/*! run-parallel-limit. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var runParallelLimit_1 = runParallelLimit;
const queueMicrotask$1 = queueMicrotask_1;
function runParallelLimit(tasks, limit, cb) {
  if (typeof limit !== "number")
    throw new Error("second argument must be a Number");
  let results, len2, pending, keys, isErrored;
  let isSync = true;
  let next;
  if (Array.isArray(tasks)) {
    results = [];
    pending = len2 = tasks.length;
  } else {
    keys = Object.keys(tasks);
    results = {};
    pending = len2 = keys.length;
  }
  function done(err2) {
    function end2() {
      if (cb)
        cb(err2, results);
      cb = null;
    }
    if (isSync)
      queueMicrotask$1(end2);
    else
      end2();
  }
  function each2(i2, err2, result) {
    results[i2] = result;
    if (err2)
      isErrored = true;
    if (--pending === 0 || err2) {
      done(err2);
    } else if (!isErrored && next < len2) {
      let key;
      if (keys) {
        key = keys[next];
        next += 1;
        tasks[key](function(err3, result2) {
          each2(key, err3, result2);
        });
      } else {
        key = next;
        next += 1;
        tasks[key](function(err3, result2) {
          each2(key, err3, result2);
        });
      }
    }
  }
  next = limit;
  if (!pending) {
    done(null);
  } else if (keys) {
    keys.some(function(key, i2) {
      tasks[key](function(err2, result) {
        each2(key, err2, result);
      });
      if (i2 === limit - 1)
        return true;
      return false;
    });
  } else {
    tasks.some(function(task, i2) {
      task(function(err2, result) {
        each2(i2, err2, result);
      });
      if (i2 === limit - 1)
        return true;
      return false;
    });
  }
  isSync = false;
}
var iterator = {};
var keyRange = function createKeyRange2(options) {
  const lower = options.gte !== void 0 ? options.gte : options.gt !== void 0 ? options.gt : void 0;
  const upper = options.lte !== void 0 ? options.lte : options.lt !== void 0 ? options.lt : void 0;
  const lowerExclusive = options.gte === void 0;
  const upperExclusive = options.lte === void 0;
  if (lower !== void 0 && upper !== void 0) {
    return IDBKeyRange.bound(lower, upper, lowerExclusive, upperExclusive);
  } else if (lower !== void 0) {
    return IDBKeyRange.lowerBound(lower, lowerExclusive);
  } else if (upper !== void 0) {
    return IDBKeyRange.upperBound(upper, upperExclusive);
  } else {
    return null;
  }
};
const textEncoder = new TextEncoder();
var deserialize$2 = function(data) {
  if (data instanceof Uint8Array) {
    return data;
  } else if (data instanceof ArrayBuffer) {
    return new Uint8Array(data);
  } else {
    return textEncoder.encode(data);
  }
};
const { AbstractIterator } = abstractLevel$1;
const createKeyRange$1 = keyRange;
const deserialize$1 = deserialize$2;
const kCache = Symbol("cache");
const kFinished = Symbol("finished");
const kOptions = Symbol("options");
const kCurrentOptions = Symbol("currentOptions");
const kPosition = Symbol("position");
const kLocation$1 = Symbol("location");
const kFirst = Symbol("first");
const emptyOptions = {};
class Iterator$1 extends AbstractIterator {
  constructor(db, location2, options) {
    super(db, options);
    this[kCache] = [];
    this[kFinished] = this.limit === 0;
    this[kOptions] = options;
    this[kCurrentOptions] = { ...options };
    this[kPosition] = void 0;
    this[kLocation$1] = location2;
    this[kFirst] = true;
  }
  _nextv(size2, options, callback) {
    this[kFirst] = false;
    if (this[kFinished]) {
      return this.nextTick(callback, null, []);
    } else if (this[kCache].length > 0) {
      size2 = Math.min(size2, this[kCache].length);
      return this.nextTick(callback, null, this[kCache].splice(0, size2));
    }
    if (this[kPosition] !== void 0) {
      if (this[kOptions].reverse) {
        this[kCurrentOptions].lt = this[kPosition];
        this[kCurrentOptions].lte = void 0;
      } else {
        this[kCurrentOptions].gt = this[kPosition];
        this[kCurrentOptions].gte = void 0;
      }
    }
    let keyRange2;
    try {
      keyRange2 = createKeyRange$1(this[kCurrentOptions]);
    } catch (_) {
      this[kFinished] = true;
      return this.nextTick(callback, null, []);
    }
    const transaction = this.db.db.transaction([this[kLocation$1]], "readonly");
    const store = transaction.objectStore(this[kLocation$1]);
    const entries = [];
    if (!this[kOptions].reverse) {
      let keys;
      let values;
      const complete = () => {
        if (keys === void 0 || values === void 0)
          return;
        const length3 = Math.max(keys.length, values.length);
        if (length3 === 0 || size2 === Infinity) {
          this[kFinished] = true;
        } else {
          this[kPosition] = keys[length3 - 1];
        }
        entries.length = length3;
        for (let i2 = 0; i2 < length3; i2++) {
          const key = keys[i2];
          const value2 = values[i2];
          entries[i2] = [
            this[kOptions].keys && key !== void 0 ? deserialize$1(key) : void 0,
            this[kOptions].values && value2 !== void 0 ? deserialize$1(value2) : void 0
          ];
        }
        maybeCommit(transaction);
      };
      if (this[kOptions].keys || size2 < Infinity) {
        store.getAllKeys(keyRange2, size2 < Infinity ? size2 : void 0).onsuccess = (ev) => {
          keys = ev.target.result;
          complete();
        };
      } else {
        keys = [];
        this.nextTick(complete);
      }
      if (this[kOptions].values) {
        store.getAll(keyRange2, size2 < Infinity ? size2 : void 0).onsuccess = (ev) => {
          values = ev.target.result;
          complete();
        };
      } else {
        values = [];
        this.nextTick(complete);
      }
    } else {
      const method = !this[kOptions].values && store.openKeyCursor ? "openKeyCursor" : "openCursor";
      store[method](keyRange2, "prev").onsuccess = (ev) => {
        const cursor = ev.target.result;
        if (cursor) {
          const { key, value: value2 } = cursor;
          this[kPosition] = key;
          entries.push([
            this[kOptions].keys && key !== void 0 ? deserialize$1(key) : void 0,
            this[kOptions].values && value2 !== void 0 ? deserialize$1(value2) : void 0
          ]);
          if (entries.length < size2) {
            cursor.continue();
          } else {
            maybeCommit(transaction);
          }
        } else {
          this[kFinished] = true;
        }
      };
    }
    transaction.onabort = () => {
      callback(transaction.error || new Error("aborted by user"));
      callback = null;
    };
    transaction.oncomplete = () => {
      callback(null, entries);
      callback = null;
    };
  }
  _next(callback) {
    if (this[kCache].length > 0) {
      const [key, value2] = this[kCache].shift();
      this.nextTick(callback, null, key, value2);
    } else if (this[kFinished]) {
      this.nextTick(callback);
    } else {
      let size2 = Math.min(100, this.limit - this.count);
      if (this[kFirst]) {
        this[kFirst] = false;
        size2 = 1;
      }
      this._nextv(size2, emptyOptions, (err2, entries) => {
        if (err2)
          return callback(err2);
        this[kCache] = entries;
        this._next(callback);
      });
    }
  }
  _all(options, callback) {
    this[kFirst] = false;
    const cache2 = this[kCache].splice(0, this[kCache].length);
    const size2 = this.limit - this.count - cache2.length;
    if (size2 <= 0) {
      return this.nextTick(callback, null, cache2);
    }
    this._nextv(size2, emptyOptions, (err2, entries) => {
      if (err2)
        return callback(err2);
      if (cache2.length > 0)
        entries = cache2.concat(entries);
      callback(null, entries);
    });
  }
  _seek(target, options) {
    this[kFirst] = true;
    this[kCache] = [];
    this[kFinished] = false;
    this[kPosition] = void 0;
    this[kCurrentOptions] = { ...this[kOptions] };
    let keyRange2;
    try {
      keyRange2 = createKeyRange$1(this[kOptions]);
    } catch (_) {
      this[kFinished] = true;
      return;
    }
    if (keyRange2 !== null && !keyRange2.includes(target)) {
      this[kFinished] = true;
    } else if (this[kOptions].reverse) {
      this[kCurrentOptions].lte = target;
    } else {
      this[kCurrentOptions].gte = target;
    }
  }
}
iterator.Iterator = Iterator$1;
function maybeCommit(transaction) {
  if (typeof transaction.commit === "function") {
    transaction.commit();
  }
}
var clear$1 = function clear2(db, location2, keyRange2, options, callback) {
  if (options.limit === 0)
    return db.nextTick(callback);
  const transaction = db.db.transaction([location2], "readwrite");
  const store = transaction.objectStore(location2);
  let count = 0;
  transaction.oncomplete = function() {
    callback();
  };
  transaction.onabort = function() {
    callback(transaction.error || new Error("aborted by user"));
  };
  const method = store.openKeyCursor ? "openKeyCursor" : "openCursor";
  const direction = options.reverse ? "prev" : "next";
  store[method](keyRange2, direction).onsuccess = function(ev) {
    const cursor = ev.target.result;
    if (cursor) {
      store.delete(cursor.key).onsuccess = function() {
        if (options.limit <= 0 || ++count < options.limit) {
          cursor.continue();
        }
      };
    }
  };
};
const { AbstractLevel } = abstractLevel$1;
const ModuleError = moduleError;
const parallel = runParallelLimit_1;
const { fromCallback } = catering;
const { Iterator } = iterator;
const deserialize = deserialize$2;
const clear = clear$1;
const createKeyRange = keyRange;
const DEFAULT_PREFIX = "level-js-";
const kIDB = Symbol("idb");
const kNamePrefix = Symbol("namePrefix");
const kLocation = Symbol("location");
const kVersion = Symbol("version");
const kStore = Symbol("store");
const kOnComplete = Symbol("onComplete");
const kPromise = Symbol("promise");
class BrowserLevel extends AbstractLevel {
  constructor(location2, options, _) {
    if (typeof options === "function" || typeof _ === "function") {
      throw new ModuleError("The levelup-style callback argument has been removed", {
        code: "LEVEL_LEGACY"
      });
    }
    const { prefix, version: version2, ...forward } = options || {};
    super({
      encodings: { view: true },
      snapshots: false,
      createIfMissing: false,
      errorIfExists: false,
      seek: true
    }, forward);
    if (typeof location2 !== "string") {
      throw new Error("constructor requires a location string argument");
    }
    this[kLocation] = location2;
    this[kNamePrefix] = prefix == null ? DEFAULT_PREFIX : prefix;
    this[kVersion] = parseInt(version2 || 1, 10);
    this[kIDB] = null;
  }
  get location() {
    return this[kLocation];
  }
  get namePrefix() {
    return this[kNamePrefix];
  }
  get version() {
    return this[kVersion];
  }
  get db() {
    return this[kIDB];
  }
  get type() {
    return "browser-level";
  }
  _open(options, callback) {
    const req = indexedDB.open(this[kNamePrefix] + this[kLocation], this[kVersion]);
    req.onerror = function() {
      callback(req.error || new Error("unknown error"));
    };
    req.onsuccess = () => {
      this[kIDB] = req.result;
      callback();
    };
    req.onupgradeneeded = (ev) => {
      const db = ev.target.result;
      if (!db.objectStoreNames.contains(this[kLocation])) {
        db.createObjectStore(this[kLocation]);
      }
    };
  }
  [kStore](mode) {
    const transaction = this[kIDB].transaction([this[kLocation]], mode);
    return transaction.objectStore(this[kLocation]);
  }
  [kOnComplete](request2, callback) {
    const transaction = request2.transaction;
    transaction.onabort = function() {
      callback(transaction.error || new Error("aborted by user"));
    };
    transaction.oncomplete = function() {
      callback(null, request2.result);
    };
  }
  _get(key, options, callback) {
    const store = this[kStore]("readonly");
    let req;
    try {
      req = store.get(key);
    } catch (err2) {
      return this.nextTick(callback, err2);
    }
    this[kOnComplete](req, function(err2, value2) {
      if (err2)
        return callback(err2);
      if (value2 === void 0) {
        return callback(new ModuleError("Entry not found", {
          code: "LEVEL_NOT_FOUND"
        }));
      }
      callback(null, deserialize(value2));
    });
  }
  _getMany(keys, options, callback) {
    const store = this[kStore]("readonly");
    const tasks = keys.map((key) => (next) => {
      let request2;
      try {
        request2 = store.get(key);
      } catch (err2) {
        return next(err2);
      }
      request2.onsuccess = () => {
        const value2 = request2.result;
        next(null, value2 === void 0 ? value2 : deserialize(value2));
      };
      request2.onerror = (ev) => {
        ev.stopPropagation();
        next(request2.error);
      };
    });
    parallel(tasks, 16, callback);
  }
  _del(key, options, callback) {
    const store = this[kStore]("readwrite");
    let req;
    try {
      req = store.delete(key);
    } catch (err2) {
      return this.nextTick(callback, err2);
    }
    this[kOnComplete](req, callback);
  }
  _put(key, value2, options, callback) {
    const store = this[kStore]("readwrite");
    let req;
    try {
      req = store.put(value2, key);
    } catch (err2) {
      return this.nextTick(callback, err2);
    }
    this[kOnComplete](req, callback);
  }
  _iterator(options) {
    return new Iterator(this, this[kLocation], options);
  }
  _batch(operations, options, callback) {
    const store = this[kStore]("readwrite");
    const transaction = store.transaction;
    let index = 0;
    let error2;
    transaction.onabort = function() {
      callback(error2 || transaction.error || new Error("aborted by user"));
    };
    transaction.oncomplete = function() {
      callback();
    };
    function loop() {
      const op = operations[index++];
      const key = op.key;
      let req;
      try {
        req = op.type === "del" ? store.delete(key) : store.put(op.value, key);
      } catch (err2) {
        error2 = err2;
        transaction.abort();
        return;
      }
      if (index < operations.length) {
        req.onsuccess = loop;
      } else if (typeof transaction.commit === "function") {
        transaction.commit();
      }
    }
    loop();
  }
  _clear(options, callback) {
    let keyRange2;
    let req;
    try {
      keyRange2 = createKeyRange(options);
    } catch (e) {
      return this.nextTick(callback);
    }
    if (options.limit >= 0) {
      return clear(this, this[kLocation], keyRange2, options, callback);
    }
    try {
      const store = this[kStore]("readwrite");
      req = keyRange2 ? store.delete(keyRange2) : store.clear();
    } catch (err2) {
      return this.nextTick(callback, err2);
    }
    this[kOnComplete](req, callback);
  }
  _close(callback) {
    this[kIDB].close();
    this.nextTick(callback);
  }
}
BrowserLevel.destroy = function(location2, prefix, callback) {
  if (typeof prefix === "function") {
    callback = prefix;
    prefix = DEFAULT_PREFIX;
  }
  callback = fromCallback(callback, kPromise);
  const request2 = indexedDB.deleteDatabase(prefix + location2);
  request2.onsuccess = function() {
    callback();
  };
  request2.onerror = function(err2) {
    callback(err2);
  };
  return callback[kPromise];
};
browserLevel.BrowserLevel = BrowserLevel;
var Level = browserLevel.BrowserLevel;
class LevelDatastore extends BaseDatastore {
  constructor(path2, opts = {}) {
    super();
    this.db = typeof path2 === "string" ? new Level(path2, {
      ...opts,
      keyEncoding: "utf8",
      valueEncoding: "view"
    }) : path2;
    this.opts = {
      createIfMissing: true,
      compression: false,
      ...opts
    };
  }
  async open() {
    try {
      await this.db.open(this.opts);
    } catch (err2) {
      throw dbOpenFailedError(err2);
    }
  }
  async put(key, value2) {
    try {
      await this.db.put(key.toString(), value2);
    } catch (err2) {
      throw dbWriteFailedError(err2);
    }
  }
  async get(key) {
    let data;
    try {
      data = await this.db.get(key.toString());
    } catch (err2) {
      if (err2.notFound)
        throw notFoundError$1(err2);
      throw dbWriteFailedError(err2);
    }
    return data;
  }
  async has(key) {
    try {
      await this.db.get(key.toString());
    } catch (err2) {
      if (err2.notFound)
        return false;
      throw err2;
    }
    return true;
  }
  async delete(key) {
    try {
      await this.db.del(key.toString());
    } catch (err2) {
      throw dbDeleteFailedError(err2);
    }
  }
  close() {
    return this.db && this.db.close();
  }
  batch() {
    const ops = [];
    return {
      put: (key, value2) => {
        ops.push({
          type: "put",
          key: key.toString(),
          value: value2
        });
      },
      delete: (key) => {
        ops.push({
          type: "del",
          key: key.toString()
        });
      },
      commit: () => {
        return this.db.batch(ops);
      }
    };
  }
  query(q) {
    let it = this._query({
      values: true,
      prefix: q.prefix
    });
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => filter$1(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sort(it2, f), it);
    }
    const { offset, limit } = q;
    if (offset) {
      let i2 = 0;
      it = filter$1(it, () => i2++ >= offset);
    }
    if (limit) {
      it = take(it, limit);
    }
    return it;
  }
  queryKeys(q) {
    let it = map$3(this._query({
      values: false,
      prefix: q.prefix
    }), ({ key }) => key);
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => filter$1(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sort(it2, f), it);
    }
    const { offset, limit } = q;
    if (offset) {
      let i2 = 0;
      it = filter$1(it, () => i2++ >= offset);
    }
    if (limit) {
      it = take(it, limit);
    }
    return it;
  }
  _query(opts) {
    const iteratorOpts = {
      keys: true,
      keyEncoding: "buffer",
      values: opts.values
    };
    if (opts.prefix != null) {
      const prefix = opts.prefix.toString();
      iteratorOpts.gte = prefix;
      iteratorOpts.lt = prefix + "\xFF";
    }
    const iterator2 = this.db.iterator(iteratorOpts);
    if (iterator2[Symbol.asyncIterator]) {
      return levelIteratorToIterator(iterator2);
    }
    if (iterator2.next != null && iterator2.end != null) {
      return oldLevelIteratorToIterator(iterator2);
    }
    throw new Error("Level returned incompatible iterator");
  }
}
async function* levelIteratorToIterator(li) {
  for await (const [key, value2] of li) {
    yield { key: new Key(key, false), value: value2 };
  }
  await li.close();
}
function oldLevelIteratorToIterator(li) {
  return {
    [Symbol.asyncIterator]() {
      return {
        next: () => new Promise((resolve2, reject) => {
          li.next((err2, key, value2) => {
            if (err2)
              return reject(err2);
            if (key == null) {
              return li.end((err3) => {
                if (err3)
                  return reject(err3);
                resolve2({ done: true, value: void 0 });
              });
            }
            resolve2({ done: false, value: { key: new Key(key, false), value: value2 } });
          });
        }),
        return: () => new Promise((resolve2, reject) => {
          li.end((err2) => {
            if (err2)
              return reject(err2);
            resolve2({ done: true, value: void 0 });
          });
        })
      };
    }
  };
}
const sortAll = (iterable, sorter) => {
  return async function* () {
    const values = await itAll(iterable);
    yield* values.sort(sorter);
  }();
};
class BaseBlockstore {
  open() {
    return Promise.reject(new Error(".open is not implemented"));
  }
  close() {
    return Promise.reject(new Error(".close is not implemented"));
  }
  put(key, val, options) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  get(key, options) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  has(key, options) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  delete(key, options) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *putMany(source2, options = {}) {
    for await (const { key, value: value2 } of source2) {
      await this.put(key, value2, options);
      yield { key, value: value2 };
    }
  }
  async *getMany(source2, options = {}) {
    for await (const key of source2) {
      yield this.get(key, options);
    }
  }
  async *deleteMany(source2, options = {}) {
    for await (const key of source2) {
      await this.delete(key, options);
      yield key;
    }
  }
  batch() {
    let puts = [];
    let dels = [];
    return {
      put(key, value2) {
        puts.push({ key, value: value2 });
      },
      delete(key) {
        dels.push(key);
      },
      commit: async (options) => {
        await itDrain(this.putMany(puts, options));
        puts = [];
        await itDrain(this.deleteMany(dels, options));
        dels = [];
      }
    };
  }
  async *_all(q, options) {
    throw new Error("._all is not implemented");
  }
  async *_allKeys(q, options) {
    throw new Error("._allKeys is not implemented");
  }
  query(q, options) {
    let it = this._all(q, options);
    if (q.prefix != null) {
      it = itFilter(
        it,
        (e) => e.key.toString().startsWith(q.prefix || "")
      );
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => itFilter(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sortAll(it2, f), it);
    }
    if (q.offset != null) {
      let i2 = 0;
      it = itFilter(it, () => i2++ >= (q.offset || 0));
    }
    if (q.limit != null) {
      it = itTake(it, q.limit);
    }
    return it;
  }
  queryKeys(q, options) {
    let it = this._allKeys(q, options);
    if (q.prefix != null) {
      it = itFilter(it, (cid) => cid.toString().startsWith(q.prefix || ""));
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => itFilter(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sortAll(it2, f), it);
    }
    if (q.offset != null) {
      let i2 = 0;
      it = itFilter(it, () => i2++ >= q.offset);
    }
    if (q.limit != null) {
      it = itTake(it, q.limit);
    }
    return it;
  }
}
function cidToKey(cid) {
  const c = CID.asCID(cid);
  if (!c) {
    throw errCode(new Error("Not a valid cid"), "ERR_INVALID_CID");
  }
  return new Key("/" + base32$2.encode(c.multihash.bytes).slice(1).toUpperCase(), false);
}
function keyToCid(key) {
  return CID.createV1(code$3, decode$j(base32$2.decode("b" + key.toString().slice(1).toLowerCase())));
}
function convertPrefix(prefix) {
  const firstChar = prefix.substring(0, 1);
  if (firstChar === "/") {
    return convertPrefix(prefix.substring(1));
  }
  let decoder;
  if (firstChar.toLowerCase() === "b") {
    decoder = (input) => base32$2.decode(input.toLowerCase()).subarray(2);
  } else if (firstChar.toLowerCase() === "c") {
    decoder = (input) => base32pad$1.decode(input.toLowerCase()).subarray(2);
  } else if (firstChar === "z") {
    decoder = (input) => base58btc$1.decode(input).subarray(2);
  } else if (firstChar === "Q") {
    decoder = (input) => base58btc$1.decode("z" + input);
  } else {
    decoder = (input) => base32$2.decode("b" + input.toLowerCase()).subarray(2);
  }
  let bytes2;
  for (let i2 = 1; i2 < prefix.length; i2++) {
    try {
      bytes2 = decoder(prefix.substring(0, i2));
    } catch (err2) {
      if (err2.message !== "Unexpected end of data") {
        throw err2;
      }
    }
  }
  let str = "/C";
  if (bytes2) {
    str = `/${base32$2.encode(bytes2).slice(1, -1).toUpperCase() || "C"}`;
  }
  return str;
}
function convertQuery(query) {
  return {
    ...query,
    prefix: query.prefix ? convertPrefix(query.prefix) : void 0,
    filters: query.filters ? query.filters.map(
      (filter2) => (pair2) => {
        return filter2({ key: keyToCid(pair2.key), value: pair2.value });
      }
    ) : void 0,
    orders: query.orders ? query.orders.map(
      (order) => (a, b2) => {
        return order({ key: keyToCid(a.key), value: a.value }, { key: keyToCid(b2.key), value: b2.value });
      }
    ) : void 0
  };
}
function convertKeyQuery(query) {
  return {
    ...query,
    prefix: query.prefix ? convertPrefix(query.prefix) : void 0,
    filters: query.filters ? query.filters.map(
      (filter2) => (key) => {
        return filter2(keyToCid(key));
      }
    ) : void 0,
    orders: query.orders ? query.orders.map(
      (order) => (a, b2) => {
        return order(keyToCid(a), keyToCid(b2));
      }
    ) : void 0
  };
}
class BlockstoreDatastoreAdapter extends BaseBlockstore {
  constructor(datastore) {
    super();
    this.child = datastore;
  }
  open() {
    return this.child.open();
  }
  close() {
    return this.child.close();
  }
  async *query(query, options) {
    for await (const { key, value: value2 } of this.child.query(convertQuery(query), options)) {
      yield { key: keyToCid(key), value: value2 };
    }
  }
  async *queryKeys(query, options) {
    for await (const key of this.child.queryKeys(convertKeyQuery(query), options)) {
      yield keyToCid(key);
    }
  }
  async get(cid, options) {
    return this.child.get(cidToKey(cid), options);
  }
  async *getMany(cids, options) {
    for await (const cid of cids) {
      yield this.get(cid, options);
    }
  }
  async put(cid, value2, options) {
    await this.child.put(cidToKey(cid), value2, options);
  }
  async *putMany(blocks, options) {
    const output = pushable({
      objectMode: true
    });
    const runner = globalThis.process && globalThis.process.nextTick ? globalThis.process.nextTick : globalThis.setImmediate || globalThis.setTimeout;
    runner(async () => {
      try {
        const store = this.child;
        await drain(this.child.putMany(async function* () {
          for await (const block of blocks) {
            const key = cidToKey(block.key);
            const exists2 = await store.has(key, options);
            if (!exists2) {
              yield { key, value: block.value };
            }
            output.push(block);
          }
        }()));
        output.end();
      } catch (err2) {
        output.end(err2);
      }
    });
    yield* output;
  }
  has(cid, options) {
    return this.child.has(cidToKey(cid), options);
  }
  delete(cid, options) {
    return this.child.delete(cidToKey(cid), options);
  }
  deleteMany(cids, options) {
    const out = pushable({
      objectMode: true
    });
    drain(this.child.deleteMany(async function* () {
      for await (const cid of cids) {
        yield cidToKey(cid);
        out.push(cid);
      }
      out.end();
    }(), options)).catch((err2) => {
      out.end(err2);
    });
    return out;
  }
}
function createRepo$1(print, codecs2, options) {
  const repoPath = options.path || "ipfs";
  return createRepo$2(repoPath, (codeOrName) => codecs2.getCodec(codeOrName), {
    root: new LevelDatastore(repoPath, {
      prefix: "",
      version: 2
    }),
    blocks: new BlockstoreDatastoreAdapter(
      new LevelDatastore(`${repoPath}/blocks`, {
        prefix: "",
        version: 2
      })
    ),
    datastore: new LevelDatastore(`${repoPath}/datastore`, {
      prefix: "",
      version: 2
    }),
    keys: new LevelDatastore(`${repoPath}/keys`, {
      prefix: "",
      version: 2
    }),
    pins: new LevelDatastore(`${repoPath}/pins`, {
      prefix: "",
      version: 2
    })
  }, {
    autoMigrate: options.autoMigrate,
    onMigrationProgress: options.onMigrationProgress || print,
    repoLock: MemoryLock
  });
}
const codes$2 = {
  ERR_SIGNATURE_NOT_VALID: "ERR_SIGNATURE_NOT_VALID"
};
var Envelope;
(function(Envelope2) {
  let _codec;
  Envelope2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (opts.writeDefaults === true || obj.publicKey != null && obj.publicKey.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.publicKey);
        }
        if (opts.writeDefaults === true || obj.payloadType != null && obj.payloadType.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.payloadType);
        }
        if (opts.writeDefaults === true || obj.payload != null && obj.payload.byteLength > 0) {
          w.uint32(26);
          w.bytes(obj.payload);
        }
        if (opts.writeDefaults === true || obj.signature != null && obj.signature.byteLength > 0) {
          w.uint32(42);
          w.bytes(obj.signature);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length3) => {
        const obj = {
          publicKey: new Uint8Array(0),
          payloadType: new Uint8Array(0),
          payload: new Uint8Array(0),
          signature: new Uint8Array(0)
        };
        const end2 = length3 == null ? reader2.len : reader2.pos + length3;
        while (reader2.pos < end2) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.publicKey = reader2.bytes();
              break;
            case 2:
              obj.payloadType = reader2.bytes();
              break;
            case 3:
              obj.payload = reader2.bytes();
              break;
            case 5:
              obj.signature = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Envelope2.encode = (obj) => {
    return encodeMessage(obj, Envelope2.codec());
  };
  Envelope2.decode = (buf2) => {
    return decodeMessage(buf2, Envelope2.codec());
  };
})(Envelope || (Envelope = {}));
function accessor(buf2) {
  if (buf2 instanceof Uint8Array) {
    return {
      get(index) {
        return buf2[index];
      },
      set(index, value2) {
        buf2[index] = value2;
      }
    };
  }
  return {
    get(index) {
      return buf2.get(index);
    },
    set(index, value2) {
      buf2.set(index, value2);
    }
  };
}
const TWO_32 = 4294967296;
class LongBits {
  constructor(hi = 0, lo = 0) {
    this.hi = hi;
    this.lo = lo;
  }
  toBigInt(unsigned2) {
    if (unsigned2 === true) {
      return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
    }
    if (this.hi >>> 31 !== 0) {
      const lo = ~this.lo + 1 >>> 0;
      let hi = ~this.hi >>> 0;
      if (lo === 0) {
        hi = hi + 1 >>> 0;
      }
      return -(BigInt(lo) + (BigInt(hi) << 32n));
    }
    return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
  }
  toNumber(unsigned2) {
    return Number(this.toBigInt(unsigned2));
  }
  zzDecode() {
    const mask = -(this.lo & 1);
    const lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    const hi = (this.hi >>> 1 ^ mask) >>> 0;
    return new LongBits(hi, lo);
  }
  zzEncode() {
    const mask = this.hi >> 31;
    const hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    const lo = (this.lo << 1 ^ mask) >>> 0;
    return new LongBits(hi, lo);
  }
  toBytes(buf2, offset = 0) {
    const access = accessor(buf2);
    while (this.hi > 0) {
      access.set(offset++, this.lo & 127 | 128);
      this.lo = (this.lo >>> 7 | this.hi << 25) >>> 0;
      this.hi >>>= 7;
    }
    while (this.lo > 127) {
      access.set(offset++, this.lo & 127 | 128);
      this.lo = this.lo >>> 7;
    }
    access.set(offset++, this.lo);
  }
  static fromBigInt(value2) {
    if (value2 === 0n) {
      return new LongBits();
    }
    const negative = value2 < 0;
    if (negative) {
      value2 = -value2;
    }
    let hi = Number(value2 >> 32n) | 0;
    let lo = Number(value2 - (BigInt(hi) << 32n)) | 0;
    if (negative) {
      hi = ~hi >>> 0;
      lo = ~lo >>> 0;
      if (++lo > TWO_32) {
        lo = 0;
        if (++hi > TWO_32) {
          hi = 0;
        }
      }
    }
    return new LongBits(hi, lo);
  }
  static fromNumber(value2) {
    if (value2 === 0) {
      return new LongBits();
    }
    const sign2 = value2 < 0;
    if (sign2) {
      value2 = -value2;
    }
    let lo = value2 >>> 0;
    let hi = (value2 - lo) / 4294967296 >>> 0;
    if (sign2) {
      hi = ~hi >>> 0;
      lo = ~lo >>> 0;
      if (++lo > 4294967295) {
        lo = 0;
        if (++hi > 4294967295) {
          hi = 0;
        }
      }
    }
    return new LongBits(hi, lo);
  }
  static fromBytes(buf2, offset = 0) {
    const access = accessor(buf2);
    const bits2 = new LongBits();
    let i2 = 0;
    if (buf2.length - offset > 4) {
      for (; i2 < 4; ++i2) {
        bits2.lo = (bits2.lo | (access.get(offset) & 127) << i2 * 7) >>> 0;
        if (access.get(offset++) < 128) {
          return bits2;
        }
      }
      bits2.lo = (bits2.lo | (access.get(offset) & 127) << 28) >>> 0;
      bits2.hi = (bits2.hi | (access.get(offset) & 127) >> 4) >>> 0;
      if (access.get(offset++) < 128) {
        return bits2;
      }
      i2 = 0;
    } else {
      for (; i2 < 4; ++i2) {
        if (offset >= buf2.length) {
          throw RangeError(`index out of range: ${offset} > ${buf2.length}`);
        }
        bits2.lo = (bits2.lo | (access.get(offset) & 127) << i2 * 7) >>> 0;
        if (access.get(offset++) < 128) {
          return bits2;
        }
      }
    }
    if (buf2.length - offset > 4) {
      for (; i2 < 5; ++i2) {
        bits2.hi = (bits2.hi | (access.get(offset) & 127) << i2 * 7 + 3) >>> 0;
        if (access.get(offset++) < 128) {
          return bits2;
        }
      }
    } else if (offset < buf2.byteLength) {
      for (; i2 < 5; ++i2) {
        if (offset >= buf2.length) {
          throw RangeError(`index out of range: ${offset} > ${buf2.length}`);
        }
        bits2.hi = (bits2.hi | (access.get(offset) & 127) << i2 * 7 + 3) >>> 0;
        if (access.get(offset++) < 128) {
          return bits2;
        }
      }
    }
    throw RangeError("invalid varint encoding");
  }
}
const N1$2 = Math.pow(2, 7);
const N2$2 = Math.pow(2, 14);
const N3$2 = Math.pow(2, 21);
const N4$2 = Math.pow(2, 28);
const N5$2 = Math.pow(2, 35);
const N6$2 = Math.pow(2, 42);
const N7$2 = Math.pow(2, 49);
const N8$2 = Math.pow(2, 56);
const N9$2 = Math.pow(2, 63);
const unsigned = {
  encodingLength(value2) {
    if (value2 < N1$2) {
      return 1;
    }
    if (value2 < N2$2) {
      return 2;
    }
    if (value2 < N3$2) {
      return 3;
    }
    if (value2 < N4$2) {
      return 4;
    }
    if (value2 < N5$2) {
      return 5;
    }
    if (value2 < N6$2) {
      return 6;
    }
    if (value2 < N7$2) {
      return 7;
    }
    if (value2 < N8$2) {
      return 8;
    }
    if (value2 < N9$2) {
      return 9;
    }
    return 10;
  },
  encode(value2, buf2, offset = 0) {
    if (Number.MAX_SAFE_INTEGER != null && value2 > Number.MAX_SAFE_INTEGER) {
      throw new RangeError("Could not encode varint");
    }
    if (buf2 == null) {
      buf2 = allocUnsafe$4(unsigned.encodingLength(value2));
    }
    LongBits.fromNumber(value2).toBytes(buf2, offset);
    return buf2;
  },
  decode(buf2, offset = 0) {
    return LongBits.fromBytes(buf2, offset).toNumber(true);
  }
};
class RecordEnvelope {
  constructor(init2) {
    const { peerId, payloadType, payload, signature } = init2;
    this.peerId = peerId;
    this.payloadType = payloadType;
    this.payload = payload;
    this.signature = signature;
  }
  marshal() {
    if (this.peerId.publicKey == null) {
      throw new Error("Missing public key");
    }
    if (this.marshaled == null) {
      this.marshaled = Envelope.encode({
        publicKey: this.peerId.publicKey,
        payloadType: this.payloadType,
        payload: this.payload.subarray(),
        signature: this.signature
      });
    }
    return this.marshaled;
  }
  equals(other) {
    return equals$1(this.marshal(), other.marshal());
  }
  async validate(domain) {
    const signData = formatSignaturePayload(domain, this.payloadType, this.payload);
    if (this.peerId.publicKey == null) {
      throw new Error("Missing public key");
    }
    const key = unmarshalPublicKey(this.peerId.publicKey);
    return await key.verify(signData.subarray(), this.signature);
  }
}
RecordEnvelope.createFromProtobuf = async (data) => {
  const envelopeData = Envelope.decode(data);
  const peerId = await peerIdFromKeys(envelopeData.publicKey);
  return new RecordEnvelope({
    peerId,
    payloadType: envelopeData.payloadType,
    payload: envelopeData.payload,
    signature: envelopeData.signature
  });
};
RecordEnvelope.seal = async (record, peerId) => {
  if (peerId.privateKey == null) {
    throw new Error("Missing private key");
  }
  const domain = record.domain;
  const payloadType = record.codec;
  const payload = record.marshal();
  const signData = formatSignaturePayload(domain, payloadType, payload);
  const key = await unmarshalPrivateKey(peerId.privateKey);
  const signature = await key.sign(signData.subarray());
  return new RecordEnvelope({
    peerId,
    payloadType,
    payload,
    signature
  });
};
RecordEnvelope.openAndCertify = async (data, domain) => {
  const envelope = await RecordEnvelope.createFromProtobuf(data);
  const valid = await envelope.validate(domain);
  if (!valid) {
    throw errCode(new Error("envelope signature is not valid for the given domain"), codes$2.ERR_SIGNATURE_NOT_VALID);
  }
  return envelope;
};
const formatSignaturePayload = (domain, payloadType, payload) => {
  const domainUint8Array = fromString$3(domain);
  const domainLength = unsigned.encode(domainUint8Array.byteLength);
  const payloadTypeLength = unsigned.encode(payloadType.length);
  const payloadLength = unsigned.encode(payload.length);
  return new Uint8ArrayList(domainLength, domainUint8Array, payloadTypeLength, payloadType, payloadLength, payload);
};
function arrayEquals$1(a, b2) {
  const sort2 = (a2, b3) => a2.toString().localeCompare(b3.toString());
  if (a.length !== b2.length) {
    return false;
  }
  b2.sort(sort2);
  return a.sort(sort2).every((item, index) => b2[index].equals(item));
}
var PeerRecord$1;
(function(PeerRecord2) {
  (function(AddressInfo) {
    let _codec2;
    AddressInfo.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (opts.writeDefaults === true || obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.multiaddr);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length3) => {
          const obj = {
            multiaddr: new Uint8Array(0)
          };
          const end2 = length3 == null ? reader2.len : reader2.pos + length3;
          while (reader2.pos < end2) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.multiaddr = reader2.bytes();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    AddressInfo.encode = (obj) => {
      return encodeMessage(obj, AddressInfo.codec());
    };
    AddressInfo.decode = (buf2) => {
      return decodeMessage(buf2, AddressInfo.codec());
    };
  })(PeerRecord2.AddressInfo || (PeerRecord2.AddressInfo = {}));
  let _codec;
  PeerRecord2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (opts.writeDefaults === true || obj.peerId != null && obj.peerId.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.peerId);
        }
        if (opts.writeDefaults === true || obj.seq !== 0n) {
          w.uint32(16);
          w.uint64(obj.seq);
        }
        if (obj.addresses != null) {
          for (const value2 of obj.addresses) {
            w.uint32(26);
            PeerRecord2.AddressInfo.codec().encode(value2, w, {
              writeDefaults: true
            });
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length3) => {
        const obj = {
          peerId: new Uint8Array(0),
          seq: 0n,
          addresses: []
        };
        const end2 = length3 == null ? reader2.len : reader2.pos + length3;
        while (reader2.pos < end2) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.peerId = reader2.bytes();
              break;
            case 2:
              obj.seq = reader2.uint64();
              break;
            case 3:
              obj.addresses.push(PeerRecord2.AddressInfo.codec().decode(reader2, reader2.uint32()));
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PeerRecord2.encode = (obj) => {
    return encodeMessage(obj, PeerRecord2.codec());
  };
  PeerRecord2.decode = (buf2) => {
    return decodeMessage(buf2, PeerRecord2.codec());
  };
})(PeerRecord$1 || (PeerRecord$1 = {}));
const ENVELOPE_DOMAIN_PEER_RECORD = "libp2p-peer-record";
const ENVELOPE_PAYLOAD_TYPE_PEER_RECORD = Uint8Array.from([3, 1]);
class PeerRecord {
  constructor(init2) {
    this.domain = PeerRecord.DOMAIN;
    this.codec = PeerRecord.CODEC;
    const { peerId, multiaddrs, seqNumber } = init2;
    this.peerId = peerId;
    this.multiaddrs = multiaddrs ?? [];
    this.seqNumber = seqNumber ?? BigInt(Date.now());
  }
  marshal() {
    if (this.marshaled == null) {
      this.marshaled = PeerRecord$1.encode({
        peerId: this.peerId.toBytes(),
        seq: BigInt(this.seqNumber),
        addresses: this.multiaddrs.map((m) => ({
          multiaddr: m.bytes
        }))
      });
    }
    return this.marshaled;
  }
  equals(other) {
    if (!(other instanceof PeerRecord)) {
      return false;
    }
    if (!this.peerId.equals(other.peerId)) {
      return false;
    }
    if (this.seqNumber !== other.seqNumber) {
      return false;
    }
    if (!arrayEquals$1(this.multiaddrs, other.multiaddrs)) {
      return false;
    }
    return true;
  }
}
PeerRecord.createFromProtobuf = (buf2) => {
  const peerRecord = PeerRecord$1.decode(buf2);
  const peerId = peerIdFromBytes(peerRecord.peerId);
  const multiaddrs = (peerRecord.addresses ?? []).map((a) => multiaddr(a.multiaddr));
  const seqNumber = peerRecord.seq;
  return new PeerRecord({ peerId, multiaddrs, seqNumber });
};
PeerRecord.DOMAIN = ENVELOPE_DOMAIN_PEER_RECORD;
PeerRecord.CODEC = ENVELOPE_PAYLOAD_TYPE_PEER_RECORD;
const topologySymbol = Symbol.for("@libp2p/topology");
function isTopology(other) {
  return other != null && Boolean(other[topologySymbol]);
}
const noop$2 = () => {
};
class TopologyImpl {
  constructor(init2) {
    this.min = init2.min ?? 0;
    this.max = init2.max ?? Infinity;
    this.peers = /* @__PURE__ */ new Set();
    this.onConnect = init2.onConnect ?? noop$2;
    this.onDisconnect = init2.onDisconnect ?? noop$2;
  }
  get [Symbol.toStringTag]() {
    return topologySymbol.toString();
  }
  get [topologySymbol]() {
    return true;
  }
  async setRegistrar(registrar) {
    this.registrar = registrar;
  }
  disconnect(peerId) {
    this.onDisconnect(peerId);
  }
}
function createTopology(init2) {
  return new TopologyImpl(init2);
}
var __classPrivateFieldGet = globalThis && globalThis.__classPrivateFieldGet || function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _EventEmitter_listeners;
class EventEmitter$1 extends EventTarget {
  constructor() {
    super(...arguments);
    _EventEmitter_listeners.set(this, /* @__PURE__ */ new Map());
  }
  listenerCount(type) {
    const listeners2 = __classPrivateFieldGet(this, _EventEmitter_listeners, "f").get(type);
    if (listeners2 == null) {
      return 0;
    }
    return listeners2.length;
  }
  addEventListener(type, listener, options) {
    super.addEventListener(type, listener, options);
    let list = __classPrivateFieldGet(this, _EventEmitter_listeners, "f").get(type);
    if (list == null) {
      list = [];
      __classPrivateFieldGet(this, _EventEmitter_listeners, "f").set(type, list);
    }
    list.push({
      callback: listener,
      once: (options !== true && options !== false && options?.once) ?? false
    });
  }
  removeEventListener(type, listener, options) {
    super.removeEventListener(type.toString(), listener ?? null, options);
    let list = __classPrivateFieldGet(this, _EventEmitter_listeners, "f").get(type);
    if (list == null) {
      return;
    }
    list = list.filter(({ callback }) => callback !== listener);
    __classPrivateFieldGet(this, _EventEmitter_listeners, "f").set(type, list);
  }
  dispatchEvent(event) {
    const result = super.dispatchEvent(event);
    let list = __classPrivateFieldGet(this, _EventEmitter_listeners, "f").get(event.type);
    if (list == null) {
      return result;
    }
    list = list.filter(({ once: once3 }) => !once3);
    __classPrivateFieldGet(this, _EventEmitter_listeners, "f").set(event.type, list);
    return result;
  }
}
_EventEmitter_listeners = /* @__PURE__ */ new WeakMap();
class CustomEventPolyfill extends Event {
  constructor(message2, data) {
    super(message2, data);
    this.detail = data?.detail;
  }
}
const CustomEvent = globalThis.CustomEvent ?? CustomEventPolyfill;
class MessageCache {
  constructor(gossip, historyCapacity, msgIdToStrFn) {
    this.gossip = gossip;
    this.msgs = /* @__PURE__ */ new Map();
    this.history = [];
    this.msgIdToStrFn = msgIdToStrFn;
    for (let i2 = 0; i2 < historyCapacity; i2++) {
      this.history[i2] = [];
    }
  }
  get size() {
    return this.msgs.size;
  }
  put(messageId, msg, validated = false) {
    const { msgIdStr } = messageId;
    if (this.msgs.has(msgIdStr)) {
      return false;
    }
    this.msgs.set(msgIdStr, {
      message: msg,
      validated,
      originatingPeers: /* @__PURE__ */ new Set(),
      iwantCounts: /* @__PURE__ */ new Map()
    });
    this.history[0].push({ ...messageId, topic: msg.topic });
    return true;
  }
  observeDuplicate(msgId2, fromPeerIdStr) {
    const entry = this.msgs.get(msgId2);
    if (entry && !entry.validated) {
      entry.originatingPeers.add(fromPeerIdStr);
    }
  }
  get(msgId2) {
    return this.msgs.get(this.msgIdToStrFn(msgId2))?.message;
  }
  getWithIWantCount(msgIdStr, p) {
    const msg = this.msgs.get(msgIdStr);
    if (!msg) {
      return null;
    }
    const count = (msg.iwantCounts.get(p) ?? 0) + 1;
    msg.iwantCounts.set(p, count);
    return { msg: msg.message, count };
  }
  getGossipIDs(topics) {
    const msgIdsByTopic = /* @__PURE__ */ new Map();
    for (let i2 = 0; i2 < this.gossip; i2++) {
      this.history[i2].forEach((entry) => {
        const msg = this.msgs.get(entry.msgIdStr);
        if (msg && msg.validated && topics.has(entry.topic)) {
          let msgIds = msgIdsByTopic.get(entry.topic);
          if (!msgIds) {
            msgIds = [];
            msgIdsByTopic.set(entry.topic, msgIds);
          }
          msgIds.push(entry.msgId);
        }
      });
    }
    return msgIdsByTopic;
  }
  validate(msgId2) {
    const entry = this.msgs.get(msgId2);
    if (!entry) {
      return null;
    }
    const { message: message2, originatingPeers } = entry;
    entry.validated = true;
    entry.originatingPeers = /* @__PURE__ */ new Set();
    return { message: message2, originatingPeers };
  }
  shift() {
    const last2 = this.history[this.history.length - 1];
    last2.forEach((entry) => {
      this.msgs.delete(entry.msgIdStr);
    });
    this.history.pop();
    this.history.unshift([]);
  }
  remove(msgId2) {
    const entry = this.msgs.get(msgId2);
    if (!entry) {
      return null;
    }
    this.msgs.delete(msgId2);
    return entry;
  }
}
var rpc$1 = { exports: {} };
var minimal$1 = { exports: {} };
var indexMinimal = {};
var minimal = {};
var longbits;
var hasRequiredLongbits;
function requireLongbits() {
  if (hasRequiredLongbits)
    return longbits;
  hasRequiredLongbits = 1;
  longbits = LongBits2;
  var util2 = requireMinimal$1();
  function LongBits2(lo, hi) {
    this.lo = lo >>> 0;
    this.hi = hi >>> 0;
  }
  var zero2 = LongBits2.zero = new LongBits2(0, 0);
  zero2.toNumber = function() {
    return 0;
  };
  zero2.zzEncode = zero2.zzDecode = function() {
    return this;
  };
  zero2.length = function() {
    return 1;
  };
  var zeroHash = LongBits2.zeroHash = "\0\0\0\0\0\0\0\0";
  LongBits2.fromNumber = function fromNumber(value2) {
    if (value2 === 0)
      return zero2;
    var sign2 = value2 < 0;
    if (sign2)
      value2 = -value2;
    var lo = value2 >>> 0, hi = (value2 - lo) / 4294967296 >>> 0;
    if (sign2) {
      hi = ~hi >>> 0;
      lo = ~lo >>> 0;
      if (++lo > 4294967295) {
        lo = 0;
        if (++hi > 4294967295)
          hi = 0;
      }
    }
    return new LongBits2(lo, hi);
  };
  LongBits2.from = function from2(value2) {
    if (typeof value2 === "number")
      return LongBits2.fromNumber(value2);
    if (util2.isString(value2)) {
      if (util2.Long)
        value2 = util2.Long.fromString(value2);
      else
        return LongBits2.fromNumber(parseInt(value2, 10));
    }
    return value2.low || value2.high ? new LongBits2(value2.low >>> 0, value2.high >>> 0) : zero2;
  };
  LongBits2.prototype.toNumber = function toNumber(unsigned2) {
    if (!unsigned2 && this.hi >>> 31) {
      var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
      if (!lo)
        hi = hi + 1 >>> 0;
      return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  };
  LongBits2.prototype.toLong = function toLong(unsigned2) {
    return util2.Long ? new util2.Long(this.lo | 0, this.hi | 0, Boolean(unsigned2)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned2) };
  };
  var charCodeAt = String.prototype.charCodeAt;
  LongBits2.fromHash = function fromHash(hash2) {
    if (hash2 === zeroHash)
      return zero2;
    return new LongBits2(
      (charCodeAt.call(hash2, 0) | charCodeAt.call(hash2, 1) << 8 | charCodeAt.call(hash2, 2) << 16 | charCodeAt.call(hash2, 3) << 24) >>> 0,
      (charCodeAt.call(hash2, 4) | charCodeAt.call(hash2, 5) << 8 | charCodeAt.call(hash2, 6) << 16 | charCodeAt.call(hash2, 7) << 24) >>> 0
    );
  };
  LongBits2.prototype.toHash = function toHash() {
    return String.fromCharCode(
      this.lo & 255,
      this.lo >>> 8 & 255,
      this.lo >>> 16 & 255,
      this.lo >>> 24,
      this.hi & 255,
      this.hi >>> 8 & 255,
      this.hi >>> 16 & 255,
      this.hi >>> 24
    );
  };
  LongBits2.prototype.zzEncode = function zzEncode() {
    var mask = this.hi >> 31;
    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo = (this.lo << 1 ^ mask) >>> 0;
    return this;
  };
  LongBits2.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi = (this.hi >>> 1 ^ mask) >>> 0;
    return this;
  };
  LongBits2.prototype.length = function length3() {
    var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
  };
  return longbits;
}
var hasRequiredMinimal$1;
function requireMinimal$1() {
  if (hasRequiredMinimal$1)
    return minimal;
  hasRequiredMinimal$1 = 1;
  (function(exports) {
    var util2 = exports;
    util2.asPromise = aspromise;
    util2.base64 = base64$3;
    util2.EventEmitter = eventemitter;
    util2.float = float;
    util2.inquire = inquire_1;
    util2.utf8 = utf8$2;
    util2.pool = pool_1;
    util2.LongBits = requireLongbits();
    util2.isNode = Boolean(typeof globalThis !== "undefined" && globalThis && globalThis.process && globalThis.process.versions && globalThis.process.versions.node);
    util2.global = util2.isNode && globalThis || typeof window !== "undefined" && window || typeof self !== "undefined" && self || commonjsGlobal;
    util2.emptyArray = Object.freeze ? Object.freeze([]) : [];
    util2.emptyObject = Object.freeze ? Object.freeze({}) : {};
    util2.isInteger = Number.isInteger || function isInteger(value2) {
      return typeof value2 === "number" && isFinite(value2) && Math.floor(value2) === value2;
    };
    util2.isString = function isString2(value2) {
      return typeof value2 === "string" || value2 instanceof String;
    };
    util2.isObject = function isObject(value2) {
      return value2 && typeof value2 === "object";
    };
    util2.isset = util2.isSet = function isSet(obj, prop) {
      var value2 = obj[prop];
      if (value2 != null && obj.hasOwnProperty(prop))
        return typeof value2 !== "object" || (Array.isArray(value2) ? value2.length : Object.keys(value2).length) > 0;
      return false;
    };
    util2.Buffer = function() {
      try {
        var Buffer2 = util2.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : null;
      } catch (e) {
        return null;
      }
    }();
    util2._Buffer_from = null;
    util2._Buffer_allocUnsafe = null;
    util2.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util2.Buffer ? util2._Buffer_allocUnsafe(sizeOrArray) : new util2.Array(sizeOrArray) : util2.Buffer ? util2._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util2.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util2.Long = util2.global.dcodeIO && util2.global.dcodeIO.Long || util2.global.Long || util2.inquire("long");
    util2.key2Re = /^true|false|0|1$/;
    util2.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util2.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util2.longToHash = function longToHash(value2) {
      return value2 ? util2.LongBits.from(value2).toHash() : util2.LongBits.zeroHash;
    };
    util2.longFromHash = function longFromHash(hash2, unsigned2) {
      var bits2 = util2.LongBits.fromHash(hash2);
      if (util2.Long)
        return util2.Long.fromBits(bits2.lo, bits2.hi, unsigned2);
      return bits2.toNumber(Boolean(unsigned2));
    };
    function merge2(dst, src2, ifNotSet) {
      for (var keys = Object.keys(src2), i2 = 0; i2 < keys.length; ++i2)
        if (dst[keys[i2]] === void 0 || !ifNotSet)
          dst[keys[i2]] = src2[keys[i2]];
      return dst;
    }
    util2.merge = merge2;
    util2.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name2) {
      function CustomError(message2, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message2, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message2;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge2(this, properties);
      }
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: function() {
        return name2;
      } });
      CustomError.prototype.toString = function toString2() {
        return this.name + ": " + this.message;
      };
      return CustomError;
    }
    util2.newError = newError;
    util2.ProtocolError = newError("ProtocolError");
    util2.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i2 = 0; i2 < fieldNames.length; ++i2)
        fieldMap[fieldNames[i2]] = 1;
      return function() {
        for (var keys = Object.keys(this), i3 = keys.length - 1; i3 > -1; --i3)
          if (fieldMap[keys[i3]] === 1 && this[keys[i3]] !== void 0 && this[keys[i3]] !== null)
            return keys[i3];
      };
    };
    util2.oneOfSetter = function setOneOf(fieldNames) {
      return function(name2) {
        for (var i2 = 0; i2 < fieldNames.length; ++i2)
          if (fieldNames[i2] !== name2)
            delete this[fieldNames[i2]];
      };
    };
    util2.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util2._configure = function() {
      var Buffer2 = util2.Buffer;
      if (!Buffer2) {
        util2._Buffer_from = util2._Buffer_allocUnsafe = null;
        return;
      }
      util2._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || function Buffer_from(value2, encoding2) {
        return new Buffer2(value2, encoding2);
      };
      util2._Buffer_allocUnsafe = Buffer2.allocUnsafe || function Buffer_allocUnsafe(size2) {
        return new Buffer2(size2);
      };
    };
  })(minimal);
  return minimal;
}
var writer;
var hasRequiredWriter;
function requireWriter() {
  if (hasRequiredWriter)
    return writer;
  hasRequiredWriter = 1;
  writer = Writer2;
  var util2 = requireMinimal$1();
  var BufferWriter2;
  var LongBits2 = util2.LongBits, base642 = util2.base64, utf82 = util2.utf8;
  function Op2(fn, len2, val) {
    this.fn = fn;
    this.len = len2;
    this.next = void 0;
    this.val = val;
  }
  function noop2() {
  }
  function State2(writer2) {
    this.head = writer2.head;
    this.tail = writer2.tail;
    this.len = writer2.len;
    this.next = writer2.states;
  }
  function Writer2() {
    this.len = 0;
    this.head = new Op2(noop2, 0, 0);
    this.tail = this.head;
    this.states = null;
  }
  var create4 = function create5() {
    return util2.Buffer ? function create_buffer_setup() {
      return (Writer2.create = function create_buffer() {
        return new BufferWriter2();
      })();
    } : function create_array3() {
      return new Writer2();
    };
  };
  Writer2.create = create4();
  Writer2.alloc = function alloc3(size2) {
    return new util2.Array(size2);
  };
  if (util2.Array !== Array)
    Writer2.alloc = util2.pool(Writer2.alloc, util2.Array.prototype.subarray);
  Writer2.prototype._push = function push3(fn, len2, val) {
    this.tail = this.tail.next = new Op2(fn, len2, val);
    this.len += len2;
    return this;
  };
  function writeByte2(val, buf2, pos) {
    buf2[pos] = val & 255;
  }
  function writeVarint322(val, buf2, pos) {
    while (val > 127) {
      buf2[pos++] = val & 127 | 128;
      val >>>= 7;
    }
    buf2[pos] = val;
  }
  function VarintOp2(len2, val) {
    this.len = len2;
    this.next = void 0;
    this.val = val;
  }
  VarintOp2.prototype = Object.create(Op2.prototype);
  VarintOp2.prototype.fn = writeVarint322;
  Writer2.prototype.uint32 = function write_uint322(value2) {
    this.len += (this.tail = this.tail.next = new VarintOp2(
      (value2 = value2 >>> 0) < 128 ? 1 : value2 < 16384 ? 2 : value2 < 2097152 ? 3 : value2 < 268435456 ? 4 : 5,
      value2
    )).len;
    return this;
  };
  Writer2.prototype.int32 = function write_int322(value2) {
    return value2 < 0 ? this._push(writeVarint642, 10, LongBits2.fromNumber(value2)) : this.uint32(value2);
  };
  Writer2.prototype.sint32 = function write_sint322(value2) {
    return this.uint32((value2 << 1 ^ value2 >> 31) >>> 0);
  };
  function writeVarint642(val, buf2, pos) {
    while (val.hi) {
      buf2[pos++] = val.lo & 127 | 128;
      val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
      val.hi >>>= 7;
    }
    while (val.lo > 127) {
      buf2[pos++] = val.lo & 127 | 128;
      val.lo = val.lo >>> 7;
    }
    buf2[pos++] = val.lo;
  }
  Writer2.prototype.uint64 = function write_uint642(value2) {
    var bits2 = LongBits2.from(value2);
    return this._push(writeVarint642, bits2.length(), bits2);
  };
  Writer2.prototype.int64 = Writer2.prototype.uint64;
  Writer2.prototype.sint64 = function write_sint642(value2) {
    var bits2 = LongBits2.from(value2).zzEncode();
    return this._push(writeVarint642, bits2.length(), bits2);
  };
  Writer2.prototype.bool = function write_bool2(value2) {
    return this._push(writeByte2, 1, value2 ? 1 : 0);
  };
  function writeFixed322(val, buf2, pos) {
    buf2[pos] = val & 255;
    buf2[pos + 1] = val >>> 8 & 255;
    buf2[pos + 2] = val >>> 16 & 255;
    buf2[pos + 3] = val >>> 24;
  }
  Writer2.prototype.fixed32 = function write_fixed322(value2) {
    return this._push(writeFixed322, 4, value2 >>> 0);
  };
  Writer2.prototype.sfixed32 = Writer2.prototype.fixed32;
  Writer2.prototype.fixed64 = function write_fixed642(value2) {
    var bits2 = LongBits2.from(value2);
    return this._push(writeFixed322, 4, bits2.lo)._push(writeFixed322, 4, bits2.hi);
  };
  Writer2.prototype.sfixed64 = Writer2.prototype.fixed64;
  Writer2.prototype.float = function write_float2(value2) {
    return this._push(util2.float.writeFloatLE, 4, value2);
  };
  Writer2.prototype.double = function write_double2(value2) {
    return this._push(util2.float.writeDoubleLE, 8, value2);
  };
  var writeBytes2 = util2.Array.prototype.set ? function writeBytes_set2(val, buf2, pos) {
    buf2.set(val, pos);
  } : function writeBytes_for2(val, buf2, pos) {
    for (var i2 = 0; i2 < val.length; ++i2)
      buf2[pos + i2] = val[i2];
  };
  Writer2.prototype.bytes = function write_bytes2(value2) {
    var len2 = value2.length >>> 0;
    if (!len2)
      return this._push(writeByte2, 1, 0);
    if (util2.isString(value2)) {
      var buf2 = Writer2.alloc(len2 = base642.length(value2));
      base642.decode(value2, buf2, 0);
      value2 = buf2;
    }
    return this.uint32(len2)._push(writeBytes2, len2, value2);
  };
  Writer2.prototype.string = function write_string2(value2) {
    var len2 = utf82.length(value2);
    return len2 ? this.uint32(len2)._push(utf82.write, len2, value2) : this._push(writeByte2, 1, 0);
  };
  Writer2.prototype.fork = function fork2() {
    this.states = new State2(this);
    this.head = this.tail = new Op2(noop2, 0, 0);
    this.len = 0;
    return this;
  };
  Writer2.prototype.reset = function reset2() {
    if (this.states) {
      this.head = this.states.head;
      this.tail = this.states.tail;
      this.len = this.states.len;
      this.states = this.states.next;
    } else {
      this.head = this.tail = new Op2(noop2, 0, 0);
      this.len = 0;
    }
    return this;
  };
  Writer2.prototype.ldelim = function ldelim2() {
    var head = this.head, tail = this.tail, len2 = this.len;
    this.reset().uint32(len2);
    if (len2) {
      this.tail.next = head.next;
      this.tail = tail;
      this.len += len2;
    }
    return this;
  };
  Writer2.prototype.finish = function finish2() {
    var head = this.head.next, buf2 = this.constructor.alloc(this.len), pos = 0;
    while (head) {
      head.fn(head.val, buf2, pos);
      pos += head.len;
      head = head.next;
    }
    return buf2;
  };
  Writer2._configure = function(BufferWriter_) {
    BufferWriter2 = BufferWriter_;
    Writer2.create = create4();
    BufferWriter2._configure();
  };
  return writer;
}
var writer_buffer;
var hasRequiredWriter_buffer;
function requireWriter_buffer() {
  if (hasRequiredWriter_buffer)
    return writer_buffer;
  hasRequiredWriter_buffer = 1;
  writer_buffer = BufferWriter2;
  var Writer2 = requireWriter();
  (BufferWriter2.prototype = Object.create(Writer2.prototype)).constructor = BufferWriter2;
  var util2 = requireMinimal$1();
  function BufferWriter2() {
    Writer2.call(this);
  }
  BufferWriter2._configure = function() {
    BufferWriter2.alloc = util2._Buffer_allocUnsafe;
    BufferWriter2.writeBytesBuffer = util2.Buffer && util2.Buffer.prototype instanceof Uint8Array && util2.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf2, pos) {
      buf2.set(val, pos);
    } : function writeBytesBuffer_copy(val, buf2, pos) {
      if (val.copy)
        val.copy(buf2, pos, 0, val.length);
      else
        for (var i2 = 0; i2 < val.length; )
          buf2[pos++] = val[i2++];
    };
  };
  BufferWriter2.prototype.bytes = function write_bytes_buffer2(value2) {
    if (util2.isString(value2))
      value2 = util2._Buffer_from(value2, "base64");
    var len2 = value2.length >>> 0;
    this.uint32(len2);
    if (len2)
      this._push(BufferWriter2.writeBytesBuffer, len2, value2);
    return this;
  };
  function writeStringBuffer2(val, buf2, pos) {
    if (val.length < 40)
      util2.utf8.write(val, buf2, pos);
    else if (buf2.utf8Write)
      buf2.utf8Write(val, pos);
    else
      buf2.write(val, pos);
  }
  BufferWriter2.prototype.string = function write_string_buffer2(value2) {
    var len2 = util2.Buffer.byteLength(value2);
    this.uint32(len2);
    if (len2)
      this._push(writeStringBuffer2, len2, value2);
    return this;
  };
  BufferWriter2._configure();
  return writer_buffer;
}
var reader;
var hasRequiredReader;
function requireReader() {
  if (hasRequiredReader)
    return reader;
  hasRequiredReader = 1;
  reader = Reader2;
  var util2 = requireMinimal$1();
  var BufferReader2;
  var LongBits2 = util2.LongBits, utf82 = util2.utf8;
  function indexOutOfRange2(reader2, writeLength) {
    return RangeError("index out of range: " + reader2.pos + " + " + (writeLength || 1) + " > " + reader2.len);
  }
  function Reader2(buffer2) {
    this.buf = buffer2;
    this.pos = 0;
    this.len = buffer2.length;
  }
  var create_array3 = typeof Uint8Array !== "undefined" ? function create_typed_array2(buffer2) {
    if (buffer2 instanceof Uint8Array || Array.isArray(buffer2))
      return new Reader2(buffer2);
    throw Error("illegal buffer");
  } : function create_array4(buffer2) {
    if (Array.isArray(buffer2))
      return new Reader2(buffer2);
    throw Error("illegal buffer");
  };
  var create4 = function create5() {
    return util2.Buffer ? function create_buffer_setup(buffer2) {
      return (Reader2.create = function create_buffer(buffer3) {
        return util2.Buffer.isBuffer(buffer3) ? new BufferReader2(buffer3) : create_array3(buffer3);
      })(buffer2);
    } : create_array3;
  };
  Reader2.create = create4();
  Reader2.prototype._slice = util2.Array.prototype.subarray || util2.Array.prototype.slice;
  Reader2.prototype.uint32 = function read_uint32_setup2() {
    var value2 = 4294967295;
    return function read_uint32() {
      value2 = (this.buf[this.pos] & 127) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value2;
      value2 = (value2 | (this.buf[this.pos] & 127) << 7) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value2;
      value2 = (value2 | (this.buf[this.pos] & 127) << 14) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value2;
      value2 = (value2 | (this.buf[this.pos] & 127) << 21) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value2;
      value2 = (value2 | (this.buf[this.pos] & 15) << 28) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value2;
      if ((this.pos += 5) > this.len) {
        this.pos = this.len;
        throw indexOutOfRange2(this, 10);
      }
      return value2;
    };
  }();
  Reader2.prototype.int32 = function read_int322() {
    return this.uint32() | 0;
  };
  Reader2.prototype.sint32 = function read_sint322() {
    var value2 = this.uint32();
    return value2 >>> 1 ^ -(value2 & 1) | 0;
  };
  function readLongVarint2() {
    var bits2 = new LongBits2(0, 0);
    var i2 = 0;
    if (this.len - this.pos > 4) {
      for (; i2 < 4; ++i2) {
        bits2.lo = (bits2.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits2;
      }
      bits2.lo = (bits2.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
      bits2.hi = (bits2.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits2;
      i2 = 0;
    } else {
      for (; i2 < 3; ++i2) {
        if (this.pos >= this.len)
          throw indexOutOfRange2(this);
        bits2.lo = (bits2.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits2;
      }
      bits2.lo = (bits2.lo | (this.buf[this.pos++] & 127) << i2 * 7) >>> 0;
      return bits2;
    }
    if (this.len - this.pos > 4) {
      for (; i2 < 5; ++i2) {
        bits2.hi = (bits2.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits2;
      }
    } else {
      for (; i2 < 5; ++i2) {
        if (this.pos >= this.len)
          throw indexOutOfRange2(this);
        bits2.hi = (bits2.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits2;
      }
    }
    throw Error("invalid varint encoding");
  }
  Reader2.prototype.bool = function read_bool2() {
    return this.uint32() !== 0;
  };
  function readFixed32_end2(buf2, end2) {
    return (buf2[end2 - 4] | buf2[end2 - 3] << 8 | buf2[end2 - 2] << 16 | buf2[end2 - 1] << 24) >>> 0;
  }
  Reader2.prototype.fixed32 = function read_fixed322() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange2(this, 4);
    return readFixed32_end2(this.buf, this.pos += 4);
  };
  Reader2.prototype.sfixed32 = function read_sfixed322() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange2(this, 4);
    return readFixed32_end2(this.buf, this.pos += 4) | 0;
  };
  function readFixed642() {
    if (this.pos + 8 > this.len)
      throw indexOutOfRange2(this, 8);
    return new LongBits2(readFixed32_end2(this.buf, this.pos += 4), readFixed32_end2(this.buf, this.pos += 4));
  }
  Reader2.prototype.float = function read_float2() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange2(this, 4);
    var value2 = util2.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value2;
  };
  Reader2.prototype.double = function read_double2() {
    if (this.pos + 8 > this.len)
      throw indexOutOfRange2(this, 4);
    var value2 = util2.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value2;
  };
  Reader2.prototype.bytes = function read_bytes2() {
    var length3 = this.uint32(), start = this.pos, end2 = this.pos + length3;
    if (end2 > this.len)
      throw indexOutOfRange2(this, length3);
    this.pos += length3;
    if (Array.isArray(this.buf))
      return this.buf.slice(start, end2);
    return start === end2 ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end2);
  };
  Reader2.prototype.string = function read_string2() {
    var bytes2 = this.bytes();
    return utf82.read(bytes2, 0, bytes2.length);
  };
  Reader2.prototype.skip = function skip2(length3) {
    if (typeof length3 === "number") {
      if (this.pos + length3 > this.len)
        throw indexOutOfRange2(this, length3);
      this.pos += length3;
    } else {
      do {
        if (this.pos >= this.len)
          throw indexOutOfRange2(this);
      } while (this.buf[this.pos++] & 128);
    }
    return this;
  };
  Reader2.prototype.skipType = function(wireType) {
    switch (wireType) {
      case 0:
        this.skip();
        break;
      case 1:
        this.skip(8);
        break;
      case 2:
        this.skip(this.uint32());
        break;
      case 3:
        while ((wireType = this.uint32() & 7) !== 4) {
          this.skipType(wireType);
        }
        break;
      case 5:
        this.skip(4);
        break;
      default:
        throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
  };
  Reader2._configure = function(BufferReader_) {
    BufferReader2 = BufferReader_;
    Reader2.create = create4();
    BufferReader2._configure();
    var fn = util2.Long ? "toLong" : "toNumber";
    util2.merge(Reader2.prototype, {
      int64: function read_int64() {
        return readLongVarint2.call(this)[fn](false);
      },
      uint64: function read_uint64() {
        return readLongVarint2.call(this)[fn](true);
      },
      sint64: function read_sint64() {
        return readLongVarint2.call(this).zzDecode()[fn](false);
      },
      fixed64: function read_fixed64() {
        return readFixed642.call(this)[fn](true);
      },
      sfixed64: function read_sfixed64() {
        return readFixed642.call(this)[fn](false);
      }
    });
  };
  return reader;
}
var reader_buffer;
var hasRequiredReader_buffer;
function requireReader_buffer() {
  if (hasRequiredReader_buffer)
    return reader_buffer;
  hasRequiredReader_buffer = 1;
  reader_buffer = BufferReader2;
  var Reader2 = requireReader();
  (BufferReader2.prototype = Object.create(Reader2.prototype)).constructor = BufferReader2;
  var util2 = requireMinimal$1();
  function BufferReader2(buffer2) {
    Reader2.call(this, buffer2);
  }
  BufferReader2._configure = function() {
    if (util2.Buffer)
      BufferReader2.prototype._slice = util2.Buffer.prototype.slice;
  };
  BufferReader2.prototype.string = function read_string_buffer2() {
    var len2 = this.uint32();
    return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len2, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len2, this.len));
  };
  BufferReader2._configure();
  return reader_buffer;
}
var rpc = {};
var service;
var hasRequiredService;
function requireService() {
  if (hasRequiredService)
    return service;
  hasRequiredService = 1;
  service = Service2;
  var util2 = requireMinimal$1();
  (Service2.prototype = Object.create(util2.EventEmitter.prototype)).constructor = Service2;
  function Service2(rpcImpl, requestDelimited, responseDelimited) {
    if (typeof rpcImpl !== "function")
      throw TypeError("rpcImpl must be a function");
    util2.EventEmitter.call(this);
    this.rpcImpl = rpcImpl;
    this.requestDelimited = Boolean(requestDelimited);
    this.responseDelimited = Boolean(responseDelimited);
  }
  Service2.prototype.rpcCall = function rpcCall2(method, requestCtor, responseCtor, request2, callback) {
    if (!request2)
      throw TypeError("request must be specified");
    var self2 = this;
    if (!callback)
      return util2.asPromise(rpcCall2, self2, method, requestCtor, responseCtor, request2);
    if (!self2.rpcImpl) {
      setTimeout(function() {
        callback(Error("already ended"));
      }, 0);
      return void 0;
    }
    try {
      return self2.rpcImpl(
        method,
        requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request2).finish(),
        function rpcCallback(err2, response) {
          if (err2) {
            self2.emit("error", err2, method);
            return callback(err2);
          }
          if (response === null) {
            self2.end(true);
            return void 0;
          }
          if (!(response instanceof responseCtor)) {
            try {
              response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
            } catch (err3) {
              self2.emit("error", err3, method);
              return callback(err3);
            }
          }
          self2.emit("data", response, method);
          return callback(null, response);
        }
      );
    } catch (err2) {
      self2.emit("error", err2, method);
      setTimeout(function() {
        callback(err2);
      }, 0);
      return void 0;
    }
  };
  Service2.prototype.end = function end2(endedByRPC) {
    if (this.rpcImpl) {
      if (!endedByRPC)
        this.rpcImpl(null, null, null);
      this.rpcImpl = null;
      this.emit("end").off();
    }
    return this;
  };
  return service;
}
var hasRequiredRpc;
function requireRpc() {
  if (hasRequiredRpc)
    return rpc;
  hasRequiredRpc = 1;
  (function(exports) {
    var rpc2 = exports;
    rpc2.Service = requireService();
  })(rpc);
  return rpc;
}
var roots;
var hasRequiredRoots;
function requireRoots() {
  if (hasRequiredRoots)
    return roots;
  hasRequiredRoots = 1;
  roots = {};
  return roots;
}
var hasRequiredIndexMinimal;
function requireIndexMinimal() {
  if (hasRequiredIndexMinimal)
    return indexMinimal;
  hasRequiredIndexMinimal = 1;
  (function(exports) {
    var protobuf = exports;
    protobuf.build = "minimal";
    protobuf.Writer = requireWriter();
    protobuf.BufferWriter = requireWriter_buffer();
    protobuf.Reader = requireReader();
    protobuf.BufferReader = requireReader_buffer();
    protobuf.util = requireMinimal$1();
    protobuf.rpc = requireRpc();
    protobuf.roots = requireRoots();
    protobuf.configure = configure2;
    function configure2() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure2();
  })(indexMinimal);
  return indexMinimal;
}
var hasRequiredMinimal;
function requireMinimal() {
  if (hasRequiredMinimal)
    return minimal$1.exports;
  hasRequiredMinimal = 1;
  (function(module) {
    module.exports = requireIndexMinimal();
  })(minimal$1);
  return minimal$1.exports;
}
(function(module) {
  (function(globalThis2, factory2) {
    if (typeof commonjsRequire === "function" && true && module && module.exports)
      module.exports = factory2(requireMinimal());
  })(commonjsGlobal, function($protobuf2) {
    var $Reader2 = $protobuf2.Reader, $Writer2 = $protobuf2.Writer, $util2 = $protobuf2.util;
    var $root2 = $protobuf2.roots["default"] || ($protobuf2.roots["default"] = {});
    $root2.RPC = function() {
      function RPC2(p) {
        this.subscriptions = [];
        this.messages = [];
        if (p) {
          for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
            if (p[ks[i2]] != null)
              this[ks[i2]] = p[ks[i2]];
        }
      }
      RPC2.prototype.subscriptions = $util2.emptyArray;
      RPC2.prototype.messages = $util2.emptyArray;
      RPC2.prototype.control = null;
      var $oneOfFields;
      Object.defineProperty(RPC2.prototype, "_control", {
        get: $util2.oneOfGetter($oneOfFields = ["control"]),
        set: $util2.oneOfSetter($oneOfFields)
      });
      RPC2.encode = function encode3(m, w) {
        if (!w)
          w = $Writer2.create();
        if (m.subscriptions != null && m.subscriptions.length) {
          for (var i2 = 0; i2 < m.subscriptions.length; ++i2)
            $root2.RPC.SubOpts.encode(m.subscriptions[i2], w.uint32(10).fork()).ldelim();
        }
        if (m.messages != null && m.messages.length) {
          for (var i2 = 0; i2 < m.messages.length; ++i2)
            $root2.RPC.Message.encode(m.messages[i2], w.uint32(18).fork()).ldelim();
        }
        if (m.control != null && Object.hasOwnProperty.call(m, "control"))
          $root2.RPC.ControlMessage.encode(m.control, w.uint32(26).fork()).ldelim();
        return w;
      };
      RPC2.decode = function decode3(r, l) {
        if (!(r instanceof $Reader2))
          r = $Reader2.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root2.RPC();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              if (!(m.subscriptions && m.subscriptions.length))
                m.subscriptions = [];
              m.subscriptions.push($root2.RPC.SubOpts.decode(r, r.uint32()));
              break;
            case 2:
              if (!(m.messages && m.messages.length))
                m.messages = [];
              m.messages.push($root2.RPC.Message.decode(r, r.uint32()));
              break;
            case 3:
              m.control = $root2.RPC.ControlMessage.decode(r, r.uint32());
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      RPC2.fromObject = function fromObject(d) {
        if (d instanceof $root2.RPC)
          return d;
        var m = new $root2.RPC();
        if (d.subscriptions) {
          if (!Array.isArray(d.subscriptions))
            throw TypeError(".RPC.subscriptions: array expected");
          m.subscriptions = [];
          for (var i2 = 0; i2 < d.subscriptions.length; ++i2) {
            if (typeof d.subscriptions[i2] !== "object")
              throw TypeError(".RPC.subscriptions: object expected");
            m.subscriptions[i2] = $root2.RPC.SubOpts.fromObject(d.subscriptions[i2]);
          }
        }
        if (d.messages) {
          if (!Array.isArray(d.messages))
            throw TypeError(".RPC.messages: array expected");
          m.messages = [];
          for (var i2 = 0; i2 < d.messages.length; ++i2) {
            if (typeof d.messages[i2] !== "object")
              throw TypeError(".RPC.messages: object expected");
            m.messages[i2] = $root2.RPC.Message.fromObject(d.messages[i2]);
          }
        }
        if (d.control != null) {
          if (typeof d.control !== "object")
            throw TypeError(".RPC.control: object expected");
          m.control = $root2.RPC.ControlMessage.fromObject(d.control);
        }
        return m;
      };
      RPC2.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.arrays || o.defaults) {
          d.subscriptions = [];
          d.messages = [];
        }
        if (m.subscriptions && m.subscriptions.length) {
          d.subscriptions = [];
          for (var j = 0; j < m.subscriptions.length; ++j) {
            d.subscriptions[j] = $root2.RPC.SubOpts.toObject(m.subscriptions[j], o);
          }
        }
        if (m.messages && m.messages.length) {
          d.messages = [];
          for (var j = 0; j < m.messages.length; ++j) {
            d.messages[j] = $root2.RPC.Message.toObject(m.messages[j], o);
          }
        }
        if (m.control != null && m.hasOwnProperty("control")) {
          d.control = $root2.RPC.ControlMessage.toObject(m.control, o);
          if (o.oneofs)
            d._control = "control";
        }
        return d;
      };
      RPC2.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
      };
      RPC2.SubOpts = function() {
        function SubOpts(p) {
          if (p) {
            for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
              if (p[ks[i2]] != null)
                this[ks[i2]] = p[ks[i2]];
          }
        }
        SubOpts.prototype.subscribe = null;
        SubOpts.prototype.topic = null;
        var $oneOfFields2;
        Object.defineProperty(SubOpts.prototype, "_subscribe", {
          get: $util2.oneOfGetter($oneOfFields2 = ["subscribe"]),
          set: $util2.oneOfSetter($oneOfFields2)
        });
        Object.defineProperty(SubOpts.prototype, "_topic", {
          get: $util2.oneOfGetter($oneOfFields2 = ["topic"]),
          set: $util2.oneOfSetter($oneOfFields2)
        });
        SubOpts.encode = function encode3(m, w) {
          if (!w)
            w = $Writer2.create();
          if (m.subscribe != null && Object.hasOwnProperty.call(m, "subscribe"))
            w.uint32(8).bool(m.subscribe);
          if (m.topic != null && Object.hasOwnProperty.call(m, "topic"))
            w.uint32(18).string(m.topic);
          return w;
        };
        SubOpts.decode = function decode3(r, l) {
          if (!(r instanceof $Reader2))
            r = $Reader2.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root2.RPC.SubOpts();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                m.subscribe = r.bool();
                break;
              case 2:
                m.topic = r.string();
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          return m;
        };
        SubOpts.fromObject = function fromObject(d) {
          if (d instanceof $root2.RPC.SubOpts)
            return d;
          var m = new $root2.RPC.SubOpts();
          if (d.subscribe != null) {
            m.subscribe = Boolean(d.subscribe);
          }
          if (d.topic != null) {
            m.topic = String(d.topic);
          }
          return m;
        };
        SubOpts.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (m.subscribe != null && m.hasOwnProperty("subscribe")) {
            d.subscribe = m.subscribe;
            if (o.oneofs)
              d._subscribe = "subscribe";
          }
          if (m.topic != null && m.hasOwnProperty("topic")) {
            d.topic = m.topic;
            if (o.oneofs)
              d._topic = "topic";
          }
          return d;
        };
        SubOpts.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
        };
        return SubOpts;
      }();
      RPC2.Message = function() {
        function Message2(p) {
          if (p) {
            for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
              if (p[ks[i2]] != null)
                this[ks[i2]] = p[ks[i2]];
          }
        }
        Message2.prototype.from = null;
        Message2.prototype.data = null;
        Message2.prototype.seqno = null;
        Message2.prototype.topic = "";
        Message2.prototype.signature = null;
        Message2.prototype.key = null;
        var $oneOfFields2;
        Object.defineProperty(Message2.prototype, "_from", {
          get: $util2.oneOfGetter($oneOfFields2 = ["from"]),
          set: $util2.oneOfSetter($oneOfFields2)
        });
        Object.defineProperty(Message2.prototype, "_data", {
          get: $util2.oneOfGetter($oneOfFields2 = ["data"]),
          set: $util2.oneOfSetter($oneOfFields2)
        });
        Object.defineProperty(Message2.prototype, "_seqno", {
          get: $util2.oneOfGetter($oneOfFields2 = ["seqno"]),
          set: $util2.oneOfSetter($oneOfFields2)
        });
        Object.defineProperty(Message2.prototype, "_signature", {
          get: $util2.oneOfGetter($oneOfFields2 = ["signature"]),
          set: $util2.oneOfSetter($oneOfFields2)
        });
        Object.defineProperty(Message2.prototype, "_key", {
          get: $util2.oneOfGetter($oneOfFields2 = ["key"]),
          set: $util2.oneOfSetter($oneOfFields2)
        });
        Message2.encode = function encode3(m, w) {
          if (!w)
            w = $Writer2.create();
          if (m.from != null && Object.hasOwnProperty.call(m, "from"))
            w.uint32(10).bytes(m.from);
          if (m.data != null && Object.hasOwnProperty.call(m, "data"))
            w.uint32(18).bytes(m.data);
          if (m.seqno != null && Object.hasOwnProperty.call(m, "seqno"))
            w.uint32(26).bytes(m.seqno);
          w.uint32(34).string(m.topic);
          if (m.signature != null && Object.hasOwnProperty.call(m, "signature"))
            w.uint32(42).bytes(m.signature);
          if (m.key != null && Object.hasOwnProperty.call(m, "key"))
            w.uint32(50).bytes(m.key);
          return w;
        };
        Message2.decode = function decode3(r, l) {
          if (!(r instanceof $Reader2))
            r = $Reader2.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root2.RPC.Message();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                m.from = r.bytes();
                break;
              case 2:
                m.data = r.bytes();
                break;
              case 3:
                m.seqno = r.bytes();
                break;
              case 4:
                m.topic = r.string();
                break;
              case 5:
                m.signature = r.bytes();
                break;
              case 6:
                m.key = r.bytes();
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          if (!m.hasOwnProperty("topic"))
            throw $util2.ProtocolError("missing required 'topic'", { instance: m });
          return m;
        };
        Message2.fromObject = function fromObject(d) {
          if (d instanceof $root2.RPC.Message)
            return d;
          var m = new $root2.RPC.Message();
          if (d.from != null) {
            if (typeof d.from === "string")
              $util2.base64.decode(d.from, m.from = $util2.newBuffer($util2.base64.length(d.from)), 0);
            else if (d.from.length)
              m.from = d.from;
          }
          if (d.data != null) {
            if (typeof d.data === "string")
              $util2.base64.decode(d.data, m.data = $util2.newBuffer($util2.base64.length(d.data)), 0);
            else if (d.data.length)
              m.data = d.data;
          }
          if (d.seqno != null) {
            if (typeof d.seqno === "string")
              $util2.base64.decode(d.seqno, m.seqno = $util2.newBuffer($util2.base64.length(d.seqno)), 0);
            else if (d.seqno.length)
              m.seqno = d.seqno;
          }
          if (d.topic != null) {
            m.topic = String(d.topic);
          }
          if (d.signature != null) {
            if (typeof d.signature === "string")
              $util2.base64.decode(d.signature, m.signature = $util2.newBuffer($util2.base64.length(d.signature)), 0);
            else if (d.signature.length)
              m.signature = d.signature;
          }
          if (d.key != null) {
            if (typeof d.key === "string")
              $util2.base64.decode(d.key, m.key = $util2.newBuffer($util2.base64.length(d.key)), 0);
            else if (d.key.length)
              m.key = d.key;
          }
          return m;
        };
        Message2.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.defaults) {
            d.topic = "";
          }
          if (m.from != null && m.hasOwnProperty("from")) {
            d.from = o.bytes === String ? $util2.base64.encode(m.from, 0, m.from.length) : o.bytes === Array ? Array.prototype.slice.call(m.from) : m.from;
            if (o.oneofs)
              d._from = "from";
          }
          if (m.data != null && m.hasOwnProperty("data")) {
            d.data = o.bytes === String ? $util2.base64.encode(m.data, 0, m.data.length) : o.bytes === Array ? Array.prototype.slice.call(m.data) : m.data;
            if (o.oneofs)
              d._data = "data";
          }
          if (m.seqno != null && m.hasOwnProperty("seqno")) {
            d.seqno = o.bytes === String ? $util2.base64.encode(m.seqno, 0, m.seqno.length) : o.bytes === Array ? Array.prototype.slice.call(m.seqno) : m.seqno;
            if (o.oneofs)
              d._seqno = "seqno";
          }
          if (m.topic != null && m.hasOwnProperty("topic")) {
            d.topic = m.topic;
          }
          if (m.signature != null && m.hasOwnProperty("signature")) {
            d.signature = o.bytes === String ? $util2.base64.encode(m.signature, 0, m.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m.signature) : m.signature;
            if (o.oneofs)
              d._signature = "signature";
          }
          if (m.key != null && m.hasOwnProperty("key")) {
            d.key = o.bytes === String ? $util2.base64.encode(m.key, 0, m.key.length) : o.bytes === Array ? Array.prototype.slice.call(m.key) : m.key;
            if (o.oneofs)
              d._key = "key";
          }
          return d;
        };
        Message2.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
        };
        return Message2;
      }();
      RPC2.ControlMessage = function() {
        function ControlMessage(p) {
          this.ihave = [];
          this.iwant = [];
          this.graft = [];
          this.prune = [];
          if (p) {
            for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
              if (p[ks[i2]] != null)
                this[ks[i2]] = p[ks[i2]];
          }
        }
        ControlMessage.prototype.ihave = $util2.emptyArray;
        ControlMessage.prototype.iwant = $util2.emptyArray;
        ControlMessage.prototype.graft = $util2.emptyArray;
        ControlMessage.prototype.prune = $util2.emptyArray;
        ControlMessage.encode = function encode3(m, w) {
          if (!w)
            w = $Writer2.create();
          if (m.ihave != null && m.ihave.length) {
            for (var i2 = 0; i2 < m.ihave.length; ++i2)
              $root2.RPC.ControlIHave.encode(m.ihave[i2], w.uint32(10).fork()).ldelim();
          }
          if (m.iwant != null && m.iwant.length) {
            for (var i2 = 0; i2 < m.iwant.length; ++i2)
              $root2.RPC.ControlIWant.encode(m.iwant[i2], w.uint32(18).fork()).ldelim();
          }
          if (m.graft != null && m.graft.length) {
            for (var i2 = 0; i2 < m.graft.length; ++i2)
              $root2.RPC.ControlGraft.encode(m.graft[i2], w.uint32(26).fork()).ldelim();
          }
          if (m.prune != null && m.prune.length) {
            for (var i2 = 0; i2 < m.prune.length; ++i2)
              $root2.RPC.ControlPrune.encode(m.prune[i2], w.uint32(34).fork()).ldelim();
          }
          return w;
        };
        ControlMessage.decode = function decode3(r, l) {
          if (!(r instanceof $Reader2))
            r = $Reader2.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root2.RPC.ControlMessage();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                if (!(m.ihave && m.ihave.length))
                  m.ihave = [];
                m.ihave.push($root2.RPC.ControlIHave.decode(r, r.uint32()));
                break;
              case 2:
                if (!(m.iwant && m.iwant.length))
                  m.iwant = [];
                m.iwant.push($root2.RPC.ControlIWant.decode(r, r.uint32()));
                break;
              case 3:
                if (!(m.graft && m.graft.length))
                  m.graft = [];
                m.graft.push($root2.RPC.ControlGraft.decode(r, r.uint32()));
                break;
              case 4:
                if (!(m.prune && m.prune.length))
                  m.prune = [];
                m.prune.push($root2.RPC.ControlPrune.decode(r, r.uint32()));
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          return m;
        };
        ControlMessage.fromObject = function fromObject(d) {
          if (d instanceof $root2.RPC.ControlMessage)
            return d;
          var m = new $root2.RPC.ControlMessage();
          if (d.ihave) {
            if (!Array.isArray(d.ihave))
              throw TypeError(".RPC.ControlMessage.ihave: array expected");
            m.ihave = [];
            for (var i2 = 0; i2 < d.ihave.length; ++i2) {
              if (typeof d.ihave[i2] !== "object")
                throw TypeError(".RPC.ControlMessage.ihave: object expected");
              m.ihave[i2] = $root2.RPC.ControlIHave.fromObject(d.ihave[i2]);
            }
          }
          if (d.iwant) {
            if (!Array.isArray(d.iwant))
              throw TypeError(".RPC.ControlMessage.iwant: array expected");
            m.iwant = [];
            for (var i2 = 0; i2 < d.iwant.length; ++i2) {
              if (typeof d.iwant[i2] !== "object")
                throw TypeError(".RPC.ControlMessage.iwant: object expected");
              m.iwant[i2] = $root2.RPC.ControlIWant.fromObject(d.iwant[i2]);
            }
          }
          if (d.graft) {
            if (!Array.isArray(d.graft))
              throw TypeError(".RPC.ControlMessage.graft: array expected");
            m.graft = [];
            for (var i2 = 0; i2 < d.graft.length; ++i2) {
              if (typeof d.graft[i2] !== "object")
                throw TypeError(".RPC.ControlMessage.graft: object expected");
              m.graft[i2] = $root2.RPC.ControlGraft.fromObject(d.graft[i2]);
            }
          }
          if (d.prune) {
            if (!Array.isArray(d.prune))
              throw TypeError(".RPC.ControlMessage.prune: array expected");
            m.prune = [];
            for (var i2 = 0; i2 < d.prune.length; ++i2) {
              if (typeof d.prune[i2] !== "object")
                throw TypeError(".RPC.ControlMessage.prune: object expected");
              m.prune[i2] = $root2.RPC.ControlPrune.fromObject(d.prune[i2]);
            }
          }
          return m;
        };
        ControlMessage.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.arrays || o.defaults) {
            d.ihave = [];
            d.iwant = [];
            d.graft = [];
            d.prune = [];
          }
          if (m.ihave && m.ihave.length) {
            d.ihave = [];
            for (var j = 0; j < m.ihave.length; ++j) {
              d.ihave[j] = $root2.RPC.ControlIHave.toObject(m.ihave[j], o);
            }
          }
          if (m.iwant && m.iwant.length) {
            d.iwant = [];
            for (var j = 0; j < m.iwant.length; ++j) {
              d.iwant[j] = $root2.RPC.ControlIWant.toObject(m.iwant[j], o);
            }
          }
          if (m.graft && m.graft.length) {
            d.graft = [];
            for (var j = 0; j < m.graft.length; ++j) {
              d.graft[j] = $root2.RPC.ControlGraft.toObject(m.graft[j], o);
            }
          }
          if (m.prune && m.prune.length) {
            d.prune = [];
            for (var j = 0; j < m.prune.length; ++j) {
              d.prune[j] = $root2.RPC.ControlPrune.toObject(m.prune[j], o);
            }
          }
          return d;
        };
        ControlMessage.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
        };
        return ControlMessage;
      }();
      RPC2.ControlIHave = function() {
        function ControlIHave(p) {
          this.messageIDs = [];
          if (p) {
            for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
              if (p[ks[i2]] != null)
                this[ks[i2]] = p[ks[i2]];
          }
        }
        ControlIHave.prototype.topicID = null;
        ControlIHave.prototype.messageIDs = $util2.emptyArray;
        var $oneOfFields2;
        Object.defineProperty(ControlIHave.prototype, "_topicID", {
          get: $util2.oneOfGetter($oneOfFields2 = ["topicID"]),
          set: $util2.oneOfSetter($oneOfFields2)
        });
        ControlIHave.encode = function encode3(m, w) {
          if (!w)
            w = $Writer2.create();
          if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
            w.uint32(10).string(m.topicID);
          if (m.messageIDs != null && m.messageIDs.length) {
            for (var i2 = 0; i2 < m.messageIDs.length; ++i2)
              w.uint32(18).bytes(m.messageIDs[i2]);
          }
          return w;
        };
        ControlIHave.decode = function decode3(r, l) {
          if (!(r instanceof $Reader2))
            r = $Reader2.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root2.RPC.ControlIHave();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                m.topicID = r.string();
                break;
              case 2:
                if (!(m.messageIDs && m.messageIDs.length))
                  m.messageIDs = [];
                m.messageIDs.push(r.bytes());
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          return m;
        };
        ControlIHave.fromObject = function fromObject(d) {
          if (d instanceof $root2.RPC.ControlIHave)
            return d;
          var m = new $root2.RPC.ControlIHave();
          if (d.topicID != null) {
            m.topicID = String(d.topicID);
          }
          if (d.messageIDs) {
            if (!Array.isArray(d.messageIDs))
              throw TypeError(".RPC.ControlIHave.messageIDs: array expected");
            m.messageIDs = [];
            for (var i2 = 0; i2 < d.messageIDs.length; ++i2) {
              if (typeof d.messageIDs[i2] === "string")
                $util2.base64.decode(d.messageIDs[i2], m.messageIDs[i2] = $util2.newBuffer($util2.base64.length(d.messageIDs[i2])), 0);
              else if (d.messageIDs[i2].length)
                m.messageIDs[i2] = d.messageIDs[i2];
            }
          }
          return m;
        };
        ControlIHave.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.arrays || o.defaults) {
            d.messageIDs = [];
          }
          if (m.topicID != null && m.hasOwnProperty("topicID")) {
            d.topicID = m.topicID;
            if (o.oneofs)
              d._topicID = "topicID";
          }
          if (m.messageIDs && m.messageIDs.length) {
            d.messageIDs = [];
            for (var j = 0; j < m.messageIDs.length; ++j) {
              d.messageIDs[j] = o.bytes === String ? $util2.base64.encode(m.messageIDs[j], 0, m.messageIDs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.messageIDs[j]) : m.messageIDs[j];
            }
          }
          return d;
        };
        ControlIHave.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
        };
        return ControlIHave;
      }();
      RPC2.ControlIWant = function() {
        function ControlIWant(p) {
          this.messageIDs = [];
          if (p) {
            for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
              if (p[ks[i2]] != null)
                this[ks[i2]] = p[ks[i2]];
          }
        }
        ControlIWant.prototype.messageIDs = $util2.emptyArray;
        ControlIWant.encode = function encode3(m, w) {
          if (!w)
            w = $Writer2.create();
          if (m.messageIDs != null && m.messageIDs.length) {
            for (var i2 = 0; i2 < m.messageIDs.length; ++i2)
              w.uint32(10).bytes(m.messageIDs[i2]);
          }
          return w;
        };
        ControlIWant.decode = function decode3(r, l) {
          if (!(r instanceof $Reader2))
            r = $Reader2.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root2.RPC.ControlIWant();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                if (!(m.messageIDs && m.messageIDs.length))
                  m.messageIDs = [];
                m.messageIDs.push(r.bytes());
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          return m;
        };
        ControlIWant.fromObject = function fromObject(d) {
          if (d instanceof $root2.RPC.ControlIWant)
            return d;
          var m = new $root2.RPC.ControlIWant();
          if (d.messageIDs) {
            if (!Array.isArray(d.messageIDs))
              throw TypeError(".RPC.ControlIWant.messageIDs: array expected");
            m.messageIDs = [];
            for (var i2 = 0; i2 < d.messageIDs.length; ++i2) {
              if (typeof d.messageIDs[i2] === "string")
                $util2.base64.decode(d.messageIDs[i2], m.messageIDs[i2] = $util2.newBuffer($util2.base64.length(d.messageIDs[i2])), 0);
              else if (d.messageIDs[i2].length)
                m.messageIDs[i2] = d.messageIDs[i2];
            }
          }
          return m;
        };
        ControlIWant.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.arrays || o.defaults) {
            d.messageIDs = [];
          }
          if (m.messageIDs && m.messageIDs.length) {
            d.messageIDs = [];
            for (var j = 0; j < m.messageIDs.length; ++j) {
              d.messageIDs[j] = o.bytes === String ? $util2.base64.encode(m.messageIDs[j], 0, m.messageIDs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.messageIDs[j]) : m.messageIDs[j];
            }
          }
          return d;
        };
        ControlIWant.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
        };
        return ControlIWant;
      }();
      RPC2.ControlGraft = function() {
        function ControlGraft(p) {
          if (p) {
            for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
              if (p[ks[i2]] != null)
                this[ks[i2]] = p[ks[i2]];
          }
        }
        ControlGraft.prototype.topicID = null;
        var $oneOfFields2;
        Object.defineProperty(ControlGraft.prototype, "_topicID", {
          get: $util2.oneOfGetter($oneOfFields2 = ["topicID"]),
          set: $util2.oneOfSetter($oneOfFields2)
        });
        ControlGraft.encode = function encode3(m, w) {
          if (!w)
            w = $Writer2.create();
          if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
            w.uint32(10).string(m.topicID);
          return w;
        };
        ControlGraft.decode = function decode3(r, l) {
          if (!(r instanceof $Reader2))
            r = $Reader2.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root2.RPC.ControlGraft();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                m.topicID = r.string();
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          return m;
        };
        ControlGraft.fromObject = function fromObject(d) {
          if (d instanceof $root2.RPC.ControlGraft)
            return d;
          var m = new $root2.RPC.ControlGraft();
          if (d.topicID != null) {
            m.topicID = String(d.topicID);
          }
          return m;
        };
        ControlGraft.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (m.topicID != null && m.hasOwnProperty("topicID")) {
            d.topicID = m.topicID;
            if (o.oneofs)
              d._topicID = "topicID";
          }
          return d;
        };
        ControlGraft.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
        };
        return ControlGraft;
      }();
      RPC2.ControlPrune = function() {
        function ControlPrune(p) {
          this.peers = [];
          if (p) {
            for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
              if (p[ks[i2]] != null)
                this[ks[i2]] = p[ks[i2]];
          }
        }
        ControlPrune.prototype.topicID = null;
        ControlPrune.prototype.peers = $util2.emptyArray;
        ControlPrune.prototype.backoff = null;
        var $oneOfFields2;
        Object.defineProperty(ControlPrune.prototype, "_topicID", {
          get: $util2.oneOfGetter($oneOfFields2 = ["topicID"]),
          set: $util2.oneOfSetter($oneOfFields2)
        });
        Object.defineProperty(ControlPrune.prototype, "_backoff", {
          get: $util2.oneOfGetter($oneOfFields2 = ["backoff"]),
          set: $util2.oneOfSetter($oneOfFields2)
        });
        ControlPrune.encode = function encode3(m, w) {
          if (!w)
            w = $Writer2.create();
          if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
            w.uint32(10).string(m.topicID);
          if (m.peers != null && m.peers.length) {
            for (var i2 = 0; i2 < m.peers.length; ++i2)
              $root2.RPC.PeerInfo.encode(m.peers[i2], w.uint32(18).fork()).ldelim();
          }
          if (m.backoff != null && Object.hasOwnProperty.call(m, "backoff"))
            w.uint32(24).uint64(m.backoff);
          return w;
        };
        ControlPrune.decode = function decode3(r, l) {
          if (!(r instanceof $Reader2))
            r = $Reader2.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root2.RPC.ControlPrune();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                m.topicID = r.string();
                break;
              case 2:
                if (!(m.peers && m.peers.length))
                  m.peers = [];
                m.peers.push($root2.RPC.PeerInfo.decode(r, r.uint32()));
                break;
              case 3:
                m.backoff = r.uint64();
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          return m;
        };
        ControlPrune.fromObject = function fromObject(d) {
          if (d instanceof $root2.RPC.ControlPrune)
            return d;
          var m = new $root2.RPC.ControlPrune();
          if (d.topicID != null) {
            m.topicID = String(d.topicID);
          }
          if (d.peers) {
            if (!Array.isArray(d.peers))
              throw TypeError(".RPC.ControlPrune.peers: array expected");
            m.peers = [];
            for (var i2 = 0; i2 < d.peers.length; ++i2) {
              if (typeof d.peers[i2] !== "object")
                throw TypeError(".RPC.ControlPrune.peers: object expected");
              m.peers[i2] = $root2.RPC.PeerInfo.fromObject(d.peers[i2]);
            }
          }
          if (d.backoff != null) {
            if ($util2.Long)
              (m.backoff = $util2.Long.fromValue(d.backoff)).unsigned = true;
            else if (typeof d.backoff === "string")
              m.backoff = parseInt(d.backoff, 10);
            else if (typeof d.backoff === "number")
              m.backoff = d.backoff;
            else if (typeof d.backoff === "object")
              m.backoff = new $util2.LongBits(d.backoff.low >>> 0, d.backoff.high >>> 0).toNumber(true);
          }
          return m;
        };
        ControlPrune.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.arrays || o.defaults) {
            d.peers = [];
          }
          if (m.topicID != null && m.hasOwnProperty("topicID")) {
            d.topicID = m.topicID;
            if (o.oneofs)
              d._topicID = "topicID";
          }
          if (m.peers && m.peers.length) {
            d.peers = [];
            for (var j = 0; j < m.peers.length; ++j) {
              d.peers[j] = $root2.RPC.PeerInfo.toObject(m.peers[j], o);
            }
          }
          if (m.backoff != null && m.hasOwnProperty("backoff")) {
            if (typeof m.backoff === "number")
              d.backoff = o.longs === String ? String(m.backoff) : m.backoff;
            else
              d.backoff = o.longs === String ? $util2.Long.prototype.toString.call(m.backoff) : o.longs === Number ? new $util2.LongBits(m.backoff.low >>> 0, m.backoff.high >>> 0).toNumber(true) : m.backoff;
            if (o.oneofs)
              d._backoff = "backoff";
          }
          return d;
        };
        ControlPrune.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
        };
        return ControlPrune;
      }();
      RPC2.PeerInfo = function() {
        function PeerInfo(p) {
          if (p) {
            for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
              if (p[ks[i2]] != null)
                this[ks[i2]] = p[ks[i2]];
          }
        }
        PeerInfo.prototype.peerID = null;
        PeerInfo.prototype.signedPeerRecord = null;
        var $oneOfFields2;
        Object.defineProperty(PeerInfo.prototype, "_peerID", {
          get: $util2.oneOfGetter($oneOfFields2 = ["peerID"]),
          set: $util2.oneOfSetter($oneOfFields2)
        });
        Object.defineProperty(PeerInfo.prototype, "_signedPeerRecord", {
          get: $util2.oneOfGetter($oneOfFields2 = ["signedPeerRecord"]),
          set: $util2.oneOfSetter($oneOfFields2)
        });
        PeerInfo.encode = function encode3(m, w) {
          if (!w)
            w = $Writer2.create();
          if (m.peerID != null && Object.hasOwnProperty.call(m, "peerID"))
            w.uint32(10).bytes(m.peerID);
          if (m.signedPeerRecord != null && Object.hasOwnProperty.call(m, "signedPeerRecord"))
            w.uint32(18).bytes(m.signedPeerRecord);
          return w;
        };
        PeerInfo.decode = function decode3(r, l) {
          if (!(r instanceof $Reader2))
            r = $Reader2.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root2.RPC.PeerInfo();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                m.peerID = r.bytes();
                break;
              case 2:
                m.signedPeerRecord = r.bytes();
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          return m;
        };
        PeerInfo.fromObject = function fromObject(d) {
          if (d instanceof $root2.RPC.PeerInfo)
            return d;
          var m = new $root2.RPC.PeerInfo();
          if (d.peerID != null) {
            if (typeof d.peerID === "string")
              $util2.base64.decode(d.peerID, m.peerID = $util2.newBuffer($util2.base64.length(d.peerID)), 0);
            else if (d.peerID.length)
              m.peerID = d.peerID;
          }
          if (d.signedPeerRecord != null) {
            if (typeof d.signedPeerRecord === "string")
              $util2.base64.decode(d.signedPeerRecord, m.signedPeerRecord = $util2.newBuffer($util2.base64.length(d.signedPeerRecord)), 0);
            else if (d.signedPeerRecord.length)
              m.signedPeerRecord = d.signedPeerRecord;
          }
          return m;
        };
        PeerInfo.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (m.peerID != null && m.hasOwnProperty("peerID")) {
            d.peerID = o.bytes === String ? $util2.base64.encode(m.peerID, 0, m.peerID.length) : o.bytes === Array ? Array.prototype.slice.call(m.peerID) : m.peerID;
            if (o.oneofs)
              d._peerID = "peerID";
          }
          if (m.signedPeerRecord != null && m.hasOwnProperty("signedPeerRecord")) {
            d.signedPeerRecord = o.bytes === String ? $util2.base64.encode(m.signedPeerRecord, 0, m.signedPeerRecord.length) : o.bytes === Array ? Array.prototype.slice.call(m.signedPeerRecord) : m.signedPeerRecord;
            if (o.oneofs)
              d._signedPeerRecord = "signedPeerRecord";
          }
          return d;
        };
        PeerInfo.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
        };
        return PeerInfo;
      }();
      return RPC2;
    }();
    return $root2;
  });
})(rpc$1);
const cjs = rpc$1.exports;
const { RPC: RPC$1 } = cjs;
const second$1 = 1e3;
const minute$2 = 60 * second$1;
const FloodsubID = "/floodsub/1.0.0";
const GossipsubIDv10 = "/meshsub/1.0.0";
const GossipsubIDv11 = "/meshsub/1.1.0";
const GossipsubD = 6;
const GossipsubDlo = 4;
const GossipsubDhi = 12;
const GossipsubDscore = 4;
const GossipsubDout = 2;
const GossipsubHistoryLength = 5;
const GossipsubHistoryGossip = 3;
const GossipsubDlazy = 6;
const GossipsubGossipFactor = 0.25;
const GossipsubGossipRetransmission = 3;
const GossipsubHeartbeatInitialDelay = 100;
const GossipsubHeartbeatInterval = second$1;
const GossipsubFanoutTTL = minute$2;
const GossipsubPrunePeers = 16;
const GossipsubPruneBackoff = minute$2;
const GossipsubPruneBackoffTicks = 15;
const GossipsubDirectConnectTicks = 300;
const GossipsubDirectConnectInitialDelay = second$1;
const GossipsubOpportunisticGraftTicks = 60;
const GossipsubOpportunisticGraftPeers = 2;
const GossipsubGraftFloodThreshold = 10 * second$1;
const GossipsubMaxIHaveLength = 5e3;
const GossipsubMaxIHaveMessages = 10;
const GossipsubIWantFollowupTime = 3 * second$1;
const GossipsubSeenTTL = 2 * minute$2;
const TimeCacheDuration = 120 * 1e3;
const ERR_TOPIC_VALIDATOR_REJECT = "ERR_TOPIC_VALIDATOR_REJECT";
const ERR_TOPIC_VALIDATOR_IGNORE = "ERR_TOPIC_VALIDATOR_IGNORE";
const ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE = 0;
const ACCEPT_FROM_WHITELIST_MAX_MESSAGES = 128;
const ACCEPT_FROM_WHITELIST_DURATION_MS = 1e3;
const DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS = 1e3;
function createGossipRpc(messages2 = [], control) {
  return {
    subscriptions: [],
    messages: messages2,
    control: control ? {
      graft: control.graft || [],
      prune: control.prune || [],
      ihave: control.ihave || [],
      iwant: control.iwant || []
    } : void 0
  };
}
function shuffle(arr) {
  if (arr.length <= 1) {
    return arr;
  }
  const randInt = () => {
    return Math.floor(Math.random() * Math.floor(arr.length));
  };
  for (let i2 = 0; i2 < arr.length; i2++) {
    const j = randInt();
    const tmp = arr[i2];
    arr[i2] = arr[j];
    arr[j] = tmp;
  }
  return arr;
}
function base(ALPHABET, name2) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x = ALPHABET.charAt(i2);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode3(source2) {
    if (source2 instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source2)) {
      source2 = new Uint8Array(source2.buffer, source2.byteOffset, source2.byteLength);
    } else if (Array.isArray(source2)) {
      source2 = Uint8Array.from(source2);
    }
    if (!(source2 instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source2.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length3 = 0;
    var pbegin = 0;
    var pend = source2.length;
    while (pbegin !== pend && source2[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size2 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size2);
    while (pbegin !== pend) {
      var carry = source2[pbegin];
      var i3 = 0;
      for (var it1 = size2 - 1; (carry !== 0 || i3 < length3) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length3 = i3;
      pbegin++;
    }
    var it2 = size2 - length3;
    while (it2 !== size2 && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size2; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source2) {
    if (typeof source2 !== "string") {
      throw new TypeError("Expected String");
    }
    if (source2.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source2[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length3 = 0;
    while (source2[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size2 = (source2.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size2);
    while (source2[psz]) {
      var carry = BASE_MAP[source2.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size2 - 1; (carry !== 0 || i3 < length3) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length3 = i3;
      psz++;
    }
    if (source2[psz] === " ") {
      return;
    }
    var it4 = size2 - length3;
    while (it4 !== size2 && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size2 - it4));
    var j2 = zeroes;
    while (it4 !== size2) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode3(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name2} character`);
  }
  return {
    encode: encode3,
    decodeUnsafe,
    decode: decode3
  };
}
var src$2 = base;
var _brrp__multiformats_scope_baseX = src$2;
const coerce = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
const fromString$1 = (str) => new TextEncoder().encode(str);
const toString$2 = (b2) => new TextDecoder().decode(b2);
class Encoder$2 {
  constructor(name2, prefix, baseEncode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
}
class Decoder$2 {
  constructor(name2, prefix, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or(this, decoder);
  }
}
class ComposedDecoder {
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
}
const or = (left, right) => new ComposedDecoder({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
class Codec {
  constructor(name2, prefix, baseEncode, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder$2(name2, prefix, baseEncode);
    this.decoder = new Decoder$2(name2, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
}
const from$1 = ({ name: name2, prefix, encode: encode3, decode: decode3 }) => new Codec(name2, prefix, encode3, decode3);
const baseX = ({ prefix, name: name2, alphabet: alphabet2 }) => {
  const { encode: encode3, decode: decode3 } = _brrp__multiformats_scope_baseX(alphabet2, name2);
  return from$1({
    prefix,
    name: name2,
    encode: encode3,
    decode: (text) => coerce(decode3(text))
  });
};
const decode$6 = (string2, alphabet2, bitsPerChar, name2) => {
  const codes2 = {};
  for (let i2 = 0; i2 < alphabet2.length; ++i2) {
    codes2[alphabet2[i2]] = i2;
  }
  let end2 = string2.length;
  while (string2[end2 - 1] === "=") {
    --end2;
  }
  const out = new Uint8Array(end2 * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end2; ++i2) {
    const value2 = codes2[string2[i2]];
    if (value2 === void 0) {
      throw new SyntaxError(`Non-${name2} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value2;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer2 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || 255 & buffer2 << 8 - bits2) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
const encode$9 = (data, alphabet2, bitsPerChar) => {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet2[mask & buffer2 >> bits2];
    }
  }
  if (bits2) {
    out += alphabet2[mask & buffer2 << bitsPerChar - bits2];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
const rfc4648 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
  return from$1({
    prefix,
    name: name2,
    encode(input) {
      return encode$9(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode$6(input, alphabet2, bitsPerChar, name2);
    }
  });
};
const identity$2 = from$1({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString$2(buf2),
  decode: (str) => fromString$1(str)
});
const identityBase = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: identity$2
}, Symbol.toStringTag, { value: "Module" }));
const base2 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});
const base2$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2
}, Symbol.toStringTag, { value: "Module" }));
const base8 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});
const base8$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8
}, Symbol.toStringTag, { value: "Module" }));
const base10 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});
const base10$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10
}, Symbol.toStringTag, { value: "Module" }));
const base16 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
const base16upper = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});
const base16$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16,
  base16upper
}, Symbol.toStringTag, { value: "Module" }));
const base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
const base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
const base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
const base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
const base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
const base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
const base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
const base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
const base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});
const base32$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32,
  base32upper,
  base32pad,
  base32padupper,
  base32hex,
  base32hexupper,
  base32hexpad,
  base32hexpadupper,
  base32z
}, Symbol.toStringTag, { value: "Module" }));
const base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
const base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});
const base36$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36,
  base36upper
}, Symbol.toStringTag, { value: "Module" }));
const base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
const base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});
const base58 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc,
  base58flickr
}, Symbol.toStringTag, { value: "Module" }));
const base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
const base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
const base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
const base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});
const base64$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64,
  base64pad,
  base64url,
  base64urlpad
}, Symbol.toStringTag, { value: "Module" }));
const alphabet$1 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
const alphabetBytesToChars = alphabet$1.reduce((p, c, i2) => {
  p[i2] = c;
  return p;
}, []);
const alphabetCharsToBytes = alphabet$1.reduce((p, c, i2) => {
  p[c.codePointAt(0)] = i2;
  return p;
}, []);
function encode$8(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars[c];
    return p;
  }, "");
}
function decode$5(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
const base256emoji = from$1({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode$8,
  decode: decode$5
});
const base256emoji$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji
}, Symbol.toStringTag, { value: "Module" }));
var encode_1$1 = encode$7;
var MSB$3 = 128, REST$3 = 127, MSBALL$1 = ~REST$3, INT$1 = Math.pow(2, 31);
function encode$7(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT$1) {
    out[offset++] = num & 255 | MSB$3;
    num /= 128;
  }
  while (num & MSBALL$1) {
    out[offset++] = num & 255 | MSB$3;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode$7.bytes = offset - oldOffset + 1;
  return out;
}
var decode$4 = read$2;
var MSB$1$1 = 128, REST$1$1 = 127;
function read$2(buf2, offset) {
  var res = 0, offset = offset || 0, shift2 = 0, counter2 = offset, b2, l = buf2.length;
  do {
    if (counter2 >= l) {
      read$2.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b2 = buf2[counter2++];
    res += shift2 < 28 ? (b2 & REST$1$1) << shift2 : (b2 & REST$1$1) * Math.pow(2, shift2);
    shift2 += 7;
  } while (b2 >= MSB$1$1);
  read$2.bytes = counter2 - offset;
  return res;
}
var N1$1 = Math.pow(2, 7);
var N2$1 = Math.pow(2, 14);
var N3$1 = Math.pow(2, 21);
var N4$1 = Math.pow(2, 28);
var N5$1 = Math.pow(2, 35);
var N6$1 = Math.pow(2, 42);
var N7$1 = Math.pow(2, 49);
var N8$1 = Math.pow(2, 56);
var N9$1 = Math.pow(2, 63);
var length$2 = function(value2) {
  return value2 < N1$1 ? 1 : value2 < N2$1 ? 2 : value2 < N3$1 ? 3 : value2 < N4$1 ? 4 : value2 < N5$1 ? 5 : value2 < N6$1 ? 6 : value2 < N7$1 ? 7 : value2 < N8$1 ? 8 : value2 < N9$1 ? 9 : 10;
};
var varint$2 = {
  encode: encode_1$1,
  decode: decode$4,
  encodingLength: length$2
};
var _brrp_varint = varint$2;
const encodeTo = (int2, target, offset = 0) => {
  _brrp_varint.encode(int2, target, offset);
  return target;
};
const encodingLength = (int2) => {
  return _brrp_varint.encodingLength(int2);
};
const create$3 = (code2, digest2) => {
  const size2 = digest2.byteLength;
  const sizeOffset = encodingLength(code2);
  const digestOffset = sizeOffset + encodingLength(size2);
  const bytes2 = new Uint8Array(digestOffset + size2);
  encodeTo(code2, bytes2, 0);
  encodeTo(size2, bytes2, sizeOffset);
  bytes2.set(digest2, digestOffset);
  return new Digest(code2, size2, digest2, bytes2);
};
class Digest {
  constructor(code2, size2, digest2, bytes2) {
    this.code = code2;
    this.size = size2;
    this.digest = digest2;
    this.bytes = bytes2;
  }
}
const from = ({ name: name2, code: code2, encode: encode3 }) => new Hasher(name2, code2, encode3);
class Hasher {
  constructor(name2, code2, encode3) {
    this.name = name2;
    this.code = code2;
    this.encode = encode3;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create$3(this.code, result) : result.then((digest2) => create$3(this.code, digest2));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
}
const sha = (name2) => async (data) => new Uint8Array(await crypto.subtle.digest(name2, data));
const sha256$1 = from({
  name: "sha2-256",
  code: 18,
  encode: sha("SHA-256")
});
const sha512 = from({
  name: "sha2-512",
  code: 19,
  encode: sha("SHA-512")
});
const sha2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  sha256: sha256$1,
  sha512
}, Symbol.toStringTag, { value: "Module" }));
const code = 0;
const name$1 = "identity";
const encode$6 = coerce;
const digest = (input) => create$3(code, encode$6(input));
const identity = {
  code,
  name: name$1,
  encode: encode$6,
  digest
};
const identity$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const bases = {
  ...identityBase,
  ...base2$1,
  ...base8$1,
  ...base10$1,
  ...base16$1,
  ...base32$1,
  ...base36$1,
  ...base58,
  ...base64$1,
  ...base256emoji$1
};
({
  ...sha2,
  ...identity$1
});
function asUint8Array(buf2) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
  }
  return buf2;
}
function allocUnsafe$3(size2 = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size2));
  }
  return new Uint8Array(size2);
}
function createCodec(name2, prefix, encode3, decode3) {
  return {
    name: name2,
    prefix,
    encoder: {
      name: name2,
      prefix,
      encode: encode3
    },
    decoder: { decode: decode3 }
  };
}
const string = createCodec("utf8", "u", (buf2) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf2);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
const ascii = createCodec("ascii", "a", (buf2) => {
  let string2 = "a";
  for (let i2 = 0; i2 < buf2.length; i2++) {
    string2 += String.fromCharCode(buf2[i2]);
  }
  return string2;
}, (str) => {
  str = str.substring(1);
  const buf2 = allocUnsafe$3(str.length);
  for (let i2 = 0; i2 < str.length; i2++) {
    buf2[i2] = str.charCodeAt(i2);
  }
  return buf2;
});
const BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
function toString$1(array, encoding2 = "utf8") {
  const base3 = BASES[encoding2];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding2}"`);
  }
  if ((encoding2 === "utf8" || encoding2 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base3.encoder.encode(array).substring(1);
}
function messageIdToString(msgId2) {
  return toString$1(msgId2, "base64");
}
const StrictSign = "StrictSign";
const StrictNoSign = "StrictNoSign";
var SignaturePolicy;
(function(SignaturePolicy2) {
  SignaturePolicy2["StrictSign"] = "StrictSign";
  SignaturePolicy2["StrictNoSign"] = "StrictNoSign";
})(SignaturePolicy || (SignaturePolicy = {}));
var PublishConfigType;
(function(PublishConfigType2) {
  PublishConfigType2[PublishConfigType2["Signing"] = 0] = "Signing";
  PublishConfigType2[PublishConfigType2["Anonymous"] = 1] = "Anonymous";
})(PublishConfigType || (PublishConfigType = {}));
var MessageAcceptance;
(function(MessageAcceptance2) {
  MessageAcceptance2["Accept"] = "accept";
  MessageAcceptance2["Ignore"] = "ignore";
  MessageAcceptance2["Reject"] = "reject";
})(MessageAcceptance || (MessageAcceptance = {}));
var RejectReason;
(function(RejectReason2) {
  RejectReason2["Error"] = "error";
  RejectReason2["Ignore"] = "ignore";
  RejectReason2["Reject"] = "reject";
  RejectReason2["Blacklisted"] = "blacklisted";
})(RejectReason || (RejectReason = {}));
var ValidateError;
(function(ValidateError2) {
  ValidateError2["InvalidSignature"] = "invalid_signature";
  ValidateError2["InvalidSeqno"] = "invalid_seqno";
  ValidateError2["InvalidPeerId"] = "invalid_peerid";
  ValidateError2["SignaturePresent"] = "signature_present";
  ValidateError2["SeqnoPresent"] = "seqno_present";
  ValidateError2["FromPresent"] = "from_present";
  ValidateError2["TransformFailed"] = "transform_failed";
})(ValidateError || (ValidateError = {}));
var MessageStatus;
(function(MessageStatus2) {
  MessageStatus2["duplicate"] = "duplicate";
  MessageStatus2["invalid"] = "invalid";
  MessageStatus2["valid"] = "valid";
})(MessageStatus || (MessageStatus = {}));
function rejectReasonFromAcceptance(acceptance) {
  switch (acceptance) {
    case MessageAcceptance.Ignore:
      return RejectReason.Ignore;
    case MessageAcceptance.Reject:
      return RejectReason.Reject;
  }
}
async function getPublishConfigFromPeerId(signaturePolicy, peerId) {
  switch (signaturePolicy) {
    case StrictSign: {
      if (!peerId) {
        throw Error("Must provide PeerId");
      }
      if (peerId.privateKey == null) {
        throw Error("Cannot sign message, no private key present");
      }
      if (peerId.publicKey == null) {
        throw Error("Cannot sign message, no public key present");
      }
      const privateKey = await unmarshalPrivateKey(peerId.privateKey);
      return {
        type: PublishConfigType.Signing,
        author: peerId,
        key: peerId.publicKey,
        privateKey
      };
    }
    case StrictNoSign:
      return {
        type: PublishConfigType.Anonymous
      };
    default:
      throw new Error(`Unknown signature policy "${signaturePolicy}"`);
  }
}
const ERR_INVALID_PEER_SCORE_PARAMS = "ERR_INVALID_PEER_SCORE_PARAMS";
const defaultPeerScoreParams = {
  topics: {},
  topicScoreCap: 10,
  appSpecificScore: () => 0,
  appSpecificWeight: 10,
  IPColocationFactorWeight: -5,
  IPColocationFactorThreshold: 10,
  IPColocationFactorWhitelist: /* @__PURE__ */ new Set(),
  behaviourPenaltyWeight: -10,
  behaviourPenaltyThreshold: 0,
  behaviourPenaltyDecay: 0.2,
  decayInterval: 1e3,
  decayToZero: 0.1,
  retainScore: 3600 * 1e3
};
const defaultTopicScoreParams = {
  topicWeight: 0.5,
  timeInMeshWeight: 1,
  timeInMeshQuantum: 1,
  timeInMeshCap: 3600,
  firstMessageDeliveriesWeight: 1,
  firstMessageDeliveriesDecay: 0.5,
  firstMessageDeliveriesCap: 2e3,
  meshMessageDeliveriesWeight: -1,
  meshMessageDeliveriesDecay: 0.5,
  meshMessageDeliveriesCap: 100,
  meshMessageDeliveriesThreshold: 20,
  meshMessageDeliveriesWindow: 10,
  meshMessageDeliveriesActivation: 5e3,
  meshFailurePenaltyWeight: -1,
  meshFailurePenaltyDecay: 0.5,
  invalidMessageDeliveriesWeight: -1,
  invalidMessageDeliveriesDecay: 0.3
};
function createPeerScoreParams(p = {}) {
  return {
    ...defaultPeerScoreParams,
    ...p,
    topics: p.topics ? Object.entries(p.topics).reduce((topics, [topic, topicScoreParams]) => {
      topics[topic] = createTopicScoreParams(topicScoreParams);
      return topics;
    }, {}) : {}
  };
}
function createTopicScoreParams(p = {}) {
  return {
    ...defaultTopicScoreParams,
    ...p
  };
}
function validatePeerScoreParams(p) {
  for (const [topic, params] of Object.entries(p.topics)) {
    try {
      validateTopicScoreParams(params);
    } catch (e) {
      throw errCode(new Error(`invalid score parameters for topic ${topic}: ${e.message}`), ERR_INVALID_PEER_SCORE_PARAMS);
    }
  }
  if (p.topicScoreCap < 0) {
    throw errCode(new Error("invalid topic score cap; must be positive (or 0 for no cap)"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.appSpecificScore === null || p.appSpecificScore === void 0) {
    throw errCode(new Error("missing application specific score function"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.IPColocationFactorWeight > 0) {
    throw errCode(new Error("invalid IPColocationFactorWeight; must be negative (or 0 to disable)"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.IPColocationFactorWeight !== 0 && p.IPColocationFactorThreshold < 1) {
    throw errCode(new Error("invalid IPColocationFactorThreshold; must be at least 1"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.behaviourPenaltyWeight > 0) {
    throw errCode(new Error("invalid BehaviourPenaltyWeight; must be negative (or 0 to disable)"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.behaviourPenaltyWeight !== 0 && (p.behaviourPenaltyDecay <= 0 || p.behaviourPenaltyDecay >= 1)) {
    throw errCode(new Error("invalid BehaviourPenaltyDecay; must be between 0 and 1"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.decayInterval < 1e3) {
    throw errCode(new Error("invalid DecayInterval; must be at least 1s"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.decayToZero <= 0 || p.decayToZero >= 1) {
    throw errCode(new Error("invalid DecayToZero; must be between 0 and 1"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
}
function validateTopicScoreParams(p) {
  if (p.topicWeight < 0) {
    throw errCode(new Error("invalid topic weight; must be >= 0"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.timeInMeshQuantum === 0) {
    throw errCode(new Error("invalid TimeInMeshQuantum; must be non zero"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.timeInMeshWeight < 0) {
    throw errCode(new Error("invalid TimeInMeshWeight; must be positive (or 0 to disable)"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.timeInMeshWeight !== 0 && p.timeInMeshQuantum <= 0) {
    throw errCode(new Error("invalid TimeInMeshQuantum; must be positive"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.timeInMeshWeight !== 0 && p.timeInMeshCap <= 0) {
    throw errCode(new Error("invalid TimeInMeshCap; must be positive"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.firstMessageDeliveriesWeight < 0) {
    throw errCode(new Error("invallid FirstMessageDeliveriesWeight; must be positive (or 0 to disable)"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.firstMessageDeliveriesWeight !== 0 && (p.firstMessageDeliveriesDecay <= 0 || p.firstMessageDeliveriesDecay >= 1)) {
    throw errCode(new Error("invalid FirstMessageDeliveriesDecay; must be between 0 and 1"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.firstMessageDeliveriesWeight !== 0 && p.firstMessageDeliveriesCap <= 0) {
    throw errCode(new Error("invalid FirstMessageDeliveriesCap; must be positive"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWeight > 0) {
    throw errCode(new Error("invalid MeshMessageDeliveriesWeight; must be negative (or 0 to disable)"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWeight !== 0 && (p.meshMessageDeliveriesDecay <= 0 || p.meshMessageDeliveriesDecay >= 1)) {
    throw errCode(new Error("invalid MeshMessageDeliveriesDecay; must be between 0 and 1"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesCap <= 0) {
    throw errCode(new Error("invalid MeshMessageDeliveriesCap; must be positive"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesThreshold <= 0) {
    throw errCode(new Error("invalid MeshMessageDeliveriesThreshold; must be positive"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWindow < 0) {
    throw errCode(new Error("invalid MeshMessageDeliveriesWindow; must be non-negative"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesActivation < 1e3) {
    throw errCode(new Error("invalid MeshMessageDeliveriesActivation; must be at least 1s"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshFailurePenaltyWeight > 0) {
    throw errCode(new Error("invalid MeshFailurePenaltyWeight; must be negative (or 0 to disable)"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshFailurePenaltyWeight !== 0 && (p.meshFailurePenaltyDecay <= 0 || p.meshFailurePenaltyDecay >= 1)) {
    throw errCode(new Error("invalid MeshFailurePenaltyDecay; must be between 0 and 1"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.invalidMessageDeliveriesWeight > 0) {
    throw errCode(new Error("invalid InvalidMessageDeliveriesWeight; must be negative (or 0 to disable)"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.invalidMessageDeliveriesDecay <= 0 || p.invalidMessageDeliveriesDecay >= 1) {
    throw errCode(new Error("invalid InvalidMessageDeliveriesDecay; must be between 0 and 1"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
}
const defaultPeerScoreThresholds = {
  gossipThreshold: -10,
  publishThreshold: -50,
  graylistThreshold: -80,
  acceptPXThreshold: 10,
  opportunisticGraftThreshold: 20
};
function createPeerScoreThresholds(p = {}) {
  return {
    ...defaultPeerScoreThresholds,
    ...p
  };
}
function computeScore(peer, pstats, params, peerIPs) {
  let score = 0;
  Object.entries(pstats.topics).forEach(([topic, tstats]) => {
    const topicParams = params.topics[topic];
    if (topicParams === void 0) {
      return;
    }
    let topicScore = 0;
    if (tstats.inMesh) {
      let p1 = tstats.meshTime / topicParams.timeInMeshQuantum;
      if (p1 > topicParams.timeInMeshCap) {
        p1 = topicParams.timeInMeshCap;
      }
      topicScore += p1 * topicParams.timeInMeshWeight;
    }
    let p2 = tstats.firstMessageDeliveries;
    if (p2 > topicParams.firstMessageDeliveriesCap) {
      p2 = topicParams.firstMessageDeliveriesCap;
    }
    topicScore += p2 * topicParams.firstMessageDeliveriesWeight;
    if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold) {
      const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries;
      const p3 = deficit * deficit;
      topicScore += p3 * topicParams.meshMessageDeliveriesWeight;
    }
    const p3b = tstats.meshFailurePenalty;
    topicScore += p3b * topicParams.meshFailurePenaltyWeight;
    const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries;
    topicScore += p4 * topicParams.invalidMessageDeliveriesWeight;
    score += topicScore * topicParams.topicWeight;
  });
  if (params.topicScoreCap > 0 && score > params.topicScoreCap) {
    score = params.topicScoreCap;
  }
  const p5 = params.appSpecificScore(peer);
  score += p5 * params.appSpecificWeight;
  pstats.ips.forEach((ip2) => {
    if (params.IPColocationFactorWhitelist.has(ip2)) {
      return;
    }
    const peersInIP = peerIPs.get(ip2);
    const numPeersInIP = peersInIP ? peersInIP.size : 0;
    if (numPeersInIP > params.IPColocationFactorThreshold) {
      const surplus = numPeersInIP - params.IPColocationFactorThreshold;
      const p6 = surplus * surplus;
      score += p6 * params.IPColocationFactorWeight;
    }
  });
  if (pstats.behaviourPenalty > params.behaviourPenaltyThreshold) {
    const excess = pstats.behaviourPenalty - params.behaviourPenaltyThreshold;
    const p72 = excess * excess;
    score += p72 * params.behaviourPenaltyWeight;
  }
  return score;
}
function Denque(array, options) {
  var options = options || {};
  this._head = 0;
  this._tail = 0;
  this._capacity = options.capacity;
  this._capacityMask = 3;
  this._list = new Array(4);
  if (Array.isArray(array)) {
    this._fromArray(array);
  }
}
Denque.prototype.peekAt = function peekAt(index) {
  var i2 = index;
  if (i2 !== (i2 | 0)) {
    return void 0;
  }
  var len2 = this.size();
  if (i2 >= len2 || i2 < -len2)
    return void 0;
  if (i2 < 0)
    i2 += len2;
  i2 = this._head + i2 & this._capacityMask;
  return this._list[i2];
};
Denque.prototype.get = function get2(i2) {
  return this.peekAt(i2);
};
Denque.prototype.peek = function peek() {
  if (this._head === this._tail)
    return void 0;
  return this._list[this._head];
};
Denque.prototype.peekFront = function peekFront() {
  return this.peek();
};
Denque.prototype.peekBack = function peekBack() {
  return this.peekAt(-1);
};
Object.defineProperty(Denque.prototype, "length", {
  get: function length2() {
    return this.size();
  }
});
Denque.prototype.size = function size() {
  if (this._head === this._tail)
    return 0;
  if (this._head < this._tail)
    return this._tail - this._head;
  else
    return this._capacityMask + 1 - (this._head - this._tail);
};
Denque.prototype.unshift = function unshift(item) {
  if (item === void 0)
    return this.size();
  var len2 = this._list.length;
  this._head = this._head - 1 + len2 & this._capacityMask;
  this._list[this._head] = item;
  if (this._tail === this._head)
    this._growArray();
  if (this._capacity && this.size() > this._capacity)
    this.pop();
  if (this._head < this._tail)
    return this._tail - this._head;
  else
    return this._capacityMask + 1 - (this._head - this._tail);
};
Denque.prototype.shift = function shift() {
  var head = this._head;
  if (head === this._tail)
    return void 0;
  var item = this._list[head];
  this._list[head] = void 0;
  this._head = head + 1 & this._capacityMask;
  if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2)
    this._shrinkArray();
  return item;
};
Denque.prototype.push = function push2(item) {
  if (item === void 0)
    return this.size();
  var tail = this._tail;
  this._list[tail] = item;
  this._tail = tail + 1 & this._capacityMask;
  if (this._tail === this._head) {
    this._growArray();
  }
  if (this._capacity && this.size() > this._capacity) {
    this.shift();
  }
  if (this._head < this._tail)
    return this._tail - this._head;
  else
    return this._capacityMask + 1 - (this._head - this._tail);
};
Denque.prototype.pop = function pop() {
  var tail = this._tail;
  if (tail === this._head)
    return void 0;
  var len2 = this._list.length;
  this._tail = tail - 1 + len2 & this._capacityMask;
  var item = this._list[this._tail];
  this._list[this._tail] = void 0;
  if (this._head < 2 && tail > 1e4 && tail <= len2 >>> 2)
    this._shrinkArray();
  return item;
};
Denque.prototype.removeOne = function removeOne(index) {
  var i2 = index;
  if (i2 !== (i2 | 0)) {
    return void 0;
  }
  if (this._head === this._tail)
    return void 0;
  var size2 = this.size();
  var len2 = this._list.length;
  if (i2 >= size2 || i2 < -size2)
    return void 0;
  if (i2 < 0)
    i2 += size2;
  i2 = this._head + i2 & this._capacityMask;
  var item = this._list[i2];
  var k;
  if (index < size2 / 2) {
    for (k = index; k > 0; k--) {
      this._list[i2] = this._list[i2 = i2 - 1 + len2 & this._capacityMask];
    }
    this._list[i2] = void 0;
    this._head = this._head + 1 + len2 & this._capacityMask;
  } else {
    for (k = size2 - 1 - index; k > 0; k--) {
      this._list[i2] = this._list[i2 = i2 + 1 + len2 & this._capacityMask];
    }
    this._list[i2] = void 0;
    this._tail = this._tail - 1 + len2 & this._capacityMask;
  }
  return item;
};
Denque.prototype.remove = function remove(index, count) {
  var i2 = index;
  var removed;
  var del_count = count;
  if (i2 !== (i2 | 0)) {
    return void 0;
  }
  if (this._head === this._tail)
    return void 0;
  var size2 = this.size();
  var len2 = this._list.length;
  if (i2 >= size2 || i2 < -size2 || count < 1)
    return void 0;
  if (i2 < 0)
    i2 += size2;
  if (count === 1 || !count) {
    removed = new Array(1);
    removed[0] = this.removeOne(i2);
    return removed;
  }
  if (i2 === 0 && i2 + count >= size2) {
    removed = this.toArray();
    this.clear();
    return removed;
  }
  if (i2 + count > size2)
    count = size2 - i2;
  var k;
  removed = new Array(count);
  for (k = 0; k < count; k++) {
    removed[k] = this._list[this._head + i2 + k & this._capacityMask];
  }
  i2 = this._head + i2 & this._capacityMask;
  if (index + count === size2) {
    this._tail = this._tail - count + len2 & this._capacityMask;
    for (k = count; k > 0; k--) {
      this._list[i2 = i2 + 1 + len2 & this._capacityMask] = void 0;
    }
    return removed;
  }
  if (index === 0) {
    this._head = this._head + count + len2 & this._capacityMask;
    for (k = count - 1; k > 0; k--) {
      this._list[i2 = i2 + 1 + len2 & this._capacityMask] = void 0;
    }
    return removed;
  }
  if (i2 < size2 / 2) {
    this._head = this._head + index + count + len2 & this._capacityMask;
    for (k = index; k > 0; k--) {
      this.unshift(this._list[i2 = i2 - 1 + len2 & this._capacityMask]);
    }
    i2 = this._head - 1 + len2 & this._capacityMask;
    while (del_count > 0) {
      this._list[i2 = i2 - 1 + len2 & this._capacityMask] = void 0;
      del_count--;
    }
    if (index < 0)
      this._tail = i2;
  } else {
    this._tail = i2;
    i2 = i2 + count + len2 & this._capacityMask;
    for (k = size2 - (count + index); k > 0; k--) {
      this.push(this._list[i2++]);
    }
    i2 = this._tail;
    while (del_count > 0) {
      this._list[i2 = i2 + 1 + len2 & this._capacityMask] = void 0;
      del_count--;
    }
  }
  if (this._head < 2 && this._tail > 1e4 && this._tail <= len2 >>> 2)
    this._shrinkArray();
  return removed;
};
Denque.prototype.splice = function splice(index, count) {
  var i2 = index;
  if (i2 !== (i2 | 0)) {
    return void 0;
  }
  var size2 = this.size();
  if (i2 < 0)
    i2 += size2;
  if (i2 > size2)
    return void 0;
  if (arguments.length > 2) {
    var k;
    var temp;
    var removed;
    var arg_len = arguments.length;
    var len2 = this._list.length;
    var arguments_index = 2;
    if (!size2 || i2 < size2 / 2) {
      temp = new Array(i2);
      for (k = 0; k < i2; k++) {
        temp[k] = this._list[this._head + k & this._capacityMask];
      }
      if (count === 0) {
        removed = [];
        if (i2 > 0) {
          this._head = this._head + i2 + len2 & this._capacityMask;
        }
      } else {
        removed = this.remove(i2, count);
        this._head = this._head + i2 + len2 & this._capacityMask;
      }
      while (arg_len > arguments_index) {
        this.unshift(arguments[--arg_len]);
      }
      for (k = i2; k > 0; k--) {
        this.unshift(temp[k - 1]);
      }
    } else {
      temp = new Array(size2 - (i2 + count));
      var leng = temp.length;
      for (k = 0; k < leng; k++) {
        temp[k] = this._list[this._head + i2 + count + k & this._capacityMask];
      }
      if (count === 0) {
        removed = [];
        if (i2 != size2) {
          this._tail = this._head + i2 + len2 & this._capacityMask;
        }
      } else {
        removed = this.remove(i2, count);
        this._tail = this._tail - leng + len2 & this._capacityMask;
      }
      while (arguments_index < arg_len) {
        this.push(arguments[arguments_index++]);
      }
      for (k = 0; k < leng; k++) {
        this.push(temp[k]);
      }
    }
    return removed;
  } else {
    return this.remove(i2, count);
  }
};
Denque.prototype.clear = function clear3() {
  this._head = 0;
  this._tail = 0;
};
Denque.prototype.isEmpty = function isEmpty() {
  return this._head === this._tail;
};
Denque.prototype.toArray = function toArray() {
  return this._copyArray(false);
};
Denque.prototype._fromArray = function _fromArray(array) {
  for (var i2 = 0; i2 < array.length; i2++)
    this.push(array[i2]);
};
Denque.prototype._copyArray = function _copyArray(fullCopy) {
  var newArray = [];
  var list = this._list;
  var len2 = list.length;
  var i2;
  if (fullCopy || this._head > this._tail) {
    for (i2 = this._head; i2 < len2; i2++)
      newArray.push(list[i2]);
    for (i2 = 0; i2 < this._tail; i2++)
      newArray.push(list[i2]);
  } else {
    for (i2 = this._head; i2 < this._tail; i2++)
      newArray.push(list[i2]);
  }
  return newArray;
};
Denque.prototype._growArray = function _growArray() {
  if (this._head) {
    this._list = this._copyArray(true);
    this._head = 0;
  }
  this._tail = this._list.length;
  this._list.length <<= 1;
  this._capacityMask = this._capacityMask << 1 | 1;
};
Denque.prototype._shrinkArray = function _shrinkArray() {
  this._list.length >>>= 1;
  this._capacityMask >>>= 1;
};
var denque = Denque;
var DeliveryRecordStatus;
(function(DeliveryRecordStatus2) {
  DeliveryRecordStatus2[DeliveryRecordStatus2["unknown"] = 0] = "unknown";
  DeliveryRecordStatus2[DeliveryRecordStatus2["valid"] = 1] = "valid";
  DeliveryRecordStatus2[DeliveryRecordStatus2["invalid"] = 2] = "invalid";
  DeliveryRecordStatus2[DeliveryRecordStatus2["ignored"] = 3] = "ignored";
})(DeliveryRecordStatus || (DeliveryRecordStatus = {}));
class MessageDeliveries {
  constructor() {
    this.records = /* @__PURE__ */ new Map();
    this.queue = new denque();
  }
  ensureRecord(msgIdStr) {
    let drec = this.records.get(msgIdStr);
    if (drec) {
      return drec;
    }
    drec = {
      status: DeliveryRecordStatus.unknown,
      firstSeen: Date.now(),
      validated: 0,
      peers: /* @__PURE__ */ new Set()
    };
    this.records.set(msgIdStr, drec);
    const entry = {
      msgId: msgIdStr,
      expire: Date.now() + TimeCacheDuration
    };
    this.queue.push(entry);
    return drec;
  }
  gc() {
    const now = Date.now();
    let head = this.queue.peekFront();
    while (head && head.expire < now) {
      this.records.delete(head.msgId);
      this.queue.shift();
      head = this.queue.peekFront();
    }
  }
  clear() {
    this.records.clear();
    this.queue.clear();
  }
}
function isStartable(obj) {
  return obj != null && typeof obj.start === "function" && typeof obj.stop === "function";
}
function isInitializable(obj) {
  return obj != null && typeof obj.init === "function";
}
class Components {
  constructor(init2 = {}) {
    this.started = false;
    if (init2.peerId != null) {
      this.setPeerId(init2.peerId);
    }
    if (init2.addressManager != null) {
      this.setAddressManager(init2.addressManager);
    }
    if (init2.peerStore != null) {
      this.setPeerStore(init2.peerStore);
    }
    if (init2.upgrader != null) {
      this.setUpgrader(init2.upgrader);
    }
    if (init2.metrics != null) {
      this.setMetrics(init2.metrics);
    }
    if (init2.registrar != null) {
      this.setRegistrar(init2.registrar);
    }
    if (init2.connectionManager != null) {
      this.setConnectionManager(init2.connectionManager);
    }
    if (init2.transportManager != null) {
      this.setTransportManager(init2.transportManager);
    }
    if (init2.connectionGater != null) {
      this.setConnectionGater(init2.connectionGater);
    }
    if (init2.contentRouting != null) {
      this.setContentRouting(init2.contentRouting);
    }
    if (init2.peerRouting != null) {
      this.setPeerRouting(init2.peerRouting);
    }
    if (init2.datastore != null) {
      this.setDatastore(init2.datastore);
    }
    if (init2.connectionProtector != null) {
      this.setConnectionProtector(init2.connectionProtector);
    }
    if (init2.dht != null) {
      this.setDHT(init2.dht);
    }
    if (init2.pubsub != null) {
      this.setPubSub(init2.pubsub);
    }
    if (init2.dialer != null) {
      this.setDialer(init2.dialer);
    }
  }
  isStarted() {
    return this.started;
  }
  async beforeStart() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      if (startable.beforeStart != null) {
        await startable.beforeStart();
      }
    }));
  }
  async start() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      await startable.start();
    }));
    this.started = true;
  }
  async afterStart() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      if (startable.afterStart != null) {
        await startable.afterStart();
      }
    }));
  }
  async beforeStop() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      if (startable.beforeStop != null) {
        await startable.beforeStop();
      }
    }));
  }
  async stop() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      await startable.stop();
    }));
    this.started = false;
  }
  async afterStop() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      if (startable.afterStop != null) {
        await startable.afterStop();
      }
    }));
  }
  setPeerId(peerId) {
    this.peerId = peerId;
    return peerId;
  }
  getPeerId() {
    if (this.peerId == null) {
      throw errCode(new Error("peerId not set"), "ERR_SERVICE_MISSING");
    }
    return this.peerId;
  }
  setMetrics(metrics) {
    this.metrics = metrics;
    if (isInitializable(metrics)) {
      metrics.init(this);
    }
    return metrics;
  }
  getMetrics() {
    return this.metrics;
  }
  setAddressManager(addressManager) {
    this.addressManager = addressManager;
    if (isInitializable(addressManager)) {
      addressManager.init(this);
    }
    return addressManager;
  }
  getAddressManager() {
    if (this.addressManager == null) {
      throw errCode(new Error("addressManager not set"), "ERR_SERVICE_MISSING");
    }
    return this.addressManager;
  }
  setPeerStore(peerStore) {
    this.peerStore = peerStore;
    if (isInitializable(peerStore)) {
      peerStore.init(this);
    }
    return peerStore;
  }
  getPeerStore() {
    if (this.peerStore == null) {
      throw errCode(new Error("peerStore not set"), "ERR_SERVICE_MISSING");
    }
    return this.peerStore;
  }
  setUpgrader(upgrader) {
    this.upgrader = upgrader;
    if (isInitializable(upgrader)) {
      upgrader.init(this);
    }
    return upgrader;
  }
  getUpgrader() {
    if (this.upgrader == null) {
      throw errCode(new Error("upgrader not set"), "ERR_SERVICE_MISSING");
    }
    return this.upgrader;
  }
  setRegistrar(registrar) {
    this.registrar = registrar;
    if (isInitializable(registrar)) {
      registrar.init(this);
    }
    return registrar;
  }
  getRegistrar() {
    if (this.registrar == null) {
      throw errCode(new Error("registrar not set"), "ERR_SERVICE_MISSING");
    }
    return this.registrar;
  }
  setConnectionManager(connectionManager) {
    this.connectionManager = connectionManager;
    if (isInitializable(connectionManager)) {
      connectionManager.init(this);
    }
    return connectionManager;
  }
  getConnectionManager() {
    if (this.connectionManager == null) {
      throw errCode(new Error("connectionManager not set"), "ERR_SERVICE_MISSING");
    }
    return this.connectionManager;
  }
  setTransportManager(transportManager) {
    this.transportManager = transportManager;
    if (isInitializable(transportManager)) {
      transportManager.init(this);
    }
    return transportManager;
  }
  getTransportManager() {
    if (this.transportManager == null) {
      throw errCode(new Error("transportManager not set"), "ERR_SERVICE_MISSING");
    }
    return this.transportManager;
  }
  setConnectionGater(connectionGater) {
    this.connectionGater = connectionGater;
    if (isInitializable(connectionGater)) {
      connectionGater.init(this);
    }
    return connectionGater;
  }
  getConnectionGater() {
    if (this.connectionGater == null) {
      throw errCode(new Error("connectionGater not set"), "ERR_SERVICE_MISSING");
    }
    return this.connectionGater;
  }
  setContentRouting(contentRouting) {
    this.contentRouting = contentRouting;
    if (isInitializable(contentRouting)) {
      contentRouting.init(this);
    }
    return contentRouting;
  }
  getContentRouting() {
    if (this.contentRouting == null) {
      throw errCode(new Error("contentRouting not set"), "ERR_SERVICE_MISSING");
    }
    return this.contentRouting;
  }
  setPeerRouting(peerRouting) {
    this.peerRouting = peerRouting;
    if (isInitializable(peerRouting)) {
      peerRouting.init(this);
    }
    return peerRouting;
  }
  getPeerRouting() {
    if (this.peerRouting == null) {
      throw errCode(new Error("peerRouting not set"), "ERR_SERVICE_MISSING");
    }
    return this.peerRouting;
  }
  setDatastore(datastore) {
    this.datastore = datastore;
    if (isInitializable(datastore)) {
      datastore.init(this);
    }
    return datastore;
  }
  getDatastore() {
    if (this.datastore == null) {
      throw errCode(new Error("datastore not set"), "ERR_SERVICE_MISSING");
    }
    return this.datastore;
  }
  setConnectionProtector(connectionProtector) {
    this.connectionProtector = connectionProtector;
    if (isInitializable(connectionProtector)) {
      connectionProtector.init(this);
    }
    return connectionProtector;
  }
  getConnectionProtector() {
    return this.connectionProtector;
  }
  setDHT(dht) {
    this.dht = dht;
    if (isInitializable(dht)) {
      dht.init(this);
    }
    return dht;
  }
  getDHT() {
    if (this.dht == null) {
      throw errCode(new Error("dht not set"), "ERR_SERVICE_MISSING");
    }
    return this.dht;
  }
  setPubSub(pubsub) {
    this.pubsub = pubsub;
    if (isInitializable(pubsub)) {
      pubsub.init(this);
    }
    return pubsub;
  }
  getPubSub() {
    if (this.pubsub == null) {
      throw errCode(new Error("pubsub not set"), "ERR_SERVICE_MISSING");
    }
    return this.pubsub;
  }
  setDialer(dialer) {
    this.dialer = dialer;
    if (isInitializable(dialer)) {
      dialer.init(this);
    }
    return dialer;
  }
  getDialer() {
    if (this.dialer == null) {
      throw errCode(new Error("dialer not set"), "ERR_SERVICE_MISSING");
    }
    return this.dialer;
  }
}
const log$X = logger$1("libp2p:gossipsub:score");
class PeerScore {
  constructor(params, metrics, opts) {
    this.params = params;
    this.metrics = metrics;
    this.peerStats = /* @__PURE__ */ new Map();
    this.peerIPs = /* @__PURE__ */ new Map();
    this.scoreCache = /* @__PURE__ */ new Map();
    this.deliveryRecords = new MessageDeliveries();
    this.components = new Components();
    validatePeerScoreParams(params);
    this.scoreCacheValidityMs = opts.scoreCacheValidityMs;
    this.computeScore = opts.computeScore ?? computeScore;
  }
  init(components) {
    this.components = components;
  }
  get size() {
    return this.peerStats.size;
  }
  start() {
    if (this._backgroundInterval) {
      log$X("Peer score already running");
      return;
    }
    this._backgroundInterval = setInterval(() => this.background(), this.params.decayInterval);
    log$X("started");
  }
  stop() {
    if (!this._backgroundInterval) {
      log$X("Peer score already stopped");
      return;
    }
    clearInterval(this._backgroundInterval);
    delete this._backgroundInterval;
    this.peerIPs.clear();
    this.peerStats.clear();
    this.deliveryRecords.clear();
    log$X("stopped");
  }
  background() {
    this.refreshScores();
    this.updateIPs();
    this.deliveryRecords.gc();
  }
  dumpPeerScoreStats() {
    return Object.fromEntries(Array.from(this.peerStats.entries()).map(([peer, stats]) => [peer, stats]));
  }
  refreshScores() {
    const now = Date.now();
    const decayToZero = this.params.decayToZero;
    this.peerStats.forEach((pstats, id) => {
      if (!pstats.connected) {
        if (now > pstats.expire) {
          this.removeIPs(id, pstats.ips);
          this.peerStats.delete(id);
          this.scoreCache.delete(id);
        }
        return;
      }
      Object.entries(pstats.topics).forEach(([topic, tstats]) => {
        const tparams = this.params.topics[topic];
        if (tparams === void 0) {
          return;
        }
        tstats.firstMessageDeliveries *= tparams.firstMessageDeliveriesDecay;
        if (tstats.firstMessageDeliveries < decayToZero) {
          tstats.firstMessageDeliveries = 0;
        }
        tstats.meshMessageDeliveries *= tparams.meshMessageDeliveriesDecay;
        if (tstats.meshMessageDeliveries < decayToZero) {
          tstats.meshMessageDeliveries = 0;
        }
        tstats.meshFailurePenalty *= tparams.meshFailurePenaltyDecay;
        if (tstats.meshFailurePenalty < decayToZero) {
          tstats.meshFailurePenalty = 0;
        }
        tstats.invalidMessageDeliveries *= tparams.invalidMessageDeliveriesDecay;
        if (tstats.invalidMessageDeliveries < decayToZero) {
          tstats.invalidMessageDeliveries = 0;
        }
        if (tstats.inMesh) {
          tstats.meshTime = now - tstats.graftTime;
          if (tstats.meshTime > tparams.meshMessageDeliveriesActivation) {
            tstats.meshMessageDeliveriesActive = true;
          }
        }
      });
      pstats.behaviourPenalty *= this.params.behaviourPenaltyDecay;
      if (pstats.behaviourPenalty < decayToZero) {
        pstats.behaviourPenalty = 0;
      }
    });
  }
  score(id) {
    this.metrics?.scoreFnCalls.inc();
    const pstats = this.peerStats.get(id);
    if (!pstats) {
      return 0;
    }
    const now = Date.now();
    const cacheEntry = this.scoreCache.get(id);
    if (cacheEntry && cacheEntry.cacheUntil > now) {
      return cacheEntry.score;
    }
    this.metrics?.scoreFnRuns.inc();
    const score = this.computeScore(id, pstats, this.params, this.peerIPs);
    const cacheUntil = now + this.scoreCacheValidityMs;
    if (cacheEntry) {
      this.metrics?.scoreCachedDelta.observe(Math.abs(score - cacheEntry.score));
      cacheEntry.score = score;
      cacheEntry.cacheUntil = cacheUntil;
    } else {
      this.scoreCache.set(id, { score, cacheUntil });
    }
    return score;
  }
  addPenalty(id, penalty, penaltyLabel) {
    const pstats = this.peerStats.get(id);
    if (pstats) {
      pstats.behaviourPenalty += penalty;
      this.metrics?.onScorePenalty(penaltyLabel);
    }
  }
  addPeer(id) {
    const pstats = {
      connected: true,
      expire: 0,
      topics: {},
      ips: [],
      behaviourPenalty: 0
    };
    this.peerStats.set(id, pstats);
    const ips = this.getIPs(id);
    this.setIPs(id, ips, pstats.ips);
    pstats.ips = ips;
  }
  removePeer(id) {
    const pstats = this.peerStats.get(id);
    if (!pstats) {
      return;
    }
    if (this.score(id) > 0) {
      this.removeIPs(id, pstats.ips);
      this.peerStats.delete(id);
      return;
    }
    Object.entries(pstats.topics).forEach(([topic, tstats]) => {
      tstats.firstMessageDeliveries = 0;
      const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;
      if (tstats.inMesh && tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {
        const deficit = threshold - tstats.meshMessageDeliveries;
        tstats.meshFailurePenalty += deficit * deficit;
      }
      tstats.inMesh = false;
      tstats.meshMessageDeliveriesActive = false;
    });
    pstats.connected = false;
    pstats.expire = Date.now() + this.params.retainScore;
  }
  graft(id, topic) {
    const pstats = this.peerStats.get(id);
    if (pstats) {
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats) {
        tstats.inMesh = true;
        tstats.graftTime = Date.now();
        tstats.meshTime = 0;
        tstats.meshMessageDeliveriesActive = false;
      }
    }
  }
  prune(id, topic) {
    const pstats = this.peerStats.get(id);
    if (pstats) {
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats) {
        const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;
        if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {
          const deficit = threshold - tstats.meshMessageDeliveries;
          tstats.meshFailurePenalty += deficit * deficit;
        }
        tstats.meshMessageDeliveriesActive = false;
        tstats.inMesh = false;
      }
    }
  }
  validateMessage(msgIdStr) {
    this.deliveryRecords.ensureRecord(msgIdStr);
  }
  deliverMessage(from2, msgIdStr, topic) {
    this.markFirstMessageDelivery(from2, topic);
    const drec = this.deliveryRecords.ensureRecord(msgIdStr);
    const now = Date.now();
    if (drec.status !== DeliveryRecordStatus.unknown) {
      log$X("unexpected delivery: message from %s was first seen %s ago and has delivery status %s", from2, now - drec.firstSeen, DeliveryRecordStatus[drec.status]);
      return;
    }
    drec.status = DeliveryRecordStatus.valid;
    drec.validated = now;
    drec.peers.forEach((p) => {
      if (p !== from2.toString()) {
        this.markDuplicateMessageDelivery(p, topic);
      }
    });
  }
  rejectInvalidMessage(from2, topic) {
    this.markInvalidMessageDelivery(from2, topic);
  }
  rejectMessage(from2, msgIdStr, topic, reason) {
    switch (reason) {
      case RejectReason.Error:
        this.markInvalidMessageDelivery(from2, topic);
        return;
      case RejectReason.Blacklisted:
        return;
    }
    const drec = this.deliveryRecords.ensureRecord(msgIdStr);
    if (drec.status !== DeliveryRecordStatus.unknown) {
      log$X("unexpected rejection: message from %s was first seen %s ago and has delivery status %d", from2, Date.now() - drec.firstSeen, DeliveryRecordStatus[drec.status]);
      return;
    }
    if (reason === RejectReason.Ignore) {
      drec.status = DeliveryRecordStatus.ignored;
      drec.peers.clear();
      return;
    }
    drec.status = DeliveryRecordStatus.invalid;
    this.markInvalidMessageDelivery(from2, topic);
    drec.peers.forEach((p) => {
      this.markInvalidMessageDelivery(p, topic);
    });
    drec.peers.clear();
  }
  duplicateMessage(from2, msgIdStr, topic) {
    const drec = this.deliveryRecords.ensureRecord(msgIdStr);
    if (drec.peers.has(from2)) {
      return;
    }
    switch (drec.status) {
      case DeliveryRecordStatus.unknown:
        drec.peers.add(from2);
        break;
      case DeliveryRecordStatus.valid:
        drec.peers.add(from2);
        this.markDuplicateMessageDelivery(from2, topic, drec.validated);
        break;
      case DeliveryRecordStatus.invalid:
        this.markInvalidMessageDelivery(from2, topic);
        break;
      case DeliveryRecordStatus.ignored:
        break;
    }
  }
  markInvalidMessageDelivery(from2, topic) {
    const pstats = this.peerStats.get(from2);
    if (pstats) {
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats) {
        tstats.invalidMessageDeliveries += 1;
      }
    }
  }
  markFirstMessageDelivery(from2, topic) {
    const pstats = this.peerStats.get(from2);
    if (pstats) {
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats) {
        let cap = this.params.topics[topic].firstMessageDeliveriesCap;
        tstats.firstMessageDeliveries = Math.min(cap, tstats.firstMessageDeliveries + 1);
        if (tstats.inMesh) {
          cap = this.params.topics[topic].meshMessageDeliveriesCap;
          tstats.meshMessageDeliveries = Math.min(cap, tstats.meshMessageDeliveries + 1);
        }
      }
    }
  }
  markDuplicateMessageDelivery(from2, topic, validatedTime) {
    const pstats = this.peerStats.get(from2);
    if (pstats) {
      const now = validatedTime !== void 0 ? Date.now() : 0;
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats && tstats.inMesh) {
        const tparams = this.params.topics[topic];
        if (validatedTime !== void 0) {
          const deliveryDelayMs = now - validatedTime;
          const isLateDelivery = deliveryDelayMs > tparams.meshMessageDeliveriesWindow;
          this.metrics?.onDuplicateMsgDelivery(topic, deliveryDelayMs, isLateDelivery);
          if (isLateDelivery) {
            return;
          }
        }
        const cap = tparams.meshMessageDeliveriesCap;
        tstats.meshMessageDeliveries = Math.min(cap, tstats.meshMessageDeliveries + 1);
      }
    }
  }
  getIPs(id) {
    return this.components.getConnectionManager().getConnections(peerIdFromString(id)).map((c) => c.remoteAddr.toOptions().host);
  }
  setIPs(id, newIPs, oldIPs) {
    addNewIPs:
      for (const ip2 of newIPs) {
        for (const xip of oldIPs) {
          if (ip2 === xip) {
            continue addNewIPs;
          }
        }
        let peers = this.peerIPs.get(ip2);
        if (!peers) {
          peers = /* @__PURE__ */ new Set();
          this.peerIPs.set(ip2, peers);
        }
        peers.add(id);
      }
    removeOldIPs:
      for (const ip2 of oldIPs) {
        for (const xip of newIPs) {
          if (ip2 === xip) {
            continue removeOldIPs;
          }
        }
        const peers = this.peerIPs.get(ip2);
        if (!peers) {
          continue;
        }
        peers.delete(id);
        if (!peers.size) {
          this.peerIPs.delete(ip2);
        }
      }
  }
  removeIPs(id, ips) {
    ips.forEach((ip2) => {
      const peers = this.peerIPs.get(ip2);
      if (!peers) {
        return;
      }
      peers.delete(id);
      if (!peers.size) {
        this.peerIPs.delete(ip2);
      }
    });
  }
  updateIPs() {
    this.peerStats.forEach((pstats, id) => {
      const newIPs = this.getIPs(id);
      this.setIPs(id, newIPs, pstats.ips);
      pstats.ips = newIPs;
    });
  }
  getPtopicStats(pstats, topic) {
    let topicStats = pstats.topics[topic];
    if (topicStats !== void 0) {
      return topicStats;
    }
    if (this.params.topics[topic] !== void 0) {
      topicStats = {
        inMesh: false,
        graftTime: 0,
        meshTime: 0,
        firstMessageDeliveries: 0,
        meshMessageDeliveries: 0,
        meshMessageDeliveriesActive: false,
        meshFailurePenalty: 0,
        invalidMessageDeliveries: 0
      };
      pstats.topics[topic] = topicStats;
      return topicStats;
    }
    return null;
  }
}
class IWantTracer {
  constructor(gossipsubIWantFollowupMs, msgIdToStrFn, metrics) {
    this.gossipsubIWantFollowupMs = gossipsubIWantFollowupMs;
    this.msgIdToStrFn = msgIdToStrFn;
    this.metrics = metrics;
    this.promises = /* @__PURE__ */ new Map();
    this.requestMsByMsg = /* @__PURE__ */ new Map();
    this.requestMsByMsgExpire = 10 * gossipsubIWantFollowupMs;
  }
  get size() {
    return this.promises.size;
  }
  get requestMsByMsgSize() {
    return this.requestMsByMsg.size;
  }
  addPromise(from2, msgIds) {
    const ix = Math.floor(Math.random() * msgIds.length);
    const msgId2 = msgIds[ix];
    const msgIdStr = this.msgIdToStrFn(msgId2);
    let expireByPeer = this.promises.get(msgIdStr);
    if (!expireByPeer) {
      expireByPeer = /* @__PURE__ */ new Map();
      this.promises.set(msgIdStr, expireByPeer);
    }
    const now = Date.now();
    if (!expireByPeer.has(from2)) {
      expireByPeer.set(from2, now + this.gossipsubIWantFollowupMs);
      if (this.metrics) {
        this.metrics.iwantPromiseStarted.inc(1);
        if (!this.requestMsByMsg.has(msgIdStr)) {
          this.requestMsByMsg.set(msgIdStr, now);
        }
      }
    }
  }
  getBrokenPromises() {
    const now = Date.now();
    const result = /* @__PURE__ */ new Map();
    let brokenPromises = 0;
    this.promises.forEach((expireByPeer, msgId2) => {
      expireByPeer.forEach((expire, p) => {
        if (expire < now) {
          result.set(p, (result.get(p) ?? 0) + 1);
          expireByPeer.delete(p);
          brokenPromises++;
        }
      });
      if (!expireByPeer.size) {
        this.promises.delete(msgId2);
      }
    });
    this.metrics?.iwantPromiseBroken.inc(brokenPromises);
    return result;
  }
  deliverMessage(msgIdStr) {
    this.trackMessage(msgIdStr);
    const expireByPeer = this.promises.get(msgIdStr);
    if (expireByPeer) {
      this.promises.delete(msgIdStr);
      if (this.metrics) {
        this.metrics.iwantPromiseResolved.inc(1);
        this.metrics.iwantPromiseResolvedPeers.inc(expireByPeer.size);
      }
    }
  }
  rejectMessage(msgIdStr, reason) {
    this.trackMessage(msgIdStr);
    switch (reason) {
      case RejectReason.Error:
        return;
    }
    this.promises.delete(msgIdStr);
  }
  clear() {
    this.promises.clear();
  }
  prune() {
    const maxMs = Date.now() - this.requestMsByMsgExpire;
    for (const [k, v] of this.requestMsByMsg.entries()) {
      if (v < maxMs) {
        this.requestMsByMsg.delete(k);
      } else {
        break;
      }
    }
  }
  trackMessage(msgIdStr) {
    if (this.metrics) {
      const requestMs = this.requestMsByMsg.get(msgIdStr);
      if (requestMs !== void 0) {
        this.metrics.iwantPromiseDeliveryTime.observe((Date.now() - requestMs) / 1e3);
        this.requestMsByMsg.delete(msgIdStr);
      }
    }
  }
}
class SimpleTimeCache {
  constructor(opts) {
    this.entries = /* @__PURE__ */ new Map();
    this.validityMs = opts.validityMs;
  }
  get size() {
    return this.entries.size;
  }
  put(key, value2) {
    this.entries.set(key, { value: value2, validUntilMs: Date.now() + this.validityMs });
  }
  prune() {
    const now = Date.now();
    for (const [k, v] of this.entries.entries()) {
      if (v.validUntilMs < now) {
        this.entries.delete(k);
      } else {
        break;
      }
    }
  }
  has(key) {
    return this.entries.has(key);
  }
  get(key) {
    const value2 = this.entries.get(key);
    return value2 && value2.validUntilMs >= Date.now() ? value2.value : void 0;
  }
  clear() {
    this.entries.clear();
  }
}
var MessageSource;
(function(MessageSource2) {
  MessageSource2["forward"] = "forward";
  MessageSource2["publish"] = "publish";
})(MessageSource || (MessageSource = {}));
var InclusionReason;
(function(InclusionReason2) {
  InclusionReason2["Fanout"] = "fanout";
  InclusionReason2["Random"] = "random";
  InclusionReason2["Subscribed"] = "subscribed";
  InclusionReason2["Outbound"] = "outbound";
  InclusionReason2["NotEnough"] = "not_enough";
  InclusionReason2["Opportunistic"] = "opportunistic";
})(InclusionReason || (InclusionReason = {}));
var ChurnReason;
(function(ChurnReason2) {
  ChurnReason2["Dc"] = "disconnected";
  ChurnReason2["BadScore"] = "bad_score";
  ChurnReason2["Prune"] = "prune";
  ChurnReason2["Unsub"] = "unsubscribed";
  ChurnReason2["Excess"] = "excess";
})(ChurnReason || (ChurnReason = {}));
var ScorePenalty;
(function(ScorePenalty2) {
  ScorePenalty2["GraftBackoff"] = "graft_backoff";
  ScorePenalty2["BrokenPromise"] = "broken_promise";
  ScorePenalty2["MessageDeficit"] = "message_deficit";
  ScorePenalty2["IPColocation"] = "IP_colocation";
})(ScorePenalty || (ScorePenalty = {}));
var IHaveIgnoreReason;
(function(IHaveIgnoreReason2) {
  IHaveIgnoreReason2["LowScore"] = "low_score";
  IHaveIgnoreReason2["MaxIhave"] = "max_ihave";
  IHaveIgnoreReason2["MaxIasked"] = "max_iasked";
})(IHaveIgnoreReason || (IHaveIgnoreReason = {}));
var ScoreThreshold;
(function(ScoreThreshold2) {
  ScoreThreshold2["graylist"] = "graylist";
  ScoreThreshold2["publish"] = "publish";
  ScoreThreshold2["gossip"] = "gossip";
  ScoreThreshold2["mesh"] = "mesh";
})(ScoreThreshold || (ScoreThreshold = {}));
function getMetrics(register, topicStrToLabel, opts) {
  return {
    protocolsEnabled: register.gauge({
      name: "gossipsub_protocol",
      help: "Status of enabled protocols",
      labelNames: ["protocol"]
    }),
    topicSubscriptionStatus: register.gauge({
      name: "gossipsub_topic_subscription_status",
      help: "Status of our subscription to this topic",
      labelNames: ["topicStr"]
    }),
    topicPeersCount: register.gauge({
      name: "gossipsub_topic_peer_count",
      help: "Number of peers subscribed to each topic",
      labelNames: ["topicStr"]
    }),
    meshPeerCounts: register.gauge({
      name: "gossipsub_mesh_peer_count",
      help: "Number of peers in our mesh",
      labelNames: ["topicStr"]
    }),
    meshPeerInclusionEvents: register.gauge({
      name: "gossipsub_mesh_peer_inclusion_events_total",
      help: "Number of times we include peers in a topic mesh for different reasons",
      labelNames: ["topic", "reason"]
    }),
    meshPeerChurnEvents: register.gauge({
      name: "gossipsub_peer_churn_events_total",
      help: "Number of times we remove peers in a topic mesh for different reasons",
      labelNames: ["topic", "reason"]
    }),
    peersPerProtocol: register.gauge({
      name: "gossipsub_peers_per_protocol_count",
      help: "Peers connected for each topic",
      labelNames: ["protocol"]
    }),
    heartbeatDuration: register.histogram({
      name: "gossipsub_heartbeat_duration_seconds",
      help: "The time it takes to complete one iteration of the heartbeat",
      buckets: [0.01, 0.1, 1]
    }),
    heartbeatSkipped: register.gauge({
      name: "gossipsub_heartbeat_skipped",
      help: "Heartbeat run took longer than heartbeat interval so next is skipped"
    }),
    asyncValidationResult: register.gauge({
      name: "gossipsub_async_validation_result_total",
      help: "Message validation result for each topic",
      labelNames: ["topic", "acceptance"]
    }),
    asyncValidationMcacheHit: register.gauge({
      name: "gossipsub_async_validation_mcache_hit_total",
      help: "Async validation result reported by the user layer",
      labelNames: ["hit"]
    }),
    rpcRecvBytes: register.gauge({ name: "gossipsub_rpc_recv_bytes_total", help: "RPC recv" }),
    rpcRecvCount: register.gauge({ name: "gossipsub_rpc_recv_count_total", help: "RPC recv" }),
    rpcRecvSubscription: register.gauge({ name: "gossipsub_rpc_recv_subscription_total", help: "RPC recv" }),
    rpcRecvMessage: register.gauge({ name: "gossipsub_rpc_recv_message_total", help: "RPC recv" }),
    rpcRecvControl: register.gauge({ name: "gossipsub_rpc_recv_control_total", help: "RPC recv" }),
    rpcRecvIHave: register.gauge({ name: "gossipsub_rpc_recv_ihave_total", help: "RPC recv" }),
    rpcRecvIWant: register.gauge({ name: "gossipsub_rpc_recv_iwant_total", help: "RPC recv" }),
    rpcRecvGraft: register.gauge({ name: "gossipsub_rpc_recv_graft_total", help: "RPC recv" }),
    rpcRecvPrune: register.gauge({ name: "gossipsub_rpc_recv_prune_total", help: "RPC recv" }),
    rpcRecvNotAccepted: register.gauge({
      name: "gossipsub_rpc_rcv_not_accepted_total",
      help: "Total count of RPC dropped because acceptFrom() == false"
    }),
    rpcSentBytes: register.gauge({ name: "gossipsub_rpc_sent_bytes_total", help: "RPC sent" }),
    rpcSentCount: register.gauge({ name: "gossipsub_rpc_sent_count_total", help: "RPC sent" }),
    rpcSentSubscription: register.gauge({ name: "gossipsub_rpc_sent_subscription_total", help: "RPC sent" }),
    rpcSentMessage: register.gauge({ name: "gossipsub_rpc_sent_message_total", help: "RPC sent" }),
    rpcSentControl: register.gauge({ name: "gossipsub_rpc_sent_control_total", help: "RPC sent" }),
    rpcSentIHave: register.gauge({ name: "gossipsub_rpc_sent_ihave_total", help: "RPC sent" }),
    rpcSentIWant: register.gauge({ name: "gossipsub_rpc_sent_iwant_total", help: "RPC sent" }),
    rpcSentGraft: register.gauge({ name: "gossipsub_rpc_sent_graft_total", help: "RPC sent" }),
    rpcSentPrune: register.gauge({ name: "gossipsub_rpc_sent_prune_total", help: "RPC sent" }),
    msgPublishCount: register.gauge({
      name: "gossipsub_msg_publish_count_total",
      help: "Total count of msg published by topic",
      labelNames: ["topic"]
    }),
    msgPublishPeers: register.gauge({
      name: "gossipsub_msg_publish_peers_total",
      help: "Total count of peers that we publish a msg to",
      labelNames: ["topic"]
    }),
    msgPublishPeersByGroup: register.gauge({
      name: "gossipsub_msg_publish_peers_by_group",
      help: "Total count of peers (by group) that we publish a msg to",
      labelNames: ["topic", "peerGroup"]
    }),
    msgPublishBytes: register.gauge({
      name: "gossipsub_msg_publish_bytes_total",
      help: "Total count of msg publish data.length bytes",
      labelNames: ["topic"]
    }),
    msgForwardCount: register.gauge({
      name: "gossipsub_msg_forward_count_total",
      help: "Total count of msg forwarded by topic",
      labelNames: ["topic"]
    }),
    msgForwardPeers: register.gauge({
      name: "gossipsub_msg_forward_peers_total",
      help: "Total count of peers that we forward a msg to",
      labelNames: ["topic"]
    }),
    msgReceivedPreValidation: register.gauge({
      name: "gossipsub_msg_received_prevalidation_total",
      help: "Total count of recv msgs before any validation",
      labelNames: ["topic"]
    }),
    msgReceivedStatus: register.gauge({
      name: "gossipsub_msg_received_status_total",
      help: "Tracks distribution of recv msgs by duplicate, invalid, valid",
      labelNames: ["topic", "status"]
    }),
    msgReceivedInvalid: register.gauge({
      name: "gossipsub_msg_received_invalid_total",
      help: "Tracks specific reason of invalid",
      labelNames: ["topic", "error"]
    }),
    duplicateMsgDeliveryDelay: register.histogram({
      name: "gossisub_duplicate_msg_delivery_delay_seconds",
      help: "Time since the 1st duplicated message validated",
      labelNames: ["topic"],
      buckets: [
        0.25 * opts.maxMeshMessageDeliveriesWindowSec,
        0.5 * opts.maxMeshMessageDeliveriesWindowSec,
        1 * opts.maxMeshMessageDeliveriesWindowSec,
        2 * opts.maxMeshMessageDeliveriesWindowSec,
        4 * opts.maxMeshMessageDeliveriesWindowSec
      ]
    }),
    duplicateMsgLateDelivery: register.gauge({
      name: "gossisub_duplicate_msg_late_delivery_total",
      help: "Total count of late duplicate message delivery by topic, which triggers P3 penalty",
      labelNames: ["topic"]
    }),
    scoreFnCalls: register.gauge({
      name: "gossipsub_score_fn_calls_total",
      help: "Total times score() is called"
    }),
    scoreFnRuns: register.gauge({
      name: "gossipsub_score_fn_runs_total",
      help: "Total times score() call actually computed computeScore(), no cache"
    }),
    scoreCachedDelta: register.histogram({
      name: "gossipsub_score_cache_delta",
      help: "Delta of score between cached values that expired",
      buckets: [10, 100, 1e3]
    }),
    peersByScoreThreshold: register.gauge({
      name: "gossipsub_peers_by_score_threshold_count",
      help: "Current count of peers by score threshold",
      labelNames: ["threshold"]
    }),
    score: register.avgMinMax({
      name: "gossipsub_score",
      help: "Avg min max of gossip scores",
      labelNames: ["topic", "p"]
    }),
    scoreWeights: register.avgMinMax({
      name: "gossipsub_score_weights",
      help: "Separate score weights",
      labelNames: ["topic", "p"]
    }),
    scorePerMesh: register.avgMinMax({
      name: "gossipsub_score_per_mesh",
      help: "Histogram of the scores for each mesh topic",
      labelNames: ["topic"]
    }),
    scoringPenalties: register.gauge({
      name: "gossipsub_scoring_penalties_total",
      help: "A counter of the kind of penalties being applied to peers",
      labelNames: ["penalty"]
    }),
    behaviourPenalty: register.histogram({
      name: "gossipsub_peer_stat_behaviour_penalty",
      help: "Current peer stat behaviour_penalty at each scrape",
      buckets: [
        0.25 * opts.behaviourPenaltyThreshold,
        0.5 * opts.behaviourPenaltyThreshold,
        1 * opts.behaviourPenaltyThreshold,
        2 * opts.behaviourPenaltyThreshold,
        4 * opts.behaviourPenaltyThreshold
      ]
    }),
    ihaveRcvIgnored: register.gauge({
      name: "gossipsub_ihave_rcv_ignored_total",
      help: "Total received IHAVE messages that we ignore for some reason",
      labelNames: ["reason"]
    }),
    ihaveRcvMsgids: register.gauge({
      name: "gossipsub_ihave_rcv_msgids_total",
      help: "Total received IHAVE messages by topic",
      labelNames: ["topic"]
    }),
    ihaveRcvNotSeenMsgids: register.gauge({
      name: "gossipsub_ihave_rcv_not_seen_msgids_total",
      help: "Total messages per topic we do not have, not actual requests",
      labelNames: ["topic"]
    }),
    iwantRcvMsgids: register.gauge({
      name: "gossipsub_iwant_rcv_msgids_total",
      help: "Total received IWANT messages by topic",
      labelNames: ["topic"]
    }),
    iwantRcvDonthaveMsgids: register.gauge({
      name: "gossipsub_iwant_rcv_dont_have_msgids_total",
      help: "Total requested messageIDs that we do not have"
    }),
    iwantPromiseStarted: register.gauge({
      name: "gossipsub_iwant_promise_sent_total",
      help: "Total count of started IWANT promises"
    }),
    iwantPromiseResolved: register.gauge({
      name: "gossipsub_iwant_promise_resolved_total",
      help: "Total count of resolved IWANT promises"
    }),
    iwantPromiseResolvedPeers: register.gauge({
      name: "gossipsub_iwant_promise_resolved_peers",
      help: "Total count of peers we have asked IWANT promises that are resolved"
    }),
    iwantPromiseBroken: register.gauge({
      name: "gossipsub_iwant_promise_broken",
      help: "Total count of broken IWANT promises"
    }),
    iwantPromiseDeliveryTime: register.histogram({
      name: "gossipsub_iwant_promise_delivery_seconds",
      help: "Histogram of delivery time of resolved IWANT promises",
      buckets: [
        0.5 * opts.gossipPromiseExpireSec,
        1 * opts.gossipPromiseExpireSec,
        2 * opts.gossipPromiseExpireSec,
        4 * opts.gossipPromiseExpireSec
      ]
    }),
    cacheSize: register.gauge({
      name: "gossipsub_cache_size",
      help: "Unbounded cache sizes",
      labelNames: ["cache"]
    }),
    mcacheSize: register.gauge({
      name: "gossipsub_mcache_size",
      help: "Current mcache msg count"
    }),
    topicStrToLabel,
    toTopic(topicStr) {
      return this.topicStrToLabel.get(topicStr) ?? topicStr;
    },
    onJoin(topicStr) {
      this.topicSubscriptionStatus.set({ topicStr }, 1);
      this.meshPeerCounts.set({ topicStr }, 0);
    },
    onLeave(topicStr) {
      this.topicSubscriptionStatus.set({ topicStr }, 0);
      this.meshPeerCounts.set({ topicStr }, 0);
    },
    onAddToMesh(topicStr, reason, count) {
      const topic = this.toTopic(topicStr);
      this.meshPeerInclusionEvents.inc({ topic, reason }, count);
    },
    onRemoveFromMesh(topicStr, reason, count) {
      const topic = this.toTopic(topicStr);
      this.meshPeerChurnEvents.inc({ topic, reason }, count);
    },
    onReportValidationMcacheHit(hit) {
      this.asyncValidationMcacheHit.inc({ hit: hit ? "hit" : "miss" });
    },
    onReportValidation(topicStr, acceptance) {
      const topic = this.toTopic(topicStr);
      this.asyncValidationResult.inc({ topic, acceptance });
    },
    onScorePenalty(penalty) {
      this.scoringPenalties.inc({ penalty }, 1);
    },
    onIhaveRcv(topicStr, ihave, idonthave) {
      const topic = this.toTopic(topicStr);
      this.ihaveRcvMsgids.inc({ topic }, ihave);
      this.ihaveRcvNotSeenMsgids.inc({ topic }, idonthave);
    },
    onIwantRcv(iwantByTopic, iwantDonthave) {
      for (const [topicStr, iwant] of iwantByTopic) {
        const topic = this.toTopic(topicStr);
        this.iwantRcvMsgids.inc({ topic }, iwant);
      }
      this.iwantRcvDonthaveMsgids.inc(iwantDonthave);
    },
    onForwardMsg(topicStr, tosendCount) {
      const topic = this.toTopic(topicStr);
      this.msgForwardCount.inc({ topic }, 1);
      this.msgForwardPeers.inc({ topic }, tosendCount);
    },
    onPublishMsg(topicStr, tosendGroupCount, tosendCount, dataLen) {
      const topic = this.toTopic(topicStr);
      this.msgPublishCount.inc({ topic }, 1);
      this.msgPublishBytes.inc({ topic }, tosendCount * dataLen);
      this.msgPublishPeers.inc({ topic }, tosendCount);
      this.msgPublishPeersByGroup.inc({ topic, peerGroup: "direct" }, tosendGroupCount.direct);
      this.msgPublishPeersByGroup.inc({ topic, peerGroup: "floodsub" }, tosendGroupCount.floodsub);
      this.msgPublishPeersByGroup.inc({ topic, peerGroup: "mesh" }, tosendGroupCount.mesh);
      this.msgPublishPeersByGroup.inc({ topic, peerGroup: "fanout" }, tosendGroupCount.fanout);
    },
    onMsgRecvPreValidation(topicStr) {
      const topic = this.toTopic(topicStr);
      this.msgReceivedPreValidation.inc({ topic }, 1);
    },
    onMsgRecvResult(topicStr, status) {
      const topic = this.toTopic(topicStr);
      this.msgReceivedStatus.inc({ topic, status });
    },
    onMsgRecvInvalid(topicStr, reason) {
      const topic = this.toTopic(topicStr);
      const error2 = reason.reason === RejectReason.Error ? reason.error : reason.reason;
      this.msgReceivedInvalid.inc({ topic, error: error2 }, 1);
    },
    onDuplicateMsgDelivery(topicStr, deliveryDelayMs, isLateDelivery) {
      this.duplicateMsgDeliveryDelay.observe(deliveryDelayMs / 1e3);
      if (isLateDelivery) {
        const topic = this.toTopic(topicStr);
        this.duplicateMsgLateDelivery.inc({ topic }, 1);
      }
    },
    onRpcRecv(rpc2, rpcBytes) {
      this.rpcRecvBytes.inc(rpcBytes);
      this.rpcRecvCount.inc(1);
      if (rpc2.subscriptions)
        this.rpcRecvSubscription.inc(rpc2.subscriptions.length);
      if (rpc2.messages)
        this.rpcRecvMessage.inc(rpc2.messages.length);
      if (rpc2.control) {
        this.rpcRecvControl.inc(1);
        if (rpc2.control.ihave)
          this.rpcRecvIHave.inc(rpc2.control.ihave.length);
        if (rpc2.control.iwant)
          this.rpcRecvIWant.inc(rpc2.control.iwant.length);
        if (rpc2.control.graft)
          this.rpcRecvGraft.inc(rpc2.control.graft.length);
        if (rpc2.control.prune)
          this.rpcRecvPrune.inc(rpc2.control.prune.length);
      }
    },
    onRpcSent(rpc2, rpcBytes) {
      this.rpcSentBytes.inc(rpcBytes);
      this.rpcSentCount.inc(1);
      if (rpc2.subscriptions)
        this.rpcSentSubscription.inc(rpc2.subscriptions.length);
      if (rpc2.messages)
        this.rpcSentMessage.inc(rpc2.messages.length);
      if (rpc2.control) {
        const ihave = rpc2.control.ihave?.length ?? 0;
        const iwant = rpc2.control.iwant?.length ?? 0;
        const graft = rpc2.control.graft?.length ?? 0;
        const prune = rpc2.control.prune?.length ?? 0;
        if (ihave > 0)
          this.rpcSentIHave.inc(ihave);
        if (iwant > 0)
          this.rpcSentIWant.inc(iwant);
        if (graft > 0)
          this.rpcSentGraft.inc(graft);
        if (prune > 0)
          this.rpcSentPrune.inc(prune);
        if (ihave > 0 || iwant > 0 || graft > 0 || prune > 0)
          this.rpcSentControl.inc(1);
      }
    },
    registerScores(scores, scoreThresholds) {
      let graylist = 0;
      let publish = 0;
      let gossip = 0;
      let mesh = 0;
      for (const score of scores) {
        if (score >= scoreThresholds.graylistThreshold)
          graylist++;
        if (score >= scoreThresholds.publishThreshold)
          publish++;
        if (score >= scoreThresholds.gossipThreshold)
          gossip++;
        if (score >= 0)
          mesh++;
      }
      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.graylist }, graylist);
      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.publish }, publish);
      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.gossip }, gossip);
      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.mesh }, mesh);
      this.score.set(scores);
    },
    registerScoreWeights(sw) {
      for (const [topic, wsTopic] of sw.byTopic) {
        this.scoreWeights.set({ topic, p: "p1" }, wsTopic.p1w);
        this.scoreWeights.set({ topic, p: "p2" }, wsTopic.p2w);
        this.scoreWeights.set({ topic, p: "p3" }, wsTopic.p3w);
        this.scoreWeights.set({ topic, p: "p3b" }, wsTopic.p3bw);
        this.scoreWeights.set({ topic, p: "p4" }, wsTopic.p4w);
      }
      this.scoreWeights.set({ p: "p5" }, sw.p5w);
      this.scoreWeights.set({ p: "p6" }, sw.p6w);
      this.scoreWeights.set({ p: "p7" }, sw.p7w);
    },
    registerScorePerMesh(mesh, scoreByPeer) {
      const peersPerTopicLabel = /* @__PURE__ */ new Map();
      mesh.forEach((peers, topicStr) => {
        const topicLabel = this.topicStrToLabel.get(topicStr) ?? "unknown";
        let peersInMesh = peersPerTopicLabel.get(topicLabel);
        if (!peersInMesh) {
          peersInMesh = /* @__PURE__ */ new Set();
          peersPerTopicLabel.set(topicLabel, peersInMesh);
        }
        peers.forEach((p) => peersInMesh?.add(p));
      });
      for (const [topic, peers] of peersPerTopicLabel) {
        const meshScores = [];
        peers.forEach((peer) => {
          meshScores.push(scoreByPeer.get(peer) ?? 0);
        });
        this.scorePerMesh.set({ topic }, meshScores);
      }
    }
  };
}
function concat(arrays, length3) {
  if (!length3) {
    length3 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe$3(length3);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array(output);
}
function fromString(string2, encoding2 = "utf8") {
  const base3 = BASES[encoding2];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding2}"`);
  }
  if ((encoding2 === "utf8" || encoding2 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array(globalThis.Buffer.from(string2, "utf-8"));
  }
  return base3.decoder.decode(`${base3.prefix}${string2}`);
}
const hashName = {
  sha1: "sha1",
  "sha2-256": "sha256",
  "sha2-512": "sha512"
};
function pbkdf2(password, salt, iterations, keySize, hash2) {
  if (hash2 !== "sha1" && hash2 !== "sha2-256" && hash2 !== "sha2-512") {
    const types2 = Object.keys(hashName).join(" / ");
    throw errCode(new Error(`Hash '${hash2}' is unknown or not supported. Must be ${types2}`), "ERR_UNSUPPORTED_HASH_TYPE");
  }
  const hasher = hashName[hash2];
  const dek = pbkdf2$1(password, salt, iterations, keySize, hasher);
  return util$2.exports.encode64(dek, null);
}
function equals(a, b2) {
  if (a === b2) {
    return true;
  }
  if (a.byteLength !== b2.byteLength) {
    return false;
  }
  for (let i2 = 0; i2 < a.byteLength; i2++) {
    if (a[i2] !== b2[i2]) {
      return false;
    }
  }
  return true;
}
const SignPrefix = fromString("libp2p-pubsub:");
async function buildRawMessage(publishConfig, topic, originalData, transformedData) {
  switch (publishConfig.type) {
    case PublishConfigType.Signing: {
      const rpcMsg = {
        from: publishConfig.author.toBytes(),
        data: transformedData,
        seqno: randomBytes$3(8),
        topic,
        signature: void 0,
        key: void 0
      };
      const bytes2 = concat([SignPrefix, RPC$1.Message.encode(rpcMsg).finish()]);
      rpcMsg.signature = await publishConfig.privateKey.sign(bytes2);
      rpcMsg.key = publishConfig.key;
      const msg = {
        type: "signed",
        from: publishConfig.author,
        data: originalData,
        sequenceNumber: BigInt(`0x${toString$1(rpcMsg.seqno, "base16")}`),
        topic,
        signature: rpcMsg.signature,
        key: rpcMsg.key
      };
      return {
        raw: rpcMsg,
        msg
      };
    }
    case PublishConfigType.Anonymous: {
      return {
        raw: {
          from: void 0,
          data: transformedData,
          seqno: void 0,
          topic,
          signature: void 0,
          key: void 0
        },
        msg: {
          type: "unsigned",
          data: originalData,
          topic
        }
      };
    }
  }
}
async function validateToRawMessage(signaturePolicy, msg) {
  switch (signaturePolicy) {
    case StrictNoSign:
      if (msg.signature != null)
        return { valid: false, error: ValidateError.SignaturePresent };
      if (msg.seqno != null)
        return { valid: false, error: ValidateError.SeqnoPresent };
      if (msg.key != null)
        return { valid: false, error: ValidateError.FromPresent };
      return { valid: true, message: { type: "unsigned", topic: msg.topic, data: msg.data ?? new Uint8Array(0) } };
    case StrictSign: {
      if (msg.seqno == null)
        return { valid: false, error: ValidateError.InvalidSeqno };
      if (msg.seqno.length !== 8) {
        return { valid: false, error: ValidateError.InvalidSeqno };
      }
      if (msg.signature == null)
        return { valid: false, error: ValidateError.InvalidSignature };
      if (msg.from == null)
        return { valid: false, error: ValidateError.InvalidPeerId };
      let fromPeerId;
      try {
        fromPeerId = peerIdFromBytes(msg.from);
      } catch (e) {
        return { valid: false, error: ValidateError.InvalidPeerId };
      }
      let publicKey;
      if (msg.key) {
        publicKey = unmarshalPublicKey(msg.key);
        if (fromPeerId.publicKey !== void 0 && !equals(publicKey.bytes, fromPeerId.publicKey)) {
          return { valid: false, error: ValidateError.InvalidPeerId };
        }
      } else {
        if (fromPeerId.publicKey == null) {
          return { valid: false, error: ValidateError.InvalidPeerId };
        }
        publicKey = unmarshalPublicKey(fromPeerId.publicKey);
      }
      const rpcMsgPreSign = {
        from: msg.from,
        data: msg.data,
        seqno: msg.seqno,
        topic: msg.topic,
        signature: void 0,
        key: void 0
      };
      const bytes2 = concat([SignPrefix, RPC$1.Message.encode(rpcMsgPreSign).finish()]);
      if (!await publicKey.verify(bytes2, msg.signature)) {
        return { valid: false, error: ValidateError.InvalidSignature };
      }
      return {
        valid: true,
        message: {
          type: "signed",
          from: fromPeerId,
          data: msg.data ?? new Uint8Array(0),
          sequenceNumber: BigInt(`0x${toString$1(msg.seqno, "base16")}`),
          topic: msg.topic,
          signature: msg.signature,
          key: msg.key ?? marshalPublicKey(publicKey)
        }
      };
    }
  }
}
const msgId = (key, seqno) => {
  const seqnoBytes = fromString(seqno.toString(16).padStart(16, "0"), "base16");
  const msgId2 = new Uint8Array(key.length + seqnoBytes.length);
  msgId2.set(key, 0);
  msgId2.set(seqnoBytes, key.length);
  return msgId2;
};
function msgIdFnStrictSign(msg) {
  if (msg.type !== "signed") {
    throw new Error("expected signed message type");
  }
  if (msg.sequenceNumber == null)
    throw Error("missing seqno field");
  return msgId(msg.from.toBytes(), msg.sequenceNumber);
}
async function msgIdFnStrictNoSign(msg) {
  return await sha256$1.encode(msg.data);
}
function computeScoreWeights(peer, pstats, params, peerIPs, topicStrToLabel) {
  let score = 0;
  const byTopic = /* @__PURE__ */ new Map();
  Object.entries(pstats.topics).forEach(([topic, tstats]) => {
    const topicLabel = topicStrToLabel.get(topic) ?? "unknown";
    const topicParams = params.topics[topic];
    if (topicParams === void 0) {
      return;
    }
    let topicScores = byTopic.get(topicLabel);
    if (!topicScores) {
      topicScores = {
        p1w: 0,
        p2w: 0,
        p3w: 0,
        p3bw: 0,
        p4w: 0
      };
      byTopic.set(topicLabel, topicScores);
    }
    let p1w = 0;
    let p2w = 0;
    let p3w = 0;
    let p3bw = 0;
    let p4w = 0;
    if (tstats.inMesh) {
      const p1 = Math.max(tstats.meshTime / topicParams.timeInMeshQuantum, topicParams.timeInMeshCap);
      p1w += p1 * topicParams.timeInMeshWeight;
    }
    let p2 = tstats.firstMessageDeliveries;
    if (p2 > topicParams.firstMessageDeliveriesCap) {
      p2 = topicParams.firstMessageDeliveriesCap;
    }
    p2w += p2 * topicParams.firstMessageDeliveriesWeight;
    if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold) {
      const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries;
      const p3 = deficit * deficit;
      p3w += p3 * topicParams.meshMessageDeliveriesWeight;
    }
    const p3b = tstats.meshFailurePenalty;
    p3bw += p3b * topicParams.meshFailurePenaltyWeight;
    const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries;
    p4w += p4 * topicParams.invalidMessageDeliveriesWeight;
    score += (p1w + p2w + p3w + p3bw + p4w) * topicParams.topicWeight;
    topicScores.p1w += p1w;
    topicScores.p2w += p2w;
    topicScores.p3w += p3w;
    topicScores.p3bw += p3bw;
    topicScores.p4w += p4w;
  });
  if (params.topicScoreCap > 0 && score > params.topicScoreCap) {
    score = params.topicScoreCap;
    const capF = params.topicScoreCap / score;
    for (const ws of byTopic.values()) {
      ws.p1w *= capF;
      ws.p2w *= capF;
      ws.p3w *= capF;
      ws.p3bw *= capF;
      ws.p4w *= capF;
    }
  }
  let p5w = 0;
  let p6w = 0;
  let p7w = 0;
  const p5 = params.appSpecificScore(peer);
  p5w += p5 * params.appSpecificWeight;
  pstats.ips.forEach((ip2) => {
    if (params.IPColocationFactorWhitelist.has(ip2)) {
      return;
    }
    const peersInIP = peerIPs.get(ip2);
    const numPeersInIP = peersInIP ? peersInIP.size : 0;
    if (numPeersInIP > params.IPColocationFactorThreshold) {
      const surplus = numPeersInIP - params.IPColocationFactorThreshold;
      const p6 = surplus * surplus;
      p6w += p6 * params.IPColocationFactorWeight;
    }
  });
  const p72 = pstats.behaviourPenalty * pstats.behaviourPenalty;
  p7w += p72 * params.behaviourPenaltyWeight;
  score += p5w + p6w + p7w;
  return {
    byTopic,
    p5w,
    p6w,
    p7w,
    score
  };
}
function computeAllPeersScoreWeights(peerIdStrs, peerStats, params, peerIPs, topicStrToLabel) {
  const sw = {
    byTopic: /* @__PURE__ */ new Map(),
    p5w: [],
    p6w: [],
    p7w: [],
    score: []
  };
  for (const peerIdStr of peerIdStrs) {
    const pstats = peerStats.get(peerIdStr);
    if (pstats) {
      const swPeer = computeScoreWeights(peerIdStr, pstats, params, peerIPs, topicStrToLabel);
      for (const [topic, swPeerTopic] of swPeer.byTopic) {
        let swTopic = sw.byTopic.get(topic);
        if (!swTopic) {
          swTopic = {
            p1w: [],
            p2w: [],
            p3w: [],
            p3bw: [],
            p4w: []
          };
          sw.byTopic.set(topic, swTopic);
        }
        swTopic.p1w.push(swPeerTopic.p1w);
        swTopic.p2w.push(swPeerTopic.p2w);
        swTopic.p3w.push(swPeerTopic.p3w);
        swTopic.p3bw.push(swPeerTopic.p3bw);
        swTopic.p4w.push(swPeerTopic.p4w);
      }
      sw.p5w.push(swPeer.p5w);
      sw.p6w.push(swPeer.p6w);
      sw.p7w.push(swPeer.p7w);
      sw.score.push(swPeer.score);
    } else {
      sw.p5w.push(0);
      sw.p6w.push(0);
      sw.p7w.push(0);
      sw.score.push(0);
    }
  }
  return sw;
}
function removeItemsFromSet(superSet, ineed, cond = () => true) {
  const subset = /* @__PURE__ */ new Set();
  if (ineed <= 0)
    return subset;
  for (const id of superSet) {
    if (subset.size >= ineed)
      break;
    if (cond(id)) {
      subset.add(id);
      superSet.delete(id);
    }
  }
  return subset;
}
function removeFirstNItemsFromSet(superSet, ineed) {
  return removeItemsFromSet(superSet, ineed, () => true);
}
class AbortError$1 extends Error {
  constructor(message2, code2) {
    super(message2 ?? "The operation was aborted");
    this.type = "aborted";
    this.code = code2 ?? "ABORT_ERR";
  }
}
function getIterator(obj) {
  if (obj != null) {
    if (typeof obj[Symbol.iterator] === "function") {
      return obj[Symbol.iterator]();
    }
    if (typeof obj[Symbol.asyncIterator] === "function") {
      return obj[Symbol.asyncIterator]();
    }
    if (typeof obj.next === "function") {
      return obj;
    }
  }
  throw new Error("argument is not an iterator or iterable");
}
function abortableSource(source2, signal, options) {
  const opts = options ?? {};
  const iterator2 = getIterator(source2);
  async function* abortable() {
    let nextAbortHandler;
    const abortHandler = () => {
      if (nextAbortHandler != null)
        nextAbortHandler();
    };
    signal.addEventListener("abort", abortHandler);
    while (true) {
      let result;
      try {
        if (signal.aborted) {
          const { abortMessage, abortCode } = opts;
          throw new AbortError$1(abortMessage, abortCode);
        }
        const abort = new Promise((resolve2, reject) => {
          nextAbortHandler = () => {
            const { abortMessage, abortCode } = opts;
            reject(new AbortError$1(abortMessage, abortCode));
          };
        });
        result = await Promise.race([abort, iterator2.next()]);
        nextAbortHandler = null;
      } catch (err2) {
        signal.removeEventListener("abort", abortHandler);
        const isKnownAborter = err2.type === "aborted" && signal.aborted;
        if (isKnownAborter && opts.onAbort != null) {
          await opts.onAbort(source2);
        }
        if (typeof iterator2.return === "function") {
          try {
            const p = iterator2.return();
            if (p instanceof Promise) {
              p.catch((err3) => {
                if (opts.onReturnError != null) {
                  opts.onReturnError(err3);
                }
              });
            }
          } catch (err3) {
            if (opts.onReturnError != null) {
              opts.onReturnError(err3);
            }
          }
        }
        if (isKnownAborter && opts.returnOnAbort === true) {
          return;
        }
        throw err2;
      }
      if (result.done === true) {
        break;
      }
      yield result.value;
    }
    signal.removeEventListener("abort", abortHandler);
  }
  return abortable();
}
function abortableSink(sink2, signal, options) {
  return (source2) => sink2(abortableSource(source2, signal, options));
}
function abortableDuplex(duplex2, signal, options) {
  return {
    sink: abortableSink(duplex2.sink, signal, {
      ...options,
      onAbort: void 0
    }),
    source: abortableSource(duplex2.source, signal, options)
  };
}
function allocUnsafe$2(len2) {
  if (globalThis?.Buffer?.allocUnsafe != null) {
    return globalThis.Buffer.allocUnsafe(len2);
  }
  return new Uint8Array(len2);
}
const defaultEncoder = (length3) => {
  const lengthLength = unsigned.encodingLength(length3);
  const lengthBuf = allocUnsafe$2(lengthLength);
  unsigned.encode(length3, lengthBuf);
  defaultEncoder.bytes = lengthLength;
  return lengthBuf;
};
defaultEncoder.bytes = 0;
function encode$5(options) {
  options = options ?? {};
  const encodeLength = options.lengthEncoder ?? defaultEncoder;
  const encoder2 = async function* (source2) {
    for await (const chunk of source2) {
      const length3 = encodeLength(chunk.byteLength);
      if (length3 instanceof Uint8Array) {
        yield length3;
      } else {
        yield* length3;
      }
      if (chunk instanceof Uint8Array) {
        yield chunk;
      } else {
        yield* chunk;
      }
    }
  };
  return encoder2;
}
encode$5.single = (chunk, options) => {
  options = options ?? {};
  const encodeLength = options.lengthEncoder ?? defaultEncoder;
  return new Uint8ArrayList(encodeLength(chunk.byteLength), chunk);
};
const MAX_LENGTH_LENGTH = 8;
const MAX_DATA_LENGTH = 1024 * 1024 * 4;
var ReadMode;
(function(ReadMode2) {
  ReadMode2[ReadMode2["LENGTH"] = 0] = "LENGTH";
  ReadMode2[ReadMode2["DATA"] = 1] = "DATA";
})(ReadMode || (ReadMode = {}));
const defaultDecoder = (buf2) => {
  const length3 = unsigned.decode(buf2);
  defaultDecoder.bytes = unsigned.encodingLength(length3);
  return length3;
};
defaultDecoder.bytes = 0;
function decode$3(options) {
  const decoder = async function* (source2) {
    const buffer2 = new Uint8ArrayList();
    let mode = ReadMode.LENGTH;
    let dataLength = -1;
    const lengthDecoder = options?.lengthDecoder ?? defaultDecoder;
    const maxLengthLength = options?.maxLengthLength ?? MAX_LENGTH_LENGTH;
    const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH;
    for await (const buf2 of source2) {
      buffer2.append(buf2);
      while (buffer2.byteLength > 0) {
        if (mode === ReadMode.LENGTH) {
          try {
            dataLength = lengthDecoder(buffer2);
            if (dataLength < 0) {
              throw errCode(new Error("invalid message length"), "ERR_INVALID_MSG_LENGTH");
            }
            if (dataLength > maxDataLength) {
              throw errCode(new Error("message length too long"), "ERR_MSG_DATA_TOO_LONG");
            }
            const dataLengthLength = lengthDecoder.bytes;
            buffer2.consume(dataLengthLength);
            if (options?.onLength != null) {
              options.onLength(dataLength);
            }
            mode = ReadMode.DATA;
          } catch (err2) {
            if (err2 instanceof RangeError) {
              if (buffer2.byteLength > maxLengthLength) {
                throw errCode(new Error("message length length too long"), "ERR_MSG_LENGTH_TOO_LONG");
              }
              break;
            }
            throw err2;
          }
        }
        if (mode === ReadMode.DATA) {
          if (buffer2.byteLength < dataLength) {
            break;
          }
          const data = buffer2.sublist(0, dataLength);
          buffer2.consume(dataLength);
          if (options?.onData != null) {
            options.onData(data);
          }
          yield data;
          mode = ReadMode.LENGTH;
        }
      }
    }
    if (buffer2.byteLength > 0) {
      throw errCode(new Error("unexpected end of input"), "ERR_UNEXPECTED_EOF");
    }
  };
  return decoder;
}
decode$3.fromReader = (reader2, options) => {
  let byteLength2 = 1;
  const varByteSource = async function* () {
    while (true) {
      try {
        const { done, value: value2 } = await reader2.next(byteLength2);
        if (done === true) {
          return;
        }
        if (value2 != null) {
          yield value2;
        }
      } catch (err2) {
        if (err2.code === "ERR_UNDER_READ") {
          return { done: true, value: null };
        }
        throw err2;
      } finally {
        byteLength2 = 1;
      }
    }
  }();
  const onLength = (l) => {
    byteLength2 = l;
  };
  return decode$3({
    ...options ?? {},
    onLength
  })(varByteSource);
};
class OutboundStream {
  constructor(rawStream, errCallback, opts) {
    this.rawStream = rawStream;
    this.pushable = pushable({ objectMode: false });
    this.closeController = new AbortController();
    this.maxBufferSize = opts.maxBufferSize ?? Infinity;
    pipe(abortableSource(this.pushable, this.closeController.signal, { returnOnAbort: true }), encode$5(), this.rawStream).catch(errCallback);
  }
  get protocol() {
    return this.rawStream.stat.protocol;
  }
  push(data) {
    if (this.pushable.readableLength > this.maxBufferSize) {
      throw Error(`OutboundStream buffer full, size > ${this.maxBufferSize}`);
    }
    this.pushable.push(data);
  }
  close() {
    this.closeController.abort();
    this.pushable.return();
    this.rawStream.close();
  }
}
class InboundStream {
  constructor(rawStream) {
    this.rawStream = rawStream;
    this.closeController = new AbortController();
    this.source = abortableSource(pipe(this.rawStream, decode$3()), this.closeController.signal, { returnOnAbort: true });
  }
  close() {
    this.closeController.abort();
    this.rawStream.close();
  }
}
var GossipStatusCode;
(function(GossipStatusCode2) {
  GossipStatusCode2[GossipStatusCode2["started"] = 0] = "started";
  GossipStatusCode2[GossipStatusCode2["stopped"] = 1] = "stopped";
})(GossipStatusCode || (GossipStatusCode = {}));
class GossipSub extends EventEmitter$1 {
  constructor(options = {}) {
    super();
    this.multicodecs = [GossipsubIDv11, GossipsubIDv10];
    this.peers = /* @__PURE__ */ new Set();
    this.streamsInbound = /* @__PURE__ */ new Map();
    this.streamsOutbound = /* @__PURE__ */ new Map();
    this.outboundInflightQueue = pushable({ objectMode: true });
    this.direct = /* @__PURE__ */ new Set();
    this.floodsubPeers = /* @__PURE__ */ new Set();
    this.acceptFromWhitelist = /* @__PURE__ */ new Map();
    this.topics = /* @__PURE__ */ new Map();
    this.subscriptions = /* @__PURE__ */ new Set();
    this.mesh = /* @__PURE__ */ new Map();
    this.fanout = /* @__PURE__ */ new Map();
    this.fanoutLastpub = /* @__PURE__ */ new Map();
    this.gossip = /* @__PURE__ */ new Map();
    this.control = /* @__PURE__ */ new Map();
    this.peerhave = /* @__PURE__ */ new Map();
    this.iasked = /* @__PURE__ */ new Map();
    this.backoff = /* @__PURE__ */ new Map();
    this.outbound = /* @__PURE__ */ new Map();
    this.topicValidators = /* @__PURE__ */ new Map();
    this.heartbeatTicks = 0;
    this.components = new Components();
    this.directPeerInitial = null;
    this.status = { code: GossipStatusCode.stopped };
    this.heartbeatTimer = null;
    this.runHeartbeat = () => {
      const timer = this.metrics?.heartbeatDuration.startTimer();
      this.heartbeat().catch((err2) => {
        this.log("Error running heartbeat", err2);
      }).finally(() => {
        if (timer != null) {
          timer();
        }
        if (this.status.code === GossipStatusCode.started) {
          clearTimeout(this.status.heartbeatTimeout);
          let msToNextHeartbeat = this.opts.heartbeatInterval - (Date.now() - this.status.hearbeatStartMs) % this.opts.heartbeatInterval;
          if (msToNextHeartbeat < this.opts.heartbeatInterval * 0.25) {
            msToNextHeartbeat += this.opts.heartbeatInterval;
            this.metrics?.heartbeatSkipped.inc();
          }
          this.status.heartbeatTimeout = setTimeout(this.runHeartbeat, msToNextHeartbeat);
        }
      });
    };
    const opts = {
      fallbackToFloodsub: true,
      floodPublish: true,
      doPX: false,
      directPeers: [],
      D: GossipsubD,
      Dlo: GossipsubDlo,
      Dhi: GossipsubDhi,
      Dscore: GossipsubDscore,
      Dout: GossipsubDout,
      Dlazy: GossipsubDlazy,
      heartbeatInterval: GossipsubHeartbeatInterval,
      fanoutTTL: GossipsubFanoutTTL,
      mcacheLength: GossipsubHistoryLength,
      mcacheGossip: GossipsubHistoryGossip,
      seenTTL: GossipsubSeenTTL,
      gossipsubIWantFollowupMs: GossipsubIWantFollowupTime,
      prunePeers: GossipsubPrunePeers,
      pruneBackoff: GossipsubPruneBackoff,
      graftFloodThreshold: GossipsubGraftFloodThreshold,
      opportunisticGraftPeers: GossipsubOpportunisticGraftPeers,
      opportunisticGraftTicks: GossipsubOpportunisticGraftTicks,
      directConnectTicks: GossipsubDirectConnectTicks,
      ...options,
      scoreParams: createPeerScoreParams(options.scoreParams),
      scoreThresholds: createPeerScoreThresholds(options.scoreThresholds)
    };
    this.globalSignaturePolicy = opts.globalSignaturePolicy ?? StrictSign;
    if (opts.fallbackToFloodsub) {
      this.multicodecs.push(FloodsubID);
    }
    this.log = logger$1(opts.debugName ?? "libp2p:gossipsub");
    this.opts = opts;
    this.direct = new Set(opts.directPeers.map((p) => p.id.toString()));
    this.seenCache = new SimpleTimeCache({ validityMs: opts.seenTTL });
    this.publishedMessageIds = new SimpleTimeCache({ validityMs: opts.seenTTL });
    if (options.msgIdFn) {
      this.msgIdFn = options.msgIdFn;
    } else {
      switch (this.globalSignaturePolicy) {
        case StrictSign:
          this.msgIdFn = msgIdFnStrictSign;
          break;
        case StrictNoSign:
          this.msgIdFn = msgIdFnStrictNoSign;
          break;
      }
    }
    if (options.fastMsgIdFn) {
      this.fastMsgIdFn = options.fastMsgIdFn;
      this.fastMsgIdCache = new SimpleTimeCache({ validityMs: opts.seenTTL });
    }
    this.msgIdToStrFn = options.msgIdToStrFn ?? messageIdToString;
    this.mcache = options.messageCache || new MessageCache(opts.mcacheGossip, opts.mcacheLength, this.msgIdToStrFn);
    if (options.dataTransform) {
      this.dataTransform = options.dataTransform;
    }
    if (options.metricsRegister) {
      if (!options.metricsTopicStrToLabel) {
        throw Error("Must set metricsTopicStrToLabel with metrics");
      }
      const maxMeshMessageDeliveriesWindowMs = Math.max(...Object.values(opts.scoreParams.topics).map((topicParam) => topicParam.meshMessageDeliveriesWindow), DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS);
      const metrics = getMetrics(options.metricsRegister, options.metricsTopicStrToLabel, {
        gossipPromiseExpireSec: this.opts.gossipsubIWantFollowupMs / 1e3,
        behaviourPenaltyThreshold: opts.scoreParams.behaviourPenaltyThreshold,
        maxMeshMessageDeliveriesWindowSec: maxMeshMessageDeliveriesWindowMs / 1e3
      });
      metrics.mcacheSize.addCollect(() => this.onScrapeMetrics(metrics));
      for (const protocol2 of this.multicodecs) {
        metrics.protocolsEnabled.set({ protocol: protocol2 }, 1);
      }
      this.metrics = metrics;
    } else {
      this.metrics = null;
    }
    this.gossipTracer = new IWantTracer(this.opts.gossipsubIWantFollowupMs, this.msgIdToStrFn, this.metrics);
    this.score = new PeerScore(this.opts.scoreParams, this.metrics, {
      scoreCacheValidityMs: opts.heartbeatInterval
    });
    this.maxInboundStreams = options.maxInboundStreams;
    this.maxOutboundStreams = options.maxOutboundStreams;
  }
  getPeers() {
    return [...this.peers.keys()].map((str) => peerIdFromString(str));
  }
  isStarted() {
    return this.status.code === GossipStatusCode.started;
  }
  async init(components) {
    this.components = components;
    this.score.init(components);
  }
  async start() {
    if (this.isStarted()) {
      return;
    }
    this.log("starting");
    this.publishConfig = await getPublishConfigFromPeerId(this.globalSignaturePolicy, this.components.getPeerId());
    this.outboundInflightQueue = pushable({ objectMode: true });
    pipe(this.outboundInflightQueue, async (source2) => {
      for await (const { peerId, connection } of source2) {
        await this.createOutboundStream(peerId, connection);
      }
    }).catch((e) => this.log.error("outbound inflight queue error", e));
    await Promise.all(this.opts.directPeers.map(async (p) => {
      await this.components.getPeerStore().addressBook.add(p.id, p.addrs);
    }));
    const registrar = this.components.getRegistrar();
    await Promise.all(this.multicodecs.map((multicodec) => registrar.handle(multicodec, this.onIncomingStream.bind(this), {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams
    })));
    const topology = createTopology({
      onConnect: this.onPeerConnected.bind(this),
      onDisconnect: this.onPeerDisconnected.bind(this)
    });
    const registrarTopologyIds = await Promise.all(this.multicodecs.map((multicodec) => registrar.register(multicodec, topology)));
    const heartbeatTimeout = setTimeout(this.runHeartbeat, GossipsubHeartbeatInitialDelay);
    this.status = {
      code: GossipStatusCode.started,
      registrarTopologyIds,
      heartbeatTimeout,
      hearbeatStartMs: Date.now() + GossipsubHeartbeatInitialDelay
    };
    this.score.start();
    this.directPeerInitial = setTimeout(() => {
      Promise.resolve().then(async () => {
        await Promise.all(Array.from(this.direct).map(async (id) => await this.connect(id)));
      }).catch((err2) => {
        this.log(err2);
      });
    }, GossipsubDirectConnectInitialDelay);
    this.log("started");
  }
  async stop() {
    this.log("stopping");
    if (this.status.code !== GossipStatusCode.started) {
      return;
    }
    const { registrarTopologyIds } = this.status;
    this.status = { code: GossipStatusCode.stopped };
    const registrar = this.components.getRegistrar();
    registrarTopologyIds.forEach((id) => registrar.unregister(id));
    this.outboundInflightQueue.end();
    for (const outboundStream of this.streamsOutbound.values()) {
      outboundStream.close();
    }
    this.streamsOutbound.clear();
    for (const inboundStream of this.streamsInbound.values()) {
      inboundStream.close();
    }
    this.streamsInbound.clear();
    this.peers.clear();
    this.subscriptions.clear();
    if (this.heartbeatTimer) {
      this.heartbeatTimer.cancel();
      this.heartbeatTimer = null;
    }
    this.score.stop();
    this.mesh.clear();
    this.fanout.clear();
    this.fanoutLastpub.clear();
    this.gossip.clear();
    this.control.clear();
    this.peerhave.clear();
    this.iasked.clear();
    this.backoff.clear();
    this.outbound.clear();
    this.gossipTracer.clear();
    this.seenCache.clear();
    if (this.fastMsgIdCache)
      this.fastMsgIdCache.clear();
    if (this.directPeerInitial)
      clearTimeout(this.directPeerInitial);
    this.log("stopped");
  }
  dumpPeerScoreStats() {
    return this.score.dumpPeerScoreStats();
  }
  onIncomingStream({ stream: stream2, connection }) {
    if (!this.isStarted()) {
      return;
    }
    const peerId = connection.remotePeer;
    this.addPeer(peerId, connection.stat.direction);
    this.createInboundStream(peerId, stream2);
    this.outboundInflightQueue.push({ peerId, connection });
  }
  onPeerConnected(peerId, connection) {
    if (!this.isStarted()) {
      return;
    }
    this.addPeer(peerId, connection.stat.direction);
    this.outboundInflightQueue.push({ peerId, connection });
  }
  onPeerDisconnected(peerId) {
    this.log("connection ended %p", peerId);
    this.removePeer(peerId);
  }
  async createOutboundStream(peerId, connection) {
    if (!this.isStarted()) {
      return;
    }
    const id = peerId.toString();
    if (!this.peers.has(id)) {
      return;
    }
    if (this.streamsOutbound.has(id)) {
      return;
    }
    try {
      const stream2 = new OutboundStream(await connection.newStream(this.multicodecs), (e) => this.log.error("outbound pipe error", e), { maxBufferSize: this.opts.maxOutboundBufferSize });
      this.log("create outbound stream %p", peerId);
      this.streamsOutbound.set(id, stream2);
      const protocol2 = stream2.protocol;
      if (protocol2 === FloodsubID) {
        this.floodsubPeers.add(id);
      }
      this.metrics?.peersPerProtocol.inc({ protocol: protocol2 }, 1);
      if (this.subscriptions.size > 0) {
        this.log("send subscriptions to", id);
        this.sendSubscriptions(id, Array.from(this.subscriptions), true);
      }
    } catch (e) {
      this.log.error("createOutboundStream error", e);
    }
  }
  async createInboundStream(peerId, stream2) {
    if (!this.isStarted()) {
      return;
    }
    const id = peerId.toString();
    if (!this.peers.has(id)) {
      return;
    }
    const priorInboundStream = this.streamsInbound.get(id);
    if (priorInboundStream !== void 0) {
      this.log("replacing existing inbound steam %s", id);
      priorInboundStream.close();
    }
    this.log("create inbound stream %s", id);
    const inboundStream = new InboundStream(stream2);
    this.streamsInbound.set(id, inboundStream);
    this.pipePeerReadStream(peerId, inboundStream.source).catch((err2) => this.log(err2));
  }
  addPeer(peerId, direction) {
    const id = peerId.toString();
    if (!this.peers.has(id)) {
      this.log("new peer %p", peerId);
      this.peers.add(id);
      this.score.addPeer(id);
      if (!this.outbound.has(id)) {
        this.outbound.set(id, direction === "outbound");
      }
    }
  }
  removePeer(peerId) {
    const id = peerId.toString();
    if (!this.peers.has(id)) {
      return;
    }
    this.log("delete peer %p", peerId);
    this.peers.delete(id);
    const outboundStream = this.streamsOutbound.get(id);
    const inboundStream = this.streamsInbound.get(id);
    if (outboundStream) {
      this.metrics?.peersPerProtocol.inc({ protocol: outboundStream.protocol }, -1);
    }
    outboundStream?.close();
    inboundStream?.close();
    this.streamsOutbound.delete(id);
    this.streamsInbound.delete(id);
    for (const peers of this.topics.values()) {
      peers.delete(id);
    }
    for (const [topicStr, peers] of this.mesh) {
      if (peers.delete(id) === true) {
        this.metrics?.onRemoveFromMesh(topicStr, ChurnReason.Dc, 1);
      }
    }
    for (const peers of this.fanout.values()) {
      peers.delete(id);
    }
    this.floodsubPeers.delete(id);
    this.gossip.delete(id);
    this.control.delete(id);
    this.outbound.delete(id);
    this.score.removePeer(id);
    this.acceptFromWhitelist.delete(id);
  }
  get started() {
    return this.status.code === GossipStatusCode.started;
  }
  getMeshPeers(topic) {
    const peersInTopic = this.mesh.get(topic);
    return peersInTopic ? Array.from(peersInTopic) : [];
  }
  getSubscribers(topic) {
    const peersInTopic = this.topics.get(topic);
    return (peersInTopic ? Array.from(peersInTopic) : []).map((str) => peerIdFromString(str));
  }
  getTopics() {
    return Array.from(this.subscriptions);
  }
  async pipePeerReadStream(peerId, stream2) {
    try {
      await pipe(stream2, async (source2) => {
        for await (const data of source2) {
          try {
            const rpcBytes = data.subarray();
            const rpc2 = RPC$1.decode(rpcBytes);
            this.metrics?.onRpcRecv(rpc2, rpcBytes.length);
            if (this.opts.awaitRpcHandler) {
              await this.handleReceivedRpc(peerId, rpc2);
            } else {
              this.handleReceivedRpc(peerId, rpc2).catch((err2) => this.log(err2));
            }
          } catch (e) {
            this.log(e);
          }
        }
      });
    } catch (err2) {
      this.log.error(err2);
      this.onPeerDisconnected(peerId);
    }
  }
  async handleReceivedRpc(from2, rpc2) {
    if (!this.acceptFrom(from2.toString())) {
      this.log("received message from unacceptable peer %p", from2);
      this.metrics?.rpcRecvNotAccepted.inc();
      return;
    }
    this.log("rpc from %p", from2);
    if (rpc2.subscriptions && rpc2.subscriptions.length > 0) {
      rpc2.subscriptions.forEach((subOpt) => {
        this.handleReceivedSubscription(from2, subOpt);
      });
      this.dispatchEvent(new CustomEvent("subscription-change", {
        detail: {
          peerId: from2,
          subscriptions: rpc2.subscriptions.filter((sub) => sub.topic !== null).map((sub) => {
            return {
              topic: sub.topic ?? "",
              subscribe: Boolean(sub.subscribe)
            };
          })
        }
      }));
    }
    if (rpc2.messages) {
      for (const message2 of rpc2.messages) {
        const handleReceivedMessagePromise = this.handleReceivedMessage(from2, message2).catch((err2) => this.log(err2));
        if (this.opts.awaitRpcMessageHandler) {
          await handleReceivedMessagePromise;
        }
      }
    }
    if (rpc2.control) {
      await this.handleControlMessage(from2.toString(), rpc2.control);
    }
  }
  handleReceivedSubscription(from2, subOpt) {
    if (subOpt.topic == null) {
      return;
    }
    this.log("subscription update from %p topic %s", from2, subOpt.topic);
    let topicSet = this.topics.get(subOpt.topic);
    if (topicSet == null) {
      topicSet = /* @__PURE__ */ new Set();
      this.topics.set(subOpt.topic, topicSet);
    }
    if (subOpt.subscribe) {
      topicSet.add(from2.toString());
    } else {
      topicSet.delete(from2.toString());
    }
  }
  async handleReceivedMessage(from2, rpcMsg) {
    this.metrics?.onMsgRecvPreValidation(rpcMsg.topic);
    const validationResult = await this.validateReceivedMessage(from2, rpcMsg);
    this.metrics?.onMsgRecvResult(rpcMsg.topic, validationResult.code);
    switch (validationResult.code) {
      case MessageStatus.duplicate:
        this.score.duplicateMessage(from2.toString(), validationResult.msgIdStr, rpcMsg.topic);
        this.mcache.observeDuplicate(validationResult.msgIdStr, from2.toString());
        return;
      case MessageStatus.invalid:
        if (validationResult.msgIdStr) {
          const msgIdStr = validationResult.msgIdStr;
          this.score.rejectMessage(from2.toString(), msgIdStr, rpcMsg.topic, validationResult.reason);
          this.gossipTracer.rejectMessage(msgIdStr, validationResult.reason);
        } else {
          this.score.rejectInvalidMessage(from2.toString(), rpcMsg.topic);
        }
        this.metrics?.onMsgRecvInvalid(rpcMsg.topic, validationResult);
        return;
      case MessageStatus.valid:
        this.score.validateMessage(validationResult.messageId.msgIdStr);
        this.gossipTracer.deliverMessage(validationResult.messageId.msgIdStr);
        this.mcache.put(validationResult.messageId, rpcMsg, !this.opts.asyncValidation);
        if (this.subscriptions.has(rpcMsg.topic)) {
          const isFromSelf = this.components.getPeerId().equals(from2);
          if (!isFromSelf || this.opts.emitSelf) {
            super.dispatchEvent(new CustomEvent("gossipsub:message", {
              detail: {
                propagationSource: from2,
                msgId: validationResult.messageId.msgIdStr,
                msg: validationResult.msg
              }
            }));
            super.dispatchEvent(new CustomEvent("message", { detail: validationResult.msg }));
          }
        }
        if (!this.opts.asyncValidation) {
          this.forwardMessage(validationResult.messageId.msgIdStr, rpcMsg, from2.toString());
        }
    }
  }
  async validateReceivedMessage(propagationSource, rpcMsg) {
    const fastMsgIdStr = this.fastMsgIdFn?.(rpcMsg);
    const msgIdCached = fastMsgIdStr ? this.fastMsgIdCache?.get(fastMsgIdStr) : void 0;
    if (msgIdCached) {
      return { code: MessageStatus.duplicate, msgIdStr: msgIdCached };
    }
    const validationResult = await validateToRawMessage(this.globalSignaturePolicy, rpcMsg);
    if (!validationResult.valid) {
      return { code: MessageStatus.invalid, reason: RejectReason.Error, error: validationResult.error };
    }
    const msg = validationResult.message;
    try {
      if (this.dataTransform) {
        msg.data = this.dataTransform.inboundTransform(rpcMsg.topic, msg.data);
      }
    } catch (e) {
      this.log("Invalid message, transform failed", e);
      return { code: MessageStatus.invalid, reason: RejectReason.Error, error: ValidateError.TransformFailed };
    }
    const msgId2 = await this.msgIdFn(msg);
    const msgIdStr = this.msgIdToStrFn(msgId2);
    const messageId = { msgId: msgId2, msgIdStr };
    if (fastMsgIdStr)
      this.fastMsgIdCache?.put(fastMsgIdStr, msgIdStr);
    if (this.seenCache.has(msgIdStr)) {
      return { code: MessageStatus.duplicate, msgIdStr };
    } else {
      this.seenCache.put(msgIdStr);
    }
    const topicValidator = this.topicValidators.get(rpcMsg.topic);
    if (topicValidator != null) {
      let acceptance;
      try {
        acceptance = await topicValidator(msg.topic, msg, propagationSource);
      } catch (e) {
        const errCode2 = e.code;
        if (errCode2 === ERR_TOPIC_VALIDATOR_IGNORE)
          acceptance = MessageAcceptance.Ignore;
        if (errCode2 === ERR_TOPIC_VALIDATOR_REJECT)
          acceptance = MessageAcceptance.Reject;
        else
          acceptance = MessageAcceptance.Ignore;
      }
      if (acceptance !== MessageAcceptance.Accept) {
        return { code: MessageStatus.invalid, reason: rejectReasonFromAcceptance(acceptance), msgIdStr };
      }
    }
    return { code: MessageStatus.valid, messageId, msg };
  }
  getScore(peerId) {
    return this.score.score(peerId);
  }
  sendSubscriptions(toPeer, topics, subscribe2) {
    this.sendRpc(toPeer, {
      subscriptions: topics.map((topic) => ({ topic, subscribe: subscribe2 })),
      messages: []
    });
  }
  async handleControlMessage(id, controlMsg) {
    if (controlMsg === void 0) {
      return;
    }
    const iwant = controlMsg.ihave ? this.handleIHave(id, controlMsg.ihave) : [];
    const ihave = controlMsg.iwant ? this.handleIWant(id, controlMsg.iwant) : [];
    const prune = controlMsg.graft ? await this.handleGraft(id, controlMsg.graft) : [];
    controlMsg.prune && await this.handlePrune(id, controlMsg.prune);
    if (!iwant.length && !ihave.length && !prune.length) {
      return;
    }
    this.sendRpc(id, createGossipRpc(ihave, { iwant, prune }));
  }
  acceptFrom(id) {
    if (this.direct.has(id)) {
      return true;
    }
    const now = Date.now();
    const entry = this.acceptFromWhitelist.get(id);
    if (entry && entry.messagesAccepted < ACCEPT_FROM_WHITELIST_MAX_MESSAGES && entry.acceptUntil >= now) {
      entry.messagesAccepted += 1;
      return true;
    }
    const score = this.score.score(id);
    if (score >= ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE) {
      this.acceptFromWhitelist.set(id, {
        messagesAccepted: 0,
        acceptUntil: now + ACCEPT_FROM_WHITELIST_DURATION_MS
      });
    } else {
      this.acceptFromWhitelist.delete(id);
    }
    return score >= this.opts.scoreThresholds.graylistThreshold;
  }
  handleIHave(id, ihave) {
    if (!ihave.length) {
      return [];
    }
    const score = this.score.score(id);
    if (score < this.opts.scoreThresholds.gossipThreshold) {
      this.log("IHAVE: ignoring peer %s with score below threshold [ score = %d ]", id, score);
      this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.LowScore });
      return [];
    }
    const peerhave = (this.peerhave.get(id) ?? 0) + 1;
    this.peerhave.set(id, peerhave);
    if (peerhave > GossipsubMaxIHaveMessages) {
      this.log("IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring", id, peerhave);
      this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.MaxIhave });
      return [];
    }
    const iasked = this.iasked.get(id) ?? 0;
    if (iasked >= GossipsubMaxIHaveLength) {
      this.log("IHAVE: peer %s has already advertised too many messages (%d); ignoring", id, iasked);
      this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.MaxIasked });
      return [];
    }
    const iwant = /* @__PURE__ */ new Map();
    ihave.forEach(({ topicID, messageIDs }) => {
      if (!topicID || !messageIDs || !this.mesh.has(topicID)) {
        return;
      }
      let idonthave = 0;
      messageIDs.forEach((msgId2) => {
        const msgIdStr = this.msgIdToStrFn(msgId2);
        if (!this.seenCache.has(msgIdStr)) {
          iwant.set(msgIdStr, msgId2);
          idonthave++;
        }
      });
      this.metrics?.onIhaveRcv(topicID, messageIDs.length, idonthave);
    });
    if (!iwant.size) {
      return [];
    }
    let iask = iwant.size;
    if (iask + iasked > GossipsubMaxIHaveLength) {
      iask = GossipsubMaxIHaveLength - iasked;
    }
    this.log("IHAVE: Asking for %d out of %d messages from %s", iask, iwant.size, id);
    let iwantList = Array.from(iwant.values());
    shuffle(iwantList);
    iwantList = iwantList.slice(0, iask);
    this.iasked.set(id, iasked + iask);
    this.gossipTracer.addPromise(id, iwantList);
    return [
      {
        messageIDs: iwantList
      }
    ];
  }
  handleIWant(id, iwant) {
    if (!iwant.length) {
      return [];
    }
    const score = this.score.score(id);
    if (score < this.opts.scoreThresholds.gossipThreshold) {
      this.log("IWANT: ignoring peer %s with score below threshold [score = %d]", id, score);
      return [];
    }
    const ihave = /* @__PURE__ */ new Map();
    const iwantByTopic = /* @__PURE__ */ new Map();
    let iwantDonthave = 0;
    iwant.forEach(({ messageIDs }) => {
      messageIDs && messageIDs.forEach((msgId2) => {
        const msgIdStr = this.msgIdToStrFn(msgId2);
        const entry = this.mcache.getWithIWantCount(msgIdStr, id);
        if (entry == null) {
          iwantDonthave++;
          return;
        }
        iwantByTopic.set(entry.msg.topic, 1 + (iwantByTopic.get(entry.msg.topic) ?? 0));
        if (entry.count > GossipsubGossipRetransmission) {
          this.log("IWANT: Peer %s has asked for message %s too many times: ignoring request", id, msgId2);
          return;
        }
        ihave.set(msgIdStr, entry.msg);
      });
    });
    this.metrics?.onIwantRcv(iwantByTopic, iwantDonthave);
    if (!ihave.size) {
      this.log("IWANT: Could not provide any wanted messages to %s", id);
      return [];
    }
    this.log("IWANT: Sending %d messages to %s", ihave.size, id);
    return Array.from(ihave.values());
  }
  async handleGraft(id, graft) {
    const prune = [];
    const score = this.score.score(id);
    const now = Date.now();
    let doPX = this.opts.doPX;
    graft.forEach(({ topicID }) => {
      if (!topicID) {
        return;
      }
      const peersInMesh = this.mesh.get(topicID);
      if (!peersInMesh) {
        doPX = false;
        return;
      }
      if (peersInMesh.has(id)) {
        return;
      }
      if (this.direct.has(id)) {
        this.log("GRAFT: ignoring request from direct peer %s", id);
        prune.push(topicID);
        doPX = false;
        return;
      }
      const expire = this.backoff.get(topicID)?.get(id);
      if (typeof expire === "number" && now < expire) {
        this.log("GRAFT: ignoring backed off peer %s", id);
        this.score.addPenalty(id, 1, ScorePenalty.GraftBackoff);
        doPX = false;
        const floodCutoff = expire + this.opts.graftFloodThreshold - this.opts.pruneBackoff;
        if (now < floodCutoff) {
          this.score.addPenalty(id, 1, ScorePenalty.GraftBackoff);
        }
        this.addBackoff(id, topicID);
        prune.push(topicID);
        return;
      }
      if (score < 0) {
        this.log("GRAFT: ignoring peer %s with negative score: score=%d, topic=%s", id, score, topicID);
        prune.push(topicID);
        doPX = false;
        this.addBackoff(id, topicID);
        return;
      }
      if (peersInMesh.size >= this.opts.Dhi && !this.outbound.get(id)) {
        prune.push(topicID);
        this.addBackoff(id, topicID);
        return;
      }
      this.log("GRAFT: Add mesh link from %s in %s", id, topicID);
      this.score.graft(id, topicID);
      peersInMesh.add(id);
      this.metrics?.onAddToMesh(topicID, InclusionReason.Subscribed, 1);
    });
    if (!prune.length) {
      return [];
    }
    return await Promise.all(prune.map((topic) => this.makePrune(id, topic, doPX)));
  }
  async handlePrune(id, prune) {
    const score = this.score.score(id);
    for (const { topicID, backoff, peers } of prune) {
      if (topicID == null) {
        continue;
      }
      const peersInMesh = this.mesh.get(topicID);
      if (!peersInMesh) {
        return;
      }
      this.log("PRUNE: Remove mesh link to %s in %s", id, topicID);
      this.score.prune(id, topicID);
      if (peersInMesh.has(id)) {
        peersInMesh.delete(id);
        this.metrics?.onRemoveFromMesh(topicID, ChurnReason.Unsub, 1);
      }
      if (typeof backoff === "number" && backoff > 0) {
        this.doAddBackoff(id, topicID, backoff * 1e3);
      } else {
        this.addBackoff(id, topicID);
      }
      if (peers && peers.length) {
        if (score < this.opts.scoreThresholds.acceptPXThreshold) {
          this.log("PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]", id, score, topicID);
          continue;
        }
        await this.pxConnect(peers);
      }
    }
  }
  addBackoff(id, topic) {
    this.doAddBackoff(id, topic, this.opts.pruneBackoff);
  }
  doAddBackoff(id, topic, interval) {
    let backoff = this.backoff.get(topic);
    if (!backoff) {
      backoff = /* @__PURE__ */ new Map();
      this.backoff.set(topic, backoff);
    }
    const expire = Date.now() + interval;
    const existingExpire = backoff.get(id) ?? 0;
    if (existingExpire < expire) {
      backoff.set(id, expire);
    }
  }
  applyIwantPenalties() {
    this.gossipTracer.getBrokenPromises().forEach((count, p) => {
      this.log("peer %s didn't follow up in %d IWANT requests; adding penalty", p, count);
      this.score.addPenalty(p, count, ScorePenalty.BrokenPromise);
    });
  }
  clearBackoff() {
    if (this.heartbeatTicks % GossipsubPruneBackoffTicks !== 0) {
      return;
    }
    const now = Date.now();
    this.backoff.forEach((backoff, topic) => {
      backoff.forEach((expire, id) => {
        if (expire < now) {
          backoff.delete(id);
        }
      });
      if (backoff.size === 0) {
        this.backoff.delete(topic);
      }
    });
  }
  async directConnect() {
    const toconnect = [];
    this.direct.forEach((id) => {
      if (!this.streamsOutbound.has(id)) {
        toconnect.push(id);
      }
    });
    await Promise.all(toconnect.map(async (id) => await this.connect(id)));
  }
  async pxConnect(peers) {
    if (peers.length > this.opts.prunePeers) {
      shuffle(peers);
      peers = peers.slice(0, this.opts.prunePeers);
    }
    const toconnect = [];
    await Promise.all(peers.map(async (pi) => {
      if (!pi.peerID) {
        return;
      }
      const p = peerIdFromBytes(pi.peerID).toString();
      if (this.peers.has(p)) {
        return;
      }
      if (!pi.signedPeerRecord) {
        toconnect.push(p);
        return;
      }
      try {
        const envelope = await RecordEnvelope.openAndCertify(pi.signedPeerRecord, "libp2p-peer-record");
        const eid = envelope.peerId;
        if (!envelope.peerId.equals(p)) {
          this.log("bogus peer record obtained through px: peer ID %p doesn't match expected peer %p", eid, p);
          return;
        }
        if (!await this.components.getPeerStore().addressBook.consumePeerRecord(envelope)) {
          this.log("bogus peer record obtained through px: could not add peer record to address book");
          return;
        }
        toconnect.push(p);
      } catch (e) {
        this.log("bogus peer record obtained through px: invalid signature or not a peer record");
      }
    }));
    if (!toconnect.length) {
      return;
    }
    await Promise.all(toconnect.map(async (id) => await this.connect(id)));
  }
  async connect(id) {
    this.log("Initiating connection with %s", id);
    const peerId = peerIdFromString(id);
    const connection = await this.components.getConnectionManager().openConnection(peerId);
    for (const multicodec of this.multicodecs) {
      for (const topology of this.components.getRegistrar().getTopologies(multicodec)) {
        topology.onConnect(peerId, connection);
      }
    }
  }
  subscribe(topic) {
    if (this.status.code !== GossipStatusCode.started) {
      throw new Error("Pubsub has not started");
    }
    if (!this.subscriptions.has(topic)) {
      this.subscriptions.add(topic);
      for (const peerId of this.peers.keys()) {
        this.sendSubscriptions(peerId, [topic], true);
      }
    }
    this.join(topic);
  }
  unsubscribe(topic) {
    if (this.status.code !== GossipStatusCode.started) {
      throw new Error("Pubsub is not started");
    }
    const wasSubscribed = this.subscriptions.delete(topic);
    this.log("unsubscribe from %s - am subscribed %s", topic, wasSubscribed);
    if (wasSubscribed) {
      for (const peerId of this.peers.keys()) {
        this.sendSubscriptions(peerId, [topic], false);
      }
    }
    this.leave(topic).catch((err2) => {
      this.log(err2);
    });
  }
  join(topic) {
    if (this.status.code !== GossipStatusCode.started) {
      throw new Error("Gossipsub has not started");
    }
    if (this.mesh.has(topic)) {
      return;
    }
    this.log("JOIN %s", topic);
    this.metrics?.onJoin(topic);
    const toAdd = /* @__PURE__ */ new Set();
    const fanoutPeers = this.fanout.get(topic);
    if (fanoutPeers) {
      this.fanout.delete(topic);
      this.fanoutLastpub.delete(topic);
      fanoutPeers.forEach((id) => {
        if (!this.direct.has(id) && this.score.score(id) >= 0) {
          toAdd.add(id);
        }
      });
      this.metrics?.onAddToMesh(topic, InclusionReason.Fanout, toAdd.size);
    }
    if (toAdd.size < this.opts.D) {
      const fanoutCount = toAdd.size;
      const newPeers = this.getRandomGossipPeers(topic, this.opts.D, (id) => !toAdd.has(id) && !this.direct.has(id) && this.score.score(id) >= 0);
      newPeers.forEach((peer) => {
        toAdd.add(peer);
      });
      this.metrics?.onAddToMesh(topic, InclusionReason.Random, toAdd.size - fanoutCount);
    }
    this.mesh.set(topic, toAdd);
    toAdd.forEach((id) => {
      this.log("JOIN: Add mesh link to %s in %s", id, topic);
      this.sendGraft(id, topic);
    });
  }
  async leave(topic) {
    if (this.status.code !== GossipStatusCode.started) {
      throw new Error("Gossipsub has not started");
    }
    this.log("LEAVE %s", topic);
    this.metrics?.onLeave(topic);
    const meshPeers = this.mesh.get(topic);
    if (meshPeers) {
      await Promise.all(Array.from(meshPeers).map(async (id) => {
        this.log("LEAVE: Remove mesh link to %s in %s", id, topic);
        return await this.sendPrune(id, topic);
      }));
      this.mesh.delete(topic);
    }
  }
  selectPeersToForward(topic, propagationSource, excludePeers) {
    const tosend = /* @__PURE__ */ new Set();
    const peersInTopic = this.topics.get(topic);
    if (peersInTopic) {
      this.direct.forEach((peer) => {
        if (peersInTopic.has(peer) && propagationSource !== peer && !excludePeers?.has(peer)) {
          tosend.add(peer);
        }
      });
      this.floodsubPeers.forEach((peer) => {
        if (peersInTopic.has(peer) && propagationSource !== peer && !excludePeers?.has(peer) && this.score.score(peer) >= this.opts.scoreThresholds.publishThreshold) {
          tosend.add(peer);
        }
      });
    }
    const meshPeers = this.mesh.get(topic);
    if (meshPeers && meshPeers.size > 0) {
      meshPeers.forEach((peer) => {
        if (propagationSource !== peer && !excludePeers?.has(peer)) {
          tosend.add(peer);
        }
      });
    }
    return tosend;
  }
  selectPeersToPublish(topic) {
    const tosend = /* @__PURE__ */ new Set();
    const tosendCount = {
      direct: 0,
      floodsub: 0,
      mesh: 0,
      fanout: 0
    };
    const peersInTopic = this.topics.get(topic);
    if (peersInTopic) {
      if (this.opts.floodPublish) {
        peersInTopic.forEach((id) => {
          if (this.direct.has(id)) {
            tosend.add(id);
            tosendCount.direct++;
          } else if (this.score.score(id) >= this.opts.scoreThresholds.publishThreshold) {
            tosend.add(id);
            tosendCount.floodsub++;
          }
        });
      } else {
        this.direct.forEach((id) => {
          if (peersInTopic.has(id)) {
            tosend.add(id);
            tosendCount.direct++;
          }
        });
        this.floodsubPeers.forEach((id) => {
          if (peersInTopic.has(id) && this.score.score(id) >= this.opts.scoreThresholds.publishThreshold) {
            tosend.add(id);
            tosendCount.floodsub++;
          }
        });
        const meshPeers = this.mesh.get(topic);
        if (meshPeers && meshPeers.size > 0) {
          meshPeers.forEach((peer) => {
            tosend.add(peer);
            tosendCount.mesh++;
          });
        } else {
          const fanoutPeers = this.fanout.get(topic);
          if (fanoutPeers && fanoutPeers.size > 0) {
            fanoutPeers.forEach((peer) => {
              tosend.add(peer);
              tosendCount.fanout++;
            });
          } else {
            const newFanoutPeers = this.getRandomGossipPeers(topic, this.opts.D, (id) => {
              return this.score.score(id) >= this.opts.scoreThresholds.publishThreshold;
            });
            if (newFanoutPeers.size > 0) {
              this.fanout.set(topic, newFanoutPeers);
              newFanoutPeers.forEach((peer) => {
                tosend.add(peer);
                tosendCount.fanout++;
              });
            }
          }
          this.fanoutLastpub.set(topic, Date.now());
        }
      }
    }
    return { tosend, tosendCount };
  }
  forwardMessage(msgIdStr, rawMsg, propagationSource, excludePeers) {
    if (propagationSource) {
      this.score.deliverMessage(propagationSource, msgIdStr, rawMsg.topic);
    }
    const tosend = this.selectPeersToForward(rawMsg.topic, propagationSource, excludePeers);
    const rpc2 = createGossipRpc([rawMsg]);
    tosend.forEach((id) => {
      this.sendRpc(id, rpc2);
    });
    this.metrics?.onForwardMsg(rawMsg.topic, tosend.size);
  }
  async publish(topic, data) {
    const transformedData = this.dataTransform ? this.dataTransform.outboundTransform(topic, data) : data;
    if (this.publishConfig == null) {
      throw Error("PublishError.Uninitialized");
    }
    const { raw: rawMsg, msg } = await buildRawMessage(this.publishConfig, topic, data, transformedData);
    const msgId2 = await this.msgIdFn(msg);
    const msgIdStr = this.msgIdToStrFn(msgId2);
    if (this.seenCache.has(msgIdStr)) {
      throw Error("PublishError.Duplicate");
    }
    const { tosend, tosendCount } = this.selectPeersToPublish(topic);
    const willSendToSelf = this.opts.emitSelf === true && this.subscriptions.has(topic);
    if (tosend.size === 0 && !this.opts.allowPublishToZeroPeers && !willSendToSelf) {
      throw Error("PublishError.InsufficientPeers");
    }
    this.seenCache.put(msgIdStr);
    this.mcache.put({ msgId: msgId2, msgIdStr }, rawMsg, true);
    this.publishedMessageIds.put(msgIdStr);
    const rpc2 = createGossipRpc([rawMsg]);
    for (const id of tosend) {
      const sent = this.sendRpc(id, rpc2);
      if (!sent) {
        tosend.delete(id);
      }
    }
    this.metrics?.onPublishMsg(topic, tosendCount, tosend.size, rawMsg.data != null ? rawMsg.data.length : 0);
    if (willSendToSelf) {
      tosend.add(this.components.getPeerId().toString());
      super.dispatchEvent(new CustomEvent("gossipsub:message", {
        detail: {
          propagationSource: this.components.getPeerId(),
          msgId: msgIdStr,
          msg
        }
      }));
      super.dispatchEvent(new CustomEvent("message", { detail: msg }));
    }
    return {
      recipients: Array.from(tosend.values()).map((str) => peerIdFromString(str))
    };
  }
  reportMessageValidationResult(msgId2, propagationSource, acceptance) {
    if (acceptance === MessageAcceptance.Accept) {
      const cacheEntry = this.mcache.validate(msgId2);
      this.metrics?.onReportValidationMcacheHit(cacheEntry !== null);
      if (cacheEntry != null) {
        const { message: rawMsg, originatingPeers } = cacheEntry;
        this.score.deliverMessage(propagationSource.toString(), msgId2, rawMsg.topic);
        this.forwardMessage(msgId2, cacheEntry.message, propagationSource.toString(), originatingPeers);
        this.metrics?.onReportValidation(rawMsg.topic, acceptance);
      }
    } else {
      const cacheEntry = this.mcache.remove(msgId2);
      this.metrics?.onReportValidationMcacheHit(cacheEntry !== null);
      if (cacheEntry) {
        const rejectReason = rejectReasonFromAcceptance(acceptance);
        const { message: rawMsg, originatingPeers } = cacheEntry;
        this.score.rejectMessage(propagationSource.toString(), msgId2, rawMsg.topic, rejectReason);
        for (const peer of originatingPeers) {
          this.score.rejectMessage(peer, msgId2, rawMsg.topic, rejectReason);
        }
        this.metrics?.onReportValidation(rawMsg.topic, acceptance);
      }
    }
  }
  sendGraft(id, topic) {
    const graft = [
      {
        topicID: topic
      }
    ];
    const out = createGossipRpc([], { graft });
    this.sendRpc(id, out);
  }
  async sendPrune(id, topic) {
    const prune = [await this.makePrune(id, topic, this.opts.doPX)];
    const out = createGossipRpc([], { prune });
    this.sendRpc(id, out);
  }
  sendRpc(id, rpc2) {
    const outboundStream = this.streamsOutbound.get(id);
    if (!outboundStream) {
      this.log(`Cannot send RPC to ${id} as there is no open stream to it available`);
      return false;
    }
    const ctrl = this.control.get(id);
    if (ctrl) {
      this.piggybackControl(id, rpc2, ctrl);
      this.control.delete(id);
    }
    const ihave = this.gossip.get(id);
    if (ihave) {
      this.piggybackGossip(id, rpc2, ihave);
      this.gossip.delete(id);
    }
    const rpcBytes = RPC$1.encode(rpc2).finish();
    try {
      outboundStream.push(rpcBytes);
    } catch (e) {
      this.log.error(`Cannot send rpc to ${id}`, e);
      if (ctrl) {
        this.control.set(id, ctrl);
      }
      if (ihave) {
        this.gossip.set(id, ihave);
      }
      return false;
    }
    this.metrics?.onRpcSent(rpc2, rpcBytes.length);
    return true;
  }
  piggybackControl(id, outRpc, ctrl) {
    const tograft = (ctrl.graft || []).filter(({ topicID }) => (topicID && this.mesh.get(topicID) || /* @__PURE__ */ new Set()).has(id));
    const toprune = (ctrl.prune || []).filter(({ topicID }) => !(topicID && this.mesh.get(topicID) || /* @__PURE__ */ new Set()).has(id));
    if (!tograft.length && !toprune.length) {
      return;
    }
    if (outRpc.control) {
      outRpc.control.graft = outRpc.control.graft && outRpc.control.graft.concat(tograft);
      outRpc.control.prune = outRpc.control.prune && outRpc.control.prune.concat(toprune);
    } else {
      outRpc.control = { graft: tograft, prune: toprune, ihave: [], iwant: [] };
    }
  }
  piggybackGossip(id, outRpc, ihave) {
    if (!outRpc.control) {
      outRpc.control = { ihave: [], iwant: [], graft: [], prune: [] };
    }
    outRpc.control.ihave = ihave;
  }
  async sendGraftPrune(tograft, toprune, noPX) {
    const doPX = this.opts.doPX;
    for (const [id, topics] of tograft) {
      const graft = topics.map((topicID) => ({ topicID }));
      let prune = [];
      const pruning = toprune.get(id);
      if (pruning) {
        prune = await Promise.all(pruning.map(async (topicID) => await this.makePrune(id, topicID, doPX && !(noPX.get(id) ?? false))));
        toprune.delete(id);
      }
      const outRpc = createGossipRpc([], { graft, prune });
      this.sendRpc(id, outRpc);
    }
    for (const [id, topics] of toprune) {
      const prune = await Promise.all(topics.map(async (topicID) => await this.makePrune(id, topicID, doPX && !(noPX.get(id) ?? false))));
      const outRpc = createGossipRpc([], { prune });
      this.sendRpc(id, outRpc);
    }
  }
  emitGossip(peersToGossipByTopic) {
    const gossipIDsByTopic = this.mcache.getGossipIDs(new Set(peersToGossipByTopic.keys()));
    for (const [topic, peersToGossip] of peersToGossipByTopic) {
      this.doEmitGossip(topic, peersToGossip, gossipIDsByTopic.get(topic) ?? []);
    }
  }
  doEmitGossip(topic, candidateToGossip, messageIDs) {
    if (!messageIDs.length) {
      return;
    }
    shuffle(messageIDs);
    if (messageIDs.length > GossipsubMaxIHaveLength) {
      this.log("too many messages for gossip; will truncate IHAVE list (%d messages)", messageIDs.length);
    }
    if (!candidateToGossip.size)
      return;
    let target = this.opts.Dlazy;
    const factor = GossipsubGossipFactor * candidateToGossip.size;
    let peersToGossip = candidateToGossip;
    if (factor > target) {
      target = factor;
    }
    if (target > peersToGossip.size) {
      target = peersToGossip.size;
    } else {
      peersToGossip = shuffle(Array.from(peersToGossip)).slice(0, target);
    }
    peersToGossip.forEach((id) => {
      let peerMessageIDs = messageIDs;
      if (messageIDs.length > GossipsubMaxIHaveLength) {
        peerMessageIDs = shuffle(peerMessageIDs.slice()).slice(0, GossipsubMaxIHaveLength);
      }
      this.pushGossip(id, {
        topicID: topic,
        messageIDs: peerMessageIDs
      });
    });
  }
  flush() {
    for (const [peer, ihave] of this.gossip.entries()) {
      this.gossip.delete(peer);
      this.sendRpc(peer, createGossipRpc([], { ihave }));
    }
    for (const [peer, control] of this.control.entries()) {
      this.control.delete(peer);
      this.sendRpc(peer, createGossipRpc([], { graft: control.graft, prune: control.prune }));
    }
  }
  pushGossip(id, controlIHaveMsgs) {
    this.log("Add gossip to %s", id);
    const gossip = this.gossip.get(id) || [];
    this.gossip.set(id, gossip.concat(controlIHaveMsgs));
  }
  async makePrune(id, topic, doPX) {
    this.score.prune(id, topic);
    if (this.streamsOutbound.get(id).protocol === GossipsubIDv10) {
      return {
        topicID: topic,
        peers: []
      };
    }
    const backoff = this.opts.pruneBackoff / 1e3;
    if (!doPX) {
      return {
        topicID: topic,
        peers: [],
        backoff
      };
    }
    const peers = this.getRandomGossipPeers(topic, this.opts.prunePeers, (xid) => {
      return xid !== id && this.score.score(xid) >= 0;
    });
    const px = await Promise.all(Array.from(peers).map(async (peerId) => {
      const id2 = peerIdFromString(peerId);
      return {
        peerID: id2.toBytes(),
        signedPeerRecord: await this.components.getPeerStore().addressBook.getRawEnvelope(id2)
      };
    }));
    return {
      topicID: topic,
      peers: px,
      backoff
    };
  }
  async heartbeat() {
    const { D, Dlo, Dhi, Dscore, Dout, fanoutTTL } = this.opts;
    this.heartbeatTicks++;
    const scores = /* @__PURE__ */ new Map();
    const getScore = (id) => {
      let s2 = scores.get(id);
      if (s2 === void 0) {
        s2 = this.score.score(id);
        scores.set(id, s2);
      }
      return s2;
    };
    const tograft = /* @__PURE__ */ new Map();
    const toprune = /* @__PURE__ */ new Map();
    const noPX = /* @__PURE__ */ new Map();
    this.clearBackoff();
    this.peerhave.clear();
    this.metrics?.cacheSize.set({ cache: "iasked" }, this.iasked.size);
    this.iasked.clear();
    this.applyIwantPenalties();
    if (this.heartbeatTicks % this.opts.directConnectTicks === 0) {
      await this.directConnect();
    }
    this.fastMsgIdCache?.prune();
    this.seenCache.prune();
    this.gossipTracer.prune();
    this.publishedMessageIds.prune();
    const peersToGossipByTopic = /* @__PURE__ */ new Map();
    this.mesh.forEach((peers, topic) => {
      const peersInTopic = this.topics.get(topic);
      const candidateMeshPeers = /* @__PURE__ */ new Set();
      const peersToGossip = /* @__PURE__ */ new Set();
      peersToGossipByTopic.set(topic, peersToGossip);
      if (peersInTopic) {
        const shuffledPeers = shuffle(Array.from(peersInTopic));
        const backoff = this.backoff.get(topic);
        for (const id of shuffledPeers) {
          const peerStreams = this.streamsOutbound.get(id);
          if (peerStreams && this.multicodecs.includes(peerStreams.protocol) && !peers.has(id) && !this.direct.has(id)) {
            const score = getScore(id);
            if ((!backoff || !backoff.has(id)) && score >= 0)
              candidateMeshPeers.add(id);
            if (score >= this.opts.scoreThresholds.gossipThreshold)
              peersToGossip.add(id);
          }
        }
      }
      const prunePeer = (id, reason) => {
        this.log("HEARTBEAT: Remove mesh link to %s in %s", id, topic);
        this.addBackoff(id, topic);
        peers.delete(id);
        if (getScore(id) >= this.opts.scoreThresholds.gossipThreshold)
          peersToGossip.add(id);
        this.metrics?.onRemoveFromMesh(topic, reason, 1);
        const topics = toprune.get(id);
        if (!topics) {
          toprune.set(id, [topic]);
        } else {
          topics.push(topic);
        }
      };
      const graftPeer = (id, reason) => {
        this.log("HEARTBEAT: Add mesh link to %s in %s", id, topic);
        this.score.graft(id, topic);
        peers.add(id);
        peersToGossip.delete(id);
        this.metrics?.onAddToMesh(topic, reason, 1);
        const topics = tograft.get(id);
        if (!topics) {
          tograft.set(id, [topic]);
        } else {
          topics.push(topic);
        }
      };
      peers.forEach((id) => {
        const score = getScore(id);
        if (score < 0) {
          this.log("HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s", id, score, topic);
          prunePeer(id, ChurnReason.BadScore);
          noPX.set(id, true);
        }
      });
      if (peers.size < Dlo) {
        const ineed = D - peers.size;
        const newMeshPeers = removeFirstNItemsFromSet(candidateMeshPeers, ineed);
        newMeshPeers.forEach((p) => {
          graftPeer(p, InclusionReason.NotEnough);
        });
      }
      if (peers.size > Dhi) {
        let peersArray = Array.from(peers);
        peersArray.sort((a, b2) => getScore(b2) - getScore(a));
        peersArray = peersArray.slice(0, Dscore).concat(shuffle(peersArray.slice(Dscore)));
        let outbound = 0;
        peersArray.slice(0, D).forEach((p) => {
          if (this.outbound.get(p)) {
            outbound++;
          }
        });
        if (outbound < Dout) {
          const rotate = (i2) => {
            const p = peersArray[i2];
            for (let j = i2; j > 0; j--) {
              peersArray[j] = peersArray[j - 1];
            }
            peersArray[0] = p;
          };
          if (outbound > 0) {
            let ihave = outbound;
            for (let i2 = 1; i2 < D && ihave > 0; i2++) {
              if (this.outbound.get(peersArray[i2])) {
                rotate(i2);
                ihave--;
              }
            }
          }
          let ineed = D - outbound;
          for (let i2 = D; i2 < peersArray.length && ineed > 0; i2++) {
            if (this.outbound.get(peersArray[i2])) {
              rotate(i2);
              ineed--;
            }
          }
        }
        peersArray.slice(D).forEach((p) => {
          prunePeer(p, ChurnReason.Excess);
        });
      }
      if (peers.size >= Dlo) {
        let outbound = 0;
        peers.forEach((p) => {
          if (this.outbound.get(p)) {
            outbound++;
          }
        });
        if (outbound < Dout) {
          const ineed = Dout - outbound;
          const newMeshPeers = removeItemsFromSet(candidateMeshPeers, ineed, (id) => this.outbound.get(id) === true);
          newMeshPeers.forEach((p) => {
            graftPeer(p, InclusionReason.Outbound);
          });
        }
      }
      if (this.heartbeatTicks % this.opts.opportunisticGraftTicks === 0 && peers.size > 1) {
        const peersList = Array.from(peers).sort((a, b2) => getScore(a) - getScore(b2));
        const medianIndex = Math.floor(peers.size / 2);
        const medianScore = getScore(peersList[medianIndex]);
        if (medianScore < this.opts.scoreThresholds.opportunisticGraftThreshold) {
          const ineed = this.opts.opportunisticGraftPeers;
          const newMeshPeers = removeItemsFromSet(candidateMeshPeers, ineed, (id) => getScore(id) > medianScore);
          for (const id of newMeshPeers) {
            this.log("HEARTBEAT: Opportunistically graft peer %s on topic %s", id, topic);
            graftPeer(id, InclusionReason.Opportunistic);
          }
        }
      }
    });
    const now = Date.now();
    this.fanoutLastpub.forEach((lastpb, topic) => {
      if (lastpb + fanoutTTL < now) {
        this.fanout.delete(topic);
        this.fanoutLastpub.delete(topic);
      }
    });
    this.fanout.forEach((fanoutPeers, topic) => {
      const topicPeers = this.topics.get(topic);
      fanoutPeers.forEach((id) => {
        if (!topicPeers.has(id) || getScore(id) < this.opts.scoreThresholds.publishThreshold) {
          fanoutPeers.delete(id);
        }
      });
      const peersInTopic = this.topics.get(topic);
      const candidateFanoutPeers = [];
      const peersToGossip = /* @__PURE__ */ new Set();
      peersToGossipByTopic.set(topic, peersToGossip);
      if (peersInTopic) {
        const shuffledPeers = shuffle(Array.from(peersInTopic));
        for (const id of shuffledPeers) {
          const peerStreams = this.streamsOutbound.get(id);
          if (peerStreams && this.multicodecs.includes(peerStreams.protocol) && !fanoutPeers.has(id) && !this.direct.has(id)) {
            const score = getScore(id);
            if (score >= this.opts.scoreThresholds.publishThreshold)
              candidateFanoutPeers.push(id);
            if (score >= this.opts.scoreThresholds.gossipThreshold)
              peersToGossip.add(id);
          }
        }
      }
      if (fanoutPeers.size < D) {
        const ineed = D - fanoutPeers.size;
        candidateFanoutPeers.slice(0, ineed).forEach((id) => {
          fanoutPeers.add(id);
          peersToGossip?.delete(id);
        });
      }
    });
    this.emitGossip(peersToGossipByTopic);
    await this.sendGraftPrune(tograft, toprune, noPX);
    this.flush();
    this.mcache.shift();
    this.dispatchEvent(new CustomEvent("gossipsub:heartbeat"));
  }
  getRandomGossipPeers(topic, count, filter2 = () => true) {
    const peersInTopic = this.topics.get(topic);
    if (!peersInTopic) {
      return /* @__PURE__ */ new Set();
    }
    let peers = [];
    peersInTopic.forEach((id) => {
      const peerStreams = this.streamsOutbound.get(id);
      if (!peerStreams) {
        return;
      }
      if (this.multicodecs.includes(peerStreams.protocol) && filter2(id)) {
        peers.push(id);
      }
    });
    peers = shuffle(peers);
    if (count > 0 && peers.length > count) {
      peers = peers.slice(0, count);
    }
    return new Set(peers);
  }
  onScrapeMetrics(metrics) {
    metrics.mcacheSize.set(this.mcache.size);
    metrics.cacheSize.set({ cache: "direct" }, this.direct.size);
    metrics.cacheSize.set({ cache: "seenCache" }, this.seenCache.size);
    metrics.cacheSize.set({ cache: "fastMsgIdCache" }, this.fastMsgIdCache?.size ?? 0);
    metrics.cacheSize.set({ cache: "publishedMessageIds" }, this.publishedMessageIds.size);
    metrics.cacheSize.set({ cache: "mcache" }, this.mcache.size);
    metrics.cacheSize.set({ cache: "score" }, this.score.size);
    metrics.cacheSize.set({ cache: "gossipTracer.promises" }, this.gossipTracer.size);
    metrics.cacheSize.set({ cache: "gossipTracer.requests" }, this.gossipTracer.requestMsByMsgSize);
    metrics.cacheSize.set({ cache: "topics" }, this.topics.size);
    metrics.cacheSize.set({ cache: "subscriptions" }, this.subscriptions.size);
    metrics.cacheSize.set({ cache: "mesh" }, this.mesh.size);
    metrics.cacheSize.set({ cache: "fanout" }, this.fanout.size);
    metrics.cacheSize.set({ cache: "peers" }, this.peers.size);
    metrics.cacheSize.set({ cache: "streamsOutbound" }, this.streamsOutbound.size);
    metrics.cacheSize.set({ cache: "streamsInbound" }, this.streamsInbound.size);
    metrics.cacheSize.set({ cache: "acceptFromWhitelist" }, this.acceptFromWhitelist.size);
    metrics.cacheSize.set({ cache: "gossip" }, this.gossip.size);
    metrics.cacheSize.set({ cache: "control" }, this.control.size);
    metrics.cacheSize.set({ cache: "peerhave" }, this.peerhave.size);
    metrics.cacheSize.set({ cache: "outbound" }, this.outbound.size);
    let backoffSize = 0;
    for (const backoff of this.backoff.values()) {
      backoffSize += backoff.size;
    }
    metrics.cacheSize.set({ cache: "backoff" }, backoffSize);
    for (const [topicStr, peers] of this.topics) {
      metrics.topicPeersCount.set({ topicStr }, peers.size);
    }
    for (const [topicStr, peers] of this.mesh) {
      metrics.meshPeerCounts.set({ topicStr }, peers.size);
    }
    const scores = [];
    const scoreByPeer = /* @__PURE__ */ new Map();
    metrics.behaviourPenalty.reset();
    for (const peerIdStr of this.peers.keys()) {
      const score = this.score.score(peerIdStr);
      scores.push(score);
      scoreByPeer.set(peerIdStr, score);
      metrics.behaviourPenalty.observe(this.score.peerStats.get(peerIdStr)?.behaviourPenalty ?? 0);
    }
    metrics.registerScores(scores, this.opts.scoreThresholds);
    metrics.registerScorePerMesh(this.mesh, scoreByPeer);
    const sw = computeAllPeersScoreWeights(this.peers.keys(), this.score.peerStats, this.score.params, this.score.peerIPs, metrics.topicStrToLabel);
    metrics.registerScoreWeights(sw);
  }
}
GossipSub.multicodec = GossipsubIDv11;
const routers = () => ({
  gossipsub: (components) => {
    const gossipsub = new GossipSub({
      allowPublishToZeroPeers: true,
      fallbackToFloodsub: true,
      emitSelf: true,
      maxInboundStreams: 64,
      maxOutboundStreams: 128
    });
    gossipsub.init({
      getPeerId() {
        return components.peerId;
      },
      getPeerStore() {
        return components.peerStore;
      },
      getRegistrar() {
        return components.registrar;
      },
      getConnectionManager() {
        return components.connectionManager;
      }
    });
    return gossipsub;
  }
});
const log$W = logger$1("libp2p-delegated-peer-routing");
const DEFAULT_TIMEOUT$1 = 3e4;
const CONCURRENT_HTTP_REQUESTS$1 = 4;
var EventTypes$1;
(function(EventTypes2) {
  EventTypes2[EventTypes2["SENDING_QUERY"] = 0] = "SENDING_QUERY";
  EventTypes2[EventTypes2["PEER_RESPONSE"] = 1] = "PEER_RESPONSE";
  EventTypes2[EventTypes2["FINAL_PEER"] = 2] = "FINAL_PEER";
  EventTypes2[EventTypes2["QUERY_ERROR"] = 3] = "QUERY_ERROR";
  EventTypes2[EventTypes2["PROVIDER"] = 4] = "PROVIDER";
  EventTypes2[EventTypes2["VALUE"] = 5] = "VALUE";
  EventTypes2[EventTypes2["ADDING_PEER"] = 6] = "ADDING_PEER";
  EventTypes2[EventTypes2["DIALING_PEER"] = 7] = "DIALING_PEER";
})(EventTypes$1 || (EventTypes$1 = {}));
var MessageType$1;
(function(MessageType2) {
  MessageType2[MessageType2["PUT_VALUE"] = 0] = "PUT_VALUE";
  MessageType2[MessageType2["GET_VALUE"] = 1] = "GET_VALUE";
  MessageType2[MessageType2["ADD_PROVIDER"] = 2] = "ADD_PROVIDER";
  MessageType2[MessageType2["GET_PROVIDERS"] = 3] = "GET_PROVIDERS";
  MessageType2[MessageType2["FIND_NODE"] = 4] = "FIND_NODE";
  MessageType2[MessageType2["PING"] = 5] = "PING";
})(MessageType$1 || (MessageType$1 = {}));
class DelegatedPeerRouting {
  constructor(client) {
    if (client == null) {
      throw new Error("missing ipfs http client");
    }
    this.client = client;
    this.started = false;
    this.abortController = new AbortController();
    this.httpQueue = new PQueue({
      concurrency: CONCURRENT_HTTP_REQUESTS$1
    });
    const { protocol: protocol2, host, port } = client.getEndpointConfig();
    log$W(`enabled DelegatedPeerRouting via ${protocol2}://${host}:${port}`);
  }
  isStarted() {
    return this.started;
  }
  start() {
    this.started = true;
  }
  stop() {
    this.httpQueue.clear();
    this.abortController.abort();
    this.abortController = new AbortController();
    this.started = false;
  }
  async findPeer(id, options = {}) {
    log$W("findPeer starts: %p", id);
    options.timeout = options.timeout ?? DEFAULT_TIMEOUT$1;
    options.signal = anySignal$2.exports([this.abortController.signal].concat(options.signal != null ? [options.signal] : []));
    const onStart = pDefer$1();
    const onFinish = pDefer$1();
    void this.httpQueue.add(async () => {
      onStart.resolve();
      return await onFinish.promise;
    });
    try {
      await onStart.promise;
      for await (const event of this.client.dht.findPeer(id, options)) {
        if (event.name === "FINAL_PEER") {
          const peerInfo = {
            id: event.peer.id,
            multiaddrs: event.peer.multiaddrs,
            protocols: []
          };
          return peerInfo;
        }
      }
    } catch (err2) {
      log$W.error("findPeer errored: %o", err2);
      throw err2;
    } finally {
      onFinish.resolve();
      log$W("findPeer finished: %p", id);
    }
    throw errCode(new Error("Not found"), "ERR_NOT_FOUND");
  }
  async *getClosestPeers(key, options = {}) {
    let cidOrPeerId;
    const cid = CID.asCID(key);
    if (cid != null) {
      cidOrPeerId = cid;
    } else {
      cidOrPeerId = peerIdFromBytes(key);
    }
    log$W("getClosestPeers starts: %s", cidOrPeerId);
    options.timeout = options.timeout ?? DEFAULT_TIMEOUT$1;
    options.signal = anySignal$2.exports([this.abortController.signal].concat(options.signal != null ? [options.signal] : []));
    const onStart = pDefer$1();
    const onFinish = pDefer$1();
    void this.httpQueue.add(async () => {
      onStart.resolve();
      return await onFinish.promise;
    });
    try {
      await onStart.promise;
      for await (const event of this.client.dht.query(cidOrPeerId, options)) {
        if (event.name === "PEER_RESPONSE") {
          yield* event.closer.map((closer) => ({
            id: closer.id,
            multiaddrs: closer.multiaddrs,
            protocols: []
          }));
        }
      }
    } catch (err2) {
      log$W.error("getClosestPeers errored:", err2);
      throw err2;
    } finally {
      onFinish.resolve();
      log$W("getClosestPeers finished: %b", key);
    }
  }
}
function delegatedPeerRouting(client) {
  return () => new DelegatedPeerRouting(client);
}
const log$V = logger$1("libp2p:delegated-content-routing");
const DEFAULT_TIMEOUT = 3e4;
const CONCURRENT_HTTP_REQUESTS = 4;
const CONCURRENT_HTTP_REFS_REQUESTS = 2;
var EventTypes;
(function(EventTypes2) {
  EventTypes2[EventTypes2["SENDING_QUERY"] = 0] = "SENDING_QUERY";
  EventTypes2[EventTypes2["PEER_RESPONSE"] = 1] = "PEER_RESPONSE";
  EventTypes2[EventTypes2["FINAL_PEER"] = 2] = "FINAL_PEER";
  EventTypes2[EventTypes2["QUERY_ERROR"] = 3] = "QUERY_ERROR";
  EventTypes2[EventTypes2["PROVIDER"] = 4] = "PROVIDER";
  EventTypes2[EventTypes2["VALUE"] = 5] = "VALUE";
  EventTypes2[EventTypes2["ADDING_PEER"] = 6] = "ADDING_PEER";
  EventTypes2[EventTypes2["DIALING_PEER"] = 7] = "DIALING_PEER";
})(EventTypes || (EventTypes = {}));
var MessageType;
(function(MessageType2) {
  MessageType2[MessageType2["PUT_VALUE"] = 0] = "PUT_VALUE";
  MessageType2[MessageType2["GET_VALUE"] = 1] = "GET_VALUE";
  MessageType2[MessageType2["ADD_PROVIDER"] = 2] = "ADD_PROVIDER";
  MessageType2[MessageType2["GET_PROVIDERS"] = 3] = "GET_PROVIDERS";
  MessageType2[MessageType2["FIND_NODE"] = 4] = "FIND_NODE";
  MessageType2[MessageType2["PING"] = 5] = "PING";
})(MessageType || (MessageType = {}));
class DelegatedContentRouting {
  constructor(client) {
    if (client == null) {
      throw new Error("missing ipfs http client");
    }
    this.client = client;
    this.started = false;
    this.abortController = new AbortController();
    this.httpQueue = new PQueue({
      concurrency: CONCURRENT_HTTP_REQUESTS
    });
    this.httpQueueRefs = new PQueue({
      concurrency: CONCURRENT_HTTP_REFS_REQUESTS
    });
    const { protocol: protocol2, host, port } = client.getEndpointConfig();
    log$V(`enabled DelegatedContentRouting via ${protocol2}://${host}:${port}`);
  }
  isStarted() {
    return this.started;
  }
  start() {
    this.started = true;
  }
  stop() {
    this.httpQueue.clear();
    this.httpQueueRefs.clear();
    this.abortController.abort();
    this.abortController = new AbortController();
    this.started = false;
  }
  async *findProviders(key, options = {}) {
    log$V("findProviders starts: %c", key);
    options.timeout = options.timeout ?? DEFAULT_TIMEOUT;
    options.signal = anySignal$2.exports([this.abortController.signal].concat(options.signal != null ? [options.signal] : []));
    const onStart = pDefer$1();
    const onFinish = pDefer$1();
    void this.httpQueue.add(async () => {
      onStart.resolve();
      return await onFinish.promise;
    });
    try {
      await onStart.promise;
      for await (const event of this.client.dht.findProvs(key, options)) {
        if (event.name === "PROVIDER") {
          yield* event.providers.map((prov) => {
            const peerInfo = {
              id: prov.id,
              protocols: [],
              multiaddrs: prov.multiaddrs
            };
            return peerInfo;
          });
        }
      }
    } catch (err2) {
      log$V.error("findProviders errored:", err2);
      throw err2;
    } finally {
      onFinish.resolve();
      log$V("findProviders finished: %c", key);
    }
  }
  async provide(key, options = {}) {
    log$V("provide starts: %c", key);
    options.timeout = options.timeout ?? DEFAULT_TIMEOUT;
    options.signal = anySignal$2.exports([this.abortController.signal].concat(options.signal != null ? [options.signal] : []));
    await this.httpQueueRefs.add(async () => {
      await this.client.block.stat(key, options);
      await itDrain(this.client.dht.provide(key, options));
    });
    log$V("provide finished: %c", key);
  }
  async put(key, value2, options = {}) {
    log$V("put value start: %b", key);
    options.timeout = options.timeout ?? DEFAULT_TIMEOUT;
    options.signal = anySignal$2.exports([this.abortController.signal].concat(options.signal != null ? [options.signal] : []));
    await this.httpQueue.add(async () => {
      await itDrain(this.client.dht.put(key, value2, options));
    });
    log$V("put value finished: %b", key);
  }
  async get(key, options = {}) {
    log$V("get value start: %b", key);
    options.timeout = options.timeout ?? DEFAULT_TIMEOUT;
    options.signal = anySignal$2.exports([this.abortController.signal].concat(options.signal != null ? [options.signal] : []));
    return await this.httpQueue.add(async () => {
      for await (const event of this.client.dht.get(key, options)) {
        if (event.name === "VALUE") {
          log$V("get value finished: %b", key);
          return event.value;
        }
      }
      throw errCode(new Error("Not found"), "ERR_NOT_FOUND");
    });
  }
}
function delegatedContentRouting(client) {
  return () => new DelegatedContentRouting(client);
}
const LOAD_BASE = (name2) => Promise.reject(new Error(`No base found for "${name2}"`));
class Multibases {
  constructor(options) {
    this._basesByName = {};
    this._basesByPrefix = {};
    this._loadBase = options.loadBase || LOAD_BASE;
    for (const base3 of options.bases) {
      this.addBase(base3);
    }
  }
  addBase(base3) {
    if (this._basesByName[base3.name] || this._basesByPrefix[base3.prefix]) {
      throw new Error(`Codec already exists for codec "${base3.name}"`);
    }
    this._basesByName[base3.name] = base3;
    this._basesByPrefix[base3.prefix] = base3;
  }
  removeBase(base3) {
    delete this._basesByName[base3.name];
    delete this._basesByPrefix[base3.prefix];
  }
  async getBase(nameOrPrefix) {
    if (this._basesByName[nameOrPrefix]) {
      return this._basesByName[nameOrPrefix];
    }
    if (this._basesByPrefix[nameOrPrefix]) {
      return this._basesByPrefix[nameOrPrefix];
    }
    const base3 = await this._loadBase(nameOrPrefix);
    if (this._basesByName[base3.name] == null && this._basesByPrefix[base3.prefix] == null) {
      this.addBase(base3);
    }
    return base3;
  }
  listBases() {
    return Object.values(this._basesByName);
  }
}
const LOAD_CODEC = (codeOrName) => Promise.reject(new Error(`No codec found for "${codeOrName}"`));
class Multicodecs {
  constructor(options) {
    this._codecsByName = {};
    this._codecsByCode = {};
    this._loadCodec = options.loadCodec || LOAD_CODEC;
    for (const codec of options.codecs) {
      this.addCodec(codec);
    }
  }
  addCodec(codec) {
    if (this._codecsByName[codec.name] || this._codecsByCode[codec.code]) {
      throw new Error(`Resolver already exists for codec "${codec.name}"`);
    }
    this._codecsByName[codec.name] = codec;
    this._codecsByCode[codec.code] = codec;
  }
  removeCodec(codec) {
    delete this._codecsByName[codec.name];
    delete this._codecsByCode[codec.code];
  }
  async getCodec(code2) {
    const table2 = typeof code2 === "string" ? this._codecsByName : this._codecsByCode;
    if (table2[code2]) {
      return table2[code2];
    }
    const codec = await this._loadCodec(code2);
    if (table2[code2] == null) {
      this.addCodec(codec);
    }
    return codec;
  }
  listCodecs() {
    return Object.values(this._codecsByName);
  }
}
const LOAD_HASHER = (codeOrName) => Promise.reject(new Error(`No hasher found for "${codeOrName}"`));
class Multihashes {
  constructor(options) {
    this._hashersByName = {};
    this._hashersByCode = {};
    this._loadHasher = options.loadHasher || LOAD_HASHER;
    for (const hasher of options.hashers) {
      this.addHasher(hasher);
    }
  }
  addHasher(hasher) {
    if (this._hashersByName[hasher.name] || this._hashersByCode[hasher.code]) {
      throw new Error(`Resolver already exists for codec "${hasher.name}"`);
    }
    this._hashersByName[hasher.name] = hasher;
    this._hashersByCode[hasher.code] = hasher;
  }
  removeHasher(hasher) {
    delete this._hashersByName[hasher.name];
    delete this._hashersByCode[hasher.code];
  }
  async getHasher(code2) {
    const table2 = typeof code2 === "string" ? this._hashersByName : this._hashersByCode;
    if (table2[code2]) {
      return table2[code2];
    }
    const hasher = await this._loadHasher(code2);
    if (table2[code2] == null) {
      this.addHasher(hasher);
    }
    return hasher;
  }
  listHashers() {
    return Object.values(this._hashersByName);
  }
}
function toUrlString(url2) {
  try {
    url2 = multiaddrToUri(multiaddr(url2));
  } catch (err2) {
  }
  url2 = url2.toString();
  return url2;
}
const getAgent = () => {
};
const log$U = logger$1("ipfs-http-client:lib:error-handler");
const merge = mergeOptions$g.bind({ ignoreUndefined: true });
const DEFAULT_PROTOCOL = env.isBrowser || env.isWebWorker ? location.protocol : "http";
const DEFAULT_HOST = env.isBrowser || env.isWebWorker ? location.hostname : "localhost";
const DEFAULT_PORT = env.isBrowser || env.isWebWorker ? location.port : "5001";
const normalizeOptions = (options = {}) => {
  let url2;
  let opts = {};
  let agent;
  if (typeof options === "string" || isMultiaddr(options)) {
    url2 = new URL(toUrlString(options));
  } else if (options instanceof URL) {
    url2 = options;
  } else if (typeof options.url === "string" || isMultiaddr(options.url)) {
    url2 = new URL(toUrlString(options.url));
    opts = options;
  } else if (options.url instanceof URL) {
    url2 = options.url;
    opts = options;
  } else {
    opts = options || {};
    const protocol2 = (opts.protocol || DEFAULT_PROTOCOL).replace(":", "");
    const host = (opts.host || DEFAULT_HOST).split(":")[0];
    const port = opts.port || DEFAULT_PORT;
    url2 = new URL(`${protocol2}://${host}:${port}`);
  }
  if (opts.apiPath) {
    url2.pathname = opts.apiPath;
  } else if (url2.pathname === "/" || url2.pathname === void 0) {
    url2.pathname = "api/v0";
  }
  if (env.isNode) {
    const Agent = getAgent();
    agent = opts.agent || new Agent({
      keepAlive: true,
      maxSockets: 6
    });
  }
  return {
    ...opts,
    host: url2.host,
    protocol: url2.protocol.replace(":", ""),
    port: Number(url2.port),
    apiPath: url2.pathname,
    url: url2,
    agent
  };
};
const errorHandler = async (response) => {
  let msg;
  try {
    if ((response.headers.get("Content-Type") || "").startsWith("application/json")) {
      const data = await response.json();
      log$U(data);
      msg = data.Message || data.message;
    } else {
      msg = await response.text();
    }
  } catch (err2) {
    log$U("Failed to parse error response", err2);
    msg = err2.message;
  }
  let error2 = new http.HTTPError(response);
  if (msg) {
    if (msg.includes("deadline has elapsed")) {
      error2 = new http.TimeoutError();
    }
    if (msg && msg.includes("context deadline exceeded")) {
      error2 = new http.TimeoutError();
    }
  }
  if (msg && msg.includes("request timed out")) {
    error2 = new http.TimeoutError();
  }
  if (msg) {
    error2.message = msg;
  }
  throw error2;
};
const KEBAB_REGEX = /[A-Z\u00C0-\u00D6\u00D8-\u00DE]/g;
const kebabCase = (str) => {
  return str.replace(KEBAB_REGEX, function(match) {
    return "-" + match.toLowerCase();
  });
};
const parseTimeout = (value2) => {
  return typeof value2 === "string" ? parse$3(value2) : value2;
};
class Client extends http {
  constructor(options = {}) {
    const opts = normalizeOptions(options);
    super({
      timeout: parseTimeout(opts.timeout || 0) || void 0,
      headers: opts.headers,
      base: `${opts.url}`,
      handleError: errorHandler,
      transformSearchParams: (search) => {
        const out = new URLSearchParams();
        for (const [key, value2] of search) {
          if (value2 !== "undefined" && value2 !== "null" && key !== "signal") {
            out.append(kebabCase(key), value2);
          }
          if (key === "timeout" && !isNaN(value2)) {
            out.append(kebabCase(key), value2);
          }
        }
        return out;
      },
      agent: opts.agent
    });
    delete this.get;
    delete this.put;
    delete this.delete;
    delete this.options;
    const fetch2 = this.fetch;
    this.fetch = (resource, options2 = {}) => {
      if (typeof resource === "string" && !resource.startsWith("/")) {
        resource = `${opts.url}/${resource}`;
      }
      return fetch2.call(this, resource, merge(options2, {
        method: "POST"
      }));
    };
  }
}
http.HTTPError;
const configure = (fn) => {
  return (options) => {
    return fn(new Client(options), options);
  };
};
function modeToString$1(mode) {
  if (mode == null) {
    return void 0;
  }
  if (typeof mode === "string") {
    return mode;
  }
  return mode.toString(8).padStart(4, "0");
}
function parseMtime(input) {
  if (input == null) {
    return void 0;
  }
  let mtime;
  if (input.secs != null) {
    mtime = {
      secs: input.secs,
      nsecs: input.nsecs
    };
  }
  if (input.Seconds != null) {
    mtime = {
      secs: input.Seconds,
      nsecs: input.FractionalNanoseconds
    };
  }
  if (Array.isArray(input)) {
    mtime = {
      secs: input[0],
      nsecs: input[1]
    };
  }
  if (input instanceof Date) {
    const ms2 = input.getTime();
    const secs = Math.floor(ms2 / 1e3);
    mtime = {
      secs,
      nsecs: (ms2 - secs * 1e3) * 1e3
    };
  }
  if (!Object.prototype.hasOwnProperty.call(mtime, "secs")) {
    return void 0;
  }
  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
    throw errCode(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS");
  }
  return mtime;
}
function toUrlSearchParams({ arg, searchParams, hashAlg, mtime, mode, ...options } = {}) {
  if (searchParams) {
    options = {
      ...options,
      ...searchParams
    };
  }
  if (hashAlg) {
    options.hash = hashAlg;
  }
  if (mtime != null) {
    mtime = parseMtime(mtime);
    options.mtime = mtime.secs;
    options.mtimeNsecs = mtime.nsecs;
  }
  if (mode != null) {
    options.mode = modeToString$1(mode);
  }
  if (options.timeout && !isNaN(options.timeout)) {
    options.timeout = `${options.timeout}ms`;
  }
  if (arg === void 0 || arg === null) {
    arg = [];
  } else if (!Array.isArray(arg)) {
    arg = [arg];
  }
  const urlSearchParams = new URLSearchParams(options);
  arg.forEach((arg2) => urlSearchParams.append("arg", arg2));
  return urlSearchParams;
}
const createWantlist = configure((api2) => {
  async function wantlist(options = {}) {
    const res = await (await api2.post("bitswap/wantlist", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    })).json();
    return (res.Keys || []).map((k) => CID.parse(k["/"]));
  }
  return wantlist;
});
const createWantlistForPeer = configure((api2) => {
  async function wantlistForPeer(peerId, options = {}) {
    const res = await (await api2.post("bitswap/wantlist", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        ...options,
        peer: peerId.toString()
      }),
      headers: options.headers
    })).json();
    return (res.Keys || []).map((k) => CID.parse(k["/"]));
  }
  return wantlistForPeer;
});
const createStat$4 = configure((api2) => {
  async function stat(options = {}) {
    const res = await api2.post("bitswap/stat", {
      searchParams: toUrlSearchParams(options),
      signal: options.signal,
      headers: options.headers
    });
    return toCoreInterface$4(await res.json());
  }
  return stat;
});
function toCoreInterface$4(res) {
  return {
    provideBufLen: res.ProvideBufLen,
    wantlist: (res.Wantlist || []).map((k) => CID.parse(k["/"])),
    peers: (res.Peers || []).map((str) => peerIdFromString(str)),
    blocksReceived: BigInt(res.BlocksReceived),
    dataReceived: BigInt(res.DataReceived),
    blocksSent: BigInt(res.BlocksSent),
    dataSent: BigInt(res.DataSent),
    dupBlksReceived: BigInt(res.DupBlksReceived),
    dupDataReceived: BigInt(res.DupDataReceived)
  };
}
const createUnwant = configure((api2) => {
  async function unwant(cid, options = {}) {
    const res = await api2.post("bitswap/unwant", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    });
    return res.json();
  }
  return unwant;
});
function createBitswap$1(config2) {
  return {
    wantlist: createWantlist(config2),
    wantlistForPeer: createWantlistForPeer(config2),
    unwant: createUnwant(config2),
    stat: createStat$4(config2)
  };
}
const createGet$5 = configure((api2) => {
  async function get3(cid, options = {}) {
    const res = await api2.post("block/get", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    });
    return new Uint8Array(await res.arrayBuffer());
  }
  return get3;
});
async function normaliseContent(input) {
  if (isBytes(input)) {
    return new Blob([input]);
  }
  if (typeof input === "string" || input instanceof String) {
    return new Blob([input.toString()]);
  }
  if (isBlob(input)) {
    return input;
  }
  if (isReadableStream(input)) {
    input = browserReadableStreamToIt(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = peekableIterator(input);
    const { value: value2, done } = await peekable.peek();
    if (done) {
      return itToBlob(peekable);
    }
    peekable.push(value2);
    if (Number.isInteger(value2)) {
      return new Blob([Uint8Array.from(await all$1(peekable))]);
    }
    if (isBytes(value2) || typeof value2 === "string" || value2 instanceof String) {
      return itToBlob(peekable);
    }
  }
  throw errCode(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
}
async function itToBlob(stream2) {
  const parts2 = [];
  for await (const chunk of stream2) {
    parts2.push(chunk);
  }
  return new Blob(parts2);
}
function normaliseInput(input) {
  return normaliseCandidateMultiple(input, normaliseContent);
}
function modeToString(mode) {
  if (mode == null) {
    return void 0;
  }
  if (typeof mode === "string") {
    return mode;
  }
  return mode.toString(8).padStart(4, "0");
}
async function multipartRequest(source2, abortController, headers = {}) {
  const parts2 = [];
  const formData = new FormData();
  let index = 0;
  let total = 0;
  for await (const { content, path: path2, mode, mtime } of normaliseInput(source2)) {
    let fileSuffix = "";
    const type = content ? "file" : "dir";
    if (index > 0) {
      fileSuffix = `-${index}`;
    }
    let fieldName = type + fileSuffix;
    const qs = [];
    if (mode !== null && mode !== void 0) {
      qs.push(`mode=${modeToString(mode)}`);
    }
    if (mtime != null) {
      const { secs, nsecs } = mtime;
      qs.push(`mtime=${secs}`);
      if (nsecs != null) {
        qs.push(`mtime-nsecs=${nsecs}`);
      }
    }
    if (qs.length) {
      fieldName = `${fieldName}?${qs.join("&")}`;
    }
    if (content) {
      formData.set(fieldName, content, path2 != null ? encodeURIComponent(path2) : void 0);
      const end2 = total + content.size;
      parts2.push({ name: path2, start: total, end: end2 });
      total = end2;
    } else if (path2 != null) {
      formData.set(fieldName, new File([""], encodeURIComponent(path2), { type: "application/x-directory" }));
    } else {
      throw new Error("path or content or both must be set");
    }
    index++;
  }
  return {
    total,
    parts: parts2,
    headers,
    body: formData
  };
}
function filter(signals) {
  return signals.filter(Boolean);
}
function abortSignal(...signals) {
  return anySignal_2(filter(signals));
}
const createPut$3 = configure((api2) => {
  async function put(data, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    let res;
    try {
      const response = await api2.post("block/put", {
        signal,
        searchParams: toUrlSearchParams(options),
        ...await multipartRequest([data], controller, options.headers)
      });
      res = await response.json();
    } catch (err2) {
      if (options.format === "dag-pb") {
        return put(data, { ...options, format: "protobuf" });
      } else if (options.format === "dag-cbor") {
        return put(data, { ...options, format: "cbor" });
      }
      throw err2;
    }
    return CID.parse(res.Key);
  }
  return put;
});
const createRm$6 = configure((api2) => {
  async function* rm(cid, options = {}) {
    if (!Array.isArray(cid)) {
      cid = [cid];
    }
    const res = await api2.post("block/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.map((cid2) => cid2.toString()),
        "stream-channels": true,
        ...options
      }),
      headers: options.headers
    });
    for await (const removed of res.ndjson()) {
      yield toCoreInterface$3(removed);
    }
  }
  return rm;
});
function toCoreInterface$3(removed) {
  const out = {
    cid: CID.parse(removed.Hash)
  };
  if (removed.Error) {
    out.error = new Error(removed.Error);
  }
  return out;
}
const createStat$3 = configure((api2) => {
  async function stat(cid, options = {}) {
    const res = await api2.post("block/stat", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return { cid: CID.parse(data.Key), size: data.Size };
  }
  return stat;
});
function createBlock(config2) {
  return {
    get: createGet$5(config2),
    put: createPut$3(config2),
    rm: createRm$6(config2),
    stat: createStat$3(config2)
  };
}
const createAdd$4 = configure((api2) => {
  async function add(addr, options = {}) {
    const res = await api2.post("bootstrap/add", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: addr,
        ...options
      }),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => multiaddr(ma)) };
  }
  return add;
});
const createClear = configure((api2) => {
  async function clear4(options = {}) {
    const res = await api2.post("bootstrap/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        ...options,
        all: true
      }),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => multiaddr(ma)) };
  }
  return clear4;
});
const createList$2 = configure((api2) => {
  async function list(options = {}) {
    const res = await api2.post("bootstrap/list", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => multiaddr(ma)) };
  }
  return list;
});
const createReset = configure((api2) => {
  async function reset2(options = {}) {
    const res = await api2.post("bootstrap/add", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        ...options,
        default: true
      }),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => multiaddr(ma)) };
  }
  return reset2;
});
const createRm$5 = configure((api2) => {
  async function rm(addr, options = {}) {
    const res = await api2.post("bootstrap/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: addr,
        ...options
      }),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => multiaddr(ma)) };
  }
  return rm;
});
function createBootstrap(config2) {
  return {
    add: createAdd$4(config2),
    clear: createClear(config2),
    list: createList$2(config2),
    reset: createReset(config2),
    rm: createRm$5(config2)
  };
}
const createApply = configure((api2) => {
  async function apply(profile, options = {}) {
    const res = await api2.post("config/profile/apply", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: profile,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return {
      original: data.OldCfg,
      updated: data.NewCfg
    };
  }
  return apply;
});
function objectToCamel(obj) {
  if (obj == null) {
    return obj;
  }
  const caps = /^[A-Z]+$/;
  const output = {};
  return Object.keys(obj).reduce((camelObj, k) => {
    if (caps.test(k)) {
      camelObj[k.toLowerCase()] = obj[k];
    } else if (caps.test(k[0])) {
      camelObj[k[0].toLowerCase() + k.slice(1)] = obj[k];
    } else {
      camelObj[k] = obj[k];
    }
    return camelObj;
  }, output);
}
const createList$1 = configure((api2) => {
  async function list(options = {}) {
    const res = await api2.post("config/profile/list", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return data.map((profile) => objectToCamel(profile));
  }
  return list;
});
function createProfiles(config2) {
  return {
    apply: createApply(config2),
    list: createList$1(config2)
  };
}
const createGet$4 = configure((api2) => {
  const get3 = async (key, options = {}) => {
    if (!key) {
      throw new Error("key argument is required");
    }
    const res = await api2.post("config", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: key,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return data.Value;
  };
  return get3;
});
const createGetAll = configure((api2) => {
  const getAll = async (options = {}) => {
    const res = await api2.post("config/show", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return data;
  };
  return getAll;
});
const createReplace = configure((api2) => {
  const replace = async (config2, options = {}) => {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api2.post("config/replace", {
      signal,
      searchParams: toUrlSearchParams(options),
      ...await multipartRequest([fromString$3(JSON.stringify(config2))], controller, options.headers)
    });
    await res.text();
  };
  return replace;
});
const createSet = configure((api2) => {
  const set2 = async (key, value2, options = {}) => {
    if (typeof key !== "string") {
      throw new Error("Invalid key type");
    }
    const params = {
      ...options,
      ...encodeParam(key, value2)
    };
    const res = await api2.post("config", {
      signal: options.signal,
      searchParams: toUrlSearchParams(params),
      headers: options.headers
    });
    await res.text();
  };
  return set2;
});
const encodeParam = (key, value2) => {
  switch (typeof value2) {
    case "boolean":
      return { arg: [key, value2.toString()], bool: true };
    case "string":
      return { arg: [key, value2] };
    default:
      return { arg: [key, JSON.stringify(value2)], json: true };
  }
};
function createConfig(config2) {
  return {
    getAll: createGetAll(config2),
    get: createGet$4(config2),
    set: createSet(config2),
    replace: createReplace(config2),
    profiles: createProfiles(config2)
  };
}
const createExport$1 = configure((api2) => {
  async function* dagExport(root, options = {}) {
    const res = await api2.post("dag/export", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: root.toString()
      }),
      headers: options.headers
    });
    yield* res.iterator();
  }
  return dagExport;
});
async function* resolve(cid, path2, codecs2, getBlock, options) {
  const load = async (cid2) => {
    const codec = await codecs2.getCodec(cid2.code);
    const block = await getBlock(cid2, options);
    return codec.decode(block);
  };
  const parts2 = path2.split("/").filter(Boolean);
  let value2 = await load(cid);
  let lastCid = cid;
  while (parts2.length) {
    const key = parts2.shift();
    if (!key) {
      throw errCode(new Error(`Could not resolve path "${path2}"`), "ERR_INVALID_PATH");
    }
    if (Object.prototype.hasOwnProperty.call(value2, key)) {
      value2 = value2[key];
      yield {
        value: value2,
        remainderPath: parts2.join("/")
      };
    } else {
      throw errCode(new Error(`no link named "${key}" under ${lastCid}`), "ERR_NO_LINK");
    }
    const cid2 = CID.asCID(value2);
    if (cid2) {
      lastCid = cid2;
      value2 = await load(value2);
    }
  }
  yield {
    value: value2,
    remainderPath: ""
  };
}
const createGet$3 = (codecs2, options) => {
  const fn = configure((api2, opts) => {
    const getBlock = createGet$5(opts);
    const get3 = async (cid, options2 = {}) => {
      if (options2.path) {
        const entry = options2.localResolve ? await first$1(resolve(cid, options2.path, codecs2, getBlock, options2)) : await last(resolve(cid, options2.path, codecs2, getBlock, options2));
        const result = entry;
        if (!result) {
          throw errCode(new Error("Not found"), "ERR_NOT_FOUND");
        }
        return result;
      }
      const codec = await codecs2.getCodec(cid.code);
      const block = await getBlock(cid, options2);
      const node2 = codec.decode(block);
      return {
        value: node2,
        remainderPath: ""
      };
    };
    return get3;
  });
  return fn(options);
};
const createImport$1 = configure((api2) => {
  async function* dagImport(source2, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const { headers, body } = await multipartRequest(source2, controller, options.headers);
    const res = await api2.post("dag/import", {
      signal,
      headers,
      body,
      searchParams: toUrlSearchParams({ "pin-roots": options.pinRoots })
    });
    for await (const { Root: Root2 } of res.ndjson()) {
      if (Root2 !== void 0) {
        const { Cid: { "/": Cid }, PinErrorMsg } = Root2;
        yield {
          root: {
            cid: CID.parse(Cid),
            pinErrorMsg: PinErrorMsg
          }
        };
      }
    }
  }
  return dagImport;
});
const createPut$2 = (codecs2, options) => {
  const fn = configure((api2) => {
    const put = async (dagNode, options2 = {}) => {
      const settings = {
        storeCodec: "dag-cbor",
        hashAlg: "sha2-256",
        ...options2
      };
      let serialized;
      if (settings.inputCodec) {
        if (!(dagNode instanceof Uint8Array)) {
          throw new Error("Can only inputCodec on raw bytes that can be decoded");
        }
        serialized = dagNode;
      } else {
        const storeCodec = await codecs2.getCodec(settings.storeCodec);
        serialized = storeCodec.encode(dagNode);
        settings.inputCodec = settings.storeCodec;
      }
      const controller = new AbortController();
      const signal = abortSignal(controller.signal, settings.signal);
      const res = await api2.post("dag/put", {
        timeout: settings.timeout,
        signal,
        searchParams: toUrlSearchParams(settings),
        ...await multipartRequest([serialized], controller, settings.headers)
      });
      const data = await res.json();
      return CID.parse(data.Cid["/"]);
    };
    return put;
  });
  return fn(options);
};
const createResolve$2 = configure((api2) => {
  const resolve2 = async (ipfsPath2, options = {}) => {
    const res = await api2.post("dag/resolve", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${ipfsPath2}${options.path ? `/${options.path}`.replace(/\/[/]+/g, "/") : ""}`,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return { cid: CID.parse(data.Cid["/"]), remainderPath: data.RemPath };
  };
  return resolve2;
});
function createDag(codecs2, config2) {
  return {
    export: createExport$1(config2),
    get: createGet$3(codecs2, config2),
    import: createImport$1(config2),
    put: createPut$2(codecs2, config2),
    resolve: createResolve$2(config2)
  };
}
const SendingQuery = 0;
const PeerResponse = 1;
const FinalPeer = 2;
const QueryError = 3;
const Provider = 4;
const Value = 5;
const AddingPeer = 6;
const DialingPeer = 7;
const mapEvent = (event) => {
  if (event.Type === SendingQuery) {
    return {
      name: "SENDING_QUERY",
      type: event.Type
    };
  }
  if (event.Type === PeerResponse) {
    return {
      from: peerIdFromString(event.ID),
      name: "PEER_RESPONSE",
      type: event.Type,
      messageType: 0,
      messageName: "PUT_VALUE",
      closer: (event.Responses || []).map(({ ID, Addrs }) => ({ id: peerIdFromString(ID), multiaddrs: Addrs.map((addr) => multiaddr(addr)), protocols: [] })),
      providers: (event.Responses || []).map(({ ID, Addrs }) => ({ id: peerIdFromString(ID), multiaddrs: Addrs.map((addr) => multiaddr(addr)), protocols: [] }))
    };
  }
  if (event.Type === FinalPeer) {
    let peer = {
      id: event.ID ?? peerIdFromString(event.ID),
      multiaddrs: [],
      protocols: []
    };
    if (event.Responses && event.Responses.length) {
      peer = {
        id: peerIdFromString(event.Responses[0].ID),
        multiaddrs: event.Responses[0].Addrs.map((addr) => multiaddr(addr)),
        protocols: []
      };
    }
    return {
      name: "FINAL_PEER",
      type: event.Type,
      peer
    };
  }
  if (event.Type === QueryError) {
    return {
      name: "QUERY_ERROR",
      type: event.Type,
      error: new Error(event.Extra)
    };
  }
  if (event.Type === Provider) {
    return {
      name: "PROVIDER",
      type: event.Type,
      providers: event.Responses.map(({ ID, Addrs }) => ({ id: peerIdFromString(ID), multiaddrs: Addrs.map((addr) => multiaddr(addr)), protocols: [] }))
    };
  }
  if (event.Type === Value) {
    return {
      name: "VALUE",
      type: event.Type,
      value: fromString$3(event.Extra, "base64pad")
    };
  }
  if (event.Type === AddingPeer) {
    const peers = event.Responses.map(({ ID }) => peerIdFromString(ID));
    if (!peers.length) {
      throw new Error("No peer found");
    }
    return {
      name: "ADDING_PEER",
      type: event.Type,
      peer: peers[0]
    };
  }
  if (event.Type === DialingPeer) {
    return {
      name: "DIALING_PEER",
      type: event.Type,
      peer: peerIdFromString(event.ID)
    };
  }
  throw new Error("Unknown DHT event type");
};
const createFindPeer = configure((api2) => {
  async function* findPeer2(peerId, options = {}) {
    const res = await api2.post("dht/findpeer", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: peerId,
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return findPeer2;
});
const createFindProvs = configure((api2) => {
  async function* findProvs(cid, options = {}) {
    const res = await api2.post("dht/findprovs", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return findProvs;
});
const createGet$2 = configure((api2) => {
  async function* get3(key, options = {}) {
    const res = await api2.post("dht/get", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: key instanceof Uint8Array ? toString$5(key) : key.toString(),
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return get3;
});
const createProvide = configure((api2) => {
  async function* provide(cids, options = { recursive: false }) {
    const cidArr = Array.isArray(cids) ? cids : [cids];
    const res = await api2.post("dht/provide", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cidArr.map((cid) => cid.toString()),
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return provide;
});
const createPut$1 = configure((api2) => {
  async function* put(key, value2, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api2.post("dht/put", {
      signal,
      searchParams: toUrlSearchParams({
        arg: key instanceof Uint8Array ? toString$5(key) : key.toString(),
        ...options
      }),
      ...await multipartRequest([value2], controller, options.headers)
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return put;
});
const createQuery = configure((api2) => {
  async function* query(peerId, options = {}) {
    const res = await api2.post("dht/query", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: peerId.toString(),
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return query;
});
function createDht$1(config2) {
  return {
    findPeer: createFindPeer(config2),
    findProvs: createFindProvs(config2),
    get: createGet$2(config2),
    provide: createProvide(config2),
    put: createPut$1(config2),
    query: createQuery(config2)
  };
}
const createCmds = configure((api2) => {
  async function cmds(options = {}) {
    const res = await api2.post("diag/cmds", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return res.json();
  }
  return cmds;
});
const createNet = configure((api2) => {
  async function net(options = {}) {
    const res = await api2.post("diag/net", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return res.json();
  }
  return net;
});
const createSys = configure((api2) => {
  async function sys(options = {}) {
    const res = await api2.post("diag/sys", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return res.json();
  }
  return sys;
});
function createDiag(config2) {
  return {
    cmds: createCmds(config2),
    net: createNet(config2),
    sys: createSys(config2)
  };
}
const createChmod = configure((api2) => {
  async function chmod(path2, mode, options = {}) {
    const res = await api2.post("files/chmod", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path2,
        mode,
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return chmod;
});
const createCp = configure((api2) => {
  async function cp(sources, destination, options = {}) {
    const sourceArr = Array.isArray(sources) ? sources : [sources];
    const res = await api2.post("files/cp", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: sourceArr.concat(destination).map((src2) => CID.asCID(src2) ? `/ipfs/${src2}` : src2),
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return cp;
});
const createFlush = configure((api2) => {
  async function flush2(path2, options = {}) {
    if (!path2 || typeof path2 !== "string") {
      throw new Error("ipfs.files.flush requires a path");
    }
    const res = await api2.post("files/flush", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path2,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return CID.parse(data.Cid);
  }
  return flush2;
});
function objectToCamelWithMetadata(entry) {
  const file = objectToCamel(entry);
  if (Object.prototype.hasOwnProperty.call(file, "mode")) {
    file.mode = parseInt(file.mode, 8);
  }
  if (Object.prototype.hasOwnProperty.call(file, "mtime")) {
    file.mtime = {
      secs: file.mtime,
      nsecs: file.mtimeNsecs || 0
    };
    delete file.mtimeNsecs;
  }
  return file;
}
const createLs$6 = configure((api2) => {
  async function* ls(path2, options = {}) {
    if (!path2) {
      throw new Error("ipfs.files.ls requires a path");
    }
    const res = await api2.post("files/ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: CID.asCID(path2) ? `/ipfs/${path2}` : path2,
        long: true,
        ...options,
        stream: true
      }),
      headers: options.headers
    });
    for await (const result of res.ndjson()) {
      if ("Entries" in result) {
        for (const entry of result.Entries || []) {
          yield toCoreInterface$2(objectToCamelWithMetadata(entry));
        }
      } else {
        yield toCoreInterface$2(objectToCamelWithMetadata(result));
      }
    }
  }
  return ls;
});
function toCoreInterface$2(entry) {
  if (entry.hash) {
    entry.cid = CID.parse(entry.hash);
  }
  delete entry.hash;
  entry.type = entry.type === 1 ? "directory" : "file";
  return entry;
}
const createMkdir = configure((api2) => {
  async function mkdir(path2, options = {}) {
    const res = await api2.post("files/mkdir", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path2,
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return mkdir;
});
const createMv = configure((api2) => {
  async function mv(sources, destination, options = {}) {
    if (!Array.isArray(sources)) {
      sources = [sources];
    }
    const res = await api2.post("files/mv", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: sources.concat(destination),
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return mv;
});
var source$1 = (readable) => {
  if (readable[Symbol.asyncIterator])
    return readable;
  if (readable.getReader) {
    return async function* () {
      const reader2 = readable.getReader();
      try {
        while (true) {
          const { done, value: value2 } = await reader2.read();
          if (done)
            return;
          yield value2;
        }
      } finally {
        reader2.releaseLock();
      }
    }();
  }
  throw new Error("unknown stream");
};
const createRead = configure((api2) => {
  async function* read2(path2, options = {}) {
    const res = await api2.post("files/read", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path2,
        count: options.length,
        ...options
      }),
      headers: options.headers
    });
    yield* source$1(res.body);
  }
  return read2;
});
const createRm$4 = configure((api2) => {
  async function rm(path2, options = {}) {
    const res = await api2.post("files/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path2,
        ...options
      }),
      headers: options.headers
    });
    const body = await res.text();
    if (body !== "") {
      const error2 = new http.HTTPError(res);
      error2.message = body;
      throw error2;
    }
  }
  return rm;
});
const createStat$2 = configure((api2) => {
  async function stat(path2, options = {}) {
    const res = await api2.post("files/stat", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path2,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    data.WithLocality = data.WithLocality || false;
    return toCoreInterface$1(objectToCamelWithMetadata(data));
  }
  return stat;
});
function toCoreInterface$1(entry) {
  entry.cid = CID.parse(entry.hash);
  delete entry.hash;
  return entry;
}
const createTouch = configure((api2) => {
  async function touch(path2, options = {}) {
    const res = await api2.post("files/touch", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path2,
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return touch;
});
const createWrite = configure((api2) => {
  async function write2(path2, input, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api2.post("files/write", {
      signal,
      searchParams: toUrlSearchParams({
        arg: path2,
        streamChannels: true,
        count: options.length,
        ...options
      }),
      ...await multipartRequest([{
        content: input,
        path: "arg",
        mode: modeToString$1(options.mode),
        mtime: parseMtime(options.mtime)
      }], controller, options.headers)
    });
    await res.text();
  }
  return write2;
});
function createFiles(config2) {
  return {
    chmod: createChmod(config2),
    cp: createCp(config2),
    flush: createFlush(config2),
    ls: createLs$6(config2),
    mkdir: createMkdir(config2),
    mv: createMv(config2),
    read: createRead(config2),
    rm: createRm$4(config2),
    stat: createStat$2(config2),
    touch: createTouch(config2),
    write: createWrite(config2)
  };
}
const createExport = configure((api2) => {
  const exportKey2 = async (name2, password, options = {}) => {
    throw errCode(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
  };
  return exportKey2;
});
const createGen = configure((api2) => {
  async function gen(name2, options = { type: "Ed25519" }) {
    const res = await api2.post("key/gen", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: name2,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return objectToCamel(data);
  }
  return gen;
});
const createImport = configure((api2) => {
  async function importKey2(name2, pem2, password, options = {}) {
    const res = await api2.post("key/import", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: name2,
        pem: pem2,
        password,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return objectToCamel(data);
  }
  return importKey2;
});
const createInfo = configure((api2) => {
  const info = async (name2, options = {}) => {
    throw errCode(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
  };
  return info;
});
const createList = configure((api2) => {
  async function list(options = {}) {
    const res = await api2.post("key/list", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return (data.Keys || []).map((k) => objectToCamel(k));
  }
  return list;
});
const createRename = configure((api2) => {
  async function rename(oldName, newName, options = {}) {
    const res = await api2.post("key/rename", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: [
          oldName,
          newName
        ],
        ...options
      }),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return rename;
});
const createRm$3 = configure((api2) => {
  async function rm(name2, options = {}) {
    const res = await api2.post("key/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: name2,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return objectToCamel(data.Keys[0]);
  }
  return rm;
});
function createKey(config2) {
  return {
    export: createExport(config2),
    gen: createGen(config2),
    import: createImport(config2),
    info: createInfo(config2),
    list: createList(config2),
    rename: createRename(config2),
    rm: createRm$3(config2)
  };
}
const createLevel = configure((api2) => {
  async function level(subsystem, level2, options = {}) {
    const res = await api2.post("log/level", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: [
          subsystem,
          level2
        ],
        ...options
      }),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return level;
});
const createLs$5 = configure((api2) => {
  async function ls(options = {}) {
    const res = await api2.post("log/ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return data.Strings;
  }
  return ls;
});
const createTail = configure((api2) => {
  async function* tail(options = {}) {
    const res = await api2.post("log/tail", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    yield* res.ndjson();
  }
  return tail;
});
function createLog(config2) {
  return {
    level: createLevel(config2),
    ls: createLs$5(config2),
    tail: createTail(config2)
  };
}
const createPublish$1 = configure((api2) => {
  async function publish(path2, options = {}) {
    const res = await api2.post("name/publish", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${path2}`,
        ...options
      }),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return publish;
});
const createResolve$1 = configure((api2) => {
  async function* resolve2(path2, options = {}) {
    const res = await api2.post("name/resolve", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path2,
        stream: true,
        ...options
      }),
      headers: options.headers
    });
    for await (const result of res.ndjson()) {
      yield result.Path;
    }
  }
  return resolve2;
});
const createCancel = configure((api2) => {
  async function cancel(name2, options = {}) {
    const res = await api2.post("name/pubsub/cancel", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: name2,
        ...options
      }),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return cancel;
});
const createState = configure((api2) => {
  async function state(options = {}) {
    const res = await api2.post("name/pubsub/state", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return state;
});
const createSubs = configure((api2) => {
  async function subs(options = {}) {
    const res = await api2.post("name/pubsub/subs", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return data.Strings || [];
  }
  return subs;
});
function createPubsub$2(config2) {
  return {
    cancel: createCancel(config2),
    state: createState(config2),
    subs: createSubs(config2)
  };
}
function createName(config2) {
  return {
    publish: createPublish$1(config2),
    resolve: createResolve$1(config2),
    pubsub: createPubsub$2(config2)
  };
}
const createData = configure((api2) => {
  async function data(cid, options = {}) {
    const res = await api2.post("object/data", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${cid instanceof Uint8Array ? CID.decode(cid) : cid}`,
        ...options
      }),
      headers: options.headers
    });
    const data2 = await res.arrayBuffer();
    return new Uint8Array(data2, 0, data2.byteLength);
  }
  return data;
});
const createGet$1 = configure((api2) => {
  async function get3(cid, options = {}) {
    const res = await api2.post("object/get", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${cid instanceof Uint8Array ? CID.decode(cid) : cid}`,
        dataEncoding: "base64",
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return {
      Data: fromString$3(data.Data, "base64pad"),
      Links: (data.Links || []).map((link) => ({
        Name: link.Name,
        Hash: CID.parse(link.Hash),
        Tsize: link.Size
      }))
    };
  }
  return get3;
});
const createLinks = configure((api2) => {
  async function links2(cid, options = {}) {
    const res = await api2.post("object/links", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${cid instanceof Uint8Array ? CID.decode(cid) : cid}`,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return (data.Links || []).map((l) => ({
      Name: l.Name,
      Tsize: l.Size,
      Hash: CID.parse(l.Hash)
    }));
  }
  return links2;
});
const createNew = configure((api2) => {
  async function newObject(options = {}) {
    const res = await api2.post("object/new", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: options.template,
        ...options
      }),
      headers: options.headers
    });
    const { Hash } = await res.json();
    return CID.parse(Hash);
  }
  return newObject;
});
const createPut = (codecs2, options) => {
  const fn = configure((api2) => {
    const dagPut = createPut$2(codecs2, options);
    async function put(obj, options2 = {}) {
      return dagPut(obj, {
        ...options2,
        storeCodec: "dag-pb",
        hashAlg: "sha2-256",
        version: 1
      });
    }
    return put;
  });
  return fn(options);
};
const createStat$1 = configure((api2) => {
  async function stat(cid, options = {}) {
    const res = await api2.post("object/stat", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${cid}`,
        ...options
      }),
      headers: options.headers
    });
    const output = await res.json();
    return {
      ...output,
      Hash: CID.parse(output.Hash)
    };
  }
  return stat;
});
const createAddLink = configure((api2) => {
  async function addLink2(cid, dLink, options = {}) {
    const res = await api2.post("object/patch/add-link", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: [
          `${cid}`,
          dLink.Name || dLink.name || "",
          (dLink.Hash || dLink.cid || "").toString() || null
        ],
        ...options
      }),
      headers: options.headers
    });
    const { Hash } = await res.json();
    return CID.parse(Hash);
  }
  return addLink2;
});
const createAppendData = configure((api2) => {
  async function appendData(cid, data, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api2.post("object/patch/append-data", {
      signal,
      searchParams: toUrlSearchParams({
        arg: `${cid}`,
        ...options
      }),
      ...await multipartRequest([data], controller, options.headers)
    });
    const { Hash } = await res.json();
    return CID.parse(Hash);
  }
  return appendData;
});
const createRmLink = configure((api2) => {
  async function rmLink(cid, dLink, options = {}) {
    const res = await api2.post("object/patch/rm-link", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: [
          `${cid}`,
          dLink.Name || dLink.name || null
        ],
        ...options
      }),
      headers: options.headers
    });
    const { Hash } = await res.json();
    return CID.parse(Hash);
  }
  return rmLink;
});
const createSetData = configure((api2) => {
  async function setData(cid, data, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api2.post("object/patch/set-data", {
      signal,
      searchParams: toUrlSearchParams({
        arg: [
          `${cid}`
        ],
        ...options
      }),
      ...await multipartRequest([data], controller, options.headers)
    });
    const { Hash } = await res.json();
    return CID.parse(Hash);
  }
  return setData;
});
function createPatch(config2) {
  return {
    addLink: createAddLink(config2),
    appendData: createAppendData(config2),
    rmLink: createRmLink(config2),
    setData: createSetData(config2)
  };
}
function createObject(codecs2, config2) {
  return {
    data: createData(config2),
    get: createGet$1(config2),
    links: createLinks(config2),
    new: createNew(config2),
    put: createPut(codecs2, config2),
    stat: createStat$1(config2),
    patch: createPatch(config2)
  };
}
const createAddAll$1 = configure((api2) => {
  async function* addAll(source2, options = {}) {
    for await (const { path: path2, recursive: recursive2, metadata } of normaliseInput$3(source2)) {
      const res = await api2.post("pin/add", {
        signal: options.signal,
        searchParams: toUrlSearchParams({
          ...options,
          arg: path2,
          recursive: recursive2,
          metadata: metadata ? JSON.stringify(metadata) : void 0,
          stream: true
        }),
        headers: options.headers
      });
      for await (const pin of res.ndjson()) {
        if (pin.Pins) {
          for (const cid of pin.Pins) {
            yield CID.parse(cid);
          }
          continue;
        }
        yield CID.parse(pin);
      }
    }
  }
  return addAll;
});
function createAdd$3(config2) {
  const all2 = createAddAll$1(config2);
  return configure(() => {
    async function add(path2, options = {}) {
      return last(all2([{
        path: path2,
        ...options
      }], options));
    }
    return add;
  })(config2);
}
function toPin(type, cid, metadata) {
  const pin = {
    type,
    cid: CID.parse(cid)
  };
  if (metadata) {
    pin.metadata = metadata;
  }
  return pin;
}
const createLs$4 = configure((api2) => {
  async function* ls(options = {}) {
    let paths = [];
    if (options.paths) {
      paths = Array.isArray(options.paths) ? options.paths : [options.paths];
    }
    const res = await api2.post("pin/ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        ...options,
        arg: paths.map((path2) => `${path2}`),
        stream: true
      }),
      headers: options.headers
    });
    for await (const pin of res.ndjson()) {
      if (pin.Keys) {
        for (const cid of Object.keys(pin.Keys)) {
          yield toPin(pin.Keys[cid].Type, cid, pin.Keys[cid].Metadata);
        }
        return;
      }
      yield toPin(pin.Type, pin.Cid, pin.Metadata);
    }
  }
  return ls;
});
const createRmAll$1 = configure((api2) => {
  async function* rmAll(source2, options = {}) {
    for await (const { path: path2, recursive: recursive2 } of normaliseInput$3(source2)) {
      const searchParams = new URLSearchParams(options.searchParams);
      searchParams.append("arg", `${path2}`);
      if (recursive2 != null)
        searchParams.set("recursive", String(recursive2));
      const res = await api2.post("pin/rm", {
        signal: options.signal,
        headers: options.headers,
        searchParams: toUrlSearchParams({
          ...options,
          arg: `${path2}`,
          recursive: recursive2
        })
      });
      for await (const pin of res.ndjson()) {
        if (pin.Pins) {
          yield* pin.Pins.map((cid) => CID.parse(cid));
          continue;
        }
        yield CID.parse(pin);
      }
    }
  }
  return rmAll;
});
const createRm$2 = (config2) => {
  const all2 = createRmAll$1(config2);
  return configure(() => {
    async function rm(path2, options = {}) {
      return last(all2([{
        path: path2,
        ...options
      }], options));
    }
    return rm;
  })(config2);
};
const decodePin = ({ Name: name2, Status: status, Cid: cid }) => {
  return {
    cid: CID.parse(cid),
    name: name2,
    status
  };
};
const encodeService = (service2) => {
  if (typeof service2 === "string" && service2 !== "") {
    return service2;
  } else {
    throw new TypeError("service name must be passed");
  }
};
const encodeCID = (cid) => {
  if (CID.asCID(cid)) {
    return cid.toString();
  } else {
    throw new TypeError(`CID instance expected instead of ${typeof cid}`);
  }
};
const encodeQuery = ({ service: service2, cid, name: name2, status, all: all2 }) => {
  const query = toUrlSearchParams({
    service: encodeService(service2),
    name: name2,
    force: all2 ? true : void 0
  });
  if (cid) {
    for (const value2 of cid) {
      query.append("cid", encodeCID(value2));
    }
  }
  if (status) {
    for (const value2 of status) {
      query.append("status", value2);
    }
  }
  return query;
};
const encodeAddParams = ({ cid, service: service2, background, name: name2, origins }) => {
  const params = toUrlSearchParams({
    arg: encodeCID(cid),
    service: encodeService(service2),
    name: name2,
    background: background ? true : void 0
  });
  if (origins) {
    for (const origin of origins) {
      params.append("origin", origin.toString());
    }
  }
  return params;
};
function createAdd$2(client) {
  async function add(cid, { timeout: timeout2, signal, headers, ...query }) {
    const response = await client.post("pin/remote/add", {
      timeout: timeout2,
      signal,
      headers,
      searchParams: encodeAddParams({ cid, ...query })
    });
    return decodePin(await response.json());
  }
  return add;
}
function createLs$3(client) {
  async function* ls({ timeout: timeout2, signal, headers, ...query }) {
    const response = await client.post("pin/remote/ls", {
      timeout: timeout2,
      signal,
      headers,
      searchParams: encodeQuery(query)
    });
    for await (const pin of response.ndjson()) {
      yield decodePin(pin);
    }
  }
  return ls;
}
function createRm$1(client) {
  async function rm({ timeout: timeout2, signal, headers, ...query }) {
    await client.post("pin/remote/rm", {
      timeout: timeout2,
      signal,
      headers,
      searchParams: encodeQuery({
        ...query,
        all: false
      })
    });
  }
  return rm;
}
function createRmAll(client) {
  async function rmAll({ timeout: timeout2, signal, headers, ...query }) {
    await client.post("pin/remote/rm", {
      timeout: timeout2,
      signal,
      headers,
      searchParams: encodeQuery({
        ...query,
        all: true
      })
    });
  }
  return rmAll;
}
function encodeEndpoint(url2) {
  const href = String(url2);
  if (href === "undefined") {
    throw Error("endpoint is required");
  }
  return href[href.length - 1] === "/" ? href.slice(0, -1) : href;
}
function decodeRemoteService(json2) {
  return {
    service: json2.Service,
    endpoint: new URL(json2.ApiEndpoint),
    ...json2.Stat && { stat: decodeStat(json2.Stat) }
  };
}
function decodeStat(json2) {
  switch (json2.Status) {
    case "valid": {
      const { Pinning, Pinned, Queued, Failed } = json2.PinCount;
      return {
        status: "valid",
        pinCount: {
          queued: Queued,
          pinning: Pinning,
          pinned: Pinned,
          failed: Failed
        }
      };
    }
    case "invalid": {
      return { status: "invalid" };
    }
    default: {
      return { status: json2.Status };
    }
  }
}
function createAdd$1(client) {
  async function add(name2, options) {
    const { endpoint, key, headers, timeout: timeout2, signal } = options;
    await client.post("pin/remote/service/add", {
      timeout: timeout2,
      signal,
      searchParams: toUrlSearchParams({
        arg: [name2, encodeEndpoint(endpoint), key]
      }),
      headers
    });
  }
  return add;
}
function createLs$2(client) {
  async function ls(options = {}) {
    const { stat, headers, timeout: timeout2, signal } = options;
    const response = await client.post("pin/remote/service/ls", {
      timeout: timeout2,
      signal,
      headers,
      searchParams: stat === true ? toUrlSearchParams({ stat }) : void 0
    });
    const { RemoteServices } = await response.json();
    return RemoteServices.map(decodeRemoteService);
  }
  return ls;
}
function createRm(client) {
  async function rm(name2, options = {}) {
    await client.post("pin/remote/service/rm", {
      signal: options.signal,
      headers: options.headers,
      searchParams: toUrlSearchParams({
        arg: name2
      })
    });
  }
  return rm;
}
function createService(config2) {
  const client = new Client(config2);
  return {
    add: createAdd$1(client),
    ls: createLs$2(client),
    rm: createRm(client)
  };
}
function createRemote(config2) {
  const client = new Client(config2);
  return {
    add: createAdd$2(client),
    ls: createLs$3(client),
    rm: createRm$1(client),
    rmAll: createRmAll(client),
    service: createService(config2)
  };
}
function createPin(config2) {
  return {
    addAll: createAddAll$1(config2),
    add: createAdd$3(config2),
    ls: createLs$4(config2),
    rmAll: createRmAll$1(config2),
    rm: createRm$2(config2),
    remote: createRemote(config2)
  };
}
const rpcArrayToTextArray = (strings2) => {
  if (Array.isArray(strings2)) {
    return strings2.map(rpcToText);
  }
  return strings2;
};
const rpcToText = (mb) => toString$5(rpcToBytes(mb));
const rpcToBytes = (mb) => base64url$1.decode(mb);
const rpcToBigInt = (mb) => BigInt(`0x${toString$5(base64url$1.decode(mb), "base16")}`);
const textToUrlSafeRpc = (text) => base64url$1.encode(fromString$3(text));
const createLs$1 = configure((api2) => {
  async function ls(options = {}) {
    const { Strings } = await (await api2.post("pubsub/ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    })).json();
    return rpcArrayToTextArray(Strings) || [];
  }
  return ls;
});
const createPeers$2 = configure((api2) => {
  async function peers(topic, options = {}) {
    const res = await api2.post("pubsub/peers", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: textToUrlSafeRpc(topic),
        ...options
      }),
      headers: options.headers
    });
    const { Strings } = await res.json();
    return Strings || [];
  }
  return peers;
});
const createPublish = configure((api2) => {
  async function publish(topic, data, options = {}) {
    const searchParams = toUrlSearchParams({
      arg: textToUrlSafeRpc(topic),
      ...options
    });
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api2.post("pubsub/pub", {
      signal,
      searchParams,
      ...await multipartRequest([data], controller, options.headers)
    });
    await res.text();
  }
  return publish;
});
const log$T = logger$1("ipfs-http-client:pubsub:subscribe");
const createSubscribe = (options, subsTracker) => {
  return configure((api2) => {
    async function subscribe2(topic, handler, options2 = {}) {
      options2.signal = subsTracker.subscribe(topic, handler, options2.signal);
      let done;
      let fail;
      const result = new Promise((resolve2, reject) => {
        done = resolve2;
        fail = reject;
      });
      const ffWorkaround = setTimeout(() => done(), 1e3);
      api2.post("pubsub/sub", {
        signal: options2.signal,
        searchParams: toUrlSearchParams({
          arg: textToUrlSafeRpc(topic),
          ...options2
        }),
        headers: options2.headers
      }).catch((err2) => {
        subsTracker.unsubscribe(topic, handler);
        fail(err2);
      }).then((response) => {
        clearTimeout(ffWorkaround);
        if (!response) {
          return;
        }
        readMessages(response, {
          onMessage: (message2) => {
            if (!handler) {
              return;
            }
            if (typeof handler === "function") {
              handler(message2);
              return;
            }
            if (typeof handler.handleEvent === "function") {
              handler.handleEvent(message2);
            }
          },
          onEnd: () => subsTracker.unsubscribe(topic, handler),
          onError: options2.onError
        });
        done();
      });
      return result;
    }
    return subscribe2;
  })(options);
};
async function readMessages(response, { onMessage, onEnd, onError }) {
  onError = onError || log$T;
  try {
    for await (const msg of response.ndjson()) {
      try {
        if (!msg.from) {
          continue;
        }
        if (msg.from != null && msg.seqno != null) {
          onMessage({
            type: "signed",
            from: peerIdFromString(msg.from),
            data: rpcToBytes(msg.data),
            sequenceNumber: rpcToBigInt(msg.seqno),
            topic: rpcToText(msg.topicIDs[0]),
            key: rpcToBytes(msg.key ?? "u"),
            signature: rpcToBytes(msg.signature ?? "u")
          });
        } else {
          onMessage({
            type: "unsigned",
            data: rpcToBytes(msg.data),
            topic: rpcToText(msg.topicIDs[0])
          });
        }
      } catch (err2) {
        err2.message = `Failed to parse pubsub message: ${err2.message}`;
        onError(err2, false, msg);
      }
    }
  } catch (err2) {
    if (!isAbortError(err2)) {
      onError(err2, true);
    }
  } finally {
    onEnd();
  }
}
const isAbortError = (error2) => {
  switch (error2.type) {
    case "aborted":
      return true;
    case "abort":
      return true;
    default:
      return error2.name === "AbortError";
  }
};
const createUnsubscribe = (options, subsTracker) => {
  async function unsubscribe(topic, handler) {
    subsTracker.unsubscribe(topic, handler);
  }
  return unsubscribe;
};
class SubscriptionTracker {
  constructor() {
    this._subs = /* @__PURE__ */ new Map();
  }
  subscribe(topic, handler, signal) {
    const topicSubs = this._subs.get(topic) || [];
    if (topicSubs.find((s2) => s2.handler === handler)) {
      throw new Error(`Already subscribed to ${topic} with this handler`);
    }
    const controller = new AbortController();
    this._subs.set(topic, [{ handler, controller }].concat(topicSubs));
    if (signal) {
      signal.addEventListener("abort", () => this.unsubscribe(topic, handler));
    }
    return controller.signal;
  }
  unsubscribe(topic, handler) {
    const subs = this._subs.get(topic) || [];
    let unsubs;
    if (handler) {
      this._subs.set(topic, subs.filter((s2) => s2.handler !== handler));
      unsubs = subs.filter((s2) => s2.handler === handler);
    } else {
      this._subs.set(topic, []);
      unsubs = subs;
    }
    if (!(this._subs.get(topic) || []).length) {
      this._subs.delete(topic);
    }
    unsubs.forEach((s2) => s2.controller.abort());
  }
}
function createPubsub$1(config2) {
  const subscriptionTracker = new SubscriptionTracker();
  return {
    ls: createLs$1(config2),
    peers: createPeers$2(config2),
    publish: createPublish(config2),
    subscribe: createSubscribe(config2, subscriptionTracker),
    unsubscribe: createUnsubscribe(config2, subscriptionTracker)
  };
}
const createLocal = configure((api2) => {
  async function* refsLocal(options = {}) {
    const res = await api2.post("refs/local", {
      signal: options.signal,
      transform: objectToCamel,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    yield* res.ndjson();
  }
  return refsLocal;
});
const createRefs = configure((api2, opts) => {
  const refs = async function* (args, options = {}) {
    const argsArr = Array.isArray(args) ? args : [args];
    const res = await api2.post("refs", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: argsArr.map((arg) => `${arg instanceof Uint8Array ? CID.decode(arg) : arg}`),
        ...options
      }),
      headers: options.headers,
      transform: objectToCamel
    });
    yield* res.ndjson();
  };
  return Object.assign(refs, {
    local: createLocal(opts)
  });
});
const createGc = configure((api2) => {
  async function* gc2(options = {}) {
    const res = await api2.post("repo/gc", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers,
      transform: (res2) => {
        return {
          err: res2.Error ? new Error(res2.Error) : null,
          cid: (res2.Key || {})["/"] ? CID.parse(res2.Key["/"]) : null
        };
      }
    });
    yield* res.ndjson();
  }
  return gc2;
});
const createStat = configure((api2) => {
  async function stat(options = {}) {
    const res = await api2.post("repo/stat", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return {
      numObjects: BigInt(data.NumObjects),
      repoSize: BigInt(data.RepoSize),
      repoPath: data.RepoPath,
      version: data.Version,
      storageMax: BigInt(data.StorageMax)
    };
  }
  return stat;
});
const createVersion$1 = configure((api2) => {
  async function version2(options = {}) {
    const res = await (await api2.post("repo/version", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    })).json();
    return res.Version;
  }
  return version2;
});
function createRepo(config2) {
  return {
    gc: createGc(config2),
    stat: createStat(config2),
    version: createVersion$1(config2)
  };
}
const createBw = configure((api2) => {
  async function* bw(options = {}) {
    const res = await api2.post("stats/bw", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers,
      transform: (stats) => ({
        totalIn: BigInt(stats.TotalIn),
        totalOut: BigInt(stats.TotalOut),
        rateIn: parseFloat(stats.RateIn),
        rateOut: parseFloat(stats.RateOut)
      })
    });
    yield* res.ndjson();
  }
  return bw;
});
function createStats(config2) {
  return {
    bitswap: createStat$4(config2),
    repo: createStat(config2),
    bw: createBw(config2)
  };
}
const createAddrs$1 = configure((api2) => {
  async function addrs(options = {}) {
    const res = await api2.post("swarm/addrs", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const { Addrs } = await res.json();
    return Object.keys(Addrs).map((id) => ({
      id: peerIdFromString(id),
      addrs: (Addrs[id] || []).map((a) => multiaddr(a))
    }));
  }
  return addrs;
});
const createConnect$1 = configure((api2) => {
  async function connect2(addr, options = {}) {
    const res = await api2.post("swarm/connect", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: addr,
        ...options
      }),
      headers: options.headers
    });
    const { Strings } = await res.json();
    return Strings || [];
  }
  return connect2;
});
const createDisconnect$1 = configure((api2) => {
  async function disconnect(addr, options = {}) {
    const res = await api2.post("swarm/disconnect", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: addr,
        ...options
      }),
      headers: options.headers
    });
    const { Strings } = await res.json();
    return Strings || [];
  }
  return disconnect;
});
const createLocalAddrs$1 = configure((api2) => {
  async function localAddrs(options = {}) {
    const res = await api2.post("swarm/addrs/local", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const { Strings } = await res.json();
    return (Strings || []).map((a) => multiaddr(a));
  }
  return localAddrs;
});
const createPeers$1 = configure((api2) => {
  async function peers(options = {}) {
    const res = await api2.post("swarm/peers", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return (Peers || []).map((peer) => {
      return {
        addr: multiaddr(peer.Addr),
        peer: peerIdFromString(peer.Peer),
        muxer: peer.Muxer,
        latency: peer.Latency,
        streams: peer.Streams,
        direction: peer.Direction == null ? void 0 : peer.Direction === 0 ? "inbound" : "outbound"
      };
    });
  }
  return peers;
});
function createSwarm(config2) {
  return {
    addrs: createAddrs$1(config2),
    connect: createConnect$1(config2),
    disconnect: createDisconnect$1(config2),
    localAddrs: createLocalAddrs$1(config2),
    peers: createPeers$1(config2)
  };
}
const createAddAll = configure((api2) => {
  async function* addAll(source2, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const { headers, body, total, parts: parts2 } = await multipartRequest(source2, controller, options.headers);
    const [progressFn, onUploadProgress] = typeof options.progress === "function" ? createProgressHandler(total, parts2, options.progress) : [void 0, void 0];
    const res = await api2.post("add", {
      searchParams: toUrlSearchParams({
        "stream-channels": true,
        ...options,
        progress: Boolean(progressFn)
      }),
      onUploadProgress,
      signal,
      headers,
      body
    });
    for await (let file of res.ndjson()) {
      file = objectToCamel(file);
      if (file.hash !== void 0) {
        yield toCoreInterface(file);
      } else if (progressFn) {
        progressFn(file.bytes || 0, file.name);
      }
    }
  }
  return addAll;
});
const createProgressHandler = (total, parts2, progress) => parts2 ? [void 0, createOnUploadProgress(total, parts2, progress)] : [progress, void 0];
const createOnUploadProgress = (size2, parts2, progress) => {
  let index = 0;
  const count = parts2.length;
  return ({ loaded, total }) => {
    const position = Math.floor(loaded / total * size2);
    while (index < count) {
      const { start, end: end2, name: name2 } = parts2[index];
      if (position < end2) {
        progress(position - start, name2);
        break;
      } else {
        progress(end2 - start, name2);
        index += 1;
      }
    }
  };
};
function toCoreInterface({ name: name2, hash: hash2, size: size2, mode, mtime, mtimeNsecs }) {
  const output = {
    path: name2,
    cid: CID.parse(hash2),
    size: parseInt(size2)
  };
  if (mode != null) {
    output.mode = parseInt(mode, 8);
  }
  if (mtime != null) {
    output.mtime = {
      secs: mtime,
      nsecs: mtimeNsecs || 0
    };
  }
  return output;
}
function createAdd(options) {
  const all2 = createAddAll(options);
  return configure(() => {
    async function add(input, options2 = {}) {
      return await last(all2(normaliseInput$2(input), options2));
    }
    return add;
  })(options);
}
const createCat = configure((api2) => {
  async function* cat(path2, options = {}) {
    const res = await api2.post("cat", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path2.toString(),
        ...options
      }),
      headers: options.headers
    });
    yield* res.iterator();
  }
  return cat;
});
const createCommands = configure((api2) => {
  const commands = async (options = {}) => {
    const res = await api2.post("commands", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return res.json();
  };
  return commands;
});
const createDns = configure((api2) => {
  const dns = async (domain, options = {}) => {
    const res = await api2.post("dns", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: domain,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return data.Path;
  };
  return dns;
});
const createGetEndpointConfig = configure((api2) => {
  return () => {
    const url2 = new URL(api2.opts.base || "");
    return {
      host: url2.hostname,
      port: url2.port,
      protocol: url2.protocol,
      pathname: url2.pathname,
      "api-path": url2.pathname
    };
  };
});
const createGet = configure((api2) => {
  async function* get3(path2, options = {}) {
    const opts = {
      arg: `${path2 instanceof Uint8Array ? CID.decode(path2) : path2}`,
      ...options
    };
    if (opts.compressionLevel) {
      opts["compression-level"] = opts.compressionLevel;
      delete opts.compressionLevel;
    }
    const res = await api2.post("get", {
      signal: options.signal,
      searchParams: toUrlSearchParams(opts),
      headers: options.headers
    });
    yield* res.iterator();
  }
  return get3;
});
const createId = configure((api2) => {
  async function id(options = {}) {
    const res = await api2.post("id", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: options.peerId ? options.peerId.toString() : void 0,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    const output = {
      ...objectToCamel(data)
    };
    output.id = peerIdFromString(output.id);
    if (output.addresses) {
      output.addresses = output.addresses.map((ma) => multiaddr(ma));
    }
    return output;
  }
  return id;
});
const createIsOnline = (options) => {
  const id = createId(options);
  async function isOnline(options2 = {}) {
    const res = await id(options2);
    return Boolean(res && res.addresses && res.addresses.length);
  }
  return isOnline;
};
const createLs = configure((api2, opts) => {
  async function* ls(path2, options = {}) {
    const pathStr = `${path2 instanceof Uint8Array ? CID.decode(path2) : path2}`;
    async function mapLink(link) {
      let hash2 = link.Hash;
      if (hash2.includes("/")) {
        const ipfsPath2 = hash2.startsWith("/ipfs/") ? hash2 : `/ipfs/${hash2}`;
        const stats = await createStat$2(opts)(ipfsPath2);
        hash2 = stats.cid;
      } else {
        hash2 = CID.parse(hash2);
      }
      const entry = {
        name: link.Name,
        path: pathStr + (link.Name ? `/${link.Name}` : ""),
        size: link.Size,
        cid: hash2,
        type: typeOf(link)
      };
      if (link.Mode) {
        entry.mode = parseInt(link.Mode, 8);
      }
      if (link.Mtime !== void 0 && link.Mtime !== null) {
        entry.mtime = {
          secs: link.Mtime
        };
        if (link.MtimeNsecs !== void 0 && link.MtimeNsecs !== null) {
          entry.mtime.nsecs = link.MtimeNsecs;
        }
      }
      return entry;
    }
    const res = await api2.post("ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: pathStr,
        ...options
      }),
      headers: options.headers
    });
    for await (let result of res.ndjson()) {
      result = result.Objects;
      if (!result) {
        throw new Error("expected .Objects in results");
      }
      result = result[0];
      if (!result) {
        throw new Error("expected one array in results.Objects");
      }
      const links2 = result.Links;
      if (!Array.isArray(links2)) {
        throw new Error("expected one array in results.Objects[0].Links");
      }
      if (!links2.length) {
        yield mapLink(result);
        return;
      }
      yield* links2.map(mapLink);
    }
  }
  return ls;
});
function typeOf(link) {
  switch (link.Type) {
    case 1:
    case 5:
      return "dir";
    case 2:
      return "file";
    default:
      return "file";
  }
}
const createMount = configure((api2) => {
  async function mount(options = {}) {
    const res = await api2.post("dns", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return mount;
});
const createPing$1 = configure((api2) => {
  async function* ping(peerId, options = {}) {
    const res = await api2.post("ping", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${peerId}`,
        ...options
      }),
      headers: options.headers,
      transform: objectToCamel
    });
    yield* res.ndjson();
  }
  return ping;
});
const createResolve = configure((api2) => {
  async function resolve2(path2, options = {}) {
    const res = await api2.post("resolve", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path2,
        ...options
      }),
      headers: options.headers
    });
    const { Path } = await res.json();
    return Path;
  }
  return resolve2;
});
const createStart = configure((api2) => {
  const start = async (options = {}) => {
    throw errCode(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
  };
  return start;
});
const createStop = configure((api2) => {
  async function stop2(options = {}) {
    const res = await api2.post("shutdown", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    await res.text();
  }
  return stop2;
});
const createVersion = configure((api2) => {
  async function version2(options = {}) {
    const res = await api2.post("version", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return {
      ...objectToCamel(await res.json()),
      "ipfs-http-client": "1.0.0"
    };
  }
  return version2;
});
function create$2(options = {}) {
  const id = {
    name: identity$5.name,
    code: identity$5.code,
    encode: (id2) => id2,
    decode: (id2) => id2
  };
  const multibaseCodecs = Object.values(bases$1);
  (options.ipld && options.ipld.bases ? options.ipld.bases : []).forEach((base3) => multibaseCodecs.push(base3));
  const multibases = new Multibases({
    bases: multibaseCodecs,
    loadBase: options.ipld && options.ipld.loadBase
  });
  const blockCodecs = Object.values(codecs);
  [dagPB, dagCBOR, dagJSON, dagJOSE, id].concat(options.ipld && options.ipld.codecs || []).forEach((codec) => blockCodecs.push(codec));
  const multicodecs = new Multicodecs({
    codecs: blockCodecs,
    loadCodec: options.ipld && options.ipld.loadCodec
  });
  const multihashHashers = Object.values(hashes);
  (options.ipld && options.ipld.hashers ? options.ipld.hashers : []).forEach((hasher) => multihashHashers.push(hasher));
  const multihashes = new Multihashes({
    hashers: multihashHashers,
    loadHasher: options.ipld && options.ipld.loadHasher
  });
  const client = {
    add: createAdd(options),
    addAll: createAddAll(options),
    bitswap: createBitswap$1(options),
    block: createBlock(options),
    bootstrap: createBootstrap(options),
    cat: createCat(options),
    commands: createCommands(options),
    config: createConfig(options),
    dag: createDag(multicodecs, options),
    dht: createDht$1(options),
    diag: createDiag(options),
    dns: createDns(options),
    files: createFiles(options),
    get: createGet(options),
    getEndpointConfig: createGetEndpointConfig(options),
    id: createId(options),
    isOnline: createIsOnline(options),
    key: createKey(options),
    log: createLog(options),
    ls: createLs(options),
    mount: createMount(options),
    name: createName(options),
    object: createObject(multicodecs, options),
    pin: createPin(options),
    ping: createPing$1(options),
    pubsub: createPubsub$1(options),
    refs: createRefs(options),
    repo: createRepo(options),
    resolve: createResolve(options),
    start: createStart(options),
    stats: createStats(options),
    stop: createStop(options),
    swarm: createSwarm(options),
    version: createVersion(options),
    bases: multibases,
    codecs: multicodecs,
    hashers: multihashes
  };
  return client;
}
const CODE_P2P$1 = 421;
const CODE_CIRCUIT$1 = 290;
const CLOSE_TIMEOUT$1 = 2e3;
const PACKET_TYPES = /* @__PURE__ */ Object.create(null);
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
const PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
Object.keys(PACKET_TYPES).forEach((key) => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
const ERROR_PACKET = { type: "error", data: "parser error" };
const withNativeBlob$1 = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
const withNativeArrayBuffer$2 = typeof ArrayBuffer === "function";
const isView$1 = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
};
const encodePacket = ({ type, data }, supportsBinary, callback) => {
  if (withNativeBlob$1 && data instanceof Blob) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(data, callback);
    }
  } else if (withNativeArrayBuffer$2 && (data instanceof ArrayBuffer || isView$1(data))) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(new Blob([data]), callback);
    }
  }
  return callback(PACKET_TYPES[type] + (data || ""));
};
const encodeBlobAsBase64 = (data, callback) => {
  const fileReader = new FileReader();
  fileReader.onload = function() {
    const content = fileReader.result.split(",")[1];
    callback("b" + content);
  };
  return fileReader.readAsDataURL(data);
};
const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const lookup$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (let i2 = 0; i2 < chars.length; i2++) {
  lookup$1[chars.charCodeAt(i2)] = i2;
}
const decode$2 = (base642) => {
  let bufferLength = base642.length * 0.75, len2 = base642.length, i2, p = 0, encoded1, encoded2, encoded3, encoded4;
  if (base642[base642.length - 1] === "=") {
    bufferLength--;
    if (base642[base642.length - 2] === "=") {
      bufferLength--;
    }
  }
  const arraybuffer = new ArrayBuffer(bufferLength), bytes2 = new Uint8Array(arraybuffer);
  for (i2 = 0; i2 < len2; i2 += 4) {
    encoded1 = lookup$1[base642.charCodeAt(i2)];
    encoded2 = lookup$1[base642.charCodeAt(i2 + 1)];
    encoded3 = lookup$1[base642.charCodeAt(i2 + 2)];
    encoded4 = lookup$1[base642.charCodeAt(i2 + 3)];
    bytes2[p++] = encoded1 << 2 | encoded2 >> 4;
    bytes2[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes2[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return arraybuffer;
};
const withNativeArrayBuffer$1 = typeof ArrayBuffer === "function";
const decodePacket = (encodedPacket, binaryType) => {
  if (typeof encodedPacket !== "string") {
    return {
      type: "message",
      data: mapBinary(encodedPacket, binaryType)
    };
  }
  const type = encodedPacket.charAt(0);
  if (type === "b") {
    return {
      type: "message",
      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
    };
  }
  const packetType = PACKET_TYPES_REVERSE[type];
  if (!packetType) {
    return ERROR_PACKET;
  }
  return encodedPacket.length > 1 ? {
    type: PACKET_TYPES_REVERSE[type],
    data: encodedPacket.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[type]
  };
};
const decodeBase64Packet = (data, binaryType) => {
  if (withNativeArrayBuffer$1) {
    const decoded = decode$2(data);
    return mapBinary(decoded, binaryType);
  } else {
    return { base64: true, data };
  }
};
const mapBinary = (data, binaryType) => {
  switch (binaryType) {
    case "blob":
      return data instanceof ArrayBuffer ? new Blob([data]) : data;
    case "arraybuffer":
    default:
      return data;
  }
};
const SEPARATOR = String.fromCharCode(30);
const encodePayload = (packets, callback) => {
  const length3 = packets.length;
  const encodedPackets = new Array(length3);
  let count = 0;
  packets.forEach((packet, i2) => {
    encodePacket(packet, false, (encodedPacket) => {
      encodedPackets[i2] = encodedPacket;
      if (++count === length3) {
        callback(encodedPackets.join(SEPARATOR));
      }
    });
  });
};
const decodePayload$1 = (encodedPayload, binaryType) => {
  const encodedPackets = encodedPayload.split(SEPARATOR);
  const packets = [];
  for (let i2 = 0; i2 < encodedPackets.length; i2++) {
    const decodedPacket = decodePacket(encodedPackets[i2], binaryType);
    packets.push(decodedPacket);
    if (decodedPacket.type === "error") {
      break;
    }
  }
  return packets;
};
const protocol$1 = 4;
function Emitter(obj) {
  if (obj)
    return mixin(obj);
}
function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}
Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
  return this;
};
Emitter.prototype.once = function(event, fn) {
  function on3() {
    this.off(event, on3);
    fn.apply(this, arguments);
  }
  on3.fn = fn;
  this.on(event, on3);
  return this;
};
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }
  var callbacks = this._callbacks["$" + event];
  if (!callbacks)
    return this;
  if (1 == arguments.length) {
    delete this._callbacks["$" + event];
    return this;
  }
  var cb;
  for (var i2 = 0; i2 < callbacks.length; i2++) {
    cb = callbacks[i2];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i2, 1);
      break;
    }
  }
  if (callbacks.length === 0) {
    delete this._callbacks["$" + event];
  }
  return this;
};
Emitter.prototype.emit = function(event) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
  for (var i2 = 1; i2 < arguments.length; i2++) {
    args[i2 - 1] = arguments[i2];
  }
  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i2 = 0, len2 = callbacks.length; i2 < len2; ++i2) {
      callbacks[i2].apply(this, args);
    }
  }
  return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
Emitter.prototype.listeners = function(event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks["$" + event] || [];
};
Emitter.prototype.hasListeners = function(event) {
  return !!this.listeners(event).length;
};
const globalThisShim = (() => {
  if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else {
    return Function("return this")();
  }
})();
function pick(obj, ...attr) {
  return attr.reduce((acc, k) => {
    if (obj.hasOwnProperty(k)) {
      acc[k] = obj[k];
    }
    return acc;
  }, {});
}
const NATIVE_SET_TIMEOUT = setTimeout;
const NATIVE_CLEAR_TIMEOUT = clearTimeout;
function installTimerFunctions(obj, opts) {
  if (opts.useNativeTimers) {
    obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);
    obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);
  } else {
    obj.setTimeoutFn = setTimeout.bind(globalThisShim);
    obj.clearTimeoutFn = clearTimeout.bind(globalThisShim);
  }
}
const BASE64_OVERHEAD = 1.33;
function byteLength(obj) {
  if (typeof obj === "string") {
    return utf8Length(obj);
  }
  return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
function utf8Length(str) {
  let c = 0, length3 = 0;
  for (let i2 = 0, l = str.length; i2 < l; i2++) {
    c = str.charCodeAt(i2);
    if (c < 128) {
      length3 += 1;
    } else if (c < 2048) {
      length3 += 2;
    } else if (c < 55296 || c >= 57344) {
      length3 += 3;
    } else {
      i2++;
      length3 += 4;
    }
  }
  return length3;
}
class TransportError extends Error {
  constructor(reason, description, context) {
    super(reason);
    this.description = description;
    this.context = context;
    this.type = "TransportError";
  }
}
class Transport extends Emitter {
  constructor(opts) {
    super();
    this.writable = false;
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.query = opts.query;
    this.readyState = "";
    this.socket = opts.socket;
  }
  onError(reason, description, context) {
    super.emitReserved("error", new TransportError(reason, description, context));
    return this;
  }
  open() {
    if ("closed" === this.readyState || "" === this.readyState) {
      this.readyState = "opening";
      this.doOpen();
    }
    return this;
  }
  close() {
    if ("opening" === this.readyState || "open" === this.readyState) {
      this.doClose();
      this.onClose();
    }
    return this;
  }
  send(packets) {
    if ("open" === this.readyState) {
      this.write(packets);
    }
  }
  onOpen() {
    this.readyState = "open";
    this.writable = true;
    super.emitReserved("open");
  }
  onData(data) {
    const packet = decodePacket(data, this.socket.binaryType);
    this.onPacket(packet);
  }
  onPacket(packet) {
    super.emitReserved("packet", packet);
  }
  onClose(details) {
    this.readyState = "closed";
    super.emitReserved("close", details);
  }
}
const alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), length$1 = 64, map$1 = {};
let seed = 0, i = 0, prev;
function encode$4(num) {
  let encoded = "";
  do {
    encoded = alphabet[num % length$1] + encoded;
    num = Math.floor(num / length$1);
  } while (num > 0);
  return encoded;
}
function yeast() {
  const now = encode$4(+new Date());
  if (now !== prev)
    return seed = 0, prev = now;
  return now + "." + encode$4(seed++);
}
for (; i < length$1; i++)
  map$1[alphabet[i]] = i;
function encode$3(obj) {
  let str = "";
  for (let i2 in obj) {
    if (obj.hasOwnProperty(i2)) {
      if (str.length)
        str += "&";
      str += encodeURIComponent(i2) + "=" + encodeURIComponent(obj[i2]);
    }
  }
  return str;
}
function decode$1(qs) {
  let qry = {};
  let pairs = qs.split("&");
  for (let i2 = 0, l = pairs.length; i2 < l; i2++) {
    let pair2 = pairs[i2].split("=");
    qry[decodeURIComponent(pair2[0])] = decodeURIComponent(pair2[1]);
  }
  return qry;
}
let value = false;
try {
  value = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
} catch (err2) {
}
const hasCORS = value;
function XHR(opts) {
  const xdomain = opts.xdomain;
  try {
    if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) {
  }
  if (!xdomain) {
    try {
      return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch (e) {
    }
  }
}
function empty() {
}
const hasXHR2 = function() {
  const xhr = new XHR({
    xdomain: false
  });
  return null != xhr.responseType;
}();
class Polling extends Transport {
  constructor(opts) {
    super(opts);
    this.polling = false;
    if (typeof location !== "undefined") {
      const isSSL = "https:" === location.protocol;
      let port = location.port;
      if (!port) {
        port = isSSL ? "443" : "80";
      }
      this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
      this.xs = opts.secure !== isSSL;
    }
    const forceBase64 = opts && opts.forceBase64;
    this.supportsBinary = hasXHR2 && !forceBase64;
  }
  get name() {
    return "polling";
  }
  doOpen() {
    this.poll();
  }
  pause(onPause) {
    this.readyState = "pausing";
    const pause = () => {
      this.readyState = "paused";
      onPause();
    };
    if (this.polling || !this.writable) {
      let total = 0;
      if (this.polling) {
        total++;
        this.once("pollComplete", function() {
          --total || pause();
        });
      }
      if (!this.writable) {
        total++;
        this.once("drain", function() {
          --total || pause();
        });
      }
    } else {
      pause();
    }
  }
  poll() {
    this.polling = true;
    this.doPoll();
    this.emitReserved("poll");
  }
  onData(data) {
    const callback = (packet) => {
      if ("opening" === this.readyState && packet.type === "open") {
        this.onOpen();
      }
      if ("close" === packet.type) {
        this.onClose({ description: "transport closed by the server" });
        return false;
      }
      this.onPacket(packet);
    };
    decodePayload$1(data, this.socket.binaryType).forEach(callback);
    if ("closed" !== this.readyState) {
      this.polling = false;
      this.emitReserved("pollComplete");
      if ("open" === this.readyState) {
        this.poll();
      }
    }
  }
  doClose() {
    const close = () => {
      this.write([{ type: "close" }]);
    };
    if ("open" === this.readyState) {
      close();
    } else {
      this.once("open", close);
    }
  }
  write(packets) {
    this.writable = false;
    encodePayload(packets, (data) => {
      this.doWrite(data, () => {
        this.writable = true;
        this.emitReserved("drain");
      });
    });
  }
  uri() {
    let query = this.query || {};
    const schema = this.opts.secure ? "https" : "http";
    let port = "";
    if (false !== this.opts.timestampRequests) {
      query[this.opts.timestampParam] = yeast();
    }
    if (!this.supportsBinary && !query.sid) {
      query.b64 = 1;
    }
    if (this.opts.port && ("https" === schema && Number(this.opts.port) !== 443 || "http" === schema && Number(this.opts.port) !== 80)) {
      port = ":" + this.opts.port;
    }
    const encodedQuery = encode$3(query);
    const ipv6 = this.opts.hostname.indexOf(":") !== -1;
    return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + (encodedQuery.length ? "?" + encodedQuery : "");
  }
  request(opts = {}) {
    Object.assign(opts, { xd: this.xd, xs: this.xs }, this.opts);
    return new Request(this.uri(), opts);
  }
  doWrite(data, fn) {
    const req = this.request({
      method: "POST",
      data
    });
    req.on("success", fn);
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr post error", xhrStatus, context);
    });
  }
  doPoll() {
    const req = this.request();
    req.on("data", this.onData.bind(this));
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr poll error", xhrStatus, context);
    });
    this.pollXhr = req;
  }
}
class Request extends Emitter {
  constructor(uri, opts) {
    super();
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.method = opts.method || "GET";
    this.uri = uri;
    this.async = false !== opts.async;
    this.data = void 0 !== opts.data ? opts.data : null;
    this.create();
  }
  create() {
    const opts = pick(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    opts.xdomain = !!this.opts.xd;
    opts.xscheme = !!this.opts.xs;
    const xhr = this.xhr = new XHR(opts);
    try {
      xhr.open(this.method, this.uri, this.async);
      try {
        if (this.opts.extraHeaders) {
          xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
          for (let i2 in this.opts.extraHeaders) {
            if (this.opts.extraHeaders.hasOwnProperty(i2)) {
              xhr.setRequestHeader(i2, this.opts.extraHeaders[i2]);
            }
          }
        }
      } catch (e) {
      }
      if ("POST" === this.method) {
        try {
          xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch (e) {
        }
      }
      try {
        xhr.setRequestHeader("Accept", "*/*");
      } catch (e) {
      }
      if ("withCredentials" in xhr) {
        xhr.withCredentials = this.opts.withCredentials;
      }
      if (this.opts.requestTimeout) {
        xhr.timeout = this.opts.requestTimeout;
      }
      xhr.onreadystatechange = () => {
        if (4 !== xhr.readyState)
          return;
        if (200 === xhr.status || 1223 === xhr.status) {
          this.onLoad();
        } else {
          this.setTimeoutFn(() => {
            this.onError(typeof xhr.status === "number" ? xhr.status : 0);
          }, 0);
        }
      };
      xhr.send(this.data);
    } catch (e) {
      this.setTimeoutFn(() => {
        this.onError(e);
      }, 0);
      return;
    }
    if (typeof document !== "undefined") {
      this.index = Request.requestsCount++;
      Request.requests[this.index] = this;
    }
  }
  onError(err2) {
    this.emitReserved("error", err2, this.xhr);
    this.cleanup(true);
  }
  cleanup(fromError) {
    if ("undefined" === typeof this.xhr || null === this.xhr) {
      return;
    }
    this.xhr.onreadystatechange = empty;
    if (fromError) {
      try {
        this.xhr.abort();
      } catch (e) {
      }
    }
    if (typeof document !== "undefined") {
      delete Request.requests[this.index];
    }
    this.xhr = null;
  }
  onLoad() {
    const data = this.xhr.responseText;
    if (data !== null) {
      this.emitReserved("data", data);
      this.emitReserved("success");
      this.cleanup();
    }
  }
  abort() {
    this.cleanup();
  }
}
Request.requestsCount = 0;
Request.requests = {};
if (typeof document !== "undefined") {
  if (typeof attachEvent === "function") {
    attachEvent("onunload", unloadHandler);
  } else if (typeof addEventListener === "function") {
    const terminationEvent = "onpagehide" in globalThisShim ? "pagehide" : "unload";
    addEventListener(terminationEvent, unloadHandler, false);
  }
}
function unloadHandler() {
  for (let i2 in Request.requests) {
    if (Request.requests.hasOwnProperty(i2)) {
      Request.requests[i2].abort();
    }
  }
}
const nextTick = (() => {
  const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
  if (isPromiseAvailable) {
    return (cb) => Promise.resolve().then(cb);
  } else {
    return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
  }
})();
const WebSocket$2 = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
const usingBrowserWebSocket = true;
const defaultBinaryType = "arraybuffer";
const isReactNative$1 = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
class WS extends Transport {
  constructor(opts) {
    super(opts);
    this.supportsBinary = !opts.forceBase64;
  }
  get name() {
    return "websocket";
  }
  doOpen() {
    if (!this.check()) {
      return;
    }
    const uri = this.uri();
    const protocols = this.opts.protocols;
    const opts = isReactNative$1 ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    if (this.opts.extraHeaders) {
      opts.headers = this.opts.extraHeaders;
    }
    try {
      this.ws = usingBrowserWebSocket && !isReactNative$1 ? protocols ? new WebSocket$2(uri, protocols) : new WebSocket$2(uri) : new WebSocket$2(uri, protocols, opts);
    } catch (err2) {
      return this.emitReserved("error", err2);
    }
    this.ws.binaryType = this.socket.binaryType || defaultBinaryType;
    this.addEventListeners();
  }
  addEventListeners() {
    this.ws.onopen = () => {
      if (this.opts.autoUnref) {
        this.ws._socket.unref();
      }
      this.onOpen();
    };
    this.ws.onclose = (closeEvent) => this.onClose({
      description: "websocket connection closed",
      context: closeEvent
    });
    this.ws.onmessage = (ev) => this.onData(ev.data);
    this.ws.onerror = (e) => this.onError("websocket error", e);
  }
  write(packets) {
    this.writable = false;
    for (let i2 = 0; i2 < packets.length; i2++) {
      const packet = packets[i2];
      const lastPacket = i2 === packets.length - 1;
      encodePacket(packet, this.supportsBinary, (data) => {
        const opts = {};
        try {
          if (usingBrowserWebSocket) {
            this.ws.send(data);
          }
        } catch (e) {
        }
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    if (typeof this.ws !== "undefined") {
      this.ws.close();
      this.ws = null;
    }
  }
  uri() {
    let query = this.query || {};
    const schema = this.opts.secure ? "wss" : "ws";
    let port = "";
    if (this.opts.port && ("wss" === schema && Number(this.opts.port) !== 443 || "ws" === schema && Number(this.opts.port) !== 80)) {
      port = ":" + this.opts.port;
    }
    if (this.opts.timestampRequests) {
      query[this.opts.timestampParam] = yeast();
    }
    if (!this.supportsBinary) {
      query.b64 = 1;
    }
    const encodedQuery = encode$3(query);
    const ipv6 = this.opts.hostname.indexOf(":") !== -1;
    return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + (encodedQuery.length ? "?" + encodedQuery : "");
  }
  check() {
    return !!WebSocket$2;
  }
}
const transports = {
  websocket: WS,
  polling: Polling
};
const re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
const parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function parse$1(str) {
  const src2 = str, b2 = str.indexOf("["), e = str.indexOf("]");
  if (b2 != -1 && e != -1) {
    str = str.substring(0, b2) + str.substring(b2, e).replace(/:/g, ";") + str.substring(e, str.length);
  }
  let m = re.exec(str || ""), uri = {}, i2 = 14;
  while (i2--) {
    uri[parts[i2]] = m[i2] || "";
  }
  if (b2 != -1 && e != -1) {
    uri.source = src2;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
    uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
    uri.ipv6uri = true;
  }
  uri.pathNames = pathNames(uri, uri["path"]);
  uri.queryKey = queryKey(uri, uri["query"]);
  return uri;
}
function pathNames(obj, path2) {
  const regx = /\/{2,9}/g, names2 = path2.replace(regx, "/").split("/");
  if (path2.slice(0, 1) == "/" || path2.length === 0) {
    names2.splice(0, 1);
  }
  if (path2.slice(-1) == "/") {
    names2.splice(names2.length - 1, 1);
  }
  return names2;
}
function queryKey(uri, query) {
  const data = {};
  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
    if ($1) {
      data[$1] = $2;
    }
  });
  return data;
}
class Socket$1 extends Emitter {
  constructor(uri, opts = {}) {
    super();
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = null;
    }
    if (uri) {
      uri = parse$1(uri);
      opts.hostname = uri.host;
      opts.secure = uri.protocol === "https" || uri.protocol === "wss";
      opts.port = uri.port;
      if (uri.query)
        opts.query = uri.query;
    } else if (opts.host) {
      opts.hostname = parse$1(opts.host).host;
    }
    installTimerFunctions(this, opts);
    this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
    if (opts.hostname && !opts.port) {
      opts.port = this.secure ? "443" : "80";
    }
    this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
    this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
    this.transports = opts.transports || ["polling", "websocket"];
    this.readyState = "";
    this.writeBuffer = [];
    this.prevBufferLen = 0;
    this.opts = Object.assign({
      path: "/engine.io",
      agent: false,
      withCredentials: false,
      upgrade: true,
      timestampParam: "t",
      rememberUpgrade: false,
      rejectUnauthorized: true,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: true
    }, opts);
    this.opts.path = this.opts.path.replace(/\/$/, "") + "/";
    if (typeof this.opts.query === "string") {
      this.opts.query = decode$1(this.opts.query);
    }
    this.id = null;
    this.upgrades = null;
    this.pingInterval = null;
    this.pingTimeout = null;
    this.pingTimeoutTimer = null;
    if (typeof addEventListener === "function") {
      if (this.opts.closeOnBeforeunload) {
        this.beforeunloadEventListener = () => {
          if (this.transport) {
            this.transport.removeAllListeners();
            this.transport.close();
          }
        };
        addEventListener("beforeunload", this.beforeunloadEventListener, false);
      }
      if (this.hostname !== "localhost") {
        this.offlineEventListener = () => {
          this.onClose("transport close", {
            description: "network connection lost"
          });
        };
        addEventListener("offline", this.offlineEventListener, false);
      }
    }
    this.open();
  }
  createTransport(name2) {
    const query = Object.assign({}, this.opts.query);
    query.EIO = protocol$1;
    query.transport = name2;
    if (this.id)
      query.sid = this.id;
    const opts = Object.assign({}, this.opts.transportOptions[name2], this.opts, {
      query,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    });
    return new transports[name2](opts);
  }
  open() {
    let transport;
    if (this.opts.rememberUpgrade && Socket$1.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) {
      transport = "websocket";
    } else if (0 === this.transports.length) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    } else {
      transport = this.transports[0];
    }
    this.readyState = "opening";
    try {
      transport = this.createTransport(transport);
    } catch (e) {
      this.transports.shift();
      this.open();
      return;
    }
    transport.open();
    this.setTransport(transport);
  }
  setTransport(transport) {
    if (this.transport) {
      this.transport.removeAllListeners();
    }
    this.transport = transport;
    transport.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (reason) => this.onClose("transport close", reason));
  }
  probe(name2) {
    let transport = this.createTransport(name2);
    let failed = false;
    Socket$1.priorWebsocketSuccess = false;
    const onTransportOpen = () => {
      if (failed)
        return;
      transport.send([{ type: "ping", data: "probe" }]);
      transport.once("packet", (msg) => {
        if (failed)
          return;
        if ("pong" === msg.type && "probe" === msg.data) {
          this.upgrading = true;
          this.emitReserved("upgrading", transport);
          if (!transport)
            return;
          Socket$1.priorWebsocketSuccess = "websocket" === transport.name;
          this.transport.pause(() => {
            if (failed)
              return;
            if ("closed" === this.readyState)
              return;
            cleanup();
            this.setTransport(transport);
            transport.send([{ type: "upgrade" }]);
            this.emitReserved("upgrade", transport);
            transport = null;
            this.upgrading = false;
            this.flush();
          });
        } else {
          const err2 = new Error("probe error");
          err2.transport = transport.name;
          this.emitReserved("upgradeError", err2);
        }
      });
    };
    function freezeTransport() {
      if (failed)
        return;
      failed = true;
      cleanup();
      transport.close();
      transport = null;
    }
    const onerror = (err2) => {
      const error2 = new Error("probe error: " + err2);
      error2.transport = transport.name;
      freezeTransport();
      this.emitReserved("upgradeError", error2);
    };
    function onTransportClose() {
      onerror("transport closed");
    }
    function onclose() {
      onerror("socket closed");
    }
    function onupgrade(to) {
      if (transport && to.name !== transport.name) {
        freezeTransport();
      }
    }
    const cleanup = () => {
      transport.removeListener("open", onTransportOpen);
      transport.removeListener("error", onerror);
      transport.removeListener("close", onTransportClose);
      this.off("close", onclose);
      this.off("upgrading", onupgrade);
    };
    transport.once("open", onTransportOpen);
    transport.once("error", onerror);
    transport.once("close", onTransportClose);
    this.once("close", onclose);
    this.once("upgrading", onupgrade);
    transport.open();
  }
  onOpen() {
    this.readyState = "open";
    Socket$1.priorWebsocketSuccess = "websocket" === this.transport.name;
    this.emitReserved("open");
    this.flush();
    if ("open" === this.readyState && this.opts.upgrade && this.transport.pause) {
      let i2 = 0;
      const l = this.upgrades.length;
      for (; i2 < l; i2++) {
        this.probe(this.upgrades[i2]);
      }
    }
  }
  onPacket(packet) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.emitReserved("packet", packet);
      this.emitReserved("heartbeat");
      switch (packet.type) {
        case "open":
          this.onHandshake(JSON.parse(packet.data));
          break;
        case "ping":
          this.resetPingTimeout();
          this.sendPacket("pong");
          this.emitReserved("ping");
          this.emitReserved("pong");
          break;
        case "error":
          const err2 = new Error("server error");
          err2.code = packet.data;
          this.onError(err2);
          break;
        case "message":
          this.emitReserved("data", packet.data);
          this.emitReserved("message", packet.data);
          break;
      }
    }
  }
  onHandshake(data) {
    this.emitReserved("handshake", data);
    this.id = data.sid;
    this.transport.query.sid = data.sid;
    this.upgrades = this.filterUpgrades(data.upgrades);
    this.pingInterval = data.pingInterval;
    this.pingTimeout = data.pingTimeout;
    this.maxPayload = data.maxPayload;
    this.onOpen();
    if ("closed" === this.readyState)
      return;
    this.resetPingTimeout();
  }
  resetPingTimeout() {
    this.clearTimeoutFn(this.pingTimeoutTimer);
    this.pingTimeoutTimer = this.setTimeoutFn(() => {
      this.onClose("ping timeout");
    }, this.pingInterval + this.pingTimeout);
    if (this.opts.autoUnref) {
      this.pingTimeoutTimer.unref();
    }
  }
  onDrain() {
    this.writeBuffer.splice(0, this.prevBufferLen);
    this.prevBufferLen = 0;
    if (0 === this.writeBuffer.length) {
      this.emitReserved("drain");
    } else {
      this.flush();
    }
  }
  flush() {
    if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const packets = this.getWritablePackets();
      this.transport.send(packets);
      this.prevBufferLen = packets.length;
      this.emitReserved("flush");
    }
  }
  getWritablePackets() {
    const shouldCheckPayloadSize = this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
    if (!shouldCheckPayloadSize) {
      return this.writeBuffer;
    }
    let payloadSize = 1;
    for (let i2 = 0; i2 < this.writeBuffer.length; i2++) {
      const data = this.writeBuffer[i2].data;
      if (data) {
        payloadSize += byteLength(data);
      }
      if (i2 > 0 && payloadSize > this.maxPayload) {
        return this.writeBuffer.slice(0, i2);
      }
      payloadSize += 2;
    }
    return this.writeBuffer;
  }
  write(msg, options, fn) {
    this.sendPacket("message", msg, options, fn);
    return this;
  }
  send(msg, options, fn) {
    this.sendPacket("message", msg, options, fn);
    return this;
  }
  sendPacket(type, data, options, fn) {
    if ("function" === typeof data) {
      fn = data;
      data = void 0;
    }
    if ("function" === typeof options) {
      fn = options;
      options = null;
    }
    if ("closing" === this.readyState || "closed" === this.readyState) {
      return;
    }
    options = options || {};
    options.compress = false !== options.compress;
    const packet = {
      type,
      data,
      options
    };
    this.emitReserved("packetCreate", packet);
    this.writeBuffer.push(packet);
    if (fn)
      this.once("flush", fn);
    this.flush();
  }
  close() {
    const close = () => {
      this.onClose("forced close");
      this.transport.close();
    };
    const cleanupAndClose = () => {
      this.off("upgrade", cleanupAndClose);
      this.off("upgradeError", cleanupAndClose);
      close();
    };
    const waitForUpgrade = () => {
      this.once("upgrade", cleanupAndClose);
      this.once("upgradeError", cleanupAndClose);
    };
    if ("opening" === this.readyState || "open" === this.readyState) {
      this.readyState = "closing";
      if (this.writeBuffer.length) {
        this.once("drain", () => {
          if (this.upgrading) {
            waitForUpgrade();
          } else {
            close();
          }
        });
      } else if (this.upgrading) {
        waitForUpgrade();
      } else {
        close();
      }
    }
    return this;
  }
  onError(err2) {
    Socket$1.priorWebsocketSuccess = false;
    this.emitReserved("error", err2);
    this.onClose("transport error", err2);
  }
  onClose(reason, description) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.clearTimeoutFn(this.pingTimeoutTimer);
      this.transport.removeAllListeners("close");
      this.transport.close();
      this.transport.removeAllListeners();
      if (typeof removeEventListener === "function") {
        removeEventListener("beforeunload", this.beforeunloadEventListener, false);
        removeEventListener("offline", this.offlineEventListener, false);
      }
      this.readyState = "closed";
      this.id = null;
      this.emitReserved("close", reason, description);
      this.writeBuffer = [];
      this.prevBufferLen = 0;
    }
  }
  filterUpgrades(upgrades) {
    const filteredUpgrades = [];
    let i2 = 0;
    const j = upgrades.length;
    for (; i2 < j; i2++) {
      if (~this.transports.indexOf(upgrades[i2]))
        filteredUpgrades.push(upgrades[i2]);
    }
    return filteredUpgrades;
  }
}
Socket$1.protocol = protocol$1;
function url(uri, path2 = "", loc) {
  let obj = uri;
  loc = loc || typeof location !== "undefined" && location;
  if (null == uri)
    uri = loc.protocol + "//" + loc.host;
  if (typeof uri === "string") {
    if ("/" === uri.charAt(0)) {
      if ("/" === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }
    if (!/^(https?|wss?):\/\//.test(uri)) {
      if ("undefined" !== typeof loc) {
        uri = loc.protocol + "//" + uri;
      } else {
        uri = "https://" + uri;
      }
    }
    obj = parse$1(uri);
  }
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = "80";
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = "443";
    }
  }
  obj.path = obj.path || "/";
  const ipv6 = obj.host.indexOf(":") !== -1;
  const host = ipv6 ? "[" + obj.host + "]" : obj.host;
  obj.id = obj.protocol + "://" + host + ":" + obj.port + path2;
  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
  return obj;
}
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const isView = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
const toString = Object.prototype.toString;
const withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
const withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
function isBinary(obj) {
  return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
}
function hasBinary(obj, toJSON) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  if (Array.isArray(obj)) {
    for (let i2 = 0, l = obj.length; i2 < l; i2++) {
      if (hasBinary(obj[i2])) {
        return true;
      }
    }
    return false;
  }
  if (isBinary(obj)) {
    return true;
  }
  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }
  return false;
}
function deconstructPacket(packet) {
  const buffers = [];
  const packetData = packet.data;
  const pack2 = packet;
  pack2.data = _deconstructPacket(packetData, buffers);
  pack2.attachments = buffers.length;
  return { packet: pack2, buffers };
}
function _deconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (isBinary(data)) {
    const placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (Array.isArray(data)) {
    const newData = new Array(data.length);
    for (let i2 = 0; i2 < data.length; i2++) {
      newData[i2] = _deconstructPacket(data[i2], buffers);
    }
    return newData;
  } else if (typeof data === "object" && !(data instanceof Date)) {
    const newData = {};
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        newData[key] = _deconstructPacket(data[key], buffers);
      }
    }
    return newData;
  }
  return data;
}
function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  packet.attachments = void 0;
  return packet;
}
function _reconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (data && data._placeholder === true) {
    const isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
    if (isIndexValid) {
      return buffers[data.num];
    } else {
      throw new Error("illegal attachments");
    }
  } else if (Array.isArray(data)) {
    for (let i2 = 0; i2 < data.length; i2++) {
      data[i2] = _reconstructPacket(data[i2], buffers);
    }
  } else if (typeof data === "object") {
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        data[key] = _reconstructPacket(data[key], buffers);
      }
    }
  }
  return data;
}
const protocol = 5;
var PacketType;
(function(PacketType2) {
  PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
  PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
  PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
  PacketType2[PacketType2["ACK"] = 3] = "ACK";
  PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
  PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
  PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
class Encoder$1 {
  constructor(replacer) {
    this.replacer = replacer;
  }
  encode(obj) {
    if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
      if (hasBinary(obj)) {
        obj.type = obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK;
        return this.encodeAsBinary(obj);
      }
    }
    return [this.encodeAsString(obj)];
  }
  encodeAsString(obj) {
    let str = "" + obj.type;
    if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
      str += obj.attachments + "-";
    }
    if (obj.nsp && "/" !== obj.nsp) {
      str += obj.nsp + ",";
    }
    if (null != obj.id) {
      str += obj.id;
    }
    if (null != obj.data) {
      str += JSON.stringify(obj.data, this.replacer);
    }
    return str;
  }
  encodeAsBinary(obj) {
    const deconstruction = deconstructPacket(obj);
    const pack2 = this.encodeAsString(deconstruction.packet);
    const buffers = deconstruction.buffers;
    buffers.unshift(pack2);
    return buffers;
  }
}
class Decoder$1 extends Emitter {
  constructor(reviver) {
    super();
    this.reviver = reviver;
  }
  add(obj) {
    let packet;
    if (typeof obj === "string") {
      if (this.reconstructor) {
        throw new Error("got plaintext data when reconstructing a packet");
      }
      packet = this.decodeString(obj);
      if (packet.type === PacketType.BINARY_EVENT || packet.type === PacketType.BINARY_ACK) {
        this.reconstructor = new BinaryReconstructor(packet);
        if (packet.attachments === 0) {
          super.emitReserved("decoded", packet);
        }
      } else {
        super.emitReserved("decoded", packet);
      }
    } else if (isBinary(obj) || obj.base64) {
      if (!this.reconstructor) {
        throw new Error("got binary data when not reconstructing a packet");
      } else {
        packet = this.reconstructor.takeBinaryData(obj);
        if (packet) {
          this.reconstructor = null;
          super.emitReserved("decoded", packet);
        }
      }
    } else {
      throw new Error("Unknown type: " + obj);
    }
  }
  decodeString(str) {
    let i2 = 0;
    const p = {
      type: Number(str.charAt(0))
    };
    if (PacketType[p.type] === void 0) {
      throw new Error("unknown packet type " + p.type);
    }
    if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
      const start = i2 + 1;
      while (str.charAt(++i2) !== "-" && i2 != str.length) {
      }
      const buf2 = str.substring(start, i2);
      if (buf2 != Number(buf2) || str.charAt(i2) !== "-") {
        throw new Error("Illegal attachments");
      }
      p.attachments = Number(buf2);
    }
    if ("/" === str.charAt(i2 + 1)) {
      const start = i2 + 1;
      while (++i2) {
        const c = str.charAt(i2);
        if ("," === c)
          break;
        if (i2 === str.length)
          break;
      }
      p.nsp = str.substring(start, i2);
    } else {
      p.nsp = "/";
    }
    const next = str.charAt(i2 + 1);
    if ("" !== next && Number(next) == next) {
      const start = i2 + 1;
      while (++i2) {
        const c = str.charAt(i2);
        if (null == c || Number(c) != c) {
          --i2;
          break;
        }
        if (i2 === str.length)
          break;
      }
      p.id = Number(str.substring(start, i2 + 1));
    }
    if (str.charAt(++i2)) {
      const payload = this.tryParse(str.substr(i2));
      if (Decoder$1.isPayloadValid(p.type, payload)) {
        p.data = payload;
      } else {
        throw new Error("invalid payload");
      }
    }
    return p;
  }
  tryParse(str) {
    try {
      return JSON.parse(str, this.reviver);
    } catch (e) {
      return false;
    }
  }
  static isPayloadValid(type, payload) {
    switch (type) {
      case PacketType.CONNECT:
        return typeof payload === "object";
      case PacketType.DISCONNECT:
        return payload === void 0;
      case PacketType.CONNECT_ERROR:
        return typeof payload === "string" || typeof payload === "object";
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        return Array.isArray(payload) && payload.length > 0;
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        return Array.isArray(payload);
    }
  }
  destroy() {
    if (this.reconstructor) {
      this.reconstructor.finishedReconstruction();
    }
  }
}
class BinaryReconstructor {
  constructor(packet) {
    this.packet = packet;
    this.buffers = [];
    this.reconPack = packet;
  }
  takeBinaryData(binData) {
    this.buffers.push(binData);
    if (this.buffers.length === this.reconPack.attachments) {
      const packet = reconstructPacket(this.reconPack, this.buffers);
      this.finishedReconstruction();
      return packet;
    }
    return null;
  }
  finishedReconstruction() {
    this.reconPack = null;
    this.buffers = [];
  }
}
const parser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  protocol,
  get PacketType() {
    return PacketType;
  },
  Encoder: Encoder$1,
  Decoder: Decoder$1
}, Symbol.toStringTag, { value: "Module" }));
function on(obj, ev, fn) {
  obj.on(ev, fn);
  return function subDestroy() {
    obj.off(ev, fn);
  };
}
const RESERVED_EVENTS = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  newListener: 1,
  removeListener: 1
});
class Socket extends Emitter {
  constructor(io, nsp, opts) {
    super();
    this.connected = false;
    this.receiveBuffer = [];
    this.sendBuffer = [];
    this.ids = 0;
    this.acks = {};
    this.flags = {};
    this.io = io;
    this.nsp = nsp;
    if (opts && opts.auth) {
      this.auth = opts.auth;
    }
    if (this.io._autoConnect)
      this.open();
  }
  get disconnected() {
    return !this.connected;
  }
  subEvents() {
    if (this.subs)
      return;
    const io = this.io;
    this.subs = [
      on(io, "open", this.onopen.bind(this)),
      on(io, "packet", this.onpacket.bind(this)),
      on(io, "error", this.onerror.bind(this)),
      on(io, "close", this.onclose.bind(this))
    ];
  }
  get active() {
    return !!this.subs;
  }
  connect() {
    if (this.connected)
      return this;
    this.subEvents();
    if (!this.io["_reconnecting"])
      this.io.open();
    if ("open" === this.io._readyState)
      this.onopen();
    return this;
  }
  open() {
    return this.connect();
  }
  send(...args) {
    args.unshift("message");
    this.emit.apply(this, args);
    return this;
  }
  emit(ev, ...args) {
    if (RESERVED_EVENTS.hasOwnProperty(ev)) {
      throw new Error('"' + ev.toString() + '" is a reserved event name');
    }
    args.unshift(ev);
    const packet = {
      type: PacketType.EVENT,
      data: args
    };
    packet.options = {};
    packet.options.compress = this.flags.compress !== false;
    if ("function" === typeof args[args.length - 1]) {
      const id = this.ids++;
      const ack = args.pop();
      this._registerAckCallback(id, ack);
      packet.id = id;
    }
    const isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
    const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);
    if (discardPacket)
      ;
    else if (this.connected) {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    } else {
      this.sendBuffer.push(packet);
    }
    this.flags = {};
    return this;
  }
  _registerAckCallback(id, ack) {
    const timeout2 = this.flags.timeout;
    if (timeout2 === void 0) {
      this.acks[id] = ack;
      return;
    }
    const timer = this.io.setTimeoutFn(() => {
      delete this.acks[id];
      for (let i2 = 0; i2 < this.sendBuffer.length; i2++) {
        if (this.sendBuffer[i2].id === id) {
          this.sendBuffer.splice(i2, 1);
        }
      }
      ack.call(this, new Error("operation has timed out"));
    }, timeout2);
    this.acks[id] = (...args) => {
      this.io.clearTimeoutFn(timer);
      ack.apply(this, [null, ...args]);
    };
  }
  packet(packet) {
    packet.nsp = this.nsp;
    this.io._packet(packet);
  }
  onopen() {
    if (typeof this.auth == "function") {
      this.auth((data) => {
        this.packet({ type: PacketType.CONNECT, data });
      });
    } else {
      this.packet({ type: PacketType.CONNECT, data: this.auth });
    }
  }
  onerror(err2) {
    if (!this.connected) {
      this.emitReserved("connect_error", err2);
    }
  }
  onclose(reason, description) {
    this.connected = false;
    delete this.id;
    this.emitReserved("disconnect", reason, description);
  }
  onpacket(packet) {
    const sameNamespace = packet.nsp === this.nsp;
    if (!sameNamespace)
      return;
    switch (packet.type) {
      case PacketType.CONNECT:
        if (packet.data && packet.data.sid) {
          const id = packet.data.sid;
          this.onconnect(id);
        } else {
          this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
        }
        break;
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        this.onevent(packet);
        break;
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        this.onack(packet);
        break;
      case PacketType.DISCONNECT:
        this.ondisconnect();
        break;
      case PacketType.CONNECT_ERROR:
        this.destroy();
        const err2 = new Error(packet.data.message);
        err2.data = packet.data.data;
        this.emitReserved("connect_error", err2);
        break;
    }
  }
  onevent(packet) {
    const args = packet.data || [];
    if (null != packet.id) {
      args.push(this.ack(packet.id));
    }
    if (this.connected) {
      this.emitEvent(args);
    } else {
      this.receiveBuffer.push(Object.freeze(args));
    }
  }
  emitEvent(args) {
    if (this._anyListeners && this._anyListeners.length) {
      const listeners2 = this._anyListeners.slice();
      for (const listener of listeners2) {
        listener.apply(this, args);
      }
    }
    super.emit.apply(this, args);
  }
  ack(id) {
    const self2 = this;
    let sent = false;
    return function(...args) {
      if (sent)
        return;
      sent = true;
      self2.packet({
        type: PacketType.ACK,
        id,
        data: args
      });
    };
  }
  onack(packet) {
    const ack = this.acks[packet.id];
    if ("function" === typeof ack) {
      ack.apply(this, packet.data);
      delete this.acks[packet.id];
    }
  }
  onconnect(id) {
    this.id = id;
    this.connected = true;
    this.emitBuffered();
    this.emitReserved("connect");
  }
  emitBuffered() {
    this.receiveBuffer.forEach((args) => this.emitEvent(args));
    this.receiveBuffer = [];
    this.sendBuffer.forEach((packet) => {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    });
    this.sendBuffer = [];
  }
  ondisconnect() {
    this.destroy();
    this.onclose("io server disconnect");
  }
  destroy() {
    if (this.subs) {
      this.subs.forEach((subDestroy) => subDestroy());
      this.subs = void 0;
    }
    this.io["_destroy"](this);
  }
  disconnect() {
    if (this.connected) {
      this.packet({ type: PacketType.DISCONNECT });
    }
    this.destroy();
    if (this.connected) {
      this.onclose("io client disconnect");
    }
    return this;
  }
  close() {
    return this.disconnect();
  }
  compress(compress) {
    this.flags.compress = compress;
    return this;
  }
  get volatile() {
    this.flags.volatile = true;
    return this;
  }
  timeout(timeout2) {
    this.flags.timeout = timeout2;
    return this;
  }
  onAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.push(listener);
    return this;
  }
  prependAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.unshift(listener);
    return this;
  }
  offAny(listener) {
    if (!this._anyListeners) {
      return this;
    }
    if (listener) {
      const listeners2 = this._anyListeners;
      for (let i2 = 0; i2 < listeners2.length; i2++) {
        if (listener === listeners2[i2]) {
          listeners2.splice(i2, 1);
          return this;
        }
      }
    } else {
      this._anyListeners = [];
    }
    return this;
  }
  listenersAny() {
    return this._anyListeners || [];
  }
  onAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.push(listener);
    return this;
  }
  prependAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.unshift(listener);
    return this;
  }
  offAnyOutgoing(listener) {
    if (!this._anyOutgoingListeners) {
      return this;
    }
    if (listener) {
      const listeners2 = this._anyOutgoingListeners;
      for (let i2 = 0; i2 < listeners2.length; i2++) {
        if (listener === listeners2[i2]) {
          listeners2.splice(i2, 1);
          return this;
        }
      }
    } else {
      this._anyOutgoingListeners = [];
    }
    return this;
  }
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  notifyOutgoingListeners(packet) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const listeners2 = this._anyOutgoingListeners.slice();
      for (const listener of listeners2) {
        listener.apply(this, packet.data);
      }
    }
  }
}
function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 1e4;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
Backoff.prototype.duration = function() {
  var ms2 = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms2);
    ms2 = (Math.floor(rand * 10) & 1) == 0 ? ms2 - deviation : ms2 + deviation;
  }
  return Math.min(ms2, this.max) | 0;
};
Backoff.prototype.reset = function() {
  this.attempts = 0;
};
Backoff.prototype.setMin = function(min) {
  this.ms = min;
};
Backoff.prototype.setMax = function(max) {
  this.max = max;
};
Backoff.prototype.setJitter = function(jitter) {
  this.jitter = jitter;
};
class Manager extends Emitter {
  constructor(uri, opts) {
    var _a2;
    super();
    this.nsps = {};
    this.subs = [];
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = void 0;
    }
    opts = opts || {};
    opts.path = opts.path || "/socket.io";
    this.opts = opts;
    installTimerFunctions(this, opts);
    this.reconnection(opts.reconnection !== false);
    this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
    this.reconnectionDelay(opts.reconnectionDelay || 1e3);
    this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
    this.randomizationFactor((_a2 = opts.randomizationFactor) !== null && _a2 !== void 0 ? _a2 : 0.5);
    this.backoff = new Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    });
    this.timeout(null == opts.timeout ? 2e4 : opts.timeout);
    this._readyState = "closed";
    this.uri = uri;
    const _parser = opts.parser || parser;
    this.encoder = new _parser.Encoder();
    this.decoder = new _parser.Decoder();
    this._autoConnect = opts.autoConnect !== false;
    if (this._autoConnect)
      this.open();
  }
  reconnection(v) {
    if (!arguments.length)
      return this._reconnection;
    this._reconnection = !!v;
    return this;
  }
  reconnectionAttempts(v) {
    if (v === void 0)
      return this._reconnectionAttempts;
    this._reconnectionAttempts = v;
    return this;
  }
  reconnectionDelay(v) {
    var _a2;
    if (v === void 0)
      return this._reconnectionDelay;
    this._reconnectionDelay = v;
    (_a2 = this.backoff) === null || _a2 === void 0 ? void 0 : _a2.setMin(v);
    return this;
  }
  randomizationFactor(v) {
    var _a2;
    if (v === void 0)
      return this._randomizationFactor;
    this._randomizationFactor = v;
    (_a2 = this.backoff) === null || _a2 === void 0 ? void 0 : _a2.setJitter(v);
    return this;
  }
  reconnectionDelayMax(v) {
    var _a2;
    if (v === void 0)
      return this._reconnectionDelayMax;
    this._reconnectionDelayMax = v;
    (_a2 = this.backoff) === null || _a2 === void 0 ? void 0 : _a2.setMax(v);
    return this;
  }
  timeout(v) {
    if (!arguments.length)
      return this._timeout;
    this._timeout = v;
    return this;
  }
  maybeReconnectOnOpen() {
    if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
      this.reconnect();
    }
  }
  open(fn) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Socket$1(this.uri, this.opts);
    const socket = this.engine;
    const self2 = this;
    this._readyState = "opening";
    this.skipReconnect = false;
    const openSubDestroy = on(socket, "open", function() {
      self2.onopen();
      fn && fn();
    });
    const errorSub = on(socket, "error", (err2) => {
      self2.cleanup();
      self2._readyState = "closed";
      this.emitReserved("error", err2);
      if (fn) {
        fn(err2);
      } else {
        self2.maybeReconnectOnOpen();
      }
    });
    if (false !== this._timeout) {
      const timeout2 = this._timeout;
      if (timeout2 === 0) {
        openSubDestroy();
      }
      const timer = this.setTimeoutFn(() => {
        openSubDestroy();
        socket.close();
        socket.emit("error", new Error("timeout"));
      }, timeout2);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(function subDestroy() {
        clearTimeout(timer);
      });
    }
    this.subs.push(openSubDestroy);
    this.subs.push(errorSub);
    return this;
  }
  connect(fn) {
    return this.open(fn);
  }
  onopen() {
    this.cleanup();
    this._readyState = "open";
    this.emitReserved("open");
    const socket = this.engine;
    this.subs.push(on(socket, "ping", this.onping.bind(this)), on(socket, "data", this.ondata.bind(this)), on(socket, "error", this.onerror.bind(this)), on(socket, "close", this.onclose.bind(this)), on(this.decoder, "decoded", this.ondecoded.bind(this)));
  }
  onping() {
    this.emitReserved("ping");
  }
  ondata(data) {
    try {
      this.decoder.add(data);
    } catch (e) {
      this.onclose("parse error", e);
    }
  }
  ondecoded(packet) {
    nextTick(() => {
      this.emitReserved("packet", packet);
    }, this.setTimeoutFn);
  }
  onerror(err2) {
    this.emitReserved("error", err2);
  }
  socket(nsp, opts) {
    let socket = this.nsps[nsp];
    if (!socket) {
      socket = new Socket(this, nsp, opts);
      this.nsps[nsp] = socket;
    }
    return socket;
  }
  _destroy(socket) {
    const nsps = Object.keys(this.nsps);
    for (const nsp of nsps) {
      const socket2 = this.nsps[nsp];
      if (socket2.active) {
        return;
      }
    }
    this._close();
  }
  _packet(packet) {
    const encodedPackets = this.encoder.encode(packet);
    for (let i2 = 0; i2 < encodedPackets.length; i2++) {
      this.engine.write(encodedPackets[i2], packet.options);
    }
  }
  cleanup() {
    this.subs.forEach((subDestroy) => subDestroy());
    this.subs.length = 0;
    this.decoder.destroy();
  }
  _close() {
    this.skipReconnect = true;
    this._reconnecting = false;
    this.onclose("forced close");
    if (this.engine)
      this.engine.close();
  }
  disconnect() {
    return this._close();
  }
  onclose(reason, description) {
    this.cleanup();
    this.backoff.reset();
    this._readyState = "closed";
    this.emitReserved("close", reason, description);
    if (this._reconnection && !this.skipReconnect) {
      this.reconnect();
    }
  }
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const self2 = this;
    if (this.backoff.attempts >= this._reconnectionAttempts) {
      this.backoff.reset();
      this.emitReserved("reconnect_failed");
      this._reconnecting = false;
    } else {
      const delay2 = this.backoff.duration();
      this._reconnecting = true;
      const timer = this.setTimeoutFn(() => {
        if (self2.skipReconnect)
          return;
        this.emitReserved("reconnect_attempt", self2.backoff.attempts);
        if (self2.skipReconnect)
          return;
        self2.open((err2) => {
          if (err2) {
            self2._reconnecting = false;
            self2.reconnect();
            this.emitReserved("reconnect_error", err2);
          } else {
            self2.onreconnect();
          }
        });
      }, delay2);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(function subDestroy() {
        clearTimeout(timer);
      });
    }
  }
  onreconnect() {
    const attempt = this.backoff.attempts;
    this._reconnecting = false;
    this.backoff.reset();
    this.emitReserved("reconnect", attempt);
  }
}
const cache$1 = {};
function lookup(uri, opts) {
  if (typeof uri === "object") {
    opts = uri;
    uri = void 0;
  }
  opts = opts || {};
  const parsed = url(uri, opts.path || "/socket.io");
  const source2 = parsed.source;
  const id = parsed.id;
  const path2 = parsed.path;
  const sameNamespace = cache$1[id] && path2 in cache$1[id]["nsps"];
  const newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
  let io;
  if (newConnection) {
    io = new Manager(source2, opts);
  } else {
    if (!cache$1[id]) {
      cache$1[id] = new Manager(source2, opts);
    }
    io = cache$1[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.queryKey;
  }
  return io.socket(parsed.path, opts);
}
Object.assign(lookup, {
  Manager,
  Socket,
  io: lookup,
  connect: lookup
});
const MAX_BYTES$1 = 65536;
function randomBytes$2(size2) {
  const bytes2 = new Uint8Array(size2);
  let generated = 0;
  if (size2 > 0) {
    if (size2 > MAX_BYTES$1) {
      while (generated < size2) {
        if (generated + MAX_BYTES$1 > size2) {
          crypto.getRandomValues(
            bytes2.subarray(generated, generated + (size2 - generated))
          );
          generated += size2 - generated;
        } else {
          crypto.getRandomValues(
            bytes2.subarray(generated, generated + MAX_BYTES$1)
          );
          generated += MAX_BYTES$1;
        }
      }
    } else {
      crypto.getRandomValues(bytes2);
    }
  }
  return bytes2;
}
var random_browser = randomBytes$2;
const MAX_BUFFERED_AMOUNT = 64 * 1024;
const CHANNEL_CLOSING_TIMEOUT = 5 * 1e3;
class WebRTCDataChannel {
  constructor(channel2, opts) {
    this.label = channel2.label;
    this.open = pDefer$1();
    this.channel = channel2;
    this.channel.binaryType = "arraybuffer";
    this.log = opts.log;
    if (typeof this.channel.bufferedAmountLowThreshold === "number") {
      this.channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT;
    }
    channel2.addEventListener("message", (event) => {
      opts.onMessage(event);
    });
    channel2.addEventListener("bufferedamountlow", () => {
      this.log("stop backpressure: bufferedAmount %d", this.channel.bufferedAmount);
      this.open.resolve();
    });
    channel2.addEventListener("open", () => {
      this.open.resolve();
      opts.onOpen();
    });
    channel2.addEventListener("close", () => {
      opts.onClose();
    });
    channel2.addEventListener("error", (event) => {
      if (event.error?.message === "Transport channel closed") {
        return this.close();
      }
      opts.log.error('channel encounter an error in state "%s" message: "%s" detail: "%s', channel2.readyState, event.error?.message, event.error?.errorDetail);
      const err2 = event.error instanceof Error ? event.error : new Error(`datachannel error: ${event.error?.message} ${event.error?.errorDetail}`);
      opts.onError(errCode(err2, "ERR_DATA_CHANNEL"));
    });
    let isClosing = false;
    this.closingInterval = setInterval(() => {
      if (channel2.readyState === "closing") {
        if (isClosing) {
          opts.onClose();
        }
        isClosing = true;
      } else {
        isClosing = false;
      }
    }, CHANNEL_CLOSING_TIMEOUT);
  }
  async send(data) {
    await this.open.promise;
    this.channel.send(data);
    if (this.channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
      this.log("start backpressure: bufferedAmount %d", this.channel.bufferedAmount);
      this.open = pDefer$1();
    }
  }
  close() {
    clearInterval(this.closingInterval);
    this.channel.close();
  }
  get bufferedAmount() {
    return this.channel.bufferedAmount;
  }
}
var delay$1 = { exports: {} };
const randomInteger = (minimum, maximum) => Math.floor(Math.random() * (maximum - minimum + 1) + minimum);
const createAbortError = () => {
  const error2 = new Error("Delay aborted");
  error2.name = "AbortError";
  return error2;
};
const createDelay = ({ clearTimeout: defaultClear, setTimeout: set2, willResolve }) => (ms2, { value: value2, signal } = {}) => {
  if (signal && signal.aborted) {
    return Promise.reject(createAbortError());
  }
  let timeoutId;
  let settle;
  let rejectFn;
  const clear4 = defaultClear || clearTimeout;
  const signalListener = () => {
    clear4(timeoutId);
    rejectFn(createAbortError());
  };
  const cleanup = () => {
    if (signal) {
      signal.removeEventListener("abort", signalListener);
    }
  };
  const delayPromise = new Promise((resolve2, reject) => {
    settle = () => {
      cleanup();
      if (willResolve) {
        resolve2(value2);
      } else {
        reject(value2);
      }
    };
    rejectFn = reject;
    timeoutId = (set2 || setTimeout)(settle, ms2);
  });
  if (signal) {
    signal.addEventListener("abort", signalListener, { once: true });
  }
  delayPromise.clear = () => {
    clear4(timeoutId);
    timeoutId = null;
    settle();
  };
  return delayPromise;
};
const createWithTimers = (clearAndSet) => {
  const delay2 = createDelay({ ...clearAndSet, willResolve: true });
  delay2.reject = createDelay({ ...clearAndSet, willResolve: false });
  delay2.range = (minimum, maximum, options) => delay2(randomInteger(minimum, maximum), options);
  return delay2;
};
const delay = createWithTimers();
delay.createWithTimers = createWithTimers;
delay$1.exports = delay;
delay$1.exports.default = delay;
const DEFAULT_PEER_CONNECTION_CONFIG = {
  iceServers: [{
    urls: [
      "stun:stun.l.google.com:19302",
      "stun:globalThis.stun.twilio.com:3478"
    ]
  }]
};
function getBrowserRTC() {
  if (typeof globalThis === "undefined") {
    throw errCode(new Error("No WebRTC support detected"), "ERR_WEBRTC_SUPPORT");
  }
  const wrtc = {
    RTCPeerConnection: globalThis.RTCPeerConnection ?? globalThis.mozRTCPeerConnection ?? globalThis.webkitRTCPeerConnection,
    RTCSessionDescription: globalThis.RTCSessionDescription ?? globalThis.mozRTCSessionDescription ?? globalThis.webkitRTCSessionDescription,
    RTCIceCandidate: globalThis.RTCIceCandidate ?? globalThis.mozRTCIceCandidate ?? globalThis.webkitRTCIceCandidate
  };
  if (wrtc.RTCPeerConnection == null) {
    throw errCode(new Error("No WebRTC support detected"), "ERR_WEBRTC_SUPPORT");
  }
  return wrtc;
}
class WebRTCPeer extends EventEmitter$1 {
  constructor(opts) {
    super();
    this.id = opts.id ?? toString$5(random_browser(4), "hex").slice(0, 7);
    this.log = logger$1(`libp2p:webrtc-peer:${opts.logPrefix}:${this.id}`);
    this.wrtc = opts.wrtc ?? getBrowserRTC();
    this.peerConnection = new this.wrtc.RTCPeerConnection(Object.assign({}, DEFAULT_PEER_CONNECTION_CONFIG, opts.peerConnectionConfig));
    this.closed = false;
    this.connected = pDefer$1();
    this.source = pushable();
    this.sink = async (source2) => {
      await this.connected.promise;
      if (this.channel == null) {
        throw errCode(new Error("Connected but no channel?!"), "ERR_DATA_CHANNEL");
      }
      for await (const buf2 of source2) {
        await this.channel.send(buf2);
      }
      await this.close();
    };
  }
  handleDataChannelEvent(event) {
    const dataChannel = event.channel;
    if (dataChannel == null) {
      this.close(errCode(new Error("Data channel event is missing `channel` property"), "ERR_DATA_CHANNEL")).catch((err2) => {
        this.log("Error closing after event channel was found to be null", err2);
      });
      return;
    }
    this.channel = new WebRTCDataChannel(dataChannel, {
      log: this.log,
      onMessage: (event2) => {
        this.source.push(new Uint8Array(event2.data));
      },
      onOpen: () => {
        this.connected.resolve();
        this.dispatchEvent(new CustomEvent("ready"));
      },
      onClose: () => {
        this.close().catch((err2) => {
          this.log("error closing connection after channel close", err2);
        });
      },
      onError: (err2) => {
        this.close(err2).catch((err3) => {
          this.log("error closing connection after channel error", err3);
        });
      }
    });
  }
  async close(err2) {
    this.closed = true;
    if (err2 == null && this.channel != null) {
      while (this.channel.bufferedAmount > 0) {
        await delay$1.exports(100);
      }
    }
    this.channel?.close();
    this.peerConnection.close();
    this.source.end(err2);
    this.dispatchEvent(new CustomEvent("close"));
  }
}
class WebRTCHandshake extends EventEmitter$1 {
  constructor(options) {
    super();
    this.log = options.log;
    this.peerConnection = options.peerConnection;
    this.wrtc = options.wrtc;
    this.status = "idle";
    this.peerConnection.addEventListener("negotiationneeded", () => {
      this.log("peer connection negotiation needed");
      this.handleRenegotiate({ type: "renegotiate" }).catch((err2) => {
        this.log.error("could not renegotiate %o", err2);
      });
    });
  }
  async handleSignal(signal) {
    this.log('incoming signal "%s"', signal.type);
    if (signal.type === "offer") {
      return await this.handleOffer(signal);
    } else if (signal.type === "answer") {
      return await this.handleAnswer(signal);
    } else if (signal.type === "candidate") {
      return await this.handleCandidate(signal);
    } else if (signal.type === "renegotiate") {
      return await this.handleRenegotiate(signal);
    } else if (signal.type === "goodbye") {
      return await this.handleGoodye(signal);
    } else {
      this.log(`Unknown signal type ${signal.type}`);
    }
  }
  async handleOffer(signal) {
  }
  async handleAnswer(signal) {
  }
  async handleRenegotiate(signal) {
  }
  async handleGoodye(signal) {
    this.peerConnection.close();
  }
  async handleCandidate(signal) {
    const iceCandidate = new this.wrtc.RTCIceCandidate(signal.candidate);
    try {
      await this.peerConnection.addIceCandidate(iceCandidate);
    } catch (err2) {
      if (iceCandidate.address == null || iceCandidate.address.endsWith(".local")) {
        this.log("ignoring unsupported ICE candidate.");
      } else {
        throw errCode(err2, "ERR_ADD_ICE_CANDIDATE");
      }
    }
  }
}
const log$S = logger$1("libp2p:webrtc-peer:receiver");
class WebRTCReceiver extends WebRTCPeer {
  constructor(opts = {}) {
    super({
      ...opts,
      logPrefix: "receiver"
    });
    this.handshake = new WebRTCReceiverHandshake({
      log: this.log,
      peerConnection: this.peerConnection,
      wrtc: this.wrtc,
      answerOptions: opts.answerOptions
    });
    this.handshake.addEventListener("signal", (event) => this.dispatchEvent(new CustomEvent("signal", {
      detail: event.detail
    })));
    this.peerConnection.addEventListener("datachannel", (event) => {
      this.handleDataChannelEvent(event);
    });
  }
  handleSignal(signal) {
    this.handshake.handleSignal(signal).catch((err2) => {
      this.log("error handling signal %o %o", signal, err2);
    });
  }
}
class WebRTCReceiverHandshake extends WebRTCHandshake {
  constructor(options) {
    super(options);
    this.options = options;
    this.status = "idle";
    this.iceCandidates = [];
  }
  async handleRenegotiate() {
    log$S.trace("renegotiate");
    this.dispatchEvent(new CustomEvent("signal", {
      detail: {
        type: "renegotiate"
      }
    }));
  }
  async handleOffer(signal) {
    await this.peerConnection.setRemoteDescription(new this.wrtc.RTCSessionDescription(signal));
    for (const candidate of this.iceCandidates) {
      await this.handleCandidate(candidate);
    }
    this.iceCandidates = [];
    const answer = await this.peerConnection.createAnswer(this.options.answerOptions);
    await this.peerConnection.setLocalDescription(answer);
    log$S.trace("handle offer", this.peerConnection.localDescription);
    this.dispatchEvent(new CustomEvent("signal", {
      detail: this.peerConnection.localDescription ?? answer
    }));
  }
  async handleCandidate(signal) {
    if (this.peerConnection.remoteDescription == null || this.peerConnection.remoteDescription.type == null) {
      this.iceCandidates.push(signal);
      return;
    }
    await super.handleCandidate(signal);
  }
}
const normalizeEmitter = (emitter) => {
  const addListener2 = emitter.on || emitter.addListener || emitter.addEventListener;
  const removeListener2 = emitter.off || emitter.removeListener || emitter.removeEventListener;
  if (!addListener2 || !removeListener2) {
    throw new TypeError("Emitter is not compatible");
  }
  return {
    addListener: addListener2.bind(emitter),
    removeListener: removeListener2.bind(emitter)
  };
};
function pEventMultiple(emitter, event, options) {
  let cancel;
  const returnValue = new Promise((resolve2, reject) => {
    options = {
      rejectionEvents: ["error"],
      multiArgs: false,
      resolveImmediately: false,
      ...options
    };
    if (!(options.count >= 0 && (options.count === Number.POSITIVE_INFINITY || Number.isInteger(options.count)))) {
      throw new TypeError("The `count` option should be at least 0 or more");
    }
    const events2 = [event].flat();
    const items = [];
    const { addListener: addListener2, removeListener: removeListener2 } = normalizeEmitter(emitter);
    const onItem = (...arguments_) => {
      const value2 = options.multiArgs ? arguments_ : arguments_[0];
      if (options.filter && !options.filter(value2)) {
        return;
      }
      items.push(value2);
      if (options.count === items.length) {
        cancel();
        resolve2(items);
      }
    };
    const rejectHandler = (error2) => {
      cancel();
      reject(error2);
    };
    cancel = () => {
      for (const event2 of events2) {
        removeListener2(event2, onItem);
      }
      for (const rejectionEvent of options.rejectionEvents) {
        removeListener2(rejectionEvent, rejectHandler);
      }
    };
    for (const event2 of events2) {
      addListener2(event2, onItem);
    }
    for (const rejectionEvent of options.rejectionEvents) {
      addListener2(rejectionEvent, rejectHandler);
    }
    if (options.resolveImmediately) {
      resolve2(items);
    }
  });
  returnValue.cancel = cancel;
  if (typeof options.timeout === "number") {
    const timeout2 = pTimeout$1(returnValue, options.timeout);
    timeout2.cancel = cancel;
    return timeout2;
  }
  return returnValue;
}
function pEvent(emitter, event, options) {
  if (typeof options === "function") {
    options = { filter: options };
  }
  options = {
    ...options,
    count: 1,
    resolveImmediately: false
  };
  const arrayPromise = pEventMultiple(emitter, event, options);
  const promise2 = arrayPromise.then((array) => array[0]);
  promise2.cancel = arrayPromise.cancel;
  return promise2;
}
const log$R = logger$1("libp2p:webrtc-peer:initator");
const ICECOMPLETE_TIMEOUT = 1e3;
class WebRTCInitiator extends WebRTCPeer {
  constructor(opts = {}) {
    super({
      ...opts,
      logPrefix: "initiator"
    });
    this.handleDataChannelEvent({
      channel: this.peerConnection.createDataChannel(opts.dataChannelLabel ?? toString$5(random_browser(20), "hex").slice(0, 7), opts.dataChannelInit)
    });
    this.handshake = new WebRTCInitiatorHandshake({
      log: this.log,
      peerConnection: this.peerConnection,
      wrtc: this.wrtc,
      offerOptions: opts.offerOptions
    });
    this.handshake.addEventListener("signal", (event) => {
      this.dispatchEvent(new CustomEvent("signal", { detail: event.detail }));
    });
  }
  handleSignal(signal) {
    this.handshake.handleSignal(signal).catch((err2) => {
      this.log("error handling signal %o %o", signal, err2);
    });
  }
}
class WebRTCInitiatorHandshake extends WebRTCHandshake {
  constructor(options) {
    super(options);
    this.options = options;
    this.status = "idle";
    this.peerConnection.addEventListener("icecandidate", (event) => {
      if (event.candidate == null) {
        return;
      }
      const signal = {
        type: "candidate",
        candidate: {
          candidate: event.candidate.candidate,
          sdpMLineIndex: event.candidate.sdpMLineIndex,
          sdpMid: event.candidate.sdpMid
        }
      };
      log$R.trace("create candidate", signal);
      this.dispatchEvent(new CustomEvent("signal", {
        detail: signal
      }));
      this.dispatchEvent(new CustomEvent("ice-candidate"));
    });
  }
  async handleRenegotiate() {
    if (this.status === "negotiating") {
      this.log("already negotiating, queueing");
      return;
    }
    this.status = "negotiating";
    const offer = await this.peerConnection.createOffer(this.options.offerOptions);
    await this.peerConnection.setLocalDescription(offer);
    await pEvent(this, "ice-candidate");
    await delay$1.exports(ICECOMPLETE_TIMEOUT);
    log$R.trace("renegotiate", this.peerConnection.localDescription);
    this.dispatchEvent(new CustomEvent("signal", {
      detail: this.peerConnection.localDescription ?? offer
    }));
  }
  async handleAnswer(signal) {
    log$R.trace("handle answer", signal);
    await this.peerConnection.setRemoteDescription(new this.wrtc.RTCSessionDescription(signal));
    this.status = "idle";
  }
}
const log$Q = logger$1("libp2p:webrtc-star:socket");
function toMultiaddrConnection(socket, options) {
  const { sink: sink2, source: source2 } = socket;
  const maConn = {
    remoteAddr: options.remoteAddr,
    async sink(source3) {
      if (options.signal != null) {
        source3 = abortableSource(source3, options.signal);
      }
      try {
        await sink2(source3);
      } catch (err2) {
        if (err2.type !== "aborted") {
          log$Q.error(err2);
        }
      }
    },
    source: options.signal != null ? abortableSource(source2, options.signal) : source2,
    timeline: { open: Date.now() },
    async close() {
      if (socket.closed) {
        return;
      }
      const start = Date.now();
      const timeout2 = setTimeout(() => {
        if (maConn.remoteAddr != null) {
          const { host, port } = maConn.remoteAddr.toOptions();
          log$Q("timeout closing socket to %s:%s after %dms, destroying it manually", host, port, Date.now() - start);
        }
        if (!socket.closed) {
          socket.close().catch((err2) => {
            log$Q.error("could not close socket", err2);
          });
        }
      }, CLOSE_TIMEOUT$1);
      try {
        await socket.close();
      } finally {
        clearTimeout(timeout2);
      }
    }
  };
  socket.addEventListener("close", () => {
    if (maConn.timeline.close == null) {
      maConn.timeline.close = Date.now();
    }
  }, {
    once: true
  });
  return maConn;
}
function cleanUrlSIO(ma) {
  const maStrSplit = ma.toString().split("/");
  const tcpProto = ma.protos()[1].name;
  const wsProto = ma.protos()[2].name;
  const tcpPort = ma.stringTuples()[1][1];
  if (tcpProto !== "tcp" || wsProto !== "ws" && wsProto !== "wss") {
    throw new Error(`invalid multiaddr: ${ma.toString()}`);
  }
  if (!isName(ma)) {
    return `http://${maStrSplit[2]}:${maStrSplit[4]}`;
  }
  if (wsProto === "ws") {
    return `http://${maStrSplit[2]}${tcpPort == null || tcpPort === "80" ? "" : `:${tcpPort}`}`;
  }
  if (wsProto === "wss") {
    return `https://${maStrSplit[2]}${tcpPort == null || tcpPort === "443" ? "" : `:${tcpPort}`}`;
  }
  throw new Error("invalid multiaddr: " + ma.toString());
}
function cleanMultiaddr(maStr) {
  const legacy = "/libp2p-webrtc-star";
  if (maStr.startsWith(legacy)) {
    maStr = maStr.substring(legacy.length, maStr.length);
    let ma = multiaddr(maStr);
    const tuppleIPFS = ma.stringTuples().filter((tupple) => {
      return tupple[0] === 421;
    })[0];
    if (tuppleIPFS[1] == null) {
      throw new Error("invalid multiaddr: " + maStr);
    }
    ma = ma.decapsulate("p2p");
    ma = ma.encapsulate("/p2p-webrtc-star");
    ma = ma.encapsulate(`/p2p/${tuppleIPFS[1]}`);
    maStr = ma.toString();
  }
  return maStr;
}
const log$P = logger$1("libp2p:webrtc-star:listener");
const sioOptions = {
  transports: ["websocket"],
  path: "/socket.io-next/"
};
class SigServer extends EventEmitter$1 {
  constructor(signallingUrl, signallingAddr, upgrader, handler, channelOptions) {
    super();
    this.signallingAddr = signallingAddr;
    this.socket = lookup(signallingUrl, sioOptions);
    this.connections = [];
    this.channels = /* @__PURE__ */ new Map();
    this.pendingSignals = /* @__PURE__ */ new Map();
    this.upgrader = upgrader;
    this.handler = handler;
    this.channelOptions = channelOptions;
    this.handleWsHandshake = this.handleWsHandshake.bind(this);
    let previouslyConnected = false;
    this.socket.on("connect_error", (err2) => {
      if (previouslyConnected && err2.type === "TransportError") {
        return;
      }
      this.dispatchEvent(new CustomEvent("error", {
        detail: err2
      }));
    });
    this.socket.on("error", (err2) => {
      this.dispatchEvent(new CustomEvent("error", {
        detail: err2
      }));
    });
    this.socket.on("ws-handshake", this.handleWsHandshake);
    this.socket.on("ws-peer", (maStr) => {
      this.dispatchEvent(new CustomEvent("peer", {
        detail: maStr
      }));
    });
    this.socket.on("connect", () => {
      this.socket.emit("ss-join", this.signallingAddr.toString());
      if (previouslyConnected) {
        this.dispatchEvent(new CustomEvent("reconnect"));
      }
    });
    this.socket.once("connect", () => {
      previouslyConnected = true;
      this.dispatchEvent(new CustomEvent("listening"));
    });
    this.socket.on("disconnect", () => {
      this.dispatchEvent(new CustomEvent("disconnect"));
    });
  }
  _createChannel(intentId, srcMultiaddr, dstMultiaddr) {
    const channelOptions = {
      ...this.channelOptions
    };
    const channel2 = new WebRTCReceiver(channelOptions);
    const onError = (evt) => {
      const err2 = evt.detail;
      log$P.error("incoming connection errored", err2);
    };
    channel2.addEventListener("error", onError);
    channel2.addEventListener("close", () => {
      channel2.removeEventListener("error", onError);
    }, {
      once: true
    });
    channel2.addEventListener("signal", (evt) => {
      const signal = evt.detail;
      this.socket.emit("ss-handshake", {
        intentId,
        srcMultiaddr,
        dstMultiaddr,
        answer: true,
        signal
      });
    });
    channel2.addEventListener("ready", () => {
      const maConn = toMultiaddrConnection(channel2, { remoteAddr: this.signallingAddr });
      log$P("new inbound connection %s", maConn.remoteAddr);
      try {
        this.upgrader.upgradeInbound(maConn).then((conn) => {
          log$P("inbound connection %s upgraded", maConn.remoteAddr);
          this.connections.push(maConn);
          const untrackConn = () => {
            this.connections = this.connections.filter((c) => c !== maConn);
            this.channels.delete(intentId);
            this.pendingSignals.delete(intentId);
          };
          channel2.addEventListener("close", untrackConn, {
            once: true
          });
          this.dispatchEvent(new CustomEvent("connection", {
            detail: conn
          }));
          this.handler(conn);
        }).catch((err2) => {
          log$P.error("inbound connection failed to upgrade", err2);
          maConn.close().catch((err3) => {
            log$P.error("inbound connection failed to close after failing to upgrade", err3);
          });
        });
      } catch (err2) {
        log$P.error("inbound connection failed to upgrade", err2);
        maConn.close().catch((err3) => {
          log$P.error("inbound connection failed to close after failing to upgrade", err3);
        });
      }
    }, {
      once: true
    });
    return channel2;
  }
  handleWsHandshake(offer) {
    log$P('incoming handshake. signal type "%s" is answer %s', offer.signal.type, offer.answer);
    if (offer.answer === true || offer.err != null || offer.intentId == null) {
      return;
    }
    const intentId = offer.intentId;
    let pendingSignals = this.pendingSignals.get(intentId);
    if (pendingSignals == null) {
      pendingSignals = [];
      this.pendingSignals.set(intentId, pendingSignals);
    }
    pendingSignals.push(offer);
    let channel2 = this.channels.get(intentId);
    if (channel2 == null) {
      if (offer.signal.type !== "offer") {
        log$P("handshake is not an offer and channel does not exist, buffering until we receive an offer");
        return;
      }
      log$P("creating new channel to handle offer handshake");
      channel2 = this._createChannel(offer.intentId, offer.srcMultiaddr, offer.dstMultiaddr);
      this.channels.set(intentId, channel2);
    } else {
      log$P("channel already exists, using it to handle handshake");
    }
    while (pendingSignals.length > 0) {
      const handshake2 = pendingSignals.shift();
      if (handshake2?.signal != null) {
        channel2.handleSignal(handshake2.signal);
      }
    }
  }
  async close() {
    this.socket.emit("ss-leave", this.signallingAddr.toString());
    this.socket.removeAllListeners();
    this.socket.close();
    await Promise.all([
      ...this.connections.map(async (maConn) => await maConn.close()),
      ...Array.from(this.channels.values()).map(async (channel2) => await channel2.close())
    ]);
    this.dispatchEvent(new CustomEvent("close"));
  }
}
class WebRTCListener extends EventEmitter$1 {
  constructor(upgrader, handler, peerId, transport, options) {
    super();
    this.upgrader = upgrader;
    this.handler = handler;
    this.peerId = peerId;
    this.transport = transport;
    this.options = options;
  }
  async listen(ma) {
    if (this.listeningAddr != null) {
      throw errCode(new Error("listener already in use"), "ERR_ALREADY_LISTENING");
    }
    const defer2 = pDefer$1();
    this.listeningAddr = ma;
    let signallingAddr;
    if (!ma.protoCodes().includes(CODE_P2P$1)) {
      signallingAddr = ma.encapsulate(`/p2p/${this.peerId.toString()}`);
    } else {
      signallingAddr = ma;
    }
    const signallingUrl = this.signallingUrl = cleanUrlSIO(ma);
    log$P("connecting to signalling server on: %s", this.signallingUrl);
    const server = new SigServer(this.signallingUrl, signallingAddr, this.upgrader, this.handler, this.options.channelOptions);
    server.addEventListener("error", (evt) => {
      const err2 = evt.detail;
      log$P("error connecting to signalling server %o", err2);
      server.close().catch((err3) => {
        log$P.error("error closing server after error", err3);
      });
      defer2.reject(err2);
    });
    server.addEventListener("listening", () => {
      log$P("connected to signalling server");
      this.dispatchEvent(new CustomEvent("listening"));
      defer2.resolve();
    });
    server.addEventListener("peer", (evt) => {
      this.transport.peerDiscovered(evt.detail);
    });
    server.addEventListener("connection", (evt) => {
      const conn = evt.detail;
      if (conn.remoteAddr == null) {
        try {
          conn.remoteAddr = ma.decapsulateCode(CODE_P2P$1).encapsulate(`/p2p/${conn.remotePeer.toString()}`);
        } catch (err2) {
          log$P.error("could not determine remote address", err2);
        }
      }
      this.dispatchEvent(new CustomEvent("connection", {
        detail: conn
      }));
    });
    server.addEventListener("disconnect", () => {
      this.transport.sigServers.delete(signallingUrl);
    });
    server.addEventListener("reconnect", () => {
      this.transport.sigServers.set(signallingUrl, server);
    });
    this.transport.sigServers.set(this.signallingUrl, server);
    return await defer2.promise;
  }
  async close() {
    if (this.signallingUrl != null) {
      const server = this.transport.sigServers.get(this.signallingUrl);
      if (server != null) {
        await server.close();
        this.transport.sigServers.delete(this.signallingUrl);
      }
    }
    this.dispatchEvent(new CustomEvent("close"));
    this.listeningAddr = void 0;
  }
  getAddrs() {
    if (this.listeningAddr != null) {
      return [
        this.listeningAddr
      ];
    }
    return [];
  }
}
function createListener$2(upgrader, handler, peerId, transport, options) {
  return new WebRTCListener(upgrader, handler, peerId, transport, options);
}
function xor(a, b2) {
  if (a.length !== b2.length) {
    throw new Error("Inputs should have the same length");
  }
  const result = allocUnsafe$4(a.length);
  for (let i2 = 0; i2 < a.length; i2++) {
    result[i2] = a[i2] ^ b2[i2];
  }
  return asUint8Array$1(result);
}
const symbol$2 = Symbol.for("@libp2p/transport");
const symbol$1 = Symbol.for("@libp2p/peer-discovery");
const webrtcSupport = "RTCPeerConnection" in globalThis;
const log$O = logger$1("libp2p:webrtc-star");
const noop$1 = () => {
};
class WebRTCStarDiscovery extends EventEmitter$1 {
  constructor() {
    super(...arguments);
    this.started = false;
  }
  get [symbol$1]() {
    return true;
  }
  get [Symbol.toStringTag]() {
    return "@libp2p/webrtc-star-discovery";
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.started = true;
  }
  async stop() {
    this.started = false;
  }
  dispatchEvent(event) {
    if (!this.isStarted()) {
      return false;
    }
    return super.dispatchEvent(event);
  }
}
class WebRTCStar {
  constructor(init2) {
    if (init2?.wrtc != null) {
      this.wrtc = init2.wrtc;
    }
    this.sigServers = /* @__PURE__ */ new Map();
    this._discovery = new WebRTCStarDiscovery();
    this.discovery = () => this._discovery;
    this.peerDiscovered = this.peerDiscovered.bind(this);
  }
  get [symbol$2]() {
    return true;
  }
  get [Symbol.toStringTag]() {
    return "@libp2p/webrtc-star";
  }
  async dial(ma, options) {
    const rawConn = await this._connect(ma, options);
    const maConn = toMultiaddrConnection(rawConn, { remoteAddr: ma, signal: options.signal });
    log$O("new outbound connection %s", maConn.remoteAddr);
    const conn = await options.upgrader.upgradeOutbound(maConn);
    log$O("outbound connection %s upgraded", maConn.remoteAddr);
    return conn;
  }
  async _connect(ma, options) {
    if (options.signal?.aborted === true) {
      throw new AbortError$1();
    }
    const channelOptions = {
      ...options.channelOptions ?? {}
    };
    if (this.wrtc != null) {
      channelOptions.wrtc = this.wrtc;
    }
    const cOpts = ma.toOptions();
    const intentId = toString$5(random_browser(36), "hex");
    return await new Promise((resolve2, reject) => {
      const sio = this.sigServers.get(cleanUrlSIO(ma));
      if (sio?.socket == null) {
        return reject(errCode(new Error("unknown signal server to use"), "ERR_UNKNOWN_SIGNAL_SERVER"));
      }
      let connected = false;
      log$O("dialing %s:%s", cOpts.host, cOpts.port);
      const channel2 = new WebRTCInitiator(channelOptions);
      const onError = (evt) => {
        const err2 = evt.detail;
        if (!connected) {
          const msg = `connection error ${cOpts.host}:${cOpts.port}: ${err2.message}`;
          log$O.error(msg);
          done(err2);
        }
      };
      const onReady = () => {
        connected = true;
        log$O("connection opened %s:%s", cOpts.host, cOpts.port);
        done();
      };
      const onAbort = () => {
        log$O.error("connection aborted %s:%s", cOpts.host, cOpts.port);
        channel2.close().finally(() => {
          done(new AbortError$1());
        });
      };
      const done = (err2) => {
        channel2.removeEventListener("ready", onReady);
        options.signal?.removeEventListener("abort", onAbort);
        if (err2 == null) {
          resolve2(channel2);
        } else {
          reject(err2);
        }
      };
      channel2.addEventListener("ready", onReady, {
        once: true
      });
      channel2.addEventListener("close", () => {
        channel2.removeEventListener("error", onError);
      });
      options.signal?.addEventListener("abort", onAbort);
      channel2.addEventListener("signal", (evt) => {
        const signal = evt.detail;
        sio.socket.emit("ss-handshake", {
          intentId,
          srcMultiaddr: sio.signallingAddr.toString(),
          dstMultiaddr: ma.toString(),
          signal
        });
      });
      sio.socket.on("ws-handshake", (offer) => {
        if (offer.intentId === intentId && offer.err != null) {
          channel2.close().finally(() => {
            reject(errCode(new Error(offer.err), "ERR_SIGNALLING_FAILED"));
          });
        }
        if (offer.intentId !== intentId || offer.answer == null || channel2.closed) {
          return;
        }
        channel2.handleSignal(offer.signal);
      });
    });
  }
  createListener(options) {
    if (!webrtcSupport && this.wrtc == null) {
      throw errCode(new Error("no WebRTC support"), "ERR_NO_WEBRTC_SUPPORT");
    }
    options.channelOptions = options.channelOptions ?? {};
    if (this.wrtc != null) {
      options.channelOptions.wrtc = this.wrtc;
    }
    if (this.peerId == null) {
      throw errCode(new Error("PeerId not set"), "ERR_MISSING_PEER_ID");
    }
    return createListener$2(options.upgrader, options.handler ?? noop$1, this.peerId, this, options);
  }
  filter(multiaddrs) {
    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
    return multiaddrs.filter((ma) => {
      if (ma.protoCodes().includes(CODE_CIRCUIT$1)) {
        return false;
      }
      return WebRTCStar$1.matches(ma);
    });
  }
  peerDiscovered(maStr) {
    log$O("peer discovered: %s", maStr);
    maStr = cleanMultiaddr(maStr);
    const ma = multiaddr(maStr);
    const peerIdStr = ma.getPeerId();
    if (peerIdStr == null) {
      return;
    }
    const peerId = peerIdFromString(peerIdStr);
    this._discovery.dispatchEvent(new CustomEvent("peer", {
      detail: {
        id: peerId,
        multiaddrs: [ma],
        protocols: []
      }
    }));
  }
}
function webRTCStar(init2 = {}) {
  const transport = new WebRTCStar(init2);
  return {
    transport: (components) => {
      transport.peerId = components.peerId;
      return transport;
    },
    discovery: transport.discovery
  };
}
function libp2pConfig() {
  const webRtcStar = webRTCStar();
  const options = {
    transports: [
      webRtcStar.transport
    ],
    peerDiscovery: [
      webRtcStar.discovery
    ],
    connectionManager: {
      maxParallelDials: 150,
      maxDialsPerPeer: 4,
      dialTimeout: 1e4,
      autoDial: true
    },
    nat: {
      enabled: false
    },
    metrics: {
      enabled: true
    }
  };
  return options;
}
var messages;
(function(messages2) {
  messages2["NOT_STARTED_YET"] = "The libp2p node is not started yet";
  messages2["DHT_DISABLED"] = "DHT is not available";
  messages2["PUBSUB_DISABLED"] = "PubSub is not available";
  messages2["CONN_ENCRYPTION_REQUIRED"] = "At least one connection encryption module is required";
  messages2["ERR_TRANSPORTS_REQUIRED"] = "At least one transport module is required";
  messages2["ERR_PROTECTOR_REQUIRED"] = "Private network is enforced, but no protector was provided";
  messages2["NOT_FOUND"] = "Not found";
})(messages || (messages = {}));
var codes$1;
(function(codes2) {
  codes2["DHT_DISABLED"] = "ERR_DHT_DISABLED";
  codes2["ERR_PUBSUB_DISABLED"] = "ERR_PUBSUB_DISABLED";
  codes2["PUBSUB_NOT_STARTED"] = "ERR_PUBSUB_NOT_STARTED";
  codes2["DHT_NOT_STARTED"] = "ERR_DHT_NOT_STARTED";
  codes2["CONN_ENCRYPTION_REQUIRED"] = "ERR_CONN_ENCRYPTION_REQUIRED";
  codes2["ERR_TRANSPORTS_REQUIRED"] = "ERR_TRANSPORTS_REQUIRED";
  codes2["ERR_PROTECTOR_REQUIRED"] = "ERR_PROTECTOR_REQUIRED";
  codes2["ERR_PEER_DIAL_INTERCEPTED"] = "ERR_PEER_DIAL_INTERCEPTED";
  codes2["ERR_CONNECTION_INTERCEPTED"] = "ERR_CONNECTION_INTERCEPTED";
  codes2["ERR_INVALID_PROTOCOLS_FOR_STREAM"] = "ERR_INVALID_PROTOCOLS_FOR_STREAM";
  codes2["ERR_CONNECTION_ENDED"] = "ERR_CONNECTION_ENDED";
  codes2["ERR_CONNECTION_FAILED"] = "ERR_CONNECTION_FAILED";
  codes2["ERR_NODE_NOT_STARTED"] = "ERR_NODE_NOT_STARTED";
  codes2["ERR_ALREADY_ABORTED"] = "ERR_ALREADY_ABORTED";
  codes2["ERR_TOO_MANY_ADDRESSES"] = "ERR_TOO_MANY_ADDRESSES";
  codes2["ERR_NO_VALID_ADDRESSES"] = "ERR_NO_VALID_ADDRESSES";
  codes2["ERR_RELAYED_DIAL"] = "ERR_RELAYED_DIAL";
  codes2["ERR_DIALED_SELF"] = "ERR_DIALED_SELF";
  codes2["ERR_DISCOVERED_SELF"] = "ERR_DISCOVERED_SELF";
  codes2["ERR_DUPLICATE_TRANSPORT"] = "ERR_DUPLICATE_TRANSPORT";
  codes2["ERR_ENCRYPTION_FAILED"] = "ERR_ENCRYPTION_FAILED";
  codes2["ERR_HOP_REQUEST_FAILED"] = "ERR_HOP_REQUEST_FAILED";
  codes2["ERR_INVALID_KEY"] = "ERR_INVALID_KEY";
  codes2["ERR_INVALID_MESSAGE"] = "ERR_INVALID_MESSAGE";
  codes2["ERR_INVALID_PARAMETERS"] = "ERR_INVALID_PARAMETERS";
  codes2["ERR_INVALID_PEER"] = "ERR_INVALID_PEER";
  codes2["ERR_MUXER_UNAVAILABLE"] = "ERR_MUXER_UNAVAILABLE";
  codes2["ERR_NOT_FOUND"] = "ERR_NOT_FOUND";
  codes2["ERR_TIMEOUT"] = "ERR_TIMEOUT";
  codes2["ERR_TRANSPORT_UNAVAILABLE"] = "ERR_TRANSPORT_UNAVAILABLE";
  codes2["ERR_TRANSPORT_DIAL_FAILED"] = "ERR_TRANSPORT_DIAL_FAILED";
  codes2["ERR_UNSUPPORTED_PROTOCOL"] = "ERR_UNSUPPORTED_PROTOCOL";
  codes2["ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED"] = "ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED";
  codes2["ERR_INVALID_MULTIADDR"] = "ERR_INVALID_MULTIADDR";
  codes2["ERR_SIGNATURE_NOT_VALID"] = "ERR_SIGNATURE_NOT_VALID";
  codes2["ERR_FIND_SELF"] = "ERR_FIND_SELF";
  codes2["ERR_NO_ROUTERS_AVAILABLE"] = "ERR_NO_ROUTERS_AVAILABLE";
  codes2["ERR_CONNECTION_NOT_MULTIPLEXED"] = "ERR_CONNECTION_NOT_MULTIPLEXED";
  codes2["ERR_NO_DIAL_TOKENS"] = "ERR_NO_DIAL_TOKENS";
  codes2["ERR_KEYCHAIN_REQUIRED"] = "ERR_KEYCHAIN_REQUIRED";
  codes2["ERR_INVALID_CMS"] = "ERR_INVALID_CMS";
  codes2["ERR_MISSING_KEYS"] = "ERR_MISSING_KEYS";
  codes2["ERR_NO_KEY"] = "ERR_NO_KEY";
  codes2["ERR_INVALID_KEY_NAME"] = "ERR_INVALID_KEY_NAME";
  codes2["ERR_INVALID_KEY_TYPE"] = "ERR_INVALID_KEY_TYPE";
  codes2["ERR_KEY_ALREADY_EXISTS"] = "ERR_KEY_ALREADY_EXISTS";
  codes2["ERR_INVALID_KEY_SIZE"] = "ERR_INVALID_KEY_SIZE";
  codes2["ERR_KEY_NOT_FOUND"] = "ERR_KEY_NOT_FOUND";
  codes2["ERR_OLD_KEY_NAME_INVALID"] = "ERR_OLD_KEY_NAME_INVALID";
  codes2["ERR_NEW_KEY_NAME_INVALID"] = "ERR_NEW_KEY_NAME_INVALID";
  codes2["ERR_PASSWORD_REQUIRED"] = "ERR_PASSWORD_REQUIRED";
  codes2["ERR_PEM_REQUIRED"] = "ERR_PEM_REQUIRED";
  codes2["ERR_CANNOT_READ_KEY"] = "ERR_CANNOT_READ_KEY";
  codes2["ERR_MISSING_PRIVATE_KEY"] = "ERR_MISSING_PRIVATE_KEY";
  codes2["ERR_MISSING_PUBLIC_KEY"] = "ERR_MISSING_PUBLIC_KEY";
  codes2["ERR_INVALID_OLD_PASS_TYPE"] = "ERR_INVALID_OLD_PASS_TYPE";
  codes2["ERR_INVALID_NEW_PASS_TYPE"] = "ERR_INVALID_NEW_PASS_TYPE";
  codes2["ERR_INVALID_PASS_LENGTH"] = "ERR_INVALID_PASS_LENGTH";
  codes2["ERR_NOT_IMPLEMENTED"] = "ERR_NOT_IMPLEMENTED";
  codes2["ERR_WRONG_PING_ACK"] = "ERR_WRONG_PING_ACK";
  codes2["ERR_INVALID_RECORD"] = "ERR_INVALID_RECORD";
  codes2["ERR_ALREADY_SUCCEEDED"] = "ERR_ALREADY_SUCCEEDED";
  codes2["ERR_NO_HANDLER_FOR_PROTOCOL"] = "ERR_NO_HANDLER_FOR_PROTOCOL";
  codes2["ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS"] = "ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS";
  codes2["ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS"] = "ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS";
  codes2["ERR_CONNECTION_DENIED"] = "ERR_CONNECTION_DENIED";
})(codes$1 || (codes$1 = {}));
async function* storeAddresses(source2, peerStore) {
  yield* map$3(source2, async (peer) => {
    await peerStore.addressBook.add(peer.id, peer.multiaddrs);
    return peer;
  });
}
function uniquePeers(source2) {
  const seen = /* @__PURE__ */ new Set();
  return filter$1(source2, (peer) => {
    if (seen.has(peer.id.toString())) {
      return false;
    }
    seen.add(peer.id.toString());
    return true;
  });
}
async function* requirePeers(source2, min = 1) {
  let seen = 0;
  for await (const peer of source2) {
    seen++;
    yield peer;
  }
  if (seen < min) {
    throw errCode(new Error("not found"), "NOT_FOUND");
  }
}
const intervals = /* @__PURE__ */ new Map();
const _generateId = () => `${Date.now()}:${Math.floor(Math.random() * 1e6)}`;
async function _runPeriodically(task, interval, id) {
  while (intervals.get(id)) {
    try {
      await task();
    } catch (err2) {
      setTimeout(() => {
        throw err2;
      }, 1);
      break;
    }
    if (!intervals.get(id)) {
      break;
    }
    await new Promise((resolve2) => {
      const _timeout = setTimeout(resolve2, interval);
      intervals.set(id, _timeout);
    });
  }
}
function setDelayedInterval(task, interval, delay2) {
  delay2 = delay2 || interval;
  const id = _generateId();
  const _timeout = setTimeout(() => {
    _runPeriodically(task, interval, id);
  }, delay2);
  intervals.set(id, _timeout);
  return id;
}
function clearDelayedInterval(id) {
  const _timeout = intervals.get(id);
  if (_timeout) {
    clearTimeout(_timeout);
    intervals.delete(id);
  }
}
var src$1 = {
  setDelayedInterval,
  clearDelayedInterval
};
const log$N = logger$1("libp2p:peer-routing");
class DefaultPeerRouting {
  constructor(components, init2) {
    this.components = components;
    this.routers = init2.routers;
    this.refreshManagerInit = init2.refreshManager ?? {};
    this.started = false;
    this._findClosestPeersTask = this._findClosestPeersTask.bind(this);
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.started || this.routers.length === 0 || this.timeoutId != null || this.refreshManagerInit.enabled === false) {
      return;
    }
    this.timeoutId = src$1.setDelayedInterval(this._findClosestPeersTask, this.refreshManagerInit.interval, this.refreshManagerInit.bootDelay);
    this.started = true;
  }
  async _findClosestPeersTask() {
    if (this.abortController != null) {
      return;
    }
    try {
      this.abortController = new timeoutAbortController.TimeoutController(this.refreshManagerInit.timeout ?? 1e4);
      try {
        events.exports.setMaxListeners?.(Infinity, this.abortController.signal);
      } catch {
      }
      await drain(this.getClosestPeers(this.components.peerId.toBytes(), { signal: this.abortController.signal }));
    } catch (err2) {
      log$N.error(err2);
    } finally {
      this.abortController?.clear();
      this.abortController = void 0;
    }
  }
  async stop() {
    src$1.clearDelayedInterval(this.timeoutId);
    this.abortController?.abort();
    this.started = false;
  }
  async findPeer(id, options) {
    if (this.routers.length === 0) {
      throw errCode(new Error("No peer routers available"), codes$1.ERR_NO_ROUTERS_AVAILABLE);
    }
    if (id.toString() === this.components.peerId.toString()) {
      throw errCode(new Error("Should not try to find self"), codes$1.ERR_FIND_SELF);
    }
    const output = await pipe(merge$1(...this.routers.map((router) => async function* () {
      try {
        yield await router.findPeer(id, options);
      } catch (err2) {
        log$N.error(err2);
      }
    }())), (source2) => filter$1(source2, Boolean), (source2) => storeAddresses(source2, this.components.peerStore), async (source2) => await first$1(source2));
    if (output != null) {
      return output;
    }
    throw errCode(new Error(messages.NOT_FOUND), codes$1.ERR_NOT_FOUND);
  }
  async *getClosestPeers(key, options) {
    if (this.routers.length === 0) {
      throw errCode(new Error("No peer routers available"), codes$1.ERR_NO_ROUTERS_AVAILABLE);
    }
    yield* pipe(merge$1(...this.routers.map((router) => router.getClosestPeers(key, options))), (source2) => storeAddresses(source2, this.components.peerStore), (source2) => uniquePeers(source2), (source2) => requirePeers(source2));
  }
}
class CompoundContentRouting {
  constructor(components, init2) {
    this.routers = init2.routers ?? [];
    this.started = false;
    this.components = components;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.started = true;
  }
  async stop() {
    this.started = false;
  }
  async *findProviders(key, options = {}) {
    if (this.routers.length === 0) {
      throw errCode(new Error("No content this.routers available"), codes$1.ERR_NO_ROUTERS_AVAILABLE);
    }
    yield* pipe(merge$1(...this.routers.map((router) => router.findProviders(key, options))), (source2) => storeAddresses(source2, this.components.peerStore), (source2) => uniquePeers(source2), (source2) => requirePeers(source2));
  }
  async provide(key, options = {}) {
    if (this.routers.length === 0) {
      throw errCode(new Error("No content routers available"), codes$1.ERR_NO_ROUTERS_AVAILABLE);
    }
    await Promise.all(this.routers.map(async (router) => await router.provide(key, options)));
  }
  async put(key, value2, options) {
    if (!this.isStarted()) {
      throw errCode(new Error(messages.NOT_STARTED_YET), codes$1.DHT_NOT_STARTED);
    }
    const dht = this.components.dht;
    if (dht != null) {
      await drain(dht.put(key, value2, options));
    }
  }
  async get(key, options) {
    if (!this.isStarted()) {
      throw errCode(new Error(messages.NOT_STARTED_YET), codes$1.DHT_NOT_STARTED);
    }
    const dht = this.components.dht;
    if (dht != null) {
      for await (const event of dht.get(key, options)) {
        if (event.name === "VALUE") {
          return event.value;
        }
      }
    }
    throw errCode(new Error(messages.NOT_FOUND), codes$1.ERR_NOT_FOUND);
  }
  async *getMany(key, nVals, options) {
    if (!this.isStarted()) {
      throw errCode(new Error(messages.NOT_STARTED_YET), codes$1.DHT_NOT_STARTED);
    }
    if (nVals == null || nVals === 0) {
      return;
    }
    let gotValues = 0;
    const dht = this.components.dht;
    if (dht != null) {
      for await (const event of dht.get(key, options)) {
        if (event.name === "VALUE") {
          yield { from: event.from, val: event.value };
          gotValues++;
          if (gotValues === nVals) {
            break;
          }
        }
      }
    }
    if (gotValues === 0) {
      throw errCode(new Error(messages.NOT_FOUND), codes$1.ERR_NOT_FOUND);
    }
  }
}
function peerIdFromMultiaddr(ma) {
  const idStr = ma.getPeerId();
  if (idStr == null) {
    throw errCode(new Error(`${ma.toString()} does not have a valid peer type`), codes$1.ERR_INVALID_MULTIADDR);
  }
  try {
    return peerIdFromString(idStr);
  } catch (err2) {
    throw errCode(new Error(`${ma.toString()} is not a valid peer type`), codes$1.ERR_INVALID_MULTIADDR);
  }
}
function getPeer(peer) {
  if (isPeerId(peer)) {
    return {
      id: peer,
      multiaddrs: [],
      protocols: []
    };
  }
  if (typeof peer === "string") {
    peer = multiaddr(peer);
  }
  let addr;
  if (isMultiaddr(peer)) {
    addr = peer;
    peer = peerIdFromMultiaddr(peer);
  }
  return {
    id: peer,
    multiaddrs: addr != null ? [addr] : [],
    protocols: []
  };
}
const defaultAddressFilter = (addrs) => addrs;
class DefaultAddressManager extends EventEmitter$1 {
  constructor(components, init2) {
    super();
    const { listen = [], announce = [] } = init2;
    this.components = components;
    this.listen = new Set(listen.map((ma) => ma.toString()));
    this.announce = new Set(announce.map((ma) => ma.toString()));
    this.observed = /* @__PURE__ */ new Set();
    this.announceFilter = init2.announceFilter ?? defaultAddressFilter;
  }
  getListenAddrs() {
    return Array.from(this.listen).map((a) => multiaddr(a));
  }
  getAnnounceAddrs() {
    return Array.from(this.announce).map((a) => multiaddr(a));
  }
  getObservedAddrs() {
    return Array.from(this.observed).map((a) => multiaddr(a));
  }
  confirmObservedAddr(addr) {
  }
  removeObservedAddr(addr) {
  }
  addObservedAddr(addr) {
    let ma = multiaddr(addr);
    const remotePeer = ma.getPeerId();
    if (remotePeer != null) {
      const remotePeerId = peerIdFromString(remotePeer);
      if (remotePeerId.equals(this.components.peerId)) {
        ma = ma.decapsulate(multiaddr(`/p2p/${this.components.peerId.toString()}`));
      }
    }
    const addrString = ma.toString();
    if (this.observed.has(addrString)) {
      return;
    }
    this.observed.add(addrString);
    this.dispatchEvent(new CustomEvent("change:addresses"));
  }
  getAddresses() {
    let addrs = this.getAnnounceAddrs().map((ma) => ma.toString());
    if (addrs.length === 0) {
      addrs = this.components.transportManager.getAddrs().map((ma) => ma.toString());
    }
    addrs = addrs.concat(this.getObservedAddrs().map((ma) => ma.toString()));
    const addrSet = new Set(addrs);
    return this.announceFilter(Array.from(addrSet).map((str) => multiaddr(str))).map((ma) => {
      if (ma.getPeerId() === this.components.peerId.toString()) {
        return ma;
      }
      return ma.encapsulate(`/p2p/${this.components.peerId.toString()}`);
    });
  }
}
const log$M = logger$1("libp2p:connection-manager:latency-monitor:visibility-change-emitter");
class VisibilityChangeEmitter extends EventEmitter$1 {
  constructor() {
    super();
    this.hidden = "hidden";
    this.visibilityChange = "visibilityChange";
    if (globalThis.document != null) {
      this._initializeVisibilityVarNames();
      this._addVisibilityChangeListener();
    }
  }
  _initializeVisibilityVarNames() {
    let hidden = "hidden";
    let visibilityChange = "visibilitychange";
    if (typeof globalThis.document.hidden !== "undefined") {
      hidden = "hidden";
      visibilityChange = "visibilitychange";
    } else if (typeof globalThis.document.mozHidden !== "undefined") {
      hidden = "mozHidden";
      visibilityChange = "mozvisibilitychange";
    } else if (typeof globalThis.document.msHidden !== "undefined") {
      hidden = "msHidden";
      visibilityChange = "msvisibilitychange";
    } else if (typeof globalThis.document.webkitHidden !== "undefined") {
      hidden = "webkitHidden";
      visibilityChange = "webkitvisibilitychange";
    }
    this.hidden = hidden;
    this.visibilityChange = visibilityChange;
  }
  _addVisibilityChangeListener() {
    if (typeof globalThis.document.addEventListener === "undefined" || typeof document[this.hidden] === "undefined") {
      log$M("Checking page visibility requires a browser that supports the Page Visibility API.");
    } else {
      globalThis.document.addEventListener(this.visibilityChange, this._handleVisibilityChange.bind(this), false);
    }
  }
  isVisible() {
    if (this.hidden === void 0 || document[this.hidden] === void 0) {
      return void 0;
    }
    return document[this.hidden] == null;
  }
  _handleVisibilityChange() {
    const visible = globalThis.document[this.hidden] === false;
    log$M(visible ? "Page Visible" : "Page Hidden");
    this.dispatchEvent(new CustomEvent("visibilityChange", {
      detail: visible
    }));
  }
}
const log$L = logger$1("libp2p:connection-manager:latency-monitor");
class LatencyMonitor extends EventEmitter$1 {
  constructor(init2 = {}) {
    super();
    const { latencyCheckIntervalMs, dataEmitIntervalMs, asyncTestFn, latencyRandomPercentage } = init2;
    this.latencyCheckIntervalMs = latencyCheckIntervalMs ?? 500;
    this.latencyRandomPercentage = latencyRandomPercentage ?? 10;
    this.latencyCheckMultiply = 2 * (this.latencyRandomPercentage / 100) * this.latencyCheckIntervalMs;
    this.latencyCheckSubtract = this.latencyCheckMultiply / 2;
    this.dataEmitIntervalMs = dataEmitIntervalMs === null || dataEmitIntervalMs === 0 ? void 0 : dataEmitIntervalMs ?? 5 * 1e3;
    log$L("latencyCheckIntervalMs: %s dataEmitIntervalMs: %s", this.latencyCheckIntervalMs, this.dataEmitIntervalMs);
    if (this.dataEmitIntervalMs != null) {
      log$L("Expecting ~%s events per summary", this.latencyCheckIntervalMs / this.dataEmitIntervalMs);
    } else {
      log$L("Not emitting summaries");
    }
    this.asyncTestFn = asyncTestFn;
    if (globalThis.process?.hrtime != null) {
      log$L("Using process.hrtime for timing");
      this.now = globalThis.process.hrtime;
      this.getDeltaMS = (startTime) => {
        const hrtime = this.now(startTime);
        return hrtime[0] * 1e3 + hrtime[1] / 1e6;
      };
    } else if (typeof window !== "undefined" && window.performance?.now != null) {
      log$L("Using performance.now for timing");
      this.now = window.performance.now.bind(window.performance);
      this.getDeltaMS = (startTime) => Math.round(this.now() - startTime);
    } else {
      log$L("Using Date.now for timing");
      this.now = Date.now;
      this.getDeltaMS = (startTime) => this.now() - startTime;
    }
    this.latencyData = this.initLatencyData();
  }
  start() {
    if (isBrowser$1()) {
      this.visibilityChangeEmitter = new VisibilityChangeEmitter();
      this.visibilityChangeEmitter.addEventListener("visibilityChange", (evt) => {
        const { detail: pageInFocus } = evt;
        if (pageInFocus) {
          this._startTimers();
        } else {
          this._emitSummary();
          this._stopTimers();
        }
      });
    }
    if (this.visibilityChangeEmitter?.isVisible() === true) {
      this._startTimers();
    }
  }
  stop() {
    this._stopTimers();
  }
  _startTimers() {
    if (this.checkLatencyID != null) {
      return;
    }
    this.checkLatency();
    if (this.dataEmitIntervalMs != null) {
      this.emitIntervalID = setInterval(() => this._emitSummary(), this.dataEmitIntervalMs);
      if (typeof this.emitIntervalID.unref === "function") {
        this.emitIntervalID.unref();
      }
    }
  }
  _stopTimers() {
    if (this.checkLatencyID != null) {
      clearTimeout(this.checkLatencyID);
      this.checkLatencyID = void 0;
    }
    if (this.emitIntervalID != null) {
      clearInterval(this.emitIntervalID);
      this.emitIntervalID = void 0;
    }
  }
  _emitSummary() {
    const summary = this.getSummary();
    if (summary.events > 0) {
      this.dispatchEvent(new CustomEvent("data", {
        detail: summary
      }));
    }
  }
  getSummary() {
    const latency = {
      events: this.latencyData.events,
      minMs: this.latencyData.minMs,
      maxMs: this.latencyData.maxMs,
      avgMs: this.latencyData.events > 0 ? this.latencyData.totalMs / this.latencyData.events : Number.POSITIVE_INFINITY,
      lengthMs: this.getDeltaMS(this.latencyData.startTime)
    };
    this.latencyData = this.initLatencyData();
    log$L.trace("Summary: %O", latency);
    return latency;
  }
  checkLatency() {
    const randomness = Math.random() * this.latencyCheckMultiply - this.latencyCheckSubtract;
    const localData = {
      deltaOffset: Math.ceil(this.latencyCheckIntervalMs + randomness),
      startTime: this.now()
    };
    const cb = () => {
      if (this.checkLatencyID == null) {
        return;
      }
      const deltaMS = this.getDeltaMS(localData.startTime) - localData.deltaOffset;
      this.checkLatency();
      this.latencyData.events++;
      this.latencyData.minMs = Math.min(this.latencyData.minMs, deltaMS);
      this.latencyData.maxMs = Math.max(this.latencyData.maxMs, deltaMS);
      this.latencyData.totalMs += deltaMS;
      log$L.trace("MS: %s Data: %O", deltaMS, this.latencyData);
    };
    log$L.trace("localData: %O", localData);
    this.checkLatencyID = setTimeout(() => {
      if (this.asyncTestFn != null) {
        localData.deltaOffset = 0;
        localData.startTime = this.now();
        this.asyncTestFn(cb);
      } else {
        localData.deltaOffset -= 1;
        cb();
      }
    }, localData.deltaOffset);
    if (typeof this.checkLatencyID.unref === "function") {
      this.checkLatencyID.unref();
    }
  }
  initLatencyData() {
    return {
      startTime: this.now(),
      minMs: Number.POSITIVE_INFINITY,
      maxMs: Number.NEGATIVE_INFINITY,
      events: 0,
      totalMs: 0
    };
  }
}
function isBrowser$1() {
  return typeof globalThis.window !== "undefined";
}
const OPEN = "OPEN";
const CLOSING = "CLOSING";
const CLOSED = "CLOSED";
function mapIterable(iter, map2) {
  const iterator2 = {
    [Symbol.iterator]: () => {
      return iterator2;
    },
    next: () => {
      const next = iter.next();
      const val = next.value;
      if (next.done === true || val == null) {
        const result = {
          done: true,
          value: void 0
        };
        return result;
      }
      return {
        done: false,
        value: map2(val)
      };
    }
  };
  return iterator2;
}
class PeerMap {
  constructor(map2) {
    this.map = /* @__PURE__ */ new Map();
    if (map2 != null) {
      for (const [key, value2] of map2.entries()) {
        this.map.set(key.toString(), value2);
      }
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  clear() {
    this.map.clear();
  }
  delete(peer) {
    this.map.delete(peer.toString());
  }
  entries() {
    return mapIterable(this.map.entries(), (val) => {
      return [peerIdFromString(val[0]), val[1]];
    });
  }
  forEach(fn) {
    this.map.forEach((value2, key) => {
      fn(value2, peerIdFromString(key), this);
    });
  }
  get(peer) {
    return this.map.get(peer.toString());
  }
  has(peer) {
    return this.map.has(peer.toString());
  }
  set(peer, value2) {
    this.map.set(peer.toString(), value2);
  }
  keys() {
    return mapIterable(this.map.keys(), (val) => {
      return peerIdFromString(val);
    });
  }
  values() {
    return this.map.values();
  }
  get size() {
    return this.map.size;
  }
}
class PeerSet {
  constructor(set2) {
    this.set = /* @__PURE__ */ new Set();
    if (set2 != null) {
      for (const key of set2) {
        this.set.add(key.toString());
      }
    }
  }
  get size() {
    return this.set.size;
  }
  [Symbol.iterator]() {
    return this.values();
  }
  add(peer) {
    this.set.add(peer.toString());
  }
  clear() {
    this.set.clear();
  }
  delete(peer) {
    this.set.delete(peer.toString());
  }
  entries() {
    return mapIterable(this.set.entries(), (val) => {
      const peerId = peerIdFromString(val[0]);
      return [peerId, peerId];
    });
  }
  forEach(predicate) {
    this.set.forEach((str) => {
      const id = peerIdFromString(str);
      predicate(id, id, this);
    });
  }
  has(peer) {
    return this.set.has(peer.toString());
  }
  values() {
    return mapIterable(this.set.values(), (val) => {
      return peerIdFromString(val);
    });
  }
  intersection(other) {
    const output = new PeerSet();
    for (const peerId of other) {
      if (this.has(peerId)) {
        output.add(peerId);
      }
    }
    return output;
  }
  difference(other) {
    const output = new PeerSet();
    for (const peerId of this) {
      if (!other.has(peerId)) {
        output.add(peerId);
      }
    }
    return output;
  }
  union(other) {
    const output = new PeerSet();
    for (const peerId of other) {
      output.add(peerId);
    }
    for (const peerId of this) {
      output.add(peerId);
    }
    return output;
  }
}
const KEEP_ALIVE = "keep-alive";
var RateLimiterAbstract_1 = class RateLimiterAbstract2 {
  constructor(opts = {}) {
    this.points = opts.points;
    this.duration = opts.duration;
    this.blockDuration = opts.blockDuration;
    this.execEvenly = opts.execEvenly;
    this.execEvenlyMinDelayMs = opts.execEvenlyMinDelayMs;
    this.keyPrefix = opts.keyPrefix;
  }
  get points() {
    return this._points;
  }
  set points(value2) {
    this._points = value2 >= 0 ? value2 : 4;
  }
  get duration() {
    return this._duration;
  }
  set duration(value2) {
    this._duration = typeof value2 === "undefined" ? 1 : value2;
  }
  get msDuration() {
    return this.duration * 1e3;
  }
  get blockDuration() {
    return this._blockDuration;
  }
  set blockDuration(value2) {
    this._blockDuration = typeof value2 === "undefined" ? 0 : value2;
  }
  get msBlockDuration() {
    return this.blockDuration * 1e3;
  }
  get execEvenly() {
    return this._execEvenly;
  }
  set execEvenly(value2) {
    this._execEvenly = typeof value2 === "undefined" ? false : Boolean(value2);
  }
  get execEvenlyMinDelayMs() {
    return this._execEvenlyMinDelayMs;
  }
  set execEvenlyMinDelayMs(value2) {
    this._execEvenlyMinDelayMs = typeof value2 === "undefined" ? Math.ceil(this.msDuration / this.points) : value2;
  }
  get keyPrefix() {
    return this._keyPrefix;
  }
  set keyPrefix(value2) {
    if (typeof value2 === "undefined") {
      value2 = "rlflx";
    }
    if (typeof value2 !== "string") {
      throw new Error("keyPrefix must be string");
    }
    this._keyPrefix = value2;
  }
  _getKeySecDuration(options = {}) {
    return options && options.customDuration >= 0 ? options.customDuration : this.duration;
  }
  getKey(key) {
    return this.keyPrefix.length > 0 ? `${this.keyPrefix}:${key}` : key;
  }
  parseKey(rlKey) {
    return rlKey.substring(this.keyPrefix.length);
  }
  consume() {
    throw new Error("You have to implement the method 'consume'!");
  }
  penalty() {
    throw new Error("You have to implement the method 'penalty'!");
  }
  reward() {
    throw new Error("You have to implement the method 'reward'!");
  }
  get() {
    throw new Error("You have to implement the method 'get'!");
  }
  set() {
    throw new Error("You have to implement the method 'set'!");
  }
  block() {
    throw new Error("You have to implement the method 'block'!");
  }
  delete() {
    throw new Error("You have to implement the method 'delete'!");
  }
};
var BlockedKeys_1$1 = class BlockedKeys2 {
  constructor() {
    this._keys = {};
    this._addedKeysAmount = 0;
  }
  collectExpired() {
    const now = Date.now();
    Object.keys(this._keys).forEach((key) => {
      if (this._keys[key] <= now) {
        delete this._keys[key];
      }
    });
    this._addedKeysAmount = Object.keys(this._keys).length;
  }
  add(key, sec) {
    this.addMs(key, sec * 1e3);
  }
  addMs(key, ms2) {
    this._keys[key] = Date.now() + ms2;
    this._addedKeysAmount++;
    if (this._addedKeysAmount > 999) {
      this.collectExpired();
    }
  }
  msBeforeExpire(key) {
    const expire = this._keys[key];
    if (expire && expire >= Date.now()) {
      this.collectExpired();
      const now = Date.now();
      return expire >= now ? expire - now : 0;
    }
    return 0;
  }
  delete(key) {
    if (key) {
      delete this._keys[key];
    } else {
      Object.keys(this._keys).forEach((key2) => {
        delete this._keys[key2];
      });
    }
  }
};
const BlockedKeys$1 = BlockedKeys_1$1;
var BlockedKeys_1 = BlockedKeys$1;
var RateLimiterRes_1 = class RateLimiterRes2 {
  constructor(remainingPoints, msBeforeNext, consumedPoints, isFirstInDuration) {
    this.remainingPoints = typeof remainingPoints === "undefined" ? 0 : remainingPoints;
    this.msBeforeNext = typeof msBeforeNext === "undefined" ? 0 : msBeforeNext;
    this.consumedPoints = typeof consumedPoints === "undefined" ? 0 : consumedPoints;
    this.isFirstInDuration = typeof isFirstInDuration === "undefined" ? false : isFirstInDuration;
  }
  get msBeforeNext() {
    return this._msBeforeNext;
  }
  set msBeforeNext(ms2) {
    this._msBeforeNext = ms2;
    return this;
  }
  get remainingPoints() {
    return this._remainingPoints;
  }
  set remainingPoints(p) {
    this._remainingPoints = p;
    return this;
  }
  get consumedPoints() {
    return this._consumedPoints;
  }
  set consumedPoints(p) {
    this._consumedPoints = p;
    return this;
  }
  get isFirstInDuration() {
    return this._isFirstInDuration;
  }
  set isFirstInDuration(value2) {
    this._isFirstInDuration = Boolean(value2);
  }
  _getDecoratedProperties() {
    return {
      remainingPoints: this.remainingPoints,
      msBeforeNext: this.msBeforeNext,
      consumedPoints: this.consumedPoints,
      isFirstInDuration: this.isFirstInDuration
    };
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this._getDecoratedProperties();
  }
  toString() {
    return JSON.stringify(this._getDecoratedProperties());
  }
  toJSON() {
    return this._getDecoratedProperties();
  }
};
const RateLimiterAbstract$3 = RateLimiterAbstract_1;
const BlockedKeys = BlockedKeys_1;
const RateLimiterRes$b = RateLimiterRes_1;
var RateLimiterStoreAbstract_1 = class RateLimiterStoreAbstract2 extends RateLimiterAbstract$3 {
  constructor(opts = {}) {
    super(opts);
    this.inMemoryBlockOnConsumed = opts.inMemoryBlockOnConsumed || opts.inmemoryBlockOnConsumed;
    this.inMemoryBlockDuration = opts.inMemoryBlockDuration || opts.inmemoryBlockDuration;
    this.insuranceLimiter = opts.insuranceLimiter;
    this._inMemoryBlockedKeys = new BlockedKeys();
  }
  get client() {
    return this._client;
  }
  set client(value2) {
    if (typeof value2 === "undefined") {
      throw new Error("storeClient is not set");
    }
    this._client = value2;
  }
  _afterConsume(resolve2, reject, rlKey, changedPoints, storeResult, options = {}) {
    const res = this._getRateLimiterRes(rlKey, changedPoints, storeResult);
    if (this.inMemoryBlockOnConsumed > 0 && !(this.inMemoryBlockDuration > 0) && res.consumedPoints >= this.inMemoryBlockOnConsumed) {
      this._inMemoryBlockedKeys.addMs(rlKey, res.msBeforeNext);
      if (res.consumedPoints > this.points) {
        return reject(res);
      } else {
        return resolve2(res);
      }
    } else if (res.consumedPoints > this.points) {
      let blockPromise = Promise.resolve();
      if (this.blockDuration > 0 && res.consumedPoints <= this.points + changedPoints) {
        res.msBeforeNext = this.msBlockDuration;
        blockPromise = this._block(rlKey, res.consumedPoints, this.msBlockDuration, options);
      }
      if (this.inMemoryBlockOnConsumed > 0 && res.consumedPoints >= this.inMemoryBlockOnConsumed) {
        this._inMemoryBlockedKeys.add(rlKey, this.inMemoryBlockDuration);
        res.msBeforeNext = this.msInMemoryBlockDuration;
      }
      blockPromise.then(() => {
        reject(res);
      }).catch((err2) => {
        reject(err2);
      });
    } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {
      let delay2 = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));
      if (delay2 < this.execEvenlyMinDelayMs) {
        delay2 = res.consumedPoints * this.execEvenlyMinDelayMs;
      }
      setTimeout(resolve2, delay2, res);
    } else {
      resolve2(res);
    }
  }
  _handleError(err2, funcName, resolve2, reject, key, data = false, options = {}) {
    if (!(this.insuranceLimiter instanceof RateLimiterAbstract$3)) {
      reject(err2);
    } else {
      this.insuranceLimiter[funcName](key, data, options).then((res) => {
        resolve2(res);
      }).catch((res) => {
        reject(res);
      });
    }
  }
  get _inmemoryBlockedKeys() {
    return this._inMemoryBlockedKeys;
  }
  getInmemoryBlockMsBeforeExpire(rlKey) {
    return this.getInMemoryBlockMsBeforeExpire(rlKey);
  }
  get inmemoryBlockOnConsumed() {
    return this.inMemoryBlockOnConsumed;
  }
  set inmemoryBlockOnConsumed(value2) {
    this.inMemoryBlockOnConsumed = value2;
  }
  get inmemoryBlockDuration() {
    return this.inMemoryBlockDuration;
  }
  set inmemoryBlockDuration(value2) {
    this.inMemoryBlockDuration = value2;
  }
  get msInmemoryBlockDuration() {
    return this.inMemoryBlockDuration * 1e3;
  }
  getInMemoryBlockMsBeforeExpire(rlKey) {
    if (this.inMemoryBlockOnConsumed > 0) {
      return this._inMemoryBlockedKeys.msBeforeExpire(rlKey);
    }
    return 0;
  }
  get inMemoryBlockOnConsumed() {
    return this._inMemoryBlockOnConsumed;
  }
  set inMemoryBlockOnConsumed(value2) {
    this._inMemoryBlockOnConsumed = value2 ? parseInt(value2) : 0;
    if (this.inMemoryBlockOnConsumed > 0 && this.points > this.inMemoryBlockOnConsumed) {
      throw new Error('inMemoryBlockOnConsumed option must be greater or equal "points" option');
    }
  }
  get inMemoryBlockDuration() {
    return this._inMemoryBlockDuration;
  }
  set inMemoryBlockDuration(value2) {
    this._inMemoryBlockDuration = value2 ? parseInt(value2) : 0;
    if (this.inMemoryBlockDuration > 0 && this.inMemoryBlockOnConsumed === 0) {
      throw new Error("inMemoryBlockOnConsumed option must be set up");
    }
  }
  get msInMemoryBlockDuration() {
    return this._inMemoryBlockDuration * 1e3;
  }
  get insuranceLimiter() {
    return this._insuranceLimiter;
  }
  set insuranceLimiter(value2) {
    if (typeof value2 !== "undefined" && !(value2 instanceof RateLimiterAbstract$3)) {
      throw new Error("insuranceLimiter must be instance of RateLimiterAbstract");
    }
    this._insuranceLimiter = value2;
    if (this._insuranceLimiter) {
      this._insuranceLimiter.blockDuration = this.blockDuration;
      this._insuranceLimiter.execEvenly = this.execEvenly;
    }
  }
  block(key, secDuration, options = {}) {
    const msDuration = secDuration * 1e3;
    return this._block(this.getKey(key), this.points + 1, msDuration, options);
  }
  set(key, points, secDuration, options = {}) {
    const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1e3;
    return this._block(this.getKey(key), points, msDuration, options);
  }
  consume(key, pointsToConsume = 1, options = {}) {
    return new Promise((resolve2, reject) => {
      const rlKey = this.getKey(key);
      const inMemoryBlockMsBeforeExpire = this.getInMemoryBlockMsBeforeExpire(rlKey);
      if (inMemoryBlockMsBeforeExpire > 0) {
        return reject(new RateLimiterRes$b(0, inMemoryBlockMsBeforeExpire));
      }
      this._upsert(rlKey, pointsToConsume, this._getKeySecDuration(options) * 1e3, false, options).then((res) => {
        this._afterConsume(resolve2, reject, rlKey, pointsToConsume, res);
      }).catch((err2) => {
        this._handleError(err2, "consume", resolve2, reject, key, pointsToConsume, options);
      });
    });
  }
  penalty(key, points = 1, options = {}) {
    const rlKey = this.getKey(key);
    return new Promise((resolve2, reject) => {
      this._upsert(rlKey, points, this._getKeySecDuration(options) * 1e3, false, options).then((res) => {
        resolve2(this._getRateLimiterRes(rlKey, points, res));
      }).catch((err2) => {
        this._handleError(err2, "penalty", resolve2, reject, key, points, options);
      });
    });
  }
  reward(key, points = 1, options = {}) {
    const rlKey = this.getKey(key);
    return new Promise((resolve2, reject) => {
      this._upsert(rlKey, -points, this._getKeySecDuration(options) * 1e3, false, options).then((res) => {
        resolve2(this._getRateLimiterRes(rlKey, -points, res));
      }).catch((err2) => {
        this._handleError(err2, "reward", resolve2, reject, key, points, options);
      });
    });
  }
  get(key, options = {}) {
    const rlKey = this.getKey(key);
    return new Promise((resolve2, reject) => {
      this._get(rlKey, options).then((res) => {
        if (res === null || typeof res === "undefined") {
          resolve2(null);
        } else {
          resolve2(this._getRateLimiterRes(rlKey, 0, res));
        }
      }).catch((err2) => {
        this._handleError(err2, "get", resolve2, reject, key, options);
      });
    });
  }
  delete(key, options = {}) {
    const rlKey = this.getKey(key);
    return new Promise((resolve2, reject) => {
      this._delete(rlKey, options).then((res) => {
        this._inMemoryBlockedKeys.delete(rlKey);
        resolve2(res);
      }).catch((err2) => {
        this._handleError(err2, "delete", resolve2, reject, key, options);
      });
    });
  }
  deleteInMemoryBlockedAll() {
    this._inMemoryBlockedKeys.delete();
  }
  _getRateLimiterRes(rlKey, changedPoints, storeResult) {
    throw new Error("You have to implement the method '_getRateLimiterRes'!");
  }
  _block(rlKey, initPoints, msDuration, options = {}) {
    return new Promise((resolve2, reject) => {
      this._upsert(rlKey, initPoints, msDuration, true, options).then(() => {
        resolve2(new RateLimiterRes$b(0, msDuration > 0 ? msDuration : -1, initPoints));
      }).catch((err2) => {
        this._handleError(err2, "block", resolve2, reject, this.parseKey(rlKey), msDuration / 1e3, options);
      });
    });
  }
  _get(rlKey, options = {}) {
    throw new Error("You have to implement the method '_get'!");
  }
  _delete(rlKey, options = {}) {
    throw new Error("You have to implement the method '_delete'!");
  }
  _upsert(rlKey, points, msDuration, forceExpire = false, options = {}) {
    throw new Error("You have to implement the method '_upsert'!");
  }
};
const RateLimiterStoreAbstract$4 = RateLimiterStoreAbstract_1;
const RateLimiterRes$a = RateLimiterRes_1;
const incrTtlLuaScript = `redis.call('set', KEYS[1], 0, 'EX', ARGV[2], 'NX') local consumed = redis.call('incrby', KEYS[1], ARGV[1]) local ttl = redis.call('pttl', KEYS[1]) if ttl == -1 then   redis.call('expire', KEYS[1], ARGV[2])   ttl = 1000 * ARGV[2] end return {consumed, ttl} `;
class RateLimiterRedis$1 extends RateLimiterStoreAbstract$4 {
  constructor(opts) {
    super(opts);
    if (opts.redis) {
      this.client = opts.redis;
    } else {
      this.client = opts.storeClient;
    }
    this._rejectIfRedisNotReady = !!opts.rejectIfRedisNotReady;
    if (typeof this.client.defineCommand === "function") {
      this.client.defineCommand("rlflxIncr", {
        numberOfKeys: 1,
        lua: incrTtlLuaScript
      });
    }
  }
  _isRedisReady() {
    if (!this._rejectIfRedisNotReady) {
      return true;
    }
    if (this.client.status && this.client.status !== "ready") {
      return false;
    }
    if (typeof this.client.isReady === "function" && !this.client.isReady()) {
      return false;
    }
    return true;
  }
  _getRateLimiterRes(rlKey, changedPoints, result) {
    let [consumed, resTtlMs] = result;
    if (Array.isArray(consumed)) {
      [, consumed] = consumed;
      [, resTtlMs] = resTtlMs;
    }
    const res = new RateLimiterRes$a();
    res.consumedPoints = parseInt(consumed);
    res.isFirstInDuration = res.consumedPoints === changedPoints;
    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
    res.msBeforeNext = resTtlMs;
    return res;
  }
  _upsert(rlKey, points, msDuration, forceExpire = false) {
    return new Promise((resolve2, reject) => {
      if (!this._isRedisReady()) {
        return reject(new Error("Redis connection is not ready"));
      }
      const secDuration = Math.floor(msDuration / 1e3);
      const multi = this.client.multi();
      if (forceExpire) {
        if (secDuration > 0) {
          multi.set(rlKey, points, "EX", secDuration);
        } else {
          multi.set(rlKey, points);
        }
        multi.pttl(rlKey).exec((err2, res) => {
          if (err2) {
            return reject(err2);
          }
          return resolve2(res);
        });
      } else {
        if (secDuration > 0) {
          const incrCallback = function(err2, result) {
            if (err2) {
              return reject(err2);
            }
            return resolve2(result);
          };
          if (typeof this.client.rlflxIncr === "function") {
            this.client.rlflxIncr(rlKey, points, secDuration, incrCallback);
          } else {
            this.client.eval(incrTtlLuaScript, 1, rlKey, points, secDuration, incrCallback);
          }
        } else {
          multi.incrby(rlKey, points).pttl(rlKey).exec((err2, res) => {
            if (err2) {
              return reject(err2);
            }
            return resolve2(res);
          });
        }
      }
    });
  }
  _get(rlKey) {
    return new Promise((resolve2, reject) => {
      if (!this._isRedisReady()) {
        return reject(new Error("Redis connection is not ready"));
      }
      this.client.multi().get(rlKey).pttl(rlKey).exec((err2, res) => {
        if (err2) {
          reject(err2);
        } else {
          const [points] = res;
          if (points === null) {
            return resolve2(null);
          }
          resolve2(res);
        }
      });
    });
  }
  _delete(rlKey) {
    return new Promise((resolve2, reject) => {
      this.client.del(rlKey, (err2, res) => {
        if (err2) {
          reject(err2);
        } else {
          resolve2(res > 0);
        }
      });
    });
  }
}
var RateLimiterRedis_1 = RateLimiterRedis$1;
const RateLimiterStoreAbstract$3 = RateLimiterStoreAbstract_1;
const RateLimiterRes$9 = RateLimiterRes_1;
function getDriverVersion(client) {
  try {
    const _client = client.client ? client.client : client;
    const { version: version2 } = _client.topology.s.options.metadata.driver;
    const _v = version2.split(".").map((v) => parseInt(v));
    return {
      major: _v[0],
      feature: _v[1],
      patch: _v[2]
    };
  } catch (err2) {
    return { major: 0, feature: 0, patch: 0 };
  }
}
class RateLimiterMongo$1 extends RateLimiterStoreAbstract$3 {
  constructor(opts) {
    super(opts);
    this.dbName = opts.dbName;
    this.tableName = opts.tableName;
    this.indexKeyPrefix = opts.indexKeyPrefix;
    if (opts.mongo) {
      this.client = opts.mongo;
    } else {
      this.client = opts.storeClient;
    }
    if (typeof this.client.then === "function") {
      this.client.then((conn) => {
        this.client = conn;
        this._initCollection();
        this._driverVersion = getDriverVersion(this.client);
      });
    } else {
      this._initCollection();
      this._driverVersion = getDriverVersion(this.client);
    }
  }
  get dbName() {
    return this._dbName;
  }
  set dbName(value2) {
    this._dbName = typeof value2 === "undefined" ? RateLimiterMongo$1.getDbName() : value2;
  }
  static getDbName() {
    return "node-rate-limiter-flexible";
  }
  get tableName() {
    return this._tableName;
  }
  set tableName(value2) {
    this._tableName = typeof value2 === "undefined" ? this.keyPrefix : value2;
  }
  get client() {
    return this._client;
  }
  set client(value2) {
    if (typeof value2 === "undefined") {
      throw new Error("mongo is not set");
    }
    this._client = value2;
  }
  get indexKeyPrefix() {
    return this._indexKeyPrefix;
  }
  set indexKeyPrefix(obj) {
    this._indexKeyPrefix = obj || {};
  }
  _initCollection() {
    const db = typeof this.client.db === "function" ? this.client.db(this.dbName) : this.client;
    const collection = db.collection(this.tableName);
    collection.createIndex({ expire: -1 }, { expireAfterSeconds: 0 });
    collection.createIndex(Object.assign({}, this.indexKeyPrefix, { key: 1 }), { unique: true });
    this._collection = collection;
  }
  _getRateLimiterRes(rlKey, changedPoints, result) {
    const res = new RateLimiterRes$9();
    let doc;
    if (typeof result.value === "undefined") {
      doc = result;
    } else {
      doc = result.value;
    }
    res.isFirstInDuration = doc.points === changedPoints;
    res.consumedPoints = doc.points;
    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
    res.msBeforeNext = doc.expire !== null ? Math.max(new Date(doc.expire).getTime() - Date.now(), 0) : -1;
    return res;
  }
  _upsert(key, points, msDuration, forceExpire = false, options = {}) {
    if (!this._collection) {
      return Promise.reject(Error("Mongo connection is not established"));
    }
    const docAttrs = options.attrs || {};
    let where;
    let upsertData;
    if (forceExpire) {
      where = { key };
      where = Object.assign(where, docAttrs);
      upsertData = {
        $set: {
          key,
          points,
          expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null
        }
      };
      upsertData.$set = Object.assign(upsertData.$set, docAttrs);
    } else {
      where = {
        $or: [
          { expire: { $gt: new Date() } },
          { expire: { $eq: null } }
        ],
        key
      };
      where = Object.assign(where, docAttrs);
      upsertData = {
        $setOnInsert: {
          key,
          expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null
        },
        $inc: { points }
      };
      upsertData.$setOnInsert = Object.assign(upsertData.$setOnInsert, docAttrs);
    }
    const upsertOptions = {
      upsert: true
    };
    if (this._driverVersion.major >= 4 || (this._driverVersion.major === 3 && this._driverVersion.feature >= 7 || this._driverVersion.feature >= 6 && this._driverVersion.patch >= 7)) {
      upsertOptions.returnDocument = "after";
    } else {
      upsertOptions.returnOriginal = false;
    }
    return new Promise((resolve2, reject) => {
      this._collection.findOneAndUpdate(
        where,
        upsertData,
        upsertOptions
      ).then((res) => {
        resolve2(res);
      }).catch((errUpsert) => {
        if (errUpsert && errUpsert.code === 11e3) {
          const replaceWhere = Object.assign({
            $or: [
              { expire: { $lte: new Date() } },
              { expire: { $eq: null } }
            ],
            key
          }, docAttrs);
          const replaceTo = {
            $set: Object.assign({
              key,
              points,
              expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null
            }, docAttrs)
          };
          this._collection.findOneAndUpdate(
            replaceWhere,
            replaceTo,
            upsertOptions
          ).then((res) => {
            resolve2(res);
          }).catch((errReplace) => {
            if (errReplace && errReplace.code === 11e3) {
              this._upsert(key, points, msDuration, forceExpire).then((res) => resolve2(res)).catch((err2) => reject(err2));
            } else {
              reject(errReplace);
            }
          });
        } else {
          reject(errUpsert);
        }
      });
    });
  }
  _get(rlKey, options = {}) {
    if (!this._collection) {
      return Promise.reject(Error("Mongo connection is not established"));
    }
    const docAttrs = options.attrs || {};
    const where = Object.assign({
      key: rlKey,
      $or: [
        { expire: { $gt: new Date() } },
        { expire: { $eq: null } }
      ]
    }, docAttrs);
    return this._collection.findOne(where);
  }
  _delete(rlKey, options = {}) {
    if (!this._collection) {
      return Promise.reject(Error("Mongo connection is not established"));
    }
    const docAttrs = options.attrs || {};
    const where = Object.assign({ key: rlKey }, docAttrs);
    return this._collection.deleteOne(where).then((res) => res.deletedCount > 0);
  }
}
var RateLimiterMongo_1 = RateLimiterMongo$1;
const RateLimiterStoreAbstract$2 = RateLimiterStoreAbstract_1;
const RateLimiterRes$8 = RateLimiterRes_1;
class RateLimiterMySQL$1 extends RateLimiterStoreAbstract$2 {
  constructor(opts, cb = null) {
    super(opts);
    this.client = opts.storeClient;
    this.clientType = opts.storeType;
    this.dbName = opts.dbName;
    this.tableName = opts.tableName;
    this.clearExpiredByTimeout = opts.clearExpiredByTimeout;
    this.tableCreated = opts.tableCreated;
    if (!this.tableCreated) {
      this._createDbAndTable().then(() => {
        this.tableCreated = true;
        if (this.clearExpiredByTimeout) {
          this._clearExpiredHourAgo();
        }
        if (typeof cb === "function") {
          cb();
        }
      }).catch((err2) => {
        if (typeof cb === "function") {
          cb(err2);
        } else {
          throw err2;
        }
      });
    } else {
      if (this.clearExpiredByTimeout) {
        this._clearExpiredHourAgo();
      }
      if (typeof cb === "function") {
        cb();
      }
    }
  }
  clearExpired(expire) {
    return new Promise((resolve2) => {
      this._getConnection().then((conn) => {
        conn.query(`DELETE FROM ??.?? WHERE expire < ?`, [this.dbName, this.tableName, expire], () => {
          this._releaseConnection(conn);
          resolve2();
        });
      }).catch(() => {
        resolve2();
      });
    });
  }
  _clearExpiredHourAgo() {
    if (this._clearExpiredTimeoutId) {
      clearTimeout(this._clearExpiredTimeoutId);
    }
    this._clearExpiredTimeoutId = setTimeout(() => {
      this.clearExpired(Date.now() - 36e5).then(() => {
        this._clearExpiredHourAgo();
      });
    }, 3e5);
    this._clearExpiredTimeoutId.unref();
  }
  _getConnection() {
    switch (this.clientType) {
      case "pool":
        return new Promise((resolve2, reject) => {
          this.client.getConnection((errConn, conn) => {
            if (errConn) {
              return reject(errConn);
            }
            resolve2(conn);
          });
        });
      case "sequelize":
        return this.client.connectionManager.getConnection();
      case "knex":
        return this.client.client.acquireConnection();
      default:
        return Promise.resolve(this.client);
    }
  }
  _releaseConnection(conn) {
    switch (this.clientType) {
      case "pool":
        return conn.release();
      case "sequelize":
        return this.client.connectionManager.releaseConnection(conn);
      case "knex":
        return this.client.client.releaseConnection(conn);
      default:
        return true;
    }
  }
  _createDbAndTable() {
    return new Promise((resolve2, reject) => {
      this._getConnection().then((conn) => {
        conn.query(`CREATE DATABASE IF NOT EXISTS \`${this.dbName}\`;`, (errDb) => {
          if (errDb) {
            this._releaseConnection(conn);
            return reject(errDb);
          }
          conn.query(this._getCreateTableStmt(), (err2) => {
            if (err2) {
              this._releaseConnection(conn);
              return reject(err2);
            }
            this._releaseConnection(conn);
            resolve2();
          });
        });
      }).catch((err2) => {
        reject(err2);
      });
    });
  }
  _getCreateTableStmt() {
    return `CREATE TABLE IF NOT EXISTS \`${this.dbName}\`.\`${this.tableName}\` (\`key\` VARCHAR(255) CHARACTER SET utf8 NOT NULL,\`points\` INT(9) NOT NULL default 0,\`expire\` BIGINT UNSIGNED,PRIMARY KEY (\`key\`)) ENGINE = INNODB;`;
  }
  get clientType() {
    return this._clientType;
  }
  set clientType(value2) {
    if (typeof value2 === "undefined") {
      if (this.client.constructor.name === "Connection") {
        value2 = "connection";
      } else if (this.client.constructor.name === "Pool") {
        value2 = "pool";
      } else if (this.client.constructor.name === "Sequelize") {
        value2 = "sequelize";
      } else {
        throw new Error("storeType is not defined");
      }
    }
    this._clientType = value2.toLowerCase();
  }
  get dbName() {
    return this._dbName;
  }
  set dbName(value2) {
    this._dbName = typeof value2 === "undefined" ? "rtlmtrflx" : value2;
  }
  get tableName() {
    return this._tableName;
  }
  set tableName(value2) {
    this._tableName = typeof value2 === "undefined" ? this.keyPrefix : value2;
  }
  get tableCreated() {
    return this._tableCreated;
  }
  set tableCreated(value2) {
    this._tableCreated = typeof value2 === "undefined" ? false : !!value2;
  }
  get clearExpiredByTimeout() {
    return this._clearExpiredByTimeout;
  }
  set clearExpiredByTimeout(value2) {
    this._clearExpiredByTimeout = typeof value2 === "undefined" ? true : Boolean(value2);
  }
  _getRateLimiterRes(rlKey, changedPoints, result) {
    const res = new RateLimiterRes$8();
    const [row] = result;
    res.isFirstInDuration = changedPoints === row.points;
    res.consumedPoints = res.isFirstInDuration ? changedPoints : row.points;
    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
    res.msBeforeNext = row.expire ? Math.max(row.expire - Date.now(), 0) : -1;
    return res;
  }
  _upsertTransaction(conn, key, points, msDuration, forceExpire) {
    return new Promise((resolve2, reject) => {
      conn.query("BEGIN", (errBegin) => {
        if (errBegin) {
          conn.rollback();
          return reject(errBegin);
        }
        const dateNow = Date.now();
        const newExpire = msDuration > 0 ? dateNow + msDuration : null;
        let q;
        let values;
        if (forceExpire) {
          q = `INSERT INTO ??.?? VALUES (?, ?, ?)
          ON DUPLICATE KEY UPDATE 
            points = ?, 
            expire = ?;`;
          values = [
            this.dbName,
            this.tableName,
            key,
            points,
            newExpire,
            points,
            newExpire
          ];
        } else {
          q = `INSERT INTO ??.?? VALUES (?, ?, ?)
          ON DUPLICATE KEY UPDATE 
            points = IF(expire <= ?, ?, points + (?)), 
            expire = IF(expire <= ?, ?, expire);`;
          values = [
            this.dbName,
            this.tableName,
            key,
            points,
            newExpire,
            dateNow,
            points,
            points,
            dateNow,
            newExpire
          ];
        }
        conn.query(q, values, (errUpsert) => {
          if (errUpsert) {
            conn.rollback();
            return reject(errUpsert);
          }
          conn.query("SELECT points, expire FROM ??.?? WHERE `key` = ?;", [this.dbName, this.tableName, key], (errSelect, res) => {
            if (errSelect) {
              conn.rollback();
              return reject(errSelect);
            }
            conn.query("COMMIT", (err2) => {
              if (err2) {
                conn.rollback();
                return reject(err2);
              }
              resolve2(res);
            });
          });
        });
      });
    });
  }
  _upsert(key, points, msDuration, forceExpire = false) {
    if (!this.tableCreated) {
      return Promise.reject(Error("Table is not created yet"));
    }
    return new Promise((resolve2, reject) => {
      this._getConnection().then((conn) => {
        this._upsertTransaction(conn, key, points, msDuration, forceExpire).then((res) => {
          resolve2(res);
          this._releaseConnection(conn);
        }).catch((err2) => {
          reject(err2);
          this._releaseConnection(conn);
        });
      }).catch((err2) => {
        reject(err2);
      });
    });
  }
  _get(rlKey) {
    if (!this.tableCreated) {
      return Promise.reject(Error("Table is not created yet"));
    }
    return new Promise((resolve2, reject) => {
      this._getConnection().then((conn) => {
        conn.query(
          "SELECT points, expire FROM ??.?? WHERE `key` = ? AND (`expire` > ? OR `expire` IS NULL)",
          [this.dbName, this.tableName, rlKey, Date.now()],
          (err2, res) => {
            if (err2) {
              reject(err2);
            } else if (res.length === 0) {
              resolve2(null);
            } else {
              resolve2(res);
            }
            this._releaseConnection(conn);
          }
        );
      }).catch((err2) => {
        reject(err2);
      });
    });
  }
  _delete(rlKey) {
    if (!this.tableCreated) {
      return Promise.reject(Error("Table is not created yet"));
    }
    return new Promise((resolve2, reject) => {
      this._getConnection().then((conn) => {
        conn.query(
          "DELETE FROM ??.?? WHERE `key` = ?",
          [this.dbName, this.tableName, rlKey],
          (err2, res) => {
            if (err2) {
              reject(err2);
            } else {
              resolve2(res.affectedRows > 0);
            }
            this._releaseConnection(conn);
          }
        );
      }).catch((err2) => {
        reject(err2);
      });
    });
  }
}
var RateLimiterMySQL_1 = RateLimiterMySQL$1;
const RateLimiterStoreAbstract$1 = RateLimiterStoreAbstract_1;
const RateLimiterRes$7 = RateLimiterRes_1;
class RateLimiterPostgres$1 extends RateLimiterStoreAbstract$1 {
  constructor(opts, cb = null) {
    super(opts);
    this.client = opts.storeClient;
    this.clientType = opts.storeType;
    this.tableName = opts.tableName;
    this.clearExpiredByTimeout = opts.clearExpiredByTimeout;
    this.tableCreated = opts.tableCreated;
    if (!this.tableCreated) {
      this._createTable().then(() => {
        this.tableCreated = true;
        if (this.clearExpiredByTimeout) {
          this._clearExpiredHourAgo();
        }
        if (typeof cb === "function") {
          cb();
        }
      }).catch((err2) => {
        if (typeof cb === "function") {
          cb(err2);
        } else {
          throw err2;
        }
      });
    } else {
      if (typeof cb === "function") {
        cb();
      }
    }
  }
  clearExpired(expire) {
    return new Promise((resolve2) => {
      const q = {
        name: "rlflx-clear-expired",
        text: `DELETE FROM ${this.tableName} WHERE expire < $1`,
        values: [expire]
      };
      this._query(q).then(() => {
        resolve2();
      }).catch(() => {
        resolve2();
      });
    });
  }
  _clearExpiredHourAgo() {
    if (this._clearExpiredTimeoutId) {
      clearTimeout(this._clearExpiredTimeoutId);
    }
    this._clearExpiredTimeoutId = setTimeout(() => {
      this.clearExpired(Date.now() - 36e5).then(() => {
        this._clearExpiredHourAgo();
      });
    }, 3e5);
    this._clearExpiredTimeoutId.unref();
  }
  _getConnection() {
    switch (this.clientType) {
      case "pool":
        return Promise.resolve(this.client);
      case "sequelize":
        return this.client.connectionManager.getConnection();
      case "knex":
        return this.client.client.acquireConnection();
      case "typeorm":
        return Promise.resolve(this.client.driver.master);
      default:
        return Promise.resolve(this.client);
    }
  }
  _releaseConnection(conn) {
    switch (this.clientType) {
      case "pool":
        return true;
      case "sequelize":
        return this.client.connectionManager.releaseConnection(conn);
      case "knex":
        return this.client.client.releaseConnection(conn);
      case "typeorm":
        return true;
      default:
        return true;
    }
  }
  _createTable() {
    return new Promise((resolve2, reject) => {
      this._query({
        text: this._getCreateTableStmt()
      }).then(() => {
        resolve2();
      }).catch((err2) => {
        if (err2.code === "23505") {
          resolve2();
        } else {
          reject(err2);
        }
      });
    });
  }
  _getCreateTableStmt() {
    return `CREATE TABLE IF NOT EXISTS ${this.tableName} ( 
      key varchar(255) PRIMARY KEY,
      points integer NOT NULL DEFAULT 0,
      expire bigint
    );`;
  }
  get clientType() {
    return this._clientType;
  }
  set clientType(value2) {
    const constructorName = this.client.constructor.name;
    if (typeof value2 === "undefined") {
      if (constructorName === "Client") {
        value2 = "client";
      } else if (constructorName === "Pool" || constructorName === "BoundPool") {
        value2 = "pool";
      } else if (constructorName === "Sequelize") {
        value2 = "sequelize";
      } else {
        throw new Error("storeType is not defined");
      }
    }
    this._clientType = value2.toLowerCase();
  }
  get tableName() {
    return this._tableName;
  }
  set tableName(value2) {
    this._tableName = typeof value2 === "undefined" ? this.keyPrefix : value2;
  }
  get tableCreated() {
    return this._tableCreated;
  }
  set tableCreated(value2) {
    this._tableCreated = typeof value2 === "undefined" ? false : !!value2;
  }
  get clearExpiredByTimeout() {
    return this._clearExpiredByTimeout;
  }
  set clearExpiredByTimeout(value2) {
    this._clearExpiredByTimeout = typeof value2 === "undefined" ? true : Boolean(value2);
  }
  _getRateLimiterRes(rlKey, changedPoints, result) {
    const res = new RateLimiterRes$7();
    const row = result.rows[0];
    res.isFirstInDuration = changedPoints === row.points;
    res.consumedPoints = res.isFirstInDuration ? changedPoints : row.points;
    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
    res.msBeforeNext = row.expire ? Math.max(row.expire - Date.now(), 0) : -1;
    return res;
  }
  _query(q) {
    const prefix = this.tableName.toLowerCase();
    const queryObj = { name: `${prefix}:${q.name}`, text: q.text, values: q.values };
    return new Promise((resolve2, reject) => {
      this._getConnection().then((conn) => {
        conn.query(queryObj).then((res) => {
          resolve2(res);
          this._releaseConnection(conn);
        }).catch((err2) => {
          reject(err2);
          this._releaseConnection(conn);
        });
      }).catch((err2) => {
        reject(err2);
      });
    });
  }
  _upsert(key, points, msDuration, forceExpire = false) {
    if (!this.tableCreated) {
      return Promise.reject(Error("Table is not created yet"));
    }
    const newExpire = msDuration > 0 ? Date.now() + msDuration : null;
    const expireQ = forceExpire ? " $3 " : ` CASE
             WHEN ${this.tableName}.expire <= $4 THEN $3
             ELSE ${this.tableName}.expire
            END `;
    return this._query({
      name: forceExpire ? "rlflx-upsert-force" : "rlflx-upsert",
      text: `
            INSERT INTO ${this.tableName} VALUES ($1, $2, $3)
              ON CONFLICT(key) DO UPDATE SET
                points = CASE
                          WHEN (${this.tableName}.expire <= $4 OR 1=${forceExpire ? 1 : 0}) THEN $2
                          ELSE ${this.tableName}.points + ($2)
                         END,
                expire = ${expireQ}
            RETURNING points, expire;`,
      values: [key, points, newExpire, Date.now()]
    });
  }
  _get(rlKey) {
    if (!this.tableCreated) {
      return Promise.reject(Error("Table is not created yet"));
    }
    return new Promise((resolve2, reject) => {
      this._query({
        name: "rlflx-get",
        text: `
            SELECT points, expire FROM ${this.tableName} WHERE key = $1 AND (expire > $2 OR expire IS NULL);`,
        values: [rlKey, Date.now()]
      }).then((res) => {
        if (res.rowCount === 0) {
          res = null;
        }
        resolve2(res);
      }).catch((err2) => {
        reject(err2);
      });
    });
  }
  _delete(rlKey) {
    if (!this.tableCreated) {
      return Promise.reject(Error("Table is not created yet"));
    }
    return this._query({
      name: "rlflx-delete",
      text: `DELETE FROM ${this.tableName} WHERE key = $1`,
      values: [rlKey]
    }).then((res) => res.rowCount > 0);
  }
}
var RateLimiterPostgres_1 = RateLimiterPostgres$1;
var Record_1 = class Record2 {
  constructor(value2, expiresAt, timeoutId = null) {
    this.value = value2;
    this.expiresAt = expiresAt;
    this.timeoutId = timeoutId;
  }
  get value() {
    return this._value;
  }
  set value(value2) {
    this._value = parseInt(value2);
  }
  get expiresAt() {
    return this._expiresAt;
  }
  set expiresAt(value2) {
    if (!(value2 instanceof Date) && Number.isInteger(value2)) {
      value2 = new Date(value2);
    }
    this._expiresAt = value2;
  }
  get timeoutId() {
    return this._timeoutId;
  }
  set timeoutId(value2) {
    this._timeoutId = value2;
  }
};
const Record$1 = Record_1;
const RateLimiterRes$6 = RateLimiterRes_1;
var MemoryStorage_1 = class MemoryStorage2 {
  constructor() {
    this._storage = {};
  }
  incrby(key, value2, durationSec) {
    if (this._storage[key]) {
      const msBeforeExpires = this._storage[key].expiresAt ? this._storage[key].expiresAt.getTime() - new Date().getTime() : -1;
      if (msBeforeExpires !== 0) {
        this._storage[key].value = this._storage[key].value + value2;
        return new RateLimiterRes$6(0, msBeforeExpires, this._storage[key].value, false);
      }
      return this.set(key, value2, durationSec);
    }
    return this.set(key, value2, durationSec);
  }
  set(key, value2, durationSec) {
    const durationMs = durationSec * 1e3;
    if (this._storage[key] && this._storage[key].timeoutId) {
      clearTimeout(this._storage[key].timeoutId);
    }
    this._storage[key] = new Record$1(
      value2,
      durationMs > 0 ? new Date(Date.now() + durationMs) : null
    );
    if (durationMs > 0) {
      this._storage[key].timeoutId = setTimeout(() => {
        delete this._storage[key];
      }, durationMs);
      if (this._storage[key].timeoutId.unref) {
        this._storage[key].timeoutId.unref();
      }
    }
    return new RateLimiterRes$6(0, durationMs === 0 ? -1 : durationMs, this._storage[key].value, true);
  }
  get(key) {
    if (this._storage[key]) {
      const msBeforeExpires = this._storage[key].expiresAt ? this._storage[key].expiresAt.getTime() - new Date().getTime() : -1;
      return new RateLimiterRes$6(0, msBeforeExpires, this._storage[key].value, false);
    }
    return null;
  }
  delete(key) {
    if (this._storage[key]) {
      if (this._storage[key].timeoutId) {
        clearTimeout(this._storage[key].timeoutId);
      }
      delete this._storage[key];
      return true;
    }
    return false;
  }
};
const RateLimiterAbstract$2 = RateLimiterAbstract_1;
const MemoryStorage = MemoryStorage_1;
const RateLimiterRes$5 = RateLimiterRes_1;
class RateLimiterMemory$2 extends RateLimiterAbstract$2 {
  constructor(opts = {}) {
    super(opts);
    this._memoryStorage = new MemoryStorage();
  }
  consume(key, pointsToConsume = 1, options = {}) {
    return new Promise((resolve2, reject) => {
      const rlKey = this.getKey(key);
      const secDuration = this._getKeySecDuration(options);
      let res = this._memoryStorage.incrby(rlKey, pointsToConsume, secDuration);
      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
      if (res.consumedPoints > this.points) {
        if (this.blockDuration > 0 && res.consumedPoints <= this.points + pointsToConsume) {
          res = this._memoryStorage.set(rlKey, res.consumedPoints, this.blockDuration);
        }
        reject(res);
      } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {
        let delay2 = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));
        if (delay2 < this.execEvenlyMinDelayMs) {
          delay2 = res.consumedPoints * this.execEvenlyMinDelayMs;
        }
        setTimeout(resolve2, delay2, res);
      } else {
        resolve2(res);
      }
    });
  }
  penalty(key, points = 1, options = {}) {
    const rlKey = this.getKey(key);
    return new Promise((resolve2) => {
      const secDuration = this._getKeySecDuration(options);
      const res = this._memoryStorage.incrby(rlKey, points, secDuration);
      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
      resolve2(res);
    });
  }
  reward(key, points = 1, options = {}) {
    const rlKey = this.getKey(key);
    return new Promise((resolve2) => {
      const secDuration = this._getKeySecDuration(options);
      const res = this._memoryStorage.incrby(rlKey, -points, secDuration);
      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
      resolve2(res);
    });
  }
  block(key, secDuration) {
    const msDuration = secDuration * 1e3;
    const initPoints = this.points + 1;
    this._memoryStorage.set(this.getKey(key), initPoints, secDuration);
    return Promise.resolve(
      new RateLimiterRes$5(0, msDuration === 0 ? -1 : msDuration, initPoints)
    );
  }
  set(key, points, secDuration) {
    const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1e3;
    this._memoryStorage.set(this.getKey(key), points, secDuration);
    return Promise.resolve(
      new RateLimiterRes$5(0, msDuration === 0 ? -1 : msDuration, points)
    );
  }
  get(key) {
    const res = this._memoryStorage.get(this.getKey(key));
    if (res !== null) {
      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
    }
    return Promise.resolve(res);
  }
  delete(key) {
    return Promise.resolve(this._memoryStorage.delete(this.getKey(key)));
  }
}
var RateLimiterMemory_1 = RateLimiterMemory$2;
const cluster = require$$1;
const crypto$2 = require$$1;
const RateLimiterAbstract$1 = RateLimiterAbstract_1;
const RateLimiterMemory$1 = RateLimiterMemory_1;
const RateLimiterRes$4 = RateLimiterRes_1;
const channel = "rate_limiter_flexible";
let masterInstance = null;
const masterSendToWorker = function(worker, msg, type, res) {
  let data;
  if (res === null || res === true || res === false) {
    data = res;
  } else {
    data = {
      remainingPoints: res.remainingPoints,
      msBeforeNext: res.msBeforeNext,
      consumedPoints: res.consumedPoints,
      isFirstInDuration: res.isFirstInDuration
    };
  }
  worker.send({
    channel,
    keyPrefix: msg.keyPrefix,
    promiseId: msg.promiseId,
    type,
    data
  });
};
const workerWaitInit = function(payload) {
  setTimeout(() => {
    if (this._initiated) {
      process.send(payload);
    } else if (typeof this._promises[payload.promiseId] !== "undefined") {
      workerWaitInit.call(this, payload);
    }
  }, 30);
};
const workerSendToMaster = function(func, promiseId, key, arg, opts) {
  const payload = {
    channel,
    keyPrefix: this.keyPrefix,
    func,
    promiseId,
    data: {
      key,
      arg,
      opts
    }
  };
  if (!this._initiated) {
    workerWaitInit.call(this, payload);
  } else {
    process.send(payload);
  }
};
const masterProcessMsg = function(worker, msg) {
  if (!msg || msg.channel !== channel || typeof this._rateLimiters[msg.keyPrefix] === "undefined") {
    return false;
  }
  let promise2;
  switch (msg.func) {
    case "consume":
      promise2 = this._rateLimiters[msg.keyPrefix].consume(msg.data.key, msg.data.arg, msg.data.opts);
      break;
    case "penalty":
      promise2 = this._rateLimiters[msg.keyPrefix].penalty(msg.data.key, msg.data.arg, msg.data.opts);
      break;
    case "reward":
      promise2 = this._rateLimiters[msg.keyPrefix].reward(msg.data.key, msg.data.arg, msg.data.opts);
      break;
    case "block":
      promise2 = this._rateLimiters[msg.keyPrefix].block(msg.data.key, msg.data.arg, msg.data.opts);
      break;
    case "get":
      promise2 = this._rateLimiters[msg.keyPrefix].get(msg.data.key, msg.data.opts);
      break;
    case "delete":
      promise2 = this._rateLimiters[msg.keyPrefix].delete(msg.data.key, msg.data.opts);
      break;
    default:
      return false;
  }
  if (promise2) {
    promise2.then((res) => {
      masterSendToWorker(worker, msg, "resolve", res);
    }).catch((rejRes) => {
      masterSendToWorker(worker, msg, "reject", rejRes);
    });
  }
};
const workerProcessMsg = function(msg) {
  if (!msg || msg.channel !== channel || msg.keyPrefix !== this.keyPrefix) {
    return false;
  }
  if (this._promises[msg.promiseId]) {
    clearTimeout(this._promises[msg.promiseId].timeoutId);
    let res;
    if (msg.data === null || msg.data === true || msg.data === false) {
      res = msg.data;
    } else {
      res = new RateLimiterRes$4(
        msg.data.remainingPoints,
        msg.data.msBeforeNext,
        msg.data.consumedPoints,
        msg.data.isFirstInDuration
      );
    }
    switch (msg.type) {
      case "resolve":
        this._promises[msg.promiseId].resolve(res);
        break;
      case "reject":
        this._promises[msg.promiseId].reject(res);
        break;
      default:
        throw new Error(`RateLimiterCluster: no such message type '${msg.type}'`);
    }
    delete this._promises[msg.promiseId];
  }
};
const getOpts = function() {
  return {
    points: this.points,
    duration: this.duration,
    blockDuration: this.blockDuration,
    execEvenly: this.execEvenly,
    execEvenlyMinDelayMs: this.execEvenlyMinDelayMs,
    keyPrefix: this.keyPrefix
  };
};
const savePromise = function(resolve2, reject) {
  const hrtime = process.hrtime();
  let promiseId = hrtime[0].toString() + hrtime[1].toString();
  if (typeof this._promises[promiseId] !== "undefined") {
    promiseId += crypto$2.randomBytes(12).toString("base64");
  }
  this._promises[promiseId] = {
    resolve: resolve2,
    reject,
    timeoutId: setTimeout(() => {
      delete this._promises[promiseId];
      reject(new Error("RateLimiterCluster timeout: no answer from master in time"));
    }, this.timeoutMs)
  };
  return promiseId;
};
class RateLimiterClusterMaster$1 {
  constructor() {
    if (masterInstance) {
      return masterInstance;
    }
    this._rateLimiters = {};
    cluster.setMaxListeners(0);
    cluster.on("message", (worker, msg) => {
      if (msg && msg.channel === channel && msg.type === "init") {
        if (typeof this._rateLimiters[msg.opts.keyPrefix] === "undefined") {
          this._rateLimiters[msg.opts.keyPrefix] = new RateLimiterMemory$1(msg.opts);
        }
        worker.send({
          channel,
          type: "init",
          keyPrefix: msg.opts.keyPrefix
        });
      } else {
        masterProcessMsg.call(this, worker, msg);
      }
    });
    masterInstance = this;
  }
}
class RateLimiterClusterMasterPM2$1 {
  constructor(pm2) {
    if (masterInstance) {
      return masterInstance;
    }
    this._rateLimiters = {};
    pm2.launchBus((err2, pm2Bus) => {
      pm2Bus.on("process:msg", (packet) => {
        const msg = packet.raw;
        if (msg && msg.channel === channel && msg.type === "init") {
          if (typeof this._rateLimiters[msg.opts.keyPrefix] === "undefined") {
            this._rateLimiters[msg.opts.keyPrefix] = new RateLimiterMemory$1(msg.opts);
          }
          pm2.sendDataToProcessId(packet.process.pm_id, {
            data: {},
            topic: channel,
            channel,
            type: "init",
            keyPrefix: msg.opts.keyPrefix
          }, (sendErr, res) => {
            if (sendErr) {
              console.log(sendErr, res);
            }
          });
        } else {
          const worker = {
            send: (msgData) => {
              const pm2Message = msgData;
              pm2Message.topic = channel;
              if (typeof pm2Message.data === "undefined") {
                pm2Message.data = {};
              }
              pm2.sendDataToProcessId(packet.process.pm_id, pm2Message, (sendErr, res) => {
                if (sendErr) {
                  console.log(sendErr, res);
                }
              });
            }
          };
          masterProcessMsg.call(this, worker, msg);
        }
      });
    });
    masterInstance = this;
  }
}
class RateLimiterClusterWorker extends RateLimiterAbstract$1 {
  get timeoutMs() {
    return this._timeoutMs;
  }
  set timeoutMs(value2) {
    this._timeoutMs = typeof value2 === "undefined" ? 5e3 : Math.abs(parseInt(value2));
  }
  constructor(opts = {}) {
    super(opts);
    process.setMaxListeners(0);
    this.timeoutMs = opts.timeoutMs;
    this._initiated = false;
    process.on("message", (msg) => {
      if (msg && msg.channel === channel && msg.type === "init" && msg.keyPrefix === this.keyPrefix) {
        this._initiated = true;
      } else {
        workerProcessMsg.call(this, msg);
      }
    });
    process.send({
      channel,
      type: "init",
      opts: getOpts.call(this)
    });
    this._promises = {};
  }
  consume(key, pointsToConsume = 1, options = {}) {
    return new Promise((resolve2, reject) => {
      const promiseId = savePromise.call(this, resolve2, reject);
      workerSendToMaster.call(this, "consume", promiseId, key, pointsToConsume, options);
    });
  }
  penalty(key, points = 1, options = {}) {
    return new Promise((resolve2, reject) => {
      const promiseId = savePromise.call(this, resolve2, reject);
      workerSendToMaster.call(this, "penalty", promiseId, key, points, options);
    });
  }
  reward(key, points = 1, options = {}) {
    return new Promise((resolve2, reject) => {
      const promiseId = savePromise.call(this, resolve2, reject);
      workerSendToMaster.call(this, "reward", promiseId, key, points, options);
    });
  }
  block(key, secDuration, options = {}) {
    return new Promise((resolve2, reject) => {
      const promiseId = savePromise.call(this, resolve2, reject);
      workerSendToMaster.call(this, "block", promiseId, key, secDuration, options);
    });
  }
  get(key, options = {}) {
    return new Promise((resolve2, reject) => {
      const promiseId = savePromise.call(this, resolve2, reject);
      workerSendToMaster.call(this, "get", promiseId, key, options);
    });
  }
  delete(key, options = {}) {
    return new Promise((resolve2, reject) => {
      const promiseId = savePromise.call(this, resolve2, reject);
      workerSendToMaster.call(this, "delete", promiseId, key, options);
    });
  }
}
var RateLimiterCluster$1 = {
  RateLimiterClusterMaster: RateLimiterClusterMaster$1,
  RateLimiterClusterMasterPM2: RateLimiterClusterMasterPM2$1,
  RateLimiterCluster: RateLimiterClusterWorker
};
const RateLimiterStoreAbstract = RateLimiterStoreAbstract_1;
const RateLimiterRes$3 = RateLimiterRes_1;
class RateLimiterMemcache$1 extends RateLimiterStoreAbstract {
  constructor(opts) {
    super(opts);
    this.client = opts.storeClient;
  }
  _getRateLimiterRes(rlKey, changedPoints, result) {
    const res = new RateLimiterRes$3();
    res.consumedPoints = parseInt(result.consumedPoints);
    res.isFirstInDuration = result.consumedPoints === changedPoints;
    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
    res.msBeforeNext = result.msBeforeNext;
    return res;
  }
  _upsert(rlKey, points, msDuration, forceExpire = false, options = {}) {
    return new Promise((resolve2, reject) => {
      const nowMs = Date.now();
      const secDuration = Math.floor(msDuration / 1e3);
      if (forceExpire) {
        this.client.set(rlKey, points, secDuration, (err2) => {
          if (!err2) {
            this.client.set(
              `${rlKey}_expire`,
              secDuration > 0 ? nowMs + secDuration * 1e3 : -1,
              secDuration,
              () => {
                const res = {
                  consumedPoints: points,
                  msBeforeNext: secDuration > 0 ? secDuration * 1e3 : -1
                };
                resolve2(res);
              }
            );
          } else {
            reject(err2);
          }
        });
      } else {
        this.client.incr(rlKey, points, (err2, consumedPoints) => {
          if (err2 || consumedPoints === false) {
            this.client.add(rlKey, points, secDuration, (errAddKey, createdNew) => {
              if (errAddKey || !createdNew) {
                if (typeof options.attemptNumber === "undefined" || options.attemptNumber < 3) {
                  const nextOptions = Object.assign({}, options);
                  nextOptions.attemptNumber = nextOptions.attemptNumber ? nextOptions.attemptNumber + 1 : 1;
                  this._upsert(rlKey, points, msDuration, forceExpire, nextOptions).then((resUpsert) => resolve2(resUpsert)).catch((errUpsert) => reject(errUpsert));
                } else {
                  reject(new Error("Can not add key"));
                }
              } else {
                this.client.add(
                  `${rlKey}_expire`,
                  secDuration > 0 ? nowMs + secDuration * 1e3 : -1,
                  secDuration,
                  () => {
                    const res = {
                      consumedPoints: points,
                      msBeforeNext: secDuration > 0 ? secDuration * 1e3 : -1
                    };
                    resolve2(res);
                  }
                );
              }
            });
          } else {
            this.client.get(`${rlKey}_expire`, (errGetExpire, resGetExpireMs) => {
              if (errGetExpire) {
                reject(errGetExpire);
              } else {
                const expireMs = resGetExpireMs === false ? 0 : resGetExpireMs;
                const res = {
                  consumedPoints,
                  msBeforeNext: expireMs >= 0 ? Math.max(expireMs - nowMs, 0) : -1
                };
                resolve2(res);
              }
            });
          }
        });
      }
    });
  }
  _get(rlKey) {
    return new Promise((resolve2, reject) => {
      const nowMs = Date.now();
      this.client.get(rlKey, (err2, consumedPoints) => {
        if (!consumedPoints) {
          resolve2(null);
        } else {
          this.client.get(`${rlKey}_expire`, (errGetExpire, resGetExpireMs) => {
            if (errGetExpire) {
              reject(errGetExpire);
            } else {
              const expireMs = resGetExpireMs === false ? 0 : resGetExpireMs;
              const res = {
                consumedPoints,
                msBeforeNext: expireMs >= 0 ? Math.max(expireMs - nowMs, 0) : -1
              };
              resolve2(res);
            }
          });
        }
      });
    });
  }
  _delete(rlKey) {
    return new Promise((resolve2, reject) => {
      this.client.del(rlKey, (err2, res) => {
        if (err2) {
          reject(err2);
        } else if (res === false) {
          resolve2(res);
        } else {
          this.client.del(`${rlKey}_expire`, (errDelExpire) => {
            if (errDelExpire) {
              reject(errDelExpire);
            } else {
              resolve2(res);
            }
          });
        }
      });
    });
  }
}
var RateLimiterMemcache_1 = RateLimiterMemcache$1;
const RateLimiterRes$2 = RateLimiterRes_1;
var RLWrapperBlackAndWhite_1 = class RLWrapperBlackAndWhite2 {
  constructor(opts = {}) {
    this.limiter = opts.limiter;
    this.blackList = opts.blackList;
    this.whiteList = opts.whiteList;
    this.isBlackListed = opts.isBlackListed;
    this.isWhiteListed = opts.isWhiteListed;
    this.runActionAnyway = opts.runActionAnyway;
  }
  get limiter() {
    return this._limiter;
  }
  set limiter(value2) {
    if (typeof value2 === "undefined") {
      throw new Error("limiter is not set");
    }
    this._limiter = value2;
  }
  get runActionAnyway() {
    return this._runActionAnyway;
  }
  set runActionAnyway(value2) {
    this._runActionAnyway = typeof value2 === "undefined" ? false : value2;
  }
  get blackList() {
    return this._blackList;
  }
  set blackList(value2) {
    this._blackList = Array.isArray(value2) ? value2 : [];
  }
  get isBlackListed() {
    return this._isBlackListed;
  }
  set isBlackListed(func) {
    if (typeof func === "undefined") {
      func = () => false;
    }
    if (typeof func !== "function") {
      throw new Error("isBlackListed must be function");
    }
    this._isBlackListed = func;
  }
  get whiteList() {
    return this._whiteList;
  }
  set whiteList(value2) {
    this._whiteList = Array.isArray(value2) ? value2 : [];
  }
  get isWhiteListed() {
    return this._isWhiteListed;
  }
  set isWhiteListed(func) {
    if (typeof func === "undefined") {
      func = () => false;
    }
    if (typeof func !== "function") {
      throw new Error("isWhiteListed must be function");
    }
    this._isWhiteListed = func;
  }
  isBlackListedSomewhere(key) {
    return this.blackList.indexOf(key) >= 0 || this.isBlackListed(key);
  }
  isWhiteListedSomewhere(key) {
    return this.whiteList.indexOf(key) >= 0 || this.isWhiteListed(key);
  }
  getBlackRes() {
    return new RateLimiterRes$2(0, Number.MAX_SAFE_INTEGER, 0, false);
  }
  getWhiteRes() {
    return new RateLimiterRes$2(Number.MAX_SAFE_INTEGER, 0, 0, false);
  }
  rejectBlack() {
    return Promise.reject(this.getBlackRes());
  }
  resolveBlack() {
    return Promise.resolve(this.getBlackRes());
  }
  resolveWhite() {
    return Promise.resolve(this.getWhiteRes());
  }
  consume(key, pointsToConsume = 1) {
    let res;
    if (this.isWhiteListedSomewhere(key)) {
      res = this.resolveWhite();
    } else if (this.isBlackListedSomewhere(key)) {
      res = this.rejectBlack();
    }
    if (typeof res === "undefined") {
      return this.limiter.consume(key, pointsToConsume);
    }
    if (this.runActionAnyway) {
      this.limiter.consume(key, pointsToConsume).catch(() => {
      });
    }
    return res;
  }
  block(key, secDuration) {
    let res;
    if (this.isWhiteListedSomewhere(key)) {
      res = this.resolveWhite();
    } else if (this.isBlackListedSomewhere(key)) {
      res = this.resolveBlack();
    }
    if (typeof res === "undefined") {
      return this.limiter.block(key, secDuration);
    }
    if (this.runActionAnyway) {
      this.limiter.block(key, secDuration).catch(() => {
      });
    }
    return res;
  }
  penalty(key, points) {
    let res;
    if (this.isWhiteListedSomewhere(key)) {
      res = this.resolveWhite();
    } else if (this.isBlackListedSomewhere(key)) {
      res = this.resolveBlack();
    }
    if (typeof res === "undefined") {
      return this.limiter.penalty(key, points);
    }
    if (this.runActionAnyway) {
      this.limiter.penalty(key, points).catch(() => {
      });
    }
    return res;
  }
  reward(key, points) {
    let res;
    if (this.isWhiteListedSomewhere(key)) {
      res = this.resolveWhite();
    } else if (this.isBlackListedSomewhere(key)) {
      res = this.resolveBlack();
    }
    if (typeof res === "undefined") {
      return this.limiter.reward(key, points);
    }
    if (this.runActionAnyway) {
      this.limiter.reward(key, points).catch(() => {
      });
    }
    return res;
  }
  get(key) {
    let res;
    if (this.isWhiteListedSomewhere(key)) {
      res = this.resolveWhite();
    } else if (this.isBlackListedSomewhere(key)) {
      res = this.resolveBlack();
    }
    if (typeof res === "undefined" || this.runActionAnyway) {
      return this.limiter.get(key);
    }
    return res;
  }
  delete(key) {
    return this.limiter.delete(key);
  }
};
const RateLimiterAbstract = RateLimiterAbstract_1;
var RateLimiterUnion_1 = class RateLimiterUnion2 {
  constructor(...limiters) {
    if (limiters.length < 1) {
      throw new Error("RateLimiterUnion: at least one limiter have to be passed");
    }
    limiters.forEach((limiter) => {
      if (!(limiter instanceof RateLimiterAbstract)) {
        throw new Error("RateLimiterUnion: all limiters have to be instance of RateLimiterAbstract");
      }
    });
    this._limiters = limiters;
  }
  consume(key, points = 1) {
    return new Promise((resolve2, reject) => {
      const promises = [];
      this._limiters.forEach((limiter) => {
        promises.push(limiter.consume(key, points).catch((rej) => ({ rejected: true, rej })));
      });
      Promise.all(promises).then((res) => {
        const resObj = {};
        let rejected = false;
        res.forEach((item) => {
          if (item.rejected === true) {
            rejected = true;
          }
        });
        for (let i2 = 0; i2 < res.length; i2++) {
          if (rejected && res[i2].rejected === true) {
            resObj[this._limiters[i2].keyPrefix] = res[i2].rej;
          } else if (!rejected) {
            resObj[this._limiters[i2].keyPrefix] = res[i2];
          }
        }
        if (rejected) {
          reject(resObj);
        } else {
          resolve2(resObj);
        }
      });
    });
  }
};
var RateLimiterQueueError_1 = class RateLimiterQueueError2 extends Error {
  constructor(message2, extra) {
    super();
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = "CustomError";
    this.message = message2;
    if (extra) {
      this.extra = extra;
    }
  }
};
const RateLimiterQueueError = RateLimiterQueueError_1;
const MAX_QUEUE_SIZE = 4294967295;
const KEY_DEFAULT = "limiter";
var RateLimiterQueue_1 = class RateLimiterQueue2 {
  constructor(limiterFlexible, opts = {
    maxQueueSize: MAX_QUEUE_SIZE
  }) {
    this._queueLimiters = {
      KEY_DEFAULT: new RateLimiterQueueInternal(limiterFlexible, opts)
    };
    this._limiterFlexible = limiterFlexible;
    this._maxQueueSize = opts.maxQueueSize;
  }
  getTokensRemaining(key = KEY_DEFAULT) {
    if (this._queueLimiters[key]) {
      return this._queueLimiters[key].getTokensRemaining();
    } else {
      return Promise.resolve(this._limiterFlexible.points);
    }
  }
  removeTokens(tokens, key = KEY_DEFAULT) {
    if (!this._queueLimiters[key]) {
      this._queueLimiters[key] = new RateLimiterQueueInternal(
        this._limiterFlexible,
        {
          key,
          maxQueueSize: this._maxQueueSize
        }
      );
    }
    return this._queueLimiters[key].removeTokens(tokens);
  }
};
class RateLimiterQueueInternal {
  constructor(limiterFlexible, opts = {
    maxQueueSize: MAX_QUEUE_SIZE,
    key: KEY_DEFAULT
  }) {
    this._key = opts.key;
    this._waitTimeout = null;
    this._queue = [];
    this._limiterFlexible = limiterFlexible;
    this._maxQueueSize = opts.maxQueueSize;
  }
  getTokensRemaining() {
    return this._limiterFlexible.get(this._key).then((rlRes) => {
      return rlRes !== null ? rlRes.remainingPoints : this._limiterFlexible.points;
    });
  }
  removeTokens(tokens) {
    const _this = this;
    return new Promise((resolve2, reject) => {
      if (tokens > _this._limiterFlexible.points) {
        reject(new RateLimiterQueueError(`Requested tokens ${tokens} exceeds maximum ${_this._limiterFlexible.points} tokens per interval`));
        return;
      }
      if (_this._queue.length > 0) {
        _this._queueRequest.call(_this, resolve2, reject, tokens);
      } else {
        _this._limiterFlexible.consume(_this._key, tokens).then((res) => {
          resolve2(res.remainingPoints);
        }).catch((rej) => {
          if (rej instanceof Error) {
            reject(rej);
          } else {
            _this._queueRequest.call(_this, resolve2, reject, tokens);
            if (_this._waitTimeout === null) {
              _this._waitTimeout = setTimeout(_this._processFIFO.bind(_this), rej.msBeforeNext);
            }
          }
        });
      }
    });
  }
  _queueRequest(resolve2, reject, tokens) {
    const _this = this;
    if (_this._queue.length < _this._maxQueueSize) {
      _this._queue.push({ resolve: resolve2, reject, tokens });
    } else {
      reject(new RateLimiterQueueError(`Number of requests reached it's maximum ${_this._maxQueueSize}`));
    }
  }
  _processFIFO() {
    const _this = this;
    if (_this._waitTimeout !== null) {
      clearTimeout(_this._waitTimeout);
      _this._waitTimeout = null;
    }
    if (_this._queue.length === 0) {
      return;
    }
    const item = _this._queue.shift();
    _this._limiterFlexible.consume(_this._key, item.tokens).then((res) => {
      item.resolve(res.remainingPoints);
      _this._processFIFO.call(_this);
    }).catch((rej) => {
      if (rej instanceof Error) {
        item.reject(rej);
        _this._processFIFO.call(_this);
      } else {
        _this._queue.unshift(item);
        if (_this._waitTimeout === null) {
          _this._waitTimeout = setTimeout(_this._processFIFO.bind(_this), rej.msBeforeNext);
        }
      }
    });
  }
}
const RateLimiterRes$1 = RateLimiterRes_1;
var BurstyRateLimiter_1 = class BurstyRateLimiter2 {
  constructor(rateLimiter, burstLimiter) {
    this._rateLimiter = rateLimiter;
    this._burstLimiter = burstLimiter;
  }
  _combineRes(rlRes, blRes) {
    return new RateLimiterRes$1(
      rlRes.remainingPoints,
      Math.min(rlRes.msBeforeNext, blRes.msBeforeNext),
      rlRes.consumedPoints,
      rlRes.isFirstInDuration
    );
  }
  consume(key, pointsToConsume = 1, options = {}) {
    return this._rateLimiter.consume(key, pointsToConsume, options).catch((rlRej) => {
      if (rlRej instanceof RateLimiterRes$1) {
        return this._burstLimiter.consume(key, pointsToConsume, options).then((blRes) => {
          return Promise.resolve(this._combineRes(rlRej, blRes));
        }).catch(
          (blRej) => {
            if (blRej instanceof RateLimiterRes$1) {
              return Promise.reject(this._combineRes(rlRej, blRej));
            } else {
              return Promise.reject(blRej);
            }
          }
        );
      } else {
        return Promise.reject(rlRej);
      }
    });
  }
  get(key) {
    return Promise.all([
      this._rateLimiter.get(key),
      this._burstLimiter.get(key)
    ]).then(([rlRes, blRes]) => {
      return this._combineRes(rlRes, blRes);
    });
  }
  get points() {
    return this._rateLimiter.points;
  }
};
const RateLimiterRedis = RateLimiterRedis_1;
const RateLimiterMongo = RateLimiterMongo_1;
const RateLimiterMySQL = RateLimiterMySQL_1;
const RateLimiterPostgres = RateLimiterPostgres_1;
const { RateLimiterClusterMaster, RateLimiterClusterMasterPM2, RateLimiterCluster } = RateLimiterCluster$1;
const RateLimiterMemory = RateLimiterMemory_1;
const RateLimiterMemcache = RateLimiterMemcache_1;
const RLWrapperBlackAndWhite = RLWrapperBlackAndWhite_1;
const RateLimiterUnion = RateLimiterUnion_1;
const RateLimiterQueue = RateLimiterQueue_1;
const BurstyRateLimiter = BurstyRateLimiter_1;
const RateLimiterRes = RateLimiterRes_1;
var rateLimiterFlexible = {
  RateLimiterRedis,
  RateLimiterMongo,
  RateLimiterMySQL,
  RateLimiterPostgres,
  RateLimiterMemory,
  RateLimiterMemcache,
  RateLimiterClusterMaster,
  RateLimiterClusterMasterPM2,
  RateLimiterCluster,
  RLWrapperBlackAndWhite,
  RateLimiterUnion,
  RateLimiterQueue,
  BurstyRateLimiter,
  RateLimiterRes
};
const log$K = logger$1("libp2p:connection-manager");
const defaultOptions$4 = {
  maxConnections: Infinity,
  minConnections: 0,
  maxData: Infinity,
  maxSentData: Infinity,
  maxReceivedData: Infinity,
  maxEventLoopDelay: Infinity,
  pollInterval: 2e3,
  autoDialInterval: 1e4,
  movingAverageInterval: 6e4,
  inboundConnectionThreshold: 5,
  maxIncomingPendingConnections: 10
};
const METRICS_SYSTEM = "libp2p";
const METRICS_COMPONENT$1 = "connection-manager";
const STARTUP_RECONNECT_TIMEOUT = 6e4;
class DefaultConnectionManager extends EventEmitter$1 {
  constructor(components, init2) {
    super();
    this.opts = mergeOptions$g.call({ ignoreUndefined: true }, defaultOptions$4, init2);
    if (this.opts.maxConnections < this.opts.minConnections) {
      throw errCode(new Error("Connection Manager maxConnections must be greater than minConnections"), codes$1.ERR_INVALID_PARAMETERS);
    }
    log$K("options: %o", this.opts);
    this.components = components;
    this.connections = /* @__PURE__ */ new Map();
    this.started = false;
    this._checkMetrics = this._checkMetrics.bind(this);
    this.latencyMonitor = new LatencyMonitor({
      latencyCheckIntervalMs: init2.pollInterval,
      dataEmitIntervalMs: init2.pollInterval
    });
    try {
      events.exports.setMaxListeners?.(Infinity, this);
    } catch {
    }
    this.onConnect = this.onConnect.bind(this);
    this.onDisconnect = this.onDisconnect.bind(this);
    this.startupReconnectTimeout = init2.startupReconnectTimeout ?? STARTUP_RECONNECT_TIMEOUT;
    this.dialTimeout = init2.dialTimeout ?? 3e4;
    this.allow = (init2.allow ?? []).map((ma) => multiaddr(ma));
    this.deny = (init2.deny ?? []).map((ma) => multiaddr(ma));
    this.inboundConnectionRateLimiter = new rateLimiterFlexible.RateLimiterMemory({
      points: this.opts.inboundConnectionThreshold,
      duration: 1
    });
    this.incomingPendingConnections = 0;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.components.metrics != null) {
      this.timer = this.timer ?? retimer_1(this._checkMetrics, this.opts.pollInterval);
    }
    this.components.metrics?.updateComponentMetric({
      system: METRICS_SYSTEM,
      component: METRICS_COMPONENT$1,
      metric: "connections",
      label: "direction",
      value: () => {
        const metric = {
          inbound: 0,
          outbound: 0
        };
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            if (conn.stat.direction === "inbound") {
              metric.inbound++;
            } else {
              metric.outbound++;
            }
          }
        }
        return metric;
      }
    });
    this.components.metrics?.updateComponentMetric({
      system: METRICS_SYSTEM,
      component: METRICS_COMPONENT$1,
      metric: "protocol-streams-total",
      label: "protocol",
      value: () => {
        const metric = {};
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            for (const stream2 of conn.streams) {
              const key = `${stream2.stat.direction} ${stream2.stat.protocol ?? "unnegotiated"}`;
              metric[key] = (metric[key] ?? 0) + 1;
            }
          }
        }
        return metric;
      }
    });
    this.components.metrics?.updateComponentMetric({
      system: METRICS_SYSTEM,
      component: METRICS_COMPONENT$1,
      metric: "protocol-streams-per-connection-90th-percentile",
      label: "protocol",
      value: () => {
        const allStreams = {};
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            const streams = {};
            for (const stream2 of conn.streams) {
              const key = `${stream2.stat.direction} ${stream2.stat.protocol ?? "unnegotiated"}`;
              streams[key] = (streams[key] ?? 0) + 1;
            }
            for (const [protocol2, count] of Object.entries(streams)) {
              allStreams[protocol2] = allStreams[protocol2] ?? [];
              allStreams[protocol2].push(count);
            }
          }
        }
        const metric = {};
        for (let [protocol2, counts] of Object.entries(allStreams)) {
          counts = counts.sort((a, b2) => a - b2);
          const index = Math.floor(counts.length * 0.9);
          metric[protocol2] = counts[index];
        }
        return metric;
      }
    });
    this.latencyMonitor.start();
    this._onLatencyMeasure = this._onLatencyMeasure.bind(this);
    this.latencyMonitor.addEventListener("data", this._onLatencyMeasure);
    this.started = true;
    log$K("started");
  }
  async afterStart() {
    this.components.upgrader.addEventListener("connection", this.onConnect);
    this.components.upgrader.addEventListener("connectionEnd", this.onDisconnect);
    void Promise.resolve().then(async () => {
      const keepAlivePeers = [];
      for (const peer of await this.components.peerStore.all()) {
        const tags = await this.components.peerStore.getTags(peer.id);
        const hasKeepAlive = tags.filter((tag) => tag.name === KEEP_ALIVE).length > 0;
        if (hasKeepAlive) {
          keepAlivePeers.push(peer.id);
        }
      }
      this.connectOnStartupController?.clear();
      this.connectOnStartupController = new timeoutAbortController.TimeoutController(this.startupReconnectTimeout);
      try {
        events.exports.setMaxListeners?.(Infinity, this.connectOnStartupController.signal);
      } catch {
      }
      await Promise.all(keepAlivePeers.map(async (peer) => {
        await this.openConnection(peer, {
          signal: this.connectOnStartupController?.signal
        }).catch((err2) => {
          log$K.error(err2);
        });
      }));
    }).catch((err2) => {
      log$K.error(err2);
    }).finally(() => {
      this.connectOnStartupController?.clear();
    });
  }
  async beforeStop() {
    this.connectOnStartupController?.abort();
    this.components.upgrader.removeEventListener("connection", this.onConnect);
    this.components.upgrader.removeEventListener("connectionEnd", this.onDisconnect);
  }
  async stop() {
    this.timer?.clear();
    this.latencyMonitor.removeEventListener("data", this._onLatencyMeasure);
    this.latencyMonitor.stop();
    this.started = false;
    await this._close();
    log$K("stopped");
  }
  async _close() {
    const tasks = [];
    for (const connectionList of this.connections.values()) {
      for (const connection of connectionList) {
        tasks.push((async () => {
          try {
            await connection.close();
          } catch (err2) {
            log$K.error(err2);
          }
        })());
      }
    }
    log$K("closing %d connections", tasks.length);
    await Promise.all(tasks);
    this.connections.clear();
  }
  async _checkMetrics() {
    const metrics = this.components.metrics;
    if (metrics != null) {
      try {
        const movingAverages = metrics.getGlobal().getMovingAverages();
        const received = movingAverages.dataReceived[this.opts.movingAverageInterval].movingAverage;
        await this._checkMaxLimit("maxReceivedData", received);
        const sent = movingAverages.dataSent[this.opts.movingAverageInterval].movingAverage;
        await this._checkMaxLimit("maxSentData", sent);
        const total = received + sent;
        await this._checkMaxLimit("maxData", total);
        log$K.trace("metrics update", total);
      } finally {
        this.timer = retimer_1(this._checkMetrics, this.opts.pollInterval);
      }
    }
  }
  onConnect(evt) {
    void this._onConnect(evt).catch((err2) => {
      log$K.error(err2);
    });
  }
  async _onConnect(evt) {
    const { detail: connection } = evt;
    if (!this.started) {
      await connection.close();
      return;
    }
    const peerId = connection.remotePeer;
    const peerIdStr = peerId.toString();
    const storedConns = this.connections.get(peerIdStr);
    if (storedConns != null) {
      storedConns.push(connection);
    } else {
      this.connections.set(peerIdStr, [connection]);
    }
    if (peerId.publicKey != null) {
      await this.components.peerStore.keyBook.set(peerId, peerId.publicKey);
    }
    const numConnections = this.getConnections().length;
    const toPrune = numConnections - this.opts.maxConnections;
    await this._checkMaxLimit("maxConnections", numConnections, toPrune);
    this.dispatchEvent(new CustomEvent("peer:connect", { detail: connection }));
  }
  onDisconnect(evt) {
    const { detail: connection } = evt;
    if (!this.started) {
      return;
    }
    const peerId = connection.remotePeer.toString();
    let storedConn = this.connections.get(peerId);
    if (storedConn != null && storedConn.length > 1) {
      storedConn = storedConn.filter((conn) => conn.id !== connection.id);
      this.connections.set(peerId, storedConn);
    } else if (storedConn != null) {
      this.connections.delete(peerId);
      this.dispatchEvent(new CustomEvent("peer:disconnect", { detail: connection }));
      this.components.metrics?.onPeerDisconnected(connection.remotePeer);
    }
  }
  getConnections(peerId) {
    if (peerId != null) {
      return this.connections.get(peerId.toString()) ?? [];
    }
    let conns = [];
    for (const c of this.connections.values()) {
      conns = conns.concat(c);
    }
    return conns;
  }
  async openConnection(peerId, options = {}) {
    log$K("dial to %p", peerId);
    const existingConnections = this.getConnections(peerId);
    if (existingConnections.length > 0) {
      log$K("had an existing connection to %p", peerId);
      return existingConnections[0];
    }
    let timeoutController;
    if (options?.signal == null) {
      timeoutController = new timeoutAbortController.TimeoutController(this.dialTimeout);
      options.signal = timeoutController.signal;
      try {
        events.exports.setMaxListeners?.(Infinity, timeoutController.signal);
      } catch {
      }
    }
    try {
      const connection = await this.components.dialer.dial(peerId, options);
      let peerConnections = this.connections.get(peerId.toString());
      if (peerConnections == null) {
        peerConnections = [];
        this.connections.set(peerId.toString(), peerConnections);
      }
      let trackedConnection = false;
      for (const conn of peerConnections) {
        if (conn.id === connection.id) {
          trackedConnection = true;
        }
      }
      if (!trackedConnection) {
        peerConnections.push(connection);
      }
      return connection;
    } finally {
      if (timeoutController != null) {
        timeoutController.clear();
      }
    }
  }
  async closeConnections(peerId) {
    const connections = this.connections.get(peerId.toString()) ?? [];
    await Promise.all(connections.map(async (connection) => {
      return await connection.close();
    }));
  }
  getAll(peerId) {
    if (!isPeerId(peerId)) {
      throw errCode(new Error("peerId must be an instance of peer-id"), codes$1.ERR_INVALID_PARAMETERS);
    }
    const id = peerId.toString();
    const connections = this.connections.get(id);
    if (connections != null) {
      return connections.filter((connection) => connection.stat.status === OPEN);
    }
    return [];
  }
  _onLatencyMeasure(evt) {
    const { detail: summary } = evt;
    this._checkMaxLimit("maxEventLoopDelay", summary.avgMs, 1).catch((err2) => {
      log$K.error(err2);
    });
  }
  async _checkMaxLimit(name2, value2, toPrune = 1) {
    const limit = this.opts[name2];
    log$K.trace("checking limit of %s. current value: %d of %d", name2, value2, limit);
    if (value2 > limit) {
      log$K("%s: limit exceeded: %p, %d/%d, pruning %d connection(s)", this.components.peerId, name2, value2, limit, toPrune);
      await this._pruneConnections(toPrune);
    }
  }
  async _pruneConnections(toPrune) {
    const connections = this.getConnections();
    const peerValues = new PeerMap();
    for (const connection of connections) {
      const remotePeer = connection.remotePeer;
      if (peerValues.has(remotePeer)) {
        continue;
      }
      const tags = await this.components.peerStore.getTags(remotePeer);
      peerValues.set(remotePeer, tags.reduce((acc, curr) => {
        return acc + curr.value;
      }, 0));
    }
    const sortedConnections = connections.sort((a, b2) => {
      const peerAValue = peerValues.get(a.remotePeer) ?? 0;
      const peerBValue = peerValues.get(b2.remotePeer) ?? 0;
      if (peerAValue > peerBValue) {
        return 1;
      }
      if (peerAValue < peerBValue) {
        return -1;
      }
      return 0;
    });
    const toClose = [];
    for (const connection of sortedConnections) {
      log$K("too many connections open - closing a connection to %p", connection.remotePeer);
      toClose.push(connection);
      if (toClose.length === toPrune) {
        break;
      }
    }
    await Promise.all(toClose.map(async (connection) => {
      try {
        await connection.close();
      } catch (err2) {
        log$K.error(err2);
      }
      this.onDisconnect(new CustomEvent("connectionEnd", {
        detail: connection
      }));
    }));
  }
  async acceptIncomingConnection(maConn) {
    const denyConnection = this.deny.some((ma) => {
      return maConn.remoteAddr.toString().startsWith(ma.toString());
    });
    if (denyConnection) {
      log$K("connection from %s refused - connection remote address was in deny list", maConn.remoteAddr);
      return false;
    }
    const allowConnection = this.allow.some((ma) => {
      return maConn.remoteAddr.toString().startsWith(ma.toString());
    });
    if (allowConnection) {
      this.incomingPendingConnections++;
      return true;
    }
    if (this.incomingPendingConnections === this.opts.maxIncomingPendingConnections) {
      log$K("connection from %s refused - incomingPendingConnections exceeded by peer %s", maConn.remoteAddr);
      return false;
    }
    if (maConn.remoteAddr.isThinWaistAddress()) {
      const host = maConn.remoteAddr.nodeAddress().address;
      try {
        await this.inboundConnectionRateLimiter.consume(host, 1);
      } catch {
        log$K("connection from %s refused - inboundConnectionThreshold exceeded by host %s", host, maConn.remoteAddr);
        return false;
      }
    }
    if (this.getConnections().length < this.opts.maxConnections) {
      this.incomingPendingConnections++;
      return true;
    }
    log$K("connection from %s refused - maxConnections exceeded", maConn.remoteAddr);
    return false;
  }
  afterUpgradeInbound() {
    this.incomingPendingConnections--;
  }
}
const log$J = logger$1("libp2p:connection-manager:auto-dialler");
const defaultOptions$3 = {
  enabled: true,
  minConnections: 0,
  autoDialInterval: 1e4
};
class AutoDialler {
  constructor(components, init2) {
    this.components = components;
    this.options = mergeOptions$g.call({ ignoreUndefined: true }, defaultOptions$3, init2);
    this.running = false;
    this._autoDial = this._autoDial.bind(this);
    log$J("options: %j", this.options);
  }
  isStarted() {
    return this.running;
  }
  async start() {
    if (!this.options.enabled) {
      log$J("not enabled");
      return;
    }
    this.running = true;
    void this._autoDial().catch((err2) => {
      log$J.error("could start autodial", err2);
    });
    log$J("started");
  }
  async stop() {
    if (!this.options.enabled) {
      log$J("not enabled");
      return;
    }
    this.running = false;
    if (this.autoDialTimeout != null) {
      this.autoDialTimeout.clear();
    }
    log$J("stopped");
  }
  async _autoDial() {
    if (this.autoDialTimeout != null) {
      this.autoDialTimeout.clear();
    }
    const minConnections = this.options.minConnections;
    if (this.components.connectionManager.getConnections().length >= minConnections) {
      this.autoDialTimeout = retimer_1(this._autoDial, this.options.autoDialInterval);
      return;
    }
    const allPeers = await this.components.peerStore.all();
    const peers = await pipe(
      allPeers.sort(() => Math.random() > 0.5 ? 1 : -1),
      (source2) => filter$1(source2, (peer) => !peer.id.equals(this.components.peerId)),
      (source2) => sort(source2, (a, b2) => {
        if (b2.protocols.length > a.protocols.length) {
          return 1;
        } else if (b2.id.publicKey != null && a.id.publicKey == null) {
          return 1;
        }
        return -1;
      }),
      async (source2) => await all$1(source2)
    );
    for (let i2 = 0; this.running && i2 < peers.length && this.components.connectionManager.getConnections().length < minConnections; i2++) {
      if (!this.running) {
        return;
      }
      const peer = peers[i2];
      if (this.components.connectionManager.getConnections(peer.id).length === 0) {
        log$J("connecting to a peerStore stored peer %p", peer.id);
        try {
          await this.components.connectionManager.openConnection(peer.id);
        } catch (err2) {
          log$J.error("could not connect to peerStore stored peer", err2);
        }
      }
    }
    if (!this.running) {
      return;
    }
    this.autoDialTimeout = retimer_1(this._autoDial, this.options.autoDialInterval);
  }
}
var CircuitRelay;
(function(CircuitRelay2) {
  (function(Status) {
    Status["SUCCESS"] = "SUCCESS";
    Status["HOP_SRC_ADDR_TOO_LONG"] = "HOP_SRC_ADDR_TOO_LONG";
    Status["HOP_DST_ADDR_TOO_LONG"] = "HOP_DST_ADDR_TOO_LONG";
    Status["HOP_SRC_MULTIADDR_INVALID"] = "HOP_SRC_MULTIADDR_INVALID";
    Status["HOP_DST_MULTIADDR_INVALID"] = "HOP_DST_MULTIADDR_INVALID";
    Status["HOP_NO_CONN_TO_DST"] = "HOP_NO_CONN_TO_DST";
    Status["HOP_CANT_DIAL_DST"] = "HOP_CANT_DIAL_DST";
    Status["HOP_CANT_OPEN_DST_STREAM"] = "HOP_CANT_OPEN_DST_STREAM";
    Status["HOP_CANT_SPEAK_RELAY"] = "HOP_CANT_SPEAK_RELAY";
    Status["HOP_CANT_RELAY_TO_SELF"] = "HOP_CANT_RELAY_TO_SELF";
    Status["STOP_SRC_ADDR_TOO_LONG"] = "STOP_SRC_ADDR_TOO_LONG";
    Status["STOP_DST_ADDR_TOO_LONG"] = "STOP_DST_ADDR_TOO_LONG";
    Status["STOP_SRC_MULTIADDR_INVALID"] = "STOP_SRC_MULTIADDR_INVALID";
    Status["STOP_DST_MULTIADDR_INVALID"] = "STOP_DST_MULTIADDR_INVALID";
    Status["STOP_RELAY_REFUSED"] = "STOP_RELAY_REFUSED";
    Status["MALFORMED_MESSAGE"] = "MALFORMED_MESSAGE";
  })(CircuitRelay2.Status || (CircuitRelay2.Status = {}));
  let __StatusValues;
  (function(__StatusValues2) {
    __StatusValues2[__StatusValues2["SUCCESS"] = 100] = "SUCCESS";
    __StatusValues2[__StatusValues2["HOP_SRC_ADDR_TOO_LONG"] = 220] = "HOP_SRC_ADDR_TOO_LONG";
    __StatusValues2[__StatusValues2["HOP_DST_ADDR_TOO_LONG"] = 221] = "HOP_DST_ADDR_TOO_LONG";
    __StatusValues2[__StatusValues2["HOP_SRC_MULTIADDR_INVALID"] = 250] = "HOP_SRC_MULTIADDR_INVALID";
    __StatusValues2[__StatusValues2["HOP_DST_MULTIADDR_INVALID"] = 251] = "HOP_DST_MULTIADDR_INVALID";
    __StatusValues2[__StatusValues2["HOP_NO_CONN_TO_DST"] = 260] = "HOP_NO_CONN_TO_DST";
    __StatusValues2[__StatusValues2["HOP_CANT_DIAL_DST"] = 261] = "HOP_CANT_DIAL_DST";
    __StatusValues2[__StatusValues2["HOP_CANT_OPEN_DST_STREAM"] = 262] = "HOP_CANT_OPEN_DST_STREAM";
    __StatusValues2[__StatusValues2["HOP_CANT_SPEAK_RELAY"] = 270] = "HOP_CANT_SPEAK_RELAY";
    __StatusValues2[__StatusValues2["HOP_CANT_RELAY_TO_SELF"] = 280] = "HOP_CANT_RELAY_TO_SELF";
    __StatusValues2[__StatusValues2["STOP_SRC_ADDR_TOO_LONG"] = 320] = "STOP_SRC_ADDR_TOO_LONG";
    __StatusValues2[__StatusValues2["STOP_DST_ADDR_TOO_LONG"] = 321] = "STOP_DST_ADDR_TOO_LONG";
    __StatusValues2[__StatusValues2["STOP_SRC_MULTIADDR_INVALID"] = 350] = "STOP_SRC_MULTIADDR_INVALID";
    __StatusValues2[__StatusValues2["STOP_DST_MULTIADDR_INVALID"] = 351] = "STOP_DST_MULTIADDR_INVALID";
    __StatusValues2[__StatusValues2["STOP_RELAY_REFUSED"] = 390] = "STOP_RELAY_REFUSED";
    __StatusValues2[__StatusValues2["MALFORMED_MESSAGE"] = 400] = "MALFORMED_MESSAGE";
  })(__StatusValues || (__StatusValues = {}));
  (function(Status) {
    Status.codec = () => {
      return enumeration(__StatusValues);
    };
  })(CircuitRelay2.Status || (CircuitRelay2.Status = {}));
  (function(Type2) {
    Type2["HOP"] = "HOP";
    Type2["STOP"] = "STOP";
    Type2["STATUS"] = "STATUS";
    Type2["CAN_HOP"] = "CAN_HOP";
  })(CircuitRelay2.Type || (CircuitRelay2.Type = {}));
  let __TypeValues;
  (function(__TypeValues2) {
    __TypeValues2[__TypeValues2["HOP"] = 1] = "HOP";
    __TypeValues2[__TypeValues2["STOP"] = 2] = "STOP";
    __TypeValues2[__TypeValues2["STATUS"] = 3] = "STATUS";
    __TypeValues2[__TypeValues2["CAN_HOP"] = 4] = "CAN_HOP";
  })(__TypeValues || (__TypeValues = {}));
  (function(Type2) {
    Type2.codec = () => {
      return enumeration(__TypeValues);
    };
  })(CircuitRelay2.Type || (CircuitRelay2.Type = {}));
  (function(Peer2) {
    let _codec2;
    Peer2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (opts.writeDefaults === true || obj.id != null && obj.id.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.id);
          }
          if (obj.addrs != null) {
            for (const value2 of obj.addrs) {
              w.uint32(18);
              w.bytes(value2);
            }
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length3) => {
          const obj = {
            id: new Uint8Array(0),
            addrs: []
          };
          const end2 = length3 == null ? reader2.len : reader2.pos + length3;
          while (reader2.pos < end2) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.id = reader2.bytes();
                break;
              case 2:
                obj.addrs.push(reader2.bytes());
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Peer2.encode = (obj) => {
      return encodeMessage(obj, Peer2.codec());
    };
    Peer2.decode = (buf2) => {
      return decodeMessage(buf2, Peer2.codec());
    };
  })(CircuitRelay2.Peer || (CircuitRelay2.Peer = {}));
  let _codec;
  CircuitRelay2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.type != null) {
          w.uint32(8);
          CircuitRelay2.Type.codec().encode(obj.type, w);
        }
        if (obj.srcPeer != null) {
          w.uint32(18);
          CircuitRelay2.Peer.codec().encode(obj.srcPeer, w, {
            writeDefaults: false
          });
        }
        if (obj.dstPeer != null) {
          w.uint32(26);
          CircuitRelay2.Peer.codec().encode(obj.dstPeer, w, {
            writeDefaults: false
          });
        }
        if (obj.code != null) {
          w.uint32(32);
          CircuitRelay2.Status.codec().encode(obj.code, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length3) => {
        const obj = {};
        const end2 = length3 == null ? reader2.len : reader2.pos + length3;
        while (reader2.pos < end2) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.type = CircuitRelay2.Type.codec().decode(reader2);
              break;
            case 2:
              obj.srcPeer = CircuitRelay2.Peer.codec().decode(reader2, reader2.uint32());
              break;
            case 3:
              obj.dstPeer = CircuitRelay2.Peer.codec().decode(reader2, reader2.uint32());
              break;
            case 4:
              obj.code = CircuitRelay2.Status.codec().decode(reader2);
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  CircuitRelay2.encode = (obj) => {
    return encodeMessage(obj, CircuitRelay2.codec());
  };
  CircuitRelay2.decode = (buf2) => {
    return decodeMessage(buf2, CircuitRelay2.codec());
  };
})(CircuitRelay || (CircuitRelay = {}));
const log$I = logger$1("libp2p:stream:converter");
function streamToMaConnection(props, options = {}) {
  const { stream: stream2, remoteAddr } = props;
  const { sink: sink2, source: source2 } = stream2;
  const mapSource = async function* () {
    for await (const list of source2) {
      yield* list;
    }
  }();
  const maConn = {
    async sink(source3) {
      if (options.signal != null) {
        source3 = abortableSource(source3, options.signal);
      }
      try {
        await sink2(source3);
        await close();
      } catch (err2) {
        if (err2.type !== "aborted") {
          log$I(err2);
        }
      }
    },
    source: options.signal != null ? abortableSource(mapSource, options.signal) : mapSource,
    remoteAddr,
    timeline: { open: Date.now(), close: void 0 },
    async close() {
      await sink2(async function* () {
        yield new Uint8Array(0);
      }());
      await close();
    }
  };
  async function close() {
    if (maConn.timeline.close == null) {
      maConn.timeline.close = Date.now();
    }
    return await Promise.resolve();
  }
  return maConn;
}
const RELAY_CODEC = "/libp2p/circuit/relay/0.1.0";
function createListener$1(options) {
  const listeningAddrs = /* @__PURE__ */ new Map();
  async function listen(addr) {
    const addrString = addr.toString().split("/p2p-circuit").find((a) => a !== "");
    const ma = multiaddr(addrString);
    const relayPeerStr = ma.getPeerId();
    if (relayPeerStr == null) {
      throw new Error("Could not determine relay peer from multiaddr");
    }
    const relayPeerId = peerIdFromString(relayPeerStr);
    await options.peerStore.addressBook.add(relayPeerId, [ma]);
    const relayConn = await options.connectionManager.openConnection(relayPeerId);
    const relayedAddr = relayConn.remoteAddr.encapsulate("/p2p-circuit");
    listeningAddrs.set(relayConn.remotePeer.toString(), relayedAddr);
    listener.dispatchEvent(new CustomEvent("listening"));
  }
  function getAddrs() {
    const addrs = [];
    for (const addr of listeningAddrs.values()) {
      addrs.push(addr);
    }
    return addrs;
  }
  const listener = Object.assign(new EventEmitter$1(), {
    close: async () => await Promise.resolve(),
    listen,
    getAddrs
  });
  options.connectionManager.addEventListener("peer:disconnect", (evt) => {
    const { detail: connection } = evt;
    const deleted = listeningAddrs.delete(connection.remotePeer.toString());
    if (deleted) {
      listener.dispatchEvent(new CustomEvent("close"));
    }
  });
  return listener;
}
function writeResponse(streamHandler, status) {
  streamHandler.write({
    type: CircuitRelay.Type.STATUS,
    code: status
  });
}
function validateAddrs(msg, streamHandler) {
  try {
    if (msg.dstPeer?.addrs != null) {
      msg.dstPeer.addrs.forEach((addr) => {
        return multiaddr(addr);
      });
    }
  } catch (err2) {
    writeResponse(streamHandler, msg.type === CircuitRelay.Type.HOP ? CircuitRelay.Status.HOP_DST_MULTIADDR_INVALID : CircuitRelay.Status.STOP_DST_MULTIADDR_INVALID);
    throw err2;
  }
  try {
    if (msg.srcPeer?.addrs != null) {
      msg.srcPeer.addrs.forEach((addr) => {
        return multiaddr(addr);
      });
    }
  } catch (err2) {
    writeResponse(streamHandler, msg.type === CircuitRelay.Type.HOP ? CircuitRelay.Status.HOP_SRC_MULTIADDR_INVALID : CircuitRelay.Status.STOP_SRC_MULTIADDR_INVALID);
    throw err2;
  }
}
function handshake(stream2) {
  const writer2 = pushable();
  const source2 = reader$1(stream2.source);
  const sourcePromise = pDefer$1();
  let sinkErr;
  const sinkPromise = stream2.sink(async function* () {
    yield* writer2;
    const source3 = await sourcePromise.promise;
    yield* source3;
  }());
  sinkPromise.catch((err2) => {
    sinkErr = err2;
  });
  const rest = {
    sink: async (source3) => {
      if (sinkErr != null) {
        return await Promise.reject(sinkErr);
      }
      sourcePromise.resolve(source3);
      return await sinkPromise;
    },
    source: source2
  };
  return {
    reader: source2,
    writer: writer2,
    stream: rest,
    rest: () => writer2.end(),
    write: writer2.push,
    read: async () => {
      const res = await source2.next();
      if (res.value != null) {
        return res.value;
      }
    }
  };
}
const log$H = logger$1("libp2p:circuit:stream-handler");
class StreamHandler {
  constructor(options) {
    const { stream: stream2, maxLength = 4096 } = options;
    this.stream = stream2;
    this.shake = handshake(this.stream);
    this.decoder = decode$3.fromReader(this.shake.reader, { maxDataLength: maxLength });
  }
  async read() {
    const msg = await this.decoder.next();
    if (msg.value != null) {
      const value2 = CircuitRelay.decode(msg.value);
      log$H("read message type", value2.type);
      return value2;
    }
    log$H("read received no value, closing stream");
    this.close();
  }
  write(msg) {
    log$H("write message type %s", msg.type);
    this.shake.write(encode$5.single(CircuitRelay.encode(msg)));
  }
  rest() {
    this.shake.rest();
    return this.shake.stream;
  }
  end(msg) {
    this.write(msg);
    this.close();
  }
  close() {
    log$H("closing the stream");
    void this.rest().sink([]).catch((err2) => {
      log$H.error(err2);
    });
  }
}
const log$G = logger$1("libp2p:circuit:stop");
function handleStop(options) {
  const { connection, request: request2, streamHandler } = options;
  try {
    validateAddrs(request2, streamHandler);
  } catch (err2) {
    log$G.error("invalid stop request via peer %p %o", connection.remotePeer, err2);
    return;
  }
  log$G("stop request is valid");
  streamHandler.write({
    type: CircuitRelay.Type.STATUS,
    code: CircuitRelay.Status.SUCCESS
  });
  return streamHandler.rest();
}
async function stop(options) {
  const { connection, request: request2, signal } = options;
  const stream2 = await connection.newStream(RELAY_CODEC, {
    signal
  });
  log$G("starting stop request to %p", connection.remotePeer);
  const streamHandler = new StreamHandler({ stream: stream2 });
  streamHandler.write(request2);
  const response = await streamHandler.read();
  if (response == null) {
    streamHandler.close();
    return;
  }
  if (response.code === CircuitRelay.Status.SUCCESS) {
    log$G("stop request to %p was successful", connection.remotePeer);
    return streamHandler.rest();
  }
  log$G("stop request failed with code %d", response.code);
  streamHandler.close();
}
const log$F = logger$1("libp2p:circuit:hop");
async function handleHop(hopRequest) {
  const { connection, request: request2, streamHandler, circuit, connectionManager } = hopRequest;
  if (!circuit.hopEnabled()) {
    log$F("HOP request received but we are not acting as a relay");
    return streamHandler.end({
      type: CircuitRelay.Type.STATUS,
      code: CircuitRelay.Status.HOP_CANT_SPEAK_RELAY
    });
  }
  try {
    validateAddrs(request2, streamHandler);
  } catch (err2) {
    log$F.error("invalid hop request via peer %p %o", connection.remotePeer, err2);
    return;
  }
  if (request2.dstPeer == null) {
    log$F("HOP request received but we do not receive a dstPeer");
    return;
  }
  const destinationPeer = peerIdFromBytes(request2.dstPeer.id);
  const destinationConnections = connectionManager.getConnections(destinationPeer);
  if (destinationConnections.length === 0 && !circuit.hopActive()) {
    log$F("HOP request received but we are not connected to the destination peer");
    return streamHandler.end({
      type: CircuitRelay.Type.STATUS,
      code: CircuitRelay.Status.HOP_NO_CONN_TO_DST
    });
  }
  if (destinationConnections.length === 0) {
    log$F("did not have connection to remote peer");
    return streamHandler.end({
      type: CircuitRelay.Type.STATUS,
      code: CircuitRelay.Status.HOP_NO_CONN_TO_DST
    });
  }
  const stopRequest = {
    type: CircuitRelay.Type.STOP,
    dstPeer: request2.dstPeer,
    srcPeer: request2.srcPeer
  };
  let destinationStream;
  try {
    log$F("performing STOP request");
    const result = await stop({
      connection: destinationConnections[0],
      request: stopRequest
    });
    if (result == null) {
      throw new Error("Could not stop");
    }
    destinationStream = result;
  } catch (err2) {
    log$F.error(err2);
    return;
  }
  log$F("hop request from %p is valid", connection.remotePeer);
  streamHandler.write({
    type: CircuitRelay.Type.STATUS,
    code: CircuitRelay.Status.SUCCESS
  });
  const sourceStream = streamHandler.rest();
  log$F("creating related connections");
  return await pipe(sourceStream, destinationStream, sourceStream);
}
async function hop(options) {
  const { connection, request: request2, signal } = options;
  const stream2 = await connection.newStream(RELAY_CODEC, {
    signal
  });
  const streamHandler = new StreamHandler({ stream: stream2 });
  streamHandler.write(request2);
  const response = await streamHandler.read();
  if (response == null) {
    throw errCode(new Error("HOP request had no response"), codes$1.ERR_HOP_REQUEST_FAILED);
  }
  if (response.code === CircuitRelay.Status.SUCCESS) {
    log$F("hop request was successful");
    return streamHandler.rest();
  }
  log$F("hop request failed with code %d, closing stream", response.code);
  streamHandler.close();
  throw errCode(new Error(`HOP request failed with code "${response.code ?? "unknown"}"`), codes$1.ERR_HOP_REQUEST_FAILED);
}
async function canHop(options) {
  const { connection, signal } = options;
  const stream2 = await connection.newStream(RELAY_CODEC, {
    signal
  });
  const streamHandler = new StreamHandler({ stream: stream2 });
  streamHandler.write({
    type: CircuitRelay.Type.CAN_HOP
  });
  const response = await streamHandler.read();
  await streamHandler.close();
  if (response == null || response.code !== CircuitRelay.Status.SUCCESS) {
    return false;
  }
  return true;
}
function handleCanHop(options) {
  const { connection, streamHandler, circuit } = options;
  const canHop2 = circuit.hopEnabled();
  log$F("can hop (%s) request from %p", canHop2, connection.remotePeer);
  streamHandler.end({
    type: CircuitRelay.Type.STATUS,
    code: canHop2 ? CircuitRelay.Status.SUCCESS : CircuitRelay.Status.HOP_CANT_SPEAK_RELAY
  });
}
const log$E = logger$1("libp2p:circuit");
class Circuit {
  constructor(components, init2) {
    this._init = init2;
    this.components = components;
    this._started = false;
  }
  isStarted() {
    return this._started;
  }
  async start() {
    if (this._started) {
      return;
    }
    this._started = true;
    await this.components.registrar.handle(RELAY_CODEC, (data) => {
      void this._onProtocol(data).catch((err2) => {
        log$E.error(err2);
      });
    }).catch((err2) => {
      log$E.error(err2);
    });
  }
  async stop() {
    await this.components.registrar.unhandle(RELAY_CODEC);
  }
  hopEnabled() {
    return true;
  }
  hopActive() {
    return true;
  }
  get [symbol$2]() {
    return true;
  }
  get [Symbol.toStringTag]() {
    return "libp2p/circuit-relay-v1";
  }
  async _onProtocol(data) {
    const { connection, stream: stream2 } = data;
    const controller = new timeoutAbortController.TimeoutController(this._init.hop.timeout);
    try {
      events.exports.setMaxListeners?.(Infinity, controller.signal);
    } catch {
    }
    try {
      const source2 = abortableDuplex(stream2, controller.signal);
      const streamHandler = new StreamHandler({
        stream: {
          ...stream2,
          ...source2
        }
      });
      const request2 = await streamHandler.read();
      if (request2 == null) {
        log$E("request was invalid, could not read from stream");
        streamHandler.write({
          type: CircuitRelay.Type.STATUS,
          code: CircuitRelay.Status.MALFORMED_MESSAGE
        });
        streamHandler.close();
        return;
      }
      let virtualConnection;
      switch (request2.type) {
        case CircuitRelay.Type.CAN_HOP: {
          log$E("received CAN_HOP request from %p", connection.remotePeer);
          await handleCanHop({ circuit: this, connection, streamHandler });
          break;
        }
        case CircuitRelay.Type.HOP: {
          log$E("received HOP request from %p", connection.remotePeer);
          await handleHop({
            connection,
            request: request2,
            streamHandler,
            circuit: this,
            connectionManager: this.components.connectionManager
          });
          break;
        }
        case CircuitRelay.Type.STOP: {
          log$E("received STOP request from %p", connection.remotePeer);
          virtualConnection = await handleStop({
            connection,
            request: request2,
            streamHandler
          });
          break;
        }
        default: {
          log$E("Request of type %s not supported", request2.type);
          streamHandler.write({
            type: CircuitRelay.Type.STATUS,
            code: CircuitRelay.Status.MALFORMED_MESSAGE
          });
          streamHandler.close();
          return;
        }
      }
      if (virtualConnection != null) {
        const remoteAddr = connection.remoteAddr.encapsulate("/p2p-circuit").encapsulate(multiaddr(request2.dstPeer?.addrs[0]));
        const localAddr = multiaddr(request2.srcPeer?.addrs[0]);
        const maConn = streamToMaConnection({
          stream: virtualConnection,
          remoteAddr,
          localAddr
        });
        const type = request2.type === CircuitRelay.Type.HOP ? "relay" : "inbound";
        log$E("new %s connection %s", type, maConn.remoteAddr);
        const conn = await this.components.upgrader.upgradeInbound(maConn);
        log$E("%s connection %s upgraded", type, maConn.remoteAddr);
        if (this.handler != null) {
          this.handler(conn);
        }
      }
    } finally {
      controller.clear();
    }
  }
  async dial(ma, options = {}) {
    const addrs = ma.toString().split("/p2p-circuit");
    const relayAddr = multiaddr(addrs[0]);
    const destinationAddr = multiaddr(addrs[addrs.length - 1]);
    const relayId = relayAddr.getPeerId();
    const destinationId = destinationAddr.getPeerId();
    if (relayId == null || destinationId == null) {
      const errMsg = "Circuit relay dial failed as addresses did not have peer id";
      log$E.error(errMsg);
      throw errCode(new Error(errMsg), codes$1.ERR_RELAYED_DIAL);
    }
    const relayPeer = peerIdFromString(relayId);
    const destinationPeer = peerIdFromString(destinationId);
    let disconnectOnFailure = false;
    const relayConnections = this.components.connectionManager.getConnections(relayPeer);
    let relayConnection = relayConnections[0];
    if (relayConnection == null) {
      await this.components.peerStore.addressBook.add(relayPeer, [relayAddr]);
      relayConnection = await this.components.connectionManager.openConnection(relayPeer, options);
      disconnectOnFailure = true;
    }
    try {
      const virtualConnection = await hop({
        ...options,
        connection: relayConnection,
        request: {
          type: CircuitRelay.Type.HOP,
          srcPeer: {
            id: this.components.peerId.toBytes(),
            addrs: this.components.addressManager.getAddresses().map((addr) => addr.bytes)
          },
          dstPeer: {
            id: destinationPeer.toBytes(),
            addrs: [multiaddr(destinationAddr).bytes]
          }
        }
      });
      const localAddr = relayAddr.encapsulate(`/p2p-circuit/p2p/${this.components.peerId.toString()}`);
      const maConn = streamToMaConnection({
        stream: virtualConnection,
        remoteAddr: ma,
        localAddr
      });
      log$E("new outbound connection %s", maConn.remoteAddr);
      return await this.components.upgrader.upgradeOutbound(maConn);
    } catch (err2) {
      log$E.error("Circuit relay dial failed", err2);
      disconnectOnFailure && await relayConnection.close();
      throw err2;
    }
  }
  createListener(options) {
    this.handler = options.handler;
    return createListener$1({
      connectionManager: this.components.connectionManager,
      peerStore: this.components.peerStore
    });
  }
  filter(multiaddrs) {
    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
    return multiaddrs.filter((ma) => {
      return Circuit$1.matches(ma);
    });
  }
}
async function namespaceToCid(namespace2) {
  const bytes2 = new TextEncoder().encode(namespace2);
  const hash2 = await sha256$3.digest(bytes2);
  return CID.createV0(hash2);
}
const minute$1 = 60 * 1e3;
const ADVERTISE_BOOT_DELAY = 15 * minute$1;
const ADVERTISE_TTL = 30 * minute$1;
const CIRCUIT_PROTO_CODE = 290;
const HOP_METADATA_KEY = "hop_relay";
const HOP_METADATA_VALUE = "true";
const RELAY_RENDEZVOUS_NS = "/libp2p/relay";
var netmask = {};
var Netmask_1;
(function() {
  var Netmask, atob, chr, chr0, chrA, chra, ip2long, long2ip;
  long2ip = function(long) {
    var a, b2, c, d;
    a = (long & 255 << 24) >>> 24;
    b2 = (long & 255 << 16) >>> 16;
    c = (long & 255 << 8) >>> 8;
    d = long & 255;
    return [a, b2, c, d].join(".");
  };
  ip2long = function(ip2) {
    var b2, c, i2, j, n, ref;
    b2 = [];
    for (i2 = j = 0; j <= 3; i2 = ++j) {
      if (ip2.length === 0) {
        break;
      }
      if (i2 > 0) {
        if (ip2[0] !== ".") {
          throw new Error("Invalid IP");
        }
        ip2 = ip2.substring(1);
      }
      ref = atob(ip2), n = ref[0], c = ref[1];
      ip2 = ip2.substring(c);
      b2.push(n);
    }
    if (ip2.length !== 0) {
      throw new Error("Invalid IP");
    }
    switch (b2.length) {
      case 1:
        if (b2[0] > 4294967295) {
          throw new Error("Invalid IP");
        }
        return b2[0] >>> 0;
      case 2:
        if (b2[0] > 255 || b2[1] > 16777215) {
          throw new Error("Invalid IP");
        }
        return (b2[0] << 24 | b2[1]) >>> 0;
      case 3:
        if (b2[0] > 255 || b2[1] > 255 || b2[2] > 65535) {
          throw new Error("Invalid IP");
        }
        return (b2[0] << 24 | b2[1] << 16 | b2[2]) >>> 0;
      case 4:
        if (b2[0] > 255 || b2[1] > 255 || b2[2] > 255 || b2[3] > 255) {
          throw new Error("Invalid IP");
        }
        return (b2[0] << 24 | b2[1] << 16 | b2[2] << 8 | b2[3]) >>> 0;
      default:
        throw new Error("Invalid IP");
    }
  };
  chr = function(b2) {
    return b2.charCodeAt(0);
  };
  chr0 = chr("0");
  chra = chr("a");
  chrA = chr("A");
  atob = function(s2) {
    var base3, dmax, i2, n, start;
    n = 0;
    base3 = 10;
    dmax = "9";
    i2 = 0;
    if (s2.length > 1 && s2[i2] === "0") {
      if (s2[i2 + 1] === "x" || s2[i2 + 1] === "X") {
        i2 += 2;
        base3 = 16;
      } else if ("0" <= s2[i2 + 1] && s2[i2 + 1] <= "9") {
        i2++;
        base3 = 8;
        dmax = "7";
      }
    }
    start = i2;
    while (i2 < s2.length) {
      if ("0" <= s2[i2] && s2[i2] <= dmax) {
        n = n * base3 + (chr(s2[i2]) - chr0) >>> 0;
      } else if (base3 === 16) {
        if ("a" <= s2[i2] && s2[i2] <= "f") {
          n = n * base3 + (10 + chr(s2[i2]) - chra) >>> 0;
        } else if ("A" <= s2[i2] && s2[i2] <= "F") {
          n = n * base3 + (10 + chr(s2[i2]) - chrA) >>> 0;
        } else {
          break;
        }
      } else {
        break;
      }
      if (n > 4294967295) {
        throw new Error("too large");
      }
      i2++;
    }
    if (i2 === start) {
      throw new Error("empty octet");
    }
    return [n, i2];
  };
  Netmask = function() {
    function Netmask2(net, mask) {
      var i2, j, ref;
      if (typeof net !== "string") {
        throw new Error("Missing `net' parameter");
      }
      if (!mask) {
        ref = net.split("/", 2), net = ref[0], mask = ref[1];
      }
      if (!mask) {
        mask = 32;
      }
      if (typeof mask === "string" && mask.indexOf(".") > -1) {
        try {
          this.maskLong = ip2long(mask);
        } catch (error1) {
          throw new Error("Invalid mask: " + mask);
        }
        for (i2 = j = 32; j >= 0; i2 = --j) {
          if (this.maskLong === 4294967295 << 32 - i2 >>> 0) {
            this.bitmask = i2;
            break;
          }
        }
      } else if (mask || mask === 0) {
        this.bitmask = parseInt(mask, 10);
        this.maskLong = 0;
        if (this.bitmask > 0) {
          this.maskLong = 4294967295 << 32 - this.bitmask >>> 0;
        }
      } else {
        throw new Error("Invalid mask: empty");
      }
      try {
        this.netLong = (ip2long(net) & this.maskLong) >>> 0;
      } catch (error1) {
        throw new Error("Invalid net address: " + net);
      }
      if (!(this.bitmask <= 32)) {
        throw new Error("Invalid mask for ip4: " + mask);
      }
      this.size = Math.pow(2, 32 - this.bitmask);
      this.base = long2ip(this.netLong);
      this.mask = long2ip(this.maskLong);
      this.hostmask = long2ip(~this.maskLong);
      this.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;
      this.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);
      this.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;
    }
    Netmask2.prototype.contains = function(ip2) {
      if (typeof ip2 === "string" && (ip2.indexOf("/") > 0 || ip2.split(".").length !== 4)) {
        ip2 = new Netmask2(ip2);
      }
      if (ip2 instanceof Netmask2) {
        return this.contains(ip2.base) && this.contains(ip2.broadcast || ip2.last);
      } else {
        return (ip2long(ip2) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;
      }
    };
    Netmask2.prototype.next = function(count) {
      if (count == null) {
        count = 1;
      }
      return new Netmask2(long2ip(this.netLong + this.size * count), this.mask);
    };
    Netmask2.prototype.forEach = function(fn) {
      var index, lastLong, long;
      long = ip2long(this.first);
      lastLong = ip2long(this.last);
      index = 0;
      while (long <= lastLong) {
        fn(long2ip(long), long, index);
        index++;
        long++;
      }
    };
    Netmask2.prototype.toString = function() {
      return this.base + "/" + this.bitmask;
    };
    return Netmask2;
  }();
  netmask.ip2long = ip2long;
  netmask.long2ip = long2ip;
  Netmask_1 = netmask.Netmask = Netmask;
}).call(commonjsGlobal);
const word$1 = "[a-fA-F\\d:]";
const boundry = (options) => options && options.includeBoundaries ? `(?:(?<=\\s|^)(?=${word$1})|(?<=${word$1})(?=\\s|$))` : "";
const v4$1 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
const v6segment = "[a-fA-F\\d]{1,4}";
const v6$1 = `
(?:
(?:${v6segment}:){7}(?:${v6segment}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6segment}:){6}(?:${v4$1}|:${v6segment}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6segment}:){5}(?::${v4$1}|(?::${v6segment}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6segment}:){4}(?:(?::${v6segment}){0,1}:${v4$1}|(?::${v6segment}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6segment}:){3}(?:(?::${v6segment}){0,2}:${v4$1}|(?::${v6segment}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6segment}:){2}(?:(?::${v6segment}){0,3}:${v4$1}|(?::${v6segment}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6segment}:){1}(?:(?::${v6segment}){0,4}:${v4$1}|(?::${v6segment}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6segment}){0,5}:${v4$1}|(?::${v6segment}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
const v46Exact$1 = new RegExp(`(?:^${v4$1}$)|(?:^${v6$1}$)`);
const v4exact$1 = new RegExp(`^${v4$1}$`);
const v6exact$1 = new RegExp(`^${v6$1}$`);
const ipRegex$2 = (options) => options && options.exact ? v46Exact$1 : new RegExp(`(?:${boundry(options)}${v4$1}${boundry(options)})|(?:${boundry(options)}${v6$1}${boundry(options)})`, "g");
ipRegex$2.v4 = (options) => options && options.exact ? v4exact$1 : new RegExp(`${boundry(options)}${v4$1}${boundry(options)}`, "g");
ipRegex$2.v6 = (options) => options && options.exact ? v6exact$1 : new RegExp(`${boundry(options)}${v6$1}${boundry(options)}`, "g");
var ipaddr$1 = { exports: {} };
(function(module) {
  (function(root) {
    const ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
    const ipv4Regexes = {
      fourOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
      threeOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
      twoOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}$`, "i"),
      longValue: new RegExp(`^${ipv4Part}$`, "i")
    };
    const octalRegex = new RegExp(`^0[0-7]+$`, "i");
    const hexRegex = new RegExp(`^0x[a-f0-9]+$`, "i");
    const zoneIndex = "%[0-9a-z]{1,}";
    const ipv6Part = "(?:[0-9a-f]+::?)+";
    const ipv6Regexes = {
      zoneIndex: new RegExp(zoneIndex, "i"),
      "native": new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, "i"),
      deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?)$`, "i"),
      transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?$`, "i")
    };
    function expandIPv6(string2, parts2) {
      if (string2.indexOf("::") !== string2.lastIndexOf("::")) {
        return null;
      }
      let colonCount = 0;
      let lastColon = -1;
      let zoneId = (string2.match(ipv6Regexes.zoneIndex) || [])[0];
      let replacement, replacementCount;
      if (zoneId) {
        zoneId = zoneId.substring(1);
        string2 = string2.replace(/%.+$/, "");
      }
      while ((lastColon = string2.indexOf(":", lastColon + 1)) >= 0) {
        colonCount++;
      }
      if (string2.substr(0, 2) === "::") {
        colonCount--;
      }
      if (string2.substr(-2, 2) === "::") {
        colonCount--;
      }
      if (colonCount > parts2) {
        return null;
      }
      replacementCount = parts2 - colonCount;
      replacement = ":";
      while (replacementCount--) {
        replacement += "0:";
      }
      string2 = string2.replace("::", replacement);
      if (string2[0] === ":") {
        string2 = string2.slice(1);
      }
      if (string2[string2.length - 1] === ":") {
        string2 = string2.slice(0, -1);
      }
      parts2 = function() {
        const ref = string2.split(":");
        const results = [];
        for (let i2 = 0; i2 < ref.length; i2++) {
          results.push(parseInt(ref[i2], 16));
        }
        return results;
      }();
      return {
        parts: parts2,
        zoneId
      };
    }
    function matchCIDR(first2, second2, partSize, cidrBits) {
      if (first2.length !== second2.length) {
        throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
      }
      let part = 0;
      let shift2;
      while (cidrBits > 0) {
        shift2 = partSize - cidrBits;
        if (shift2 < 0) {
          shift2 = 0;
        }
        if (first2[part] >> shift2 !== second2[part] >> shift2) {
          return false;
        }
        cidrBits -= partSize;
        part += 1;
      }
      return true;
    }
    function parseIntAuto(string2) {
      if (hexRegex.test(string2)) {
        return parseInt(string2, 16);
      }
      if (string2[0] === "0" && !isNaN(parseInt(string2[1], 10))) {
        if (octalRegex.test(string2)) {
          return parseInt(string2, 8);
        }
        throw new Error(`ipaddr: cannot parse ${string2} as octal`);
      }
      return parseInt(string2, 10);
    }
    function padPart(part, length3) {
      while (part.length < length3) {
        part = `0${part}`;
      }
      return part;
    }
    const ipaddr2 = {};
    ipaddr2.IPv4 = function() {
      function IPv4(octets) {
        if (octets.length !== 4) {
          throw new Error("ipaddr: ipv4 octet count should be 4");
        }
        let i2, octet;
        for (i2 = 0; i2 < octets.length; i2++) {
          octet = octets[i2];
          if (!(0 <= octet && octet <= 255)) {
            throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
          }
        }
        this.octets = octets;
      }
      IPv4.prototype.SpecialRanges = {
        unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
        broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
        multicast: [[new IPv4([224, 0, 0, 0]), 4]],
        linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
        loopback: [[new IPv4([127, 0, 0, 0]), 8]],
        carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
        "private": [
          [new IPv4([10, 0, 0, 0]), 8],
          [new IPv4([172, 16, 0, 0]), 12],
          [new IPv4([192, 168, 0, 0]), 16]
        ],
        reserved: [
          [new IPv4([192, 0, 0, 0]), 24],
          [new IPv4([192, 0, 2, 0]), 24],
          [new IPv4([192, 88, 99, 0]), 24],
          [new IPv4([198, 51, 100, 0]), 24],
          [new IPv4([203, 0, 113, 0]), 24],
          [new IPv4([240, 0, 0, 0]), 4]
        ]
      };
      IPv4.prototype.kind = function() {
        return "ipv4";
      };
      IPv4.prototype.match = function(other, cidrRange) {
        let ref;
        if (cidrRange === void 0) {
          ref = other;
          other = ref[0];
          cidrRange = ref[1];
        }
        if (other.kind() !== "ipv4") {
          throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
        }
        return matchCIDR(this.octets, other.octets, 8, cidrRange);
      };
      IPv4.prototype.prefixLengthFromSubnetMask = function() {
        let cidr = 0;
        let stop2 = false;
        const zerotable = {
          0: 8,
          128: 7,
          192: 6,
          224: 5,
          240: 4,
          248: 3,
          252: 2,
          254: 1,
          255: 0
        };
        let i2, octet, zeros;
        for (i2 = 3; i2 >= 0; i2 -= 1) {
          octet = this.octets[i2];
          if (octet in zerotable) {
            zeros = zerotable[octet];
            if (stop2 && zeros !== 0) {
              return null;
            }
            if (zeros !== 8) {
              stop2 = true;
            }
            cidr += zeros;
          } else {
            return null;
          }
        }
        return 32 - cidr;
      };
      IPv4.prototype.range = function() {
        return ipaddr2.subnetMatch(this, this.SpecialRanges);
      };
      IPv4.prototype.toByteArray = function() {
        return this.octets.slice(0);
      };
      IPv4.prototype.toIPv4MappedAddress = function() {
        return ipaddr2.IPv6.parse(`::ffff:${this.toString()}`);
      };
      IPv4.prototype.toNormalizedString = function() {
        return this.toString();
      };
      IPv4.prototype.toString = function() {
        return this.octets.join(".");
      };
      return IPv4;
    }();
    ipaddr2.IPv4.broadcastAddressFromCIDR = function(string2) {
      try {
        const cidr = this.parseCIDR(string2);
        const ipInterfaceOctets = cidr[0].toByteArray();
        const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        const octets = [];
        let i2 = 0;
        while (i2 < 4) {
          octets.push(parseInt(ipInterfaceOctets[i2], 10) | parseInt(subnetMaskOctets[i2], 10) ^ 255);
          i2++;
        }
        return new this(octets);
      } catch (e) {
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
    };
    ipaddr2.IPv4.isIPv4 = function(string2) {
      return this.parser(string2) !== null;
    };
    ipaddr2.IPv4.isValid = function(string2) {
      try {
        new this(this.parser(string2));
        return true;
      } catch (e) {
        return false;
      }
    };
    ipaddr2.IPv4.isValidFourPartDecimal = function(string2) {
      if (ipaddr2.IPv4.isValid(string2) && string2.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
        return true;
      } else {
        return false;
      }
    };
    ipaddr2.IPv4.networkAddressFromCIDR = function(string2) {
      let cidr, i2, ipInterfaceOctets, octets, subnetMaskOctets;
      try {
        cidr = this.parseCIDR(string2);
        ipInterfaceOctets = cidr[0].toByteArray();
        subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        octets = [];
        i2 = 0;
        while (i2 < 4) {
          octets.push(parseInt(ipInterfaceOctets[i2], 10) & parseInt(subnetMaskOctets[i2], 10));
          i2++;
        }
        return new this(octets);
      } catch (e) {
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
    };
    ipaddr2.IPv4.parse = function(string2) {
      const parts2 = this.parser(string2);
      if (parts2 === null) {
        throw new Error("ipaddr: string is not formatted like an IPv4 Address");
      }
      return new this(parts2);
    };
    ipaddr2.IPv4.parseCIDR = function(string2) {
      let match;
      if (match = string2.match(/^(.+)\/(\d+)$/)) {
        const maskLength = parseInt(match[2]);
        if (maskLength >= 0 && maskLength <= 32) {
          const parsed = [this.parse(match[1]), maskLength];
          Object.defineProperty(parsed, "toString", {
            value: function() {
              return this.join("/");
            }
          });
          return parsed;
        }
      }
      throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
    };
    ipaddr2.IPv4.parser = function(string2) {
      let match, part, value2;
      if (match = string2.match(ipv4Regexes.fourOctet)) {
        return function() {
          const ref = match.slice(1, 6);
          const results = [];
          for (let i2 = 0; i2 < ref.length; i2++) {
            part = ref[i2];
            results.push(parseIntAuto(part));
          }
          return results;
        }();
      } else if (match = string2.match(ipv4Regexes.longValue)) {
        value2 = parseIntAuto(match[1]);
        if (value2 > 4294967295 || value2 < 0) {
          throw new Error("ipaddr: address outside defined range");
        }
        return function() {
          const results = [];
          let shift2;
          for (shift2 = 0; shift2 <= 24; shift2 += 8) {
            results.push(value2 >> shift2 & 255);
          }
          return results;
        }().reverse();
      } else if (match = string2.match(ipv4Regexes.twoOctet)) {
        return function() {
          const ref = match.slice(1, 4);
          const results = [];
          value2 = parseIntAuto(ref[1]);
          if (value2 > 16777215 || value2 < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          results.push(parseIntAuto(ref[0]));
          results.push(value2 >> 16 & 255);
          results.push(value2 >> 8 & 255);
          results.push(value2 & 255);
          return results;
        }();
      } else if (match = string2.match(ipv4Regexes.threeOctet)) {
        return function() {
          const ref = match.slice(1, 5);
          const results = [];
          value2 = parseIntAuto(ref[2]);
          if (value2 > 65535 || value2 < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          results.push(parseIntAuto(ref[0]));
          results.push(parseIntAuto(ref[1]));
          results.push(value2 >> 8 & 255);
          results.push(value2 & 255);
          return results;
        }();
      } else {
        return null;
      }
    };
    ipaddr2.IPv4.subnetMaskFromPrefixLength = function(prefix) {
      prefix = parseInt(prefix);
      if (prefix < 0 || prefix > 32) {
        throw new Error("ipaddr: invalid IPv4 prefix length");
      }
      const octets = [0, 0, 0, 0];
      let j = 0;
      const filledOctetCount = Math.floor(prefix / 8);
      while (j < filledOctetCount) {
        octets[j] = 255;
        j++;
      }
      if (filledOctetCount < 4) {
        octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
      }
      return new this(octets);
    };
    ipaddr2.IPv6 = function() {
      function IPv6(parts2, zoneId) {
        let i2, part;
        if (parts2.length === 16) {
          this.parts = [];
          for (i2 = 0; i2 <= 14; i2 += 2) {
            this.parts.push(parts2[i2] << 8 | parts2[i2 + 1]);
          }
        } else if (parts2.length === 8) {
          this.parts = parts2;
        } else {
          throw new Error("ipaddr: ipv6 part count should be 8 or 16");
        }
        for (i2 = 0; i2 < this.parts.length; i2++) {
          part = this.parts[i2];
          if (!(0 <= part && part <= 65535)) {
            throw new Error("ipaddr: ipv6 part should fit in 16 bits");
          }
        }
        if (zoneId) {
          this.zoneId = zoneId;
        }
      }
      IPv6.prototype.SpecialRanges = {
        unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
        linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
        multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
        loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
        uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
        ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
        rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
        rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
        "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
        teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
        reserved: [[new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]]
      };
      IPv6.prototype.isIPv4MappedAddress = function() {
        return this.range() === "ipv4Mapped";
      };
      IPv6.prototype.kind = function() {
        return "ipv6";
      };
      IPv6.prototype.match = function(other, cidrRange) {
        let ref;
        if (cidrRange === void 0) {
          ref = other;
          other = ref[0];
          cidrRange = ref[1];
        }
        if (other.kind() !== "ipv6") {
          throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
        }
        return matchCIDR(this.parts, other.parts, 16, cidrRange);
      };
      IPv6.prototype.prefixLengthFromSubnetMask = function() {
        let cidr = 0;
        let stop2 = false;
        const zerotable = {
          0: 16,
          32768: 15,
          49152: 14,
          57344: 13,
          61440: 12,
          63488: 11,
          64512: 10,
          65024: 9,
          65280: 8,
          65408: 7,
          65472: 6,
          65504: 5,
          65520: 4,
          65528: 3,
          65532: 2,
          65534: 1,
          65535: 0
        };
        let part, zeros;
        for (let i2 = 7; i2 >= 0; i2 -= 1) {
          part = this.parts[i2];
          if (part in zerotable) {
            zeros = zerotable[part];
            if (stop2 && zeros !== 0) {
              return null;
            }
            if (zeros !== 16) {
              stop2 = true;
            }
            cidr += zeros;
          } else {
            return null;
          }
        }
        return 128 - cidr;
      };
      IPv6.prototype.range = function() {
        return ipaddr2.subnetMatch(this, this.SpecialRanges);
      };
      IPv6.prototype.toByteArray = function() {
        let part;
        const bytes2 = [];
        const ref = this.parts;
        for (let i2 = 0; i2 < ref.length; i2++) {
          part = ref[i2];
          bytes2.push(part >> 8);
          bytes2.push(part & 255);
        }
        return bytes2;
      };
      IPv6.prototype.toFixedLengthString = function() {
        const addr = function() {
          const results = [];
          for (let i2 = 0; i2 < this.parts.length; i2++) {
            results.push(padPart(this.parts[i2].toString(16), 4));
          }
          return results;
        }.call(this).join(":");
        let suffix = "";
        if (this.zoneId) {
          suffix = `%${this.zoneId}`;
        }
        return addr + suffix;
      };
      IPv6.prototype.toIPv4Address = function() {
        if (!this.isIPv4MappedAddress()) {
          throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
        }
        const ref = this.parts.slice(-2);
        const high = ref[0];
        const low = ref[1];
        return new ipaddr2.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
      };
      IPv6.prototype.toNormalizedString = function() {
        const addr = function() {
          const results = [];
          for (let i2 = 0; i2 < this.parts.length; i2++) {
            results.push(this.parts[i2].toString(16));
          }
          return results;
        }.call(this).join(":");
        let suffix = "";
        if (this.zoneId) {
          suffix = `%${this.zoneId}`;
        }
        return addr + suffix;
      };
      IPv6.prototype.toRFC5952String = function() {
        const regex = /((^|:)(0(:|$)){2,})/g;
        const string2 = this.toNormalizedString();
        let bestMatchIndex = 0;
        let bestMatchLength = -1;
        let match;
        while (match = regex.exec(string2)) {
          if (match[0].length > bestMatchLength) {
            bestMatchIndex = match.index;
            bestMatchLength = match[0].length;
          }
        }
        if (bestMatchLength < 0) {
          return string2;
        }
        return `${string2.substring(0, bestMatchIndex)}::${string2.substring(bestMatchIndex + bestMatchLength)}`;
      };
      IPv6.prototype.toString = function() {
        return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
      };
      return IPv6;
    }();
    ipaddr2.IPv6.broadcastAddressFromCIDR = function(string2) {
      try {
        const cidr = this.parseCIDR(string2);
        const ipInterfaceOctets = cidr[0].toByteArray();
        const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        const octets = [];
        let i2 = 0;
        while (i2 < 16) {
          octets.push(parseInt(ipInterfaceOctets[i2], 10) | parseInt(subnetMaskOctets[i2], 10) ^ 255);
          i2++;
        }
        return new this(octets);
      } catch (e) {
        throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
      }
    };
    ipaddr2.IPv6.isIPv6 = function(string2) {
      return this.parser(string2) !== null;
    };
    ipaddr2.IPv6.isValid = function(string2) {
      if (typeof string2 === "string" && string2.indexOf(":") === -1) {
        return false;
      }
      try {
        const addr = this.parser(string2);
        new this(addr.parts, addr.zoneId);
        return true;
      } catch (e) {
        return false;
      }
    };
    ipaddr2.IPv6.networkAddressFromCIDR = function(string2) {
      let cidr, i2, ipInterfaceOctets, octets, subnetMaskOctets;
      try {
        cidr = this.parseCIDR(string2);
        ipInterfaceOctets = cidr[0].toByteArray();
        subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        octets = [];
        i2 = 0;
        while (i2 < 16) {
          octets.push(parseInt(ipInterfaceOctets[i2], 10) & parseInt(subnetMaskOctets[i2], 10));
          i2++;
        }
        return new this(octets);
      } catch (e) {
        throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
      }
    };
    ipaddr2.IPv6.parse = function(string2) {
      const addr = this.parser(string2);
      if (addr.parts === null) {
        throw new Error("ipaddr: string is not formatted like an IPv6 Address");
      }
      return new this(addr.parts, addr.zoneId);
    };
    ipaddr2.IPv6.parseCIDR = function(string2) {
      let maskLength, match, parsed;
      if (match = string2.match(/^(.+)\/(\d+)$/)) {
        maskLength = parseInt(match[2]);
        if (maskLength >= 0 && maskLength <= 128) {
          parsed = [this.parse(match[1]), maskLength];
          Object.defineProperty(parsed, "toString", {
            value: function() {
              return this.join("/");
            }
          });
          return parsed;
        }
      }
      throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
    };
    ipaddr2.IPv6.parser = function(string2) {
      let addr, i2, match, octet, octets, zoneId;
      if (match = string2.match(ipv6Regexes.deprecatedTransitional)) {
        return this.parser(`::ffff:${match[1]}`);
      }
      if (ipv6Regexes.native.test(string2)) {
        return expandIPv6(string2, 8);
      }
      if (match = string2.match(ipv6Regexes.transitional)) {
        zoneId = match[6] || "";
        addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
        if (addr.parts) {
          octets = [
            parseInt(match[2]),
            parseInt(match[3]),
            parseInt(match[4]),
            parseInt(match[5])
          ];
          for (i2 = 0; i2 < octets.length; i2++) {
            octet = octets[i2];
            if (!(0 <= octet && octet <= 255)) {
              return null;
            }
          }
          addr.parts.push(octets[0] << 8 | octets[1]);
          addr.parts.push(octets[2] << 8 | octets[3]);
          return {
            parts: addr.parts,
            zoneId: addr.zoneId
          };
        }
      }
      return null;
    };
    ipaddr2.IPv6.subnetMaskFromPrefixLength = function(prefix) {
      prefix = parseInt(prefix);
      if (prefix < 0 || prefix > 128) {
        throw new Error("ipaddr: invalid IPv6 prefix length");
      }
      const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      let j = 0;
      const filledOctetCount = Math.floor(prefix / 8);
      while (j < filledOctetCount) {
        octets[j] = 255;
        j++;
      }
      if (filledOctetCount < 16) {
        octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
      }
      return new this(octets);
    };
    ipaddr2.fromByteArray = function(bytes2) {
      const length3 = bytes2.length;
      if (length3 === 4) {
        return new ipaddr2.IPv4(bytes2);
      } else if (length3 === 16) {
        return new ipaddr2.IPv6(bytes2);
      } else {
        throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
      }
    };
    ipaddr2.isValid = function(string2) {
      return ipaddr2.IPv6.isValid(string2) || ipaddr2.IPv4.isValid(string2);
    };
    ipaddr2.parse = function(string2) {
      if (ipaddr2.IPv6.isValid(string2)) {
        return ipaddr2.IPv6.parse(string2);
      } else if (ipaddr2.IPv4.isValid(string2)) {
        return ipaddr2.IPv4.parse(string2);
      } else {
        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
      }
    };
    ipaddr2.parseCIDR = function(string2) {
      try {
        return ipaddr2.IPv6.parseCIDR(string2);
      } catch (e) {
        try {
          return ipaddr2.IPv4.parseCIDR(string2);
        } catch (e2) {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
        }
      }
    };
    ipaddr2.process = function(string2) {
      const addr = this.parse(string2);
      if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
        return addr.toIPv4Address();
      } else {
        return addr;
      }
    };
    ipaddr2.subnetMatch = function(address, rangeList, defaultName) {
      let i2, rangeName, rangeSubnets, subnet;
      if (defaultName === void 0 || defaultName === null) {
        defaultName = "unicast";
      }
      for (rangeName in rangeList) {
        if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {
          rangeSubnets = rangeList[rangeName];
          if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
            rangeSubnets = [rangeSubnets];
          }
          for (i2 = 0; i2 < rangeSubnets.length; i2++) {
            subnet = rangeSubnets[i2];
            if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {
              return rangeName;
            }
          }
        }
      }
      return defaultName;
    };
    if (module.exports) {
      module.exports = ipaddr2;
    } else {
      root.ipaddr = ipaddr2;
    }
  })(commonjsGlobal);
})(ipaddr$1);
const ipaddr = ipaddr$1.exports;
const { isValid: is_valid, parse } = ipaddr;
const PRIVATE_IP_RANGES$1 = [
  "0.0.0.0/8",
  "10.0.0.0/8",
  "100.64.0.0/10",
  "127.0.0.0/8",
  "169.254.0.0/16",
  "172.16.0.0/12",
  "192.0.0.0/24",
  "192.0.0.0/29",
  "192.0.0.8/32",
  "192.0.0.9/32",
  "192.0.0.10/32",
  "192.0.0.170/32",
  "192.0.0.171/32",
  "192.0.2.0/24",
  "192.31.196.0/24",
  "192.52.193.0/24",
  "192.88.99.0/24",
  "192.168.0.0/16",
  "192.175.48.0/24",
  "198.18.0.0/15",
  "198.51.100.0/24",
  "203.0.113.0/24",
  "240.0.0.0/4",
  "255.255.255.255/32"
];
const NETMASK_RANGES$1 = PRIVATE_IP_RANGES$1.map((ip_range) => new Netmask_1(ip_range));
function ipv4_check$1(ip_addr) {
  for (let r of NETMASK_RANGES$1) {
    if (r.contains(ip_addr))
      return true;
  }
  return false;
}
function ipv6_check$1(ip_addr) {
  return /^::$/.test(ip_addr) || /^::1$/.test(ip_addr) || /^::f{4}:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^::f{4}:0.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(ip_addr) || /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(ip_addr) || /^ff([0-9a-fA-F]{2,2}):/i.test(ip_addr);
}
const is_ip_private = (ip2) => {
  if (is_valid(ip2)) {
    const parsed = parse(ip2);
    if (parsed.kind() === "ipv4")
      return ipv4_check$1(parsed.toNormalizedString());
    else if (parsed.kind() === "ipv6")
      return ipv6_check$1(ip2);
  } else if (isIP(ip2) && ipRegex$2.v6().test(ip2))
    return ipv6_check$1(ip2);
  return void 0;
};
function isPrivate(ma) {
  const { address } = ma.nodeAddress();
  return Boolean(is_ip_private(address));
}
function publicAddressesFirst(a, b2) {
  const isAPrivate = isPrivate(a.multiaddr);
  const isBPrivate = isPrivate(b2.multiaddr);
  if (isAPrivate && !isBPrivate) {
    return 1;
  } else if (!isAPrivate && isBPrivate) {
    return -1;
  }
  if (a.isCertified && !b2.isCertified) {
    return -1;
  } else if (!a.isCertified && b2.isCertified) {
    return 1;
  }
  return 0;
}
const log$D = logger$1("libp2p:auto-relay");
const noop = () => {
};
class AutoRelay {
  constructor(components, init2) {
    this.components = components;
    this.addressSorter = init2.addressSorter ?? publicAddressesFirst;
    this.maxListeners = init2.maxListeners ?? 1;
    this.listenRelays = /* @__PURE__ */ new Set();
    this.onError = init2.onError ?? noop;
    this._onProtocolChange = this._onProtocolChange.bind(this);
    this._onPeerDisconnected = this._onPeerDisconnected.bind(this);
    this.components.peerStore.addEventListener("change:protocols", (evt) => {
      void this._onProtocolChange(evt).catch((err2) => {
        log$D.error(err2);
      });
    });
    this.components.connectionManager.addEventListener("peer:disconnect", this._onPeerDisconnected);
  }
  async _onProtocolChange(evt) {
    const { peerId, protocols } = evt.detail;
    const id = peerId.toString();
    const hasProtocol = protocols.find((protocol2) => protocol2 === RELAY_CODEC);
    if (hasProtocol == null) {
      if (this.listenRelays.has(id)) {
        await this._removeListenRelay(id);
      }
      return;
    }
    if (this.listenRelays.has(id)) {
      return;
    }
    try {
      const connections = this.components.connectionManager.getConnections(peerId);
      if (connections.length === 0) {
        return;
      }
      const connection = connections[0];
      if (connection.remoteAddr.protoCodes().includes(CIRCUIT_PROTO_CODE)) {
        log$D(`relayed connection to ${id} will not be used to hop on`);
        return;
      }
      const supportsHop = await canHop({ connection });
      if (supportsHop) {
        await this.components.peerStore.metadataBook.setValue(peerId, HOP_METADATA_KEY, fromString$3(HOP_METADATA_VALUE));
        await this._addListenRelay(connection, id);
      }
    } catch (err2) {
      this.onError(err2);
    }
  }
  _onPeerDisconnected(evt) {
    const connection = evt.detail;
    const peerId = connection.remotePeer;
    const id = peerId.toString();
    if (!this.listenRelays.has(id)) {
      return;
    }
    this._removeListenRelay(id).catch((err2) => {
      log$D.error(err2);
    });
  }
  async _addListenRelay(connection, id) {
    try {
      if (this.listenRelays.size >= this.maxListeners) {
        return;
      }
      const remoteAddrs = await pipe(await this.components.peerStore.addressBook.get(connection.remotePeer), (source2) => sort(source2, this.addressSorter), async (source2) => await all$1(source2));
      const result = await Promise.all(remoteAddrs.map(async (addr) => {
        try {
          let multiaddr2 = addr.multiaddr;
          if (multiaddr2.getPeerId() == null) {
            multiaddr2 = multiaddr2.encapsulate(`/p2p/${connection.remotePeer.toString()}`);
          }
          multiaddr2 = multiaddr2.encapsulate("/p2p-circuit");
          await this.components.transportManager.listen([multiaddr2]);
          return true;
        } catch (err2) {
          log$D.error("error listening on circuit address", err2);
          this.onError(err2);
        }
        return false;
      }));
      if (result.includes(true)) {
        this.listenRelays.add(id);
      }
    } catch (err2) {
      this.onError(err2);
      this.listenRelays.delete(id);
    }
  }
  async _removeListenRelay(id) {
    if (this.listenRelays.delete(id)) {
      await this._listenOnAvailableHopRelays([id]);
    }
  }
  async _listenOnAvailableHopRelays(peersToIgnore = []) {
    if (this.listenRelays.size >= this.maxListeners) {
      return;
    }
    const knownHopsToDial = [];
    const peers = await this.components.peerStore.all();
    for (const { id, metadata } of peers) {
      const idStr = id.toString();
      if (this.listenRelays.has(idStr)) {
        continue;
      }
      if (peersToIgnore.includes(idStr)) {
        continue;
      }
      const supportsHop = metadata.get(HOP_METADATA_KEY);
      if (supportsHop == null || toString$5(supportsHop) !== HOP_METADATA_VALUE) {
        continue;
      }
      const connections = this.components.connectionManager.getConnections(id);
      if (connections.length === 0) {
        knownHopsToDial.push(id);
        continue;
      }
      await this._addListenRelay(connections[0], idStr);
      if (this.listenRelays.size >= this.maxListeners) {
        return;
      }
    }
    for (const peerId of knownHopsToDial) {
      await this._tryToListenOnRelay(peerId);
      if (this.listenRelays.size >= this.maxListeners) {
        return;
      }
    }
    try {
      const cid = await namespaceToCid(RELAY_RENDEZVOUS_NS);
      for await (const provider of this.components.contentRouting.findProviders(cid)) {
        if (provider.multiaddrs.length === 0) {
          continue;
        }
        const peerId = provider.id;
        if (peerId.equals(this.components.peerId)) {
          continue;
        }
        await this.components.peerStore.addressBook.add(peerId, provider.multiaddrs);
        await this._tryToListenOnRelay(peerId);
        if (this.listenRelays.size >= this.maxListeners) {
          return;
        }
      }
    } catch (err2) {
      this.onError(err2);
    }
  }
  async _tryToListenOnRelay(peerId) {
    try {
      const connection = await this.components.connectionManager.openConnection(peerId);
      await this._addListenRelay(connection, peerId.toString());
    } catch (err2) {
      log$D.error("Could not use %p as relay", peerId, err2);
      this.onError(err2, `could not connect and listen on known hop relay ${peerId.toString()}`);
    }
  }
}
const log$C = logger$1("libp2p:relay");
class Relay {
  constructor(components, init2) {
    this.components = components;
    this.autoRelay = init2.autoRelay?.enabled !== false ? new AutoRelay(components, {
      addressSorter: init2.addressSorter,
      ...init2.autoRelay
    }) : void 0;
    this.started = false;
    this.init = init2;
    this._advertiseService = this._advertiseService.bind(this);
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.init.hop.enabled !== false && this.init.advertise.enabled !== false) {
      this.timeout = src$1.setDelayedInterval(this._advertiseService, this.init.advertise.ttl, this.init.advertise.bootDelay);
    }
    this.started = true;
  }
  async stop() {
    if (this.timeout != null) {
      src$1.clearDelayedInterval(this.timeout);
    }
    this.started = false;
  }
  async _advertiseService() {
    try {
      const cid = await namespaceToCid(RELAY_RENDEZVOUS_NS);
      await this.components.contentRouting.provide(cid);
    } catch (err2) {
      if (err2.code === codes$1.ERR_NO_ROUTERS_AVAILABLE) {
        log$C.error("a content router, such as a DHT, must be provided in order to advertise the relay service", err2);
        await this.stop();
      } else {
        log$C.error(err2);
      }
    }
  }
}
function isHighSurrogate$1(codePoint) {
  return codePoint >= 55296 && codePoint <= 56319;
}
function isLowSurrogate$1(codePoint) {
  return codePoint >= 56320 && codePoint <= 57343;
}
var truncate$2 = function truncate2(getLength2, string2, byteLength2) {
  if (typeof string2 !== "string") {
    throw new Error("Input must be string");
  }
  var charLength = string2.length;
  var curByteLength = 0;
  var codePoint;
  var segment;
  for (var i2 = 0; i2 < charLength; i2 += 1) {
    codePoint = string2.charCodeAt(i2);
    segment = string2[i2];
    if (isHighSurrogate$1(codePoint) && isLowSurrogate$1(string2.charCodeAt(i2 + 1))) {
      i2 += 1;
      segment += string2[i2];
    }
    curByteLength += getLength2(segment);
    if (curByteLength === byteLength2) {
      return string2.slice(0, i2 + 1);
    } else if (curByteLength > byteLength2) {
      return string2.slice(0, i2 - segment.length + 1);
    }
  }
  return string2;
};
function isHighSurrogate(codePoint) {
  return codePoint >= 55296 && codePoint <= 56319;
}
function isLowSurrogate(codePoint) {
  return codePoint >= 56320 && codePoint <= 57343;
}
var browser$3 = function getByteLength(string2) {
  if (typeof string2 !== "string") {
    throw new Error("Input must be string");
  }
  var charLength = string2.length;
  var byteLength2 = 0;
  var codePoint = null;
  var prevCodePoint = null;
  for (var i2 = 0; i2 < charLength; i2++) {
    codePoint = string2.charCodeAt(i2);
    if (isLowSurrogate(codePoint)) {
      if (prevCodePoint != null && isHighSurrogate(prevCodePoint)) {
        byteLength2 += 1;
      } else {
        byteLength2 += 3;
      }
    } else if (codePoint <= 127) {
      byteLength2 += 1;
    } else if (codePoint >= 128 && codePoint <= 2047) {
      byteLength2 += 2;
    } else if (codePoint >= 2048 && codePoint <= 65535) {
      byteLength2 += 3;
    }
    prevCodePoint = codePoint;
  }
  return byteLength2;
};
var truncate$1 = truncate$2;
var getLength = browser$3;
var browser$2 = truncate$1.bind(null, getLength);
var truncate = browser$2;
var illegalRe = /[\/\?<>\\:\*\|"]/g;
var controlRe = /[\x00-\x1f\x80-\x9f]/g;
var reservedRe = /^\.+$/;
var windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i;
var windowsTrailingRe = /[\. ]+$/;
function sanitize(input, replacement) {
  if (typeof input !== "string") {
    throw new Error("Input must be string");
  }
  var sanitized = input.replace(illegalRe, replacement).replace(controlRe, replacement).replace(reservedRe, replacement).replace(windowsReservedRe, replacement).replace(windowsTrailingRe, replacement);
  return truncate(sanitized, 255);
}
var sanitizeFilename = function(input, options) {
  var replacement = options && options.replacement || "";
  var output = sanitize(input, replacement);
  if (replacement === "") {
    return output;
  }
  return sanitize(output, "");
};
var forge$5 = forge$s;
var asn1$2 = forge$5.asn1;
var p7v = forge$5.pkcs7asn1 = forge$5.pkcs7asn1 || {};
forge$5.pkcs7 = forge$5.pkcs7 || {};
forge$5.pkcs7.asn1 = p7v;
var contentInfoValidator = {
  name: "ContentInfo",
  tagClass: asn1$2.Class.UNIVERSAL,
  type: asn1$2.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "ContentInfo.ContentType",
    tagClass: asn1$2.Class.UNIVERSAL,
    type: asn1$2.Type.OID,
    constructed: false,
    capture: "contentType"
  }, {
    name: "ContentInfo.content",
    tagClass: asn1$2.Class.CONTEXT_SPECIFIC,
    type: 0,
    constructed: true,
    optional: true,
    captureAsn1: "content"
  }]
};
p7v.contentInfoValidator = contentInfoValidator;
var encryptedContentInfoValidator = {
  name: "EncryptedContentInfo",
  tagClass: asn1$2.Class.UNIVERSAL,
  type: asn1$2.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "EncryptedContentInfo.contentType",
    tagClass: asn1$2.Class.UNIVERSAL,
    type: asn1$2.Type.OID,
    constructed: false,
    capture: "contentType"
  }, {
    name: "EncryptedContentInfo.contentEncryptionAlgorithm",
    tagClass: asn1$2.Class.UNIVERSAL,
    type: asn1$2.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
      tagClass: asn1$2.Class.UNIVERSAL,
      type: asn1$2.Type.OID,
      constructed: false,
      capture: "encAlgorithm"
    }, {
      name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
      tagClass: asn1$2.Class.UNIVERSAL,
      captureAsn1: "encParameter"
    }]
  }, {
    name: "EncryptedContentInfo.encryptedContent",
    tagClass: asn1$2.Class.CONTEXT_SPECIFIC,
    type: 0,
    capture: "encryptedContent",
    captureAsn1: "encryptedContentAsn1"
  }]
};
p7v.envelopedDataValidator = {
  name: "EnvelopedData",
  tagClass: asn1$2.Class.UNIVERSAL,
  type: asn1$2.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "EnvelopedData.Version",
    tagClass: asn1$2.Class.UNIVERSAL,
    type: asn1$2.Type.INTEGER,
    constructed: false,
    capture: "version"
  }, {
    name: "EnvelopedData.RecipientInfos",
    tagClass: asn1$2.Class.UNIVERSAL,
    type: asn1$2.Type.SET,
    constructed: true,
    captureAsn1: "recipientInfos"
  }].concat(encryptedContentInfoValidator)
};
p7v.encryptedDataValidator = {
  name: "EncryptedData",
  tagClass: asn1$2.Class.UNIVERSAL,
  type: asn1$2.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "EncryptedData.Version",
    tagClass: asn1$2.Class.UNIVERSAL,
    type: asn1$2.Type.INTEGER,
    constructed: false,
    capture: "version"
  }].concat(encryptedContentInfoValidator)
};
var signerValidator = {
  name: "SignerInfo",
  tagClass: asn1$2.Class.UNIVERSAL,
  type: asn1$2.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "SignerInfo.version",
    tagClass: asn1$2.Class.UNIVERSAL,
    type: asn1$2.Type.INTEGER,
    constructed: false
  }, {
    name: "SignerInfo.issuerAndSerialNumber",
    tagClass: asn1$2.Class.UNIVERSAL,
    type: asn1$2.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "SignerInfo.issuerAndSerialNumber.issuer",
      tagClass: asn1$2.Class.UNIVERSAL,
      type: asn1$2.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "issuer"
    }, {
      name: "SignerInfo.issuerAndSerialNumber.serialNumber",
      tagClass: asn1$2.Class.UNIVERSAL,
      type: asn1$2.Type.INTEGER,
      constructed: false,
      capture: "serial"
    }]
  }, {
    name: "SignerInfo.digestAlgorithm",
    tagClass: asn1$2.Class.UNIVERSAL,
    type: asn1$2.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "SignerInfo.digestAlgorithm.algorithm",
      tagClass: asn1$2.Class.UNIVERSAL,
      type: asn1$2.Type.OID,
      constructed: false,
      capture: "digestAlgorithm"
    }, {
      name: "SignerInfo.digestAlgorithm.parameter",
      tagClass: asn1$2.Class.UNIVERSAL,
      constructed: false,
      captureAsn1: "digestParameter",
      optional: true
    }]
  }, {
    name: "SignerInfo.authenticatedAttributes",
    tagClass: asn1$2.Class.CONTEXT_SPECIFIC,
    type: 0,
    constructed: true,
    optional: true,
    capture: "authenticatedAttributes"
  }, {
    name: "SignerInfo.digestEncryptionAlgorithm",
    tagClass: asn1$2.Class.UNIVERSAL,
    type: asn1$2.Type.SEQUENCE,
    constructed: true,
    capture: "signatureAlgorithm"
  }, {
    name: "SignerInfo.encryptedDigest",
    tagClass: asn1$2.Class.UNIVERSAL,
    type: asn1$2.Type.OCTETSTRING,
    constructed: false,
    capture: "signature"
  }, {
    name: "SignerInfo.unauthenticatedAttributes",
    tagClass: asn1$2.Class.CONTEXT_SPECIFIC,
    type: 1,
    constructed: true,
    optional: true,
    capture: "unauthenticatedAttributes"
  }]
};
p7v.signedDataValidator = {
  name: "SignedData",
  tagClass: asn1$2.Class.UNIVERSAL,
  type: asn1$2.Type.SEQUENCE,
  constructed: true,
  value: [
    {
      name: "SignedData.Version",
      tagClass: asn1$2.Class.UNIVERSAL,
      type: asn1$2.Type.INTEGER,
      constructed: false,
      capture: "version"
    },
    {
      name: "SignedData.DigestAlgorithms",
      tagClass: asn1$2.Class.UNIVERSAL,
      type: asn1$2.Type.SET,
      constructed: true,
      captureAsn1: "digestAlgorithms"
    },
    contentInfoValidator,
    {
      name: "SignedData.Certificates",
      tagClass: asn1$2.Class.CONTEXT_SPECIFIC,
      type: 0,
      optional: true,
      captureAsn1: "certificates"
    },
    {
      name: "SignedData.CertificateRevocationLists",
      tagClass: asn1$2.Class.CONTEXT_SPECIFIC,
      type: 1,
      optional: true,
      captureAsn1: "crls"
    },
    {
      name: "SignedData.SignerInfos",
      tagClass: asn1$2.Class.UNIVERSAL,
      type: asn1$2.Type.SET,
      capture: "signerInfos",
      optional: true,
      value: [signerValidator]
    }
  ]
};
p7v.recipientInfoValidator = {
  name: "RecipientInfo",
  tagClass: asn1$2.Class.UNIVERSAL,
  type: asn1$2.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "RecipientInfo.version",
    tagClass: asn1$2.Class.UNIVERSAL,
    type: asn1$2.Type.INTEGER,
    constructed: false,
    capture: "version"
  }, {
    name: "RecipientInfo.issuerAndSerial",
    tagClass: asn1$2.Class.UNIVERSAL,
    type: asn1$2.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "RecipientInfo.issuerAndSerial.issuer",
      tagClass: asn1$2.Class.UNIVERSAL,
      type: asn1$2.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "issuer"
    }, {
      name: "RecipientInfo.issuerAndSerial.serialNumber",
      tagClass: asn1$2.Class.UNIVERSAL,
      type: asn1$2.Type.INTEGER,
      constructed: false,
      capture: "serial"
    }]
  }, {
    name: "RecipientInfo.keyEncryptionAlgorithm",
    tagClass: asn1$2.Class.UNIVERSAL,
    type: asn1$2.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
      tagClass: asn1$2.Class.UNIVERSAL,
      type: asn1$2.Type.OID,
      constructed: false,
      capture: "encAlgorithm"
    }, {
      name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
      tagClass: asn1$2.Class.UNIVERSAL,
      constructed: false,
      captureAsn1: "encParameter",
      optional: true
    }]
  }, {
    name: "RecipientInfo.encryptedKey",
    tagClass: asn1$2.Class.UNIVERSAL,
    type: asn1$2.Type.OCTETSTRING,
    constructed: false,
    capture: "encKey"
  }]
};
var forge$4 = forge$s;
forge$4.mgf = forge$4.mgf || {};
var mgf1 = forge$4.mgf.mgf1 = forge$4.mgf1 = forge$4.mgf1 || {};
mgf1.create = function(md) {
  var mgf = {
    generate: function(seed2, maskLen) {
      var t = new forge$4.util.ByteBuffer();
      var len2 = Math.ceil(maskLen / md.digestLength);
      for (var i2 = 0; i2 < len2; i2++) {
        var c = new forge$4.util.ByteBuffer();
        c.putInt32(i2);
        md.start();
        md.update(seed2 + c.getBytes());
        t.putBuffer(md.digest());
      }
      t.truncate(t.length() - maskLen);
      return t.getBytes();
    }
  };
  return mgf;
};
var forge$3 = forge$s;
forge$3.mgf = forge$3.mgf || {};
forge$3.mgf.mgf1 = forge$3.mgf1;
var forge$2 = forge$s;
var pss = forge$2.pss = forge$2.pss || {};
pss.create = function(options) {
  if (arguments.length === 3) {
    options = {
      md: arguments[0],
      mgf: arguments[1],
      saltLength: arguments[2]
    };
  }
  var hash2 = options.md;
  var mgf = options.mgf;
  var hLen = hash2.digestLength;
  var salt_ = options.salt || null;
  if (typeof salt_ === "string") {
    salt_ = forge$2.util.createBuffer(salt_);
  }
  var sLen;
  if ("saltLength" in options) {
    sLen = options.saltLength;
  } else if (salt_ !== null) {
    sLen = salt_.length();
  } else {
    throw new Error("Salt length not specified or specific salt not given.");
  }
  if (salt_ !== null && salt_.length() !== sLen) {
    throw new Error("Given salt length does not match length of given salt.");
  }
  var prng2 = options.prng || forge$2.random;
  var pssobj = {};
  pssobj.encode = function(md, modBits) {
    var i2;
    var emBits = modBits - 1;
    var emLen = Math.ceil(emBits / 8);
    var mHash = md.digest().getBytes();
    if (emLen < hLen + sLen + 2) {
      throw new Error("Message is too long to encrypt.");
    }
    var salt;
    if (salt_ === null) {
      salt = prng2.getBytesSync(sLen);
    } else {
      salt = salt_.bytes();
    }
    var m_ = new forge$2.util.ByteBuffer();
    m_.fillWithByte(0, 8);
    m_.putBytes(mHash);
    m_.putBytes(salt);
    hash2.start();
    hash2.update(m_.getBytes());
    var h = hash2.digest().getBytes();
    var ps = new forge$2.util.ByteBuffer();
    ps.fillWithByte(0, emLen - sLen - hLen - 2);
    ps.putByte(1);
    ps.putBytes(salt);
    var db = ps.getBytes();
    var maskLen = emLen - hLen - 1;
    var dbMask = mgf.generate(h, maskLen);
    var maskedDB = "";
    for (i2 = 0; i2 < maskLen; i2++) {
      maskedDB += String.fromCharCode(db.charCodeAt(i2) ^ dbMask.charCodeAt(i2));
    }
    var mask = 65280 >> 8 * emLen - emBits & 255;
    maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1);
    return maskedDB + h + String.fromCharCode(188);
  };
  pssobj.verify = function(mHash, em, modBits) {
    var i2;
    var emBits = modBits - 1;
    var emLen = Math.ceil(emBits / 8);
    em = em.substr(-emLen);
    if (emLen < hLen + sLen + 2) {
      throw new Error("Inconsistent parameters to PSS signature verification.");
    }
    if (em.charCodeAt(emLen - 1) !== 188) {
      throw new Error("Encoded message does not end in 0xBC.");
    }
    var maskLen = emLen - hLen - 1;
    var maskedDB = em.substr(0, maskLen);
    var h = em.substr(maskLen, hLen);
    var mask = 65280 >> 8 * emLen - emBits & 255;
    if ((maskedDB.charCodeAt(0) & mask) !== 0) {
      throw new Error("Bits beyond keysize not zero as expected.");
    }
    var dbMask = mgf.generate(h, maskLen);
    var db = "";
    for (i2 = 0; i2 < maskLen; i2++) {
      db += String.fromCharCode(maskedDB.charCodeAt(i2) ^ dbMask.charCodeAt(i2));
    }
    db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);
    var checkLen = emLen - hLen - sLen - 2;
    for (i2 = 0; i2 < checkLen; i2++) {
      if (db.charCodeAt(i2) !== 0) {
        throw new Error("Leftmost octets not zero as expected");
      }
    }
    if (db.charCodeAt(checkLen) !== 1) {
      throw new Error("Inconsistent PSS signature, 0x01 marker not found");
    }
    var salt = db.substr(-sLen);
    var m_ = new forge$2.util.ByteBuffer();
    m_.fillWithByte(0, 8);
    m_.putBytes(mHash);
    m_.putBytes(salt);
    hash2.start();
    hash2.update(m_.getBytes());
    var h_ = hash2.digest().getBytes();
    return h === h_;
  };
  return pssobj;
};
var forge$1 = forge$s;
var asn1$1 = forge$1.asn1;
var pki$1 = forge$1.pki = forge$1.pki || {};
var oids = pki$1.oids;
var _shortNames = {};
_shortNames["CN"] = oids["commonName"];
_shortNames["commonName"] = "CN";
_shortNames["C"] = oids["countryName"];
_shortNames["countryName"] = "C";
_shortNames["L"] = oids["localityName"];
_shortNames["localityName"] = "L";
_shortNames["ST"] = oids["stateOrProvinceName"];
_shortNames["stateOrProvinceName"] = "ST";
_shortNames["O"] = oids["organizationName"];
_shortNames["organizationName"] = "O";
_shortNames["OU"] = oids["organizationalUnitName"];
_shortNames["organizationalUnitName"] = "OU";
_shortNames["E"] = oids["emailAddress"];
_shortNames["emailAddress"] = "E";
var publicKeyValidator = forge$1.pki.rsa.publicKeyValidator;
var x509CertificateValidator = {
  name: "Certificate",
  tagClass: asn1$1.Class.UNIVERSAL,
  type: asn1$1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "Certificate.TBSCertificate",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.SEQUENCE,
    constructed: true,
    captureAsn1: "tbsCertificate",
    value: [
      {
        name: "Certificate.TBSCertificate.version",
        tagClass: asn1$1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        value: [{
          name: "Certificate.TBSCertificate.version.integer",
          tagClass: asn1$1.Class.UNIVERSAL,
          type: asn1$1.Type.INTEGER,
          constructed: false,
          capture: "certVersion"
        }]
      },
      {
        name: "Certificate.TBSCertificate.serialNumber",
        tagClass: asn1$1.Class.UNIVERSAL,
        type: asn1$1.Type.INTEGER,
        constructed: false,
        capture: "certSerialNumber"
      },
      {
        name: "Certificate.TBSCertificate.signature",
        tagClass: asn1$1.Class.UNIVERSAL,
        type: asn1$1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "Certificate.TBSCertificate.signature.algorithm",
          tagClass: asn1$1.Class.UNIVERSAL,
          type: asn1$1.Type.OID,
          constructed: false,
          capture: "certinfoSignatureOid"
        }, {
          name: "Certificate.TBSCertificate.signature.parameters",
          tagClass: asn1$1.Class.UNIVERSAL,
          optional: true,
          captureAsn1: "certinfoSignatureParams"
        }]
      },
      {
        name: "Certificate.TBSCertificate.issuer",
        tagClass: asn1$1.Class.UNIVERSAL,
        type: asn1$1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "certIssuer"
      },
      {
        name: "Certificate.TBSCertificate.validity",
        tagClass: asn1$1.Class.UNIVERSAL,
        type: asn1$1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "Certificate.TBSCertificate.validity.notBefore (utc)",
          tagClass: asn1$1.Class.UNIVERSAL,
          type: asn1$1.Type.UTCTIME,
          constructed: false,
          optional: true,
          capture: "certValidity1UTCTime"
        }, {
          name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
          tagClass: asn1$1.Class.UNIVERSAL,
          type: asn1$1.Type.GENERALIZEDTIME,
          constructed: false,
          optional: true,
          capture: "certValidity2GeneralizedTime"
        }, {
          name: "Certificate.TBSCertificate.validity.notAfter (utc)",
          tagClass: asn1$1.Class.UNIVERSAL,
          type: asn1$1.Type.UTCTIME,
          constructed: false,
          optional: true,
          capture: "certValidity3UTCTime"
        }, {
          name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
          tagClass: asn1$1.Class.UNIVERSAL,
          type: asn1$1.Type.GENERALIZEDTIME,
          constructed: false,
          optional: true,
          capture: "certValidity4GeneralizedTime"
        }]
      },
      {
        name: "Certificate.TBSCertificate.subject",
        tagClass: asn1$1.Class.UNIVERSAL,
        type: asn1$1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "certSubject"
      },
      publicKeyValidator,
      {
        name: "Certificate.TBSCertificate.issuerUniqueID",
        tagClass: asn1$1.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        optional: true,
        value: [{
          name: "Certificate.TBSCertificate.issuerUniqueID.id",
          tagClass: asn1$1.Class.UNIVERSAL,
          type: asn1$1.Type.BITSTRING,
          constructed: false,
          captureBitStringValue: "certIssuerUniqueId"
        }]
      },
      {
        name: "Certificate.TBSCertificate.subjectUniqueID",
        tagClass: asn1$1.Class.CONTEXT_SPECIFIC,
        type: 2,
        constructed: true,
        optional: true,
        value: [{
          name: "Certificate.TBSCertificate.subjectUniqueID.id",
          tagClass: asn1$1.Class.UNIVERSAL,
          type: asn1$1.Type.BITSTRING,
          constructed: false,
          captureBitStringValue: "certSubjectUniqueId"
        }]
      },
      {
        name: "Certificate.TBSCertificate.extensions",
        tagClass: asn1$1.Class.CONTEXT_SPECIFIC,
        type: 3,
        constructed: true,
        captureAsn1: "certExtensions",
        optional: true
      }
    ]
  }, {
    name: "Certificate.signatureAlgorithm",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "Certificate.signatureAlgorithm.algorithm",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.OID,
      constructed: false,
      capture: "certSignatureOid"
    }, {
      name: "Certificate.TBSCertificate.signature.parameters",
      tagClass: asn1$1.Class.UNIVERSAL,
      optional: true,
      captureAsn1: "certSignatureParams"
    }]
  }, {
    name: "Certificate.signatureValue",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.BITSTRING,
    constructed: false,
    captureBitStringValue: "certSignature"
  }]
};
var rsassaPssParameterValidator = {
  name: "rsapss",
  tagClass: asn1$1.Class.UNIVERSAL,
  type: asn1$1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "rsapss.hashAlgorithm",
    tagClass: asn1$1.Class.CONTEXT_SPECIFIC,
    type: 0,
    constructed: true,
    value: [{
      name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Class.SEQUENCE,
      constructed: true,
      optional: true,
      value: [{
        name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
        tagClass: asn1$1.Class.UNIVERSAL,
        type: asn1$1.Type.OID,
        constructed: false,
        capture: "hashOid"
      }]
    }]
  }, {
    name: "rsapss.maskGenAlgorithm",
    tagClass: asn1$1.Class.CONTEXT_SPECIFIC,
    type: 1,
    constructed: true,
    value: [{
      name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Class.SEQUENCE,
      constructed: true,
      optional: true,
      value: [{
        name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
        tagClass: asn1$1.Class.UNIVERSAL,
        type: asn1$1.Type.OID,
        constructed: false,
        capture: "maskGenOid"
      }, {
        name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
        tagClass: asn1$1.Class.UNIVERSAL,
        type: asn1$1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
          tagClass: asn1$1.Class.UNIVERSAL,
          type: asn1$1.Type.OID,
          constructed: false,
          capture: "maskGenHashOid"
        }]
      }]
    }]
  }, {
    name: "rsapss.saltLength",
    tagClass: asn1$1.Class.CONTEXT_SPECIFIC,
    type: 2,
    optional: true,
    value: [{
      name: "rsapss.saltLength.saltLength",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Class.INTEGER,
      constructed: false,
      capture: "saltLength"
    }]
  }, {
    name: "rsapss.trailerField",
    tagClass: asn1$1.Class.CONTEXT_SPECIFIC,
    type: 3,
    optional: true,
    value: [{
      name: "rsapss.trailer.trailer",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Class.INTEGER,
      constructed: false,
      capture: "trailer"
    }]
  }]
};
var certificationRequestInfoValidator = {
  name: "CertificationRequestInfo",
  tagClass: asn1$1.Class.UNIVERSAL,
  type: asn1$1.Type.SEQUENCE,
  constructed: true,
  captureAsn1: "certificationRequestInfo",
  value: [
    {
      name: "CertificationRequestInfo.integer",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.INTEGER,
      constructed: false,
      capture: "certificationRequestInfoVersion"
    },
    {
      name: "CertificationRequestInfo.subject",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "certificationRequestInfoSubject"
    },
    publicKeyValidator,
    {
      name: "CertificationRequestInfo.attributes",
      tagClass: asn1$1.Class.CONTEXT_SPECIFIC,
      type: 0,
      constructed: true,
      optional: true,
      capture: "certificationRequestInfoAttributes",
      value: [{
        name: "CertificationRequestInfo.attributes",
        tagClass: asn1$1.Class.UNIVERSAL,
        type: asn1$1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "CertificationRequestInfo.attributes.type",
          tagClass: asn1$1.Class.UNIVERSAL,
          type: asn1$1.Type.OID,
          constructed: false
        }, {
          name: "CertificationRequestInfo.attributes.value",
          tagClass: asn1$1.Class.UNIVERSAL,
          type: asn1$1.Type.SET,
          constructed: true
        }]
      }]
    }
  ]
};
var certificationRequestValidator = {
  name: "CertificationRequest",
  tagClass: asn1$1.Class.UNIVERSAL,
  type: asn1$1.Type.SEQUENCE,
  constructed: true,
  captureAsn1: "csr",
  value: [
    certificationRequestInfoValidator,
    {
      name: "CertificationRequest.signatureAlgorithm",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "CertificationRequest.signatureAlgorithm.algorithm",
        tagClass: asn1$1.Class.UNIVERSAL,
        type: asn1$1.Type.OID,
        constructed: false,
        capture: "csrSignatureOid"
      }, {
        name: "CertificationRequest.signatureAlgorithm.parameters",
        tagClass: asn1$1.Class.UNIVERSAL,
        optional: true,
        captureAsn1: "csrSignatureParams"
      }]
    },
    {
      name: "CertificationRequest.signature",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.BITSTRING,
      constructed: false,
      captureBitStringValue: "csrSignature"
    }
  ]
};
pki$1.RDNAttributesAsArray = function(rdn, md) {
  var rval = [];
  var set2, attr, obj;
  for (var si = 0; si < rdn.value.length; ++si) {
    set2 = rdn.value[si];
    for (var i2 = 0; i2 < set2.value.length; ++i2) {
      obj = {};
      attr = set2.value[i2];
      obj.type = asn1$1.derToOid(attr.value[0].value);
      obj.value = attr.value[1].value;
      obj.valueTagClass = attr.value[1].type;
      if (obj.type in oids) {
        obj.name = oids[obj.type];
        if (obj.name in _shortNames) {
          obj.shortName = _shortNames[obj.name];
        }
      }
      if (md) {
        md.update(obj.type);
        md.update(obj.value);
      }
      rval.push(obj);
    }
  }
  return rval;
};
pki$1.CRIAttributesAsArray = function(attributes) {
  var rval = [];
  for (var si = 0; si < attributes.length; ++si) {
    var seq = attributes[si];
    var type = asn1$1.derToOid(seq.value[0].value);
    var values = seq.value[1].value;
    for (var vi = 0; vi < values.length; ++vi) {
      var obj = {};
      obj.type = type;
      obj.value = values[vi].value;
      obj.valueTagClass = values[vi].type;
      if (obj.type in oids) {
        obj.name = oids[obj.type];
        if (obj.name in _shortNames) {
          obj.shortName = _shortNames[obj.name];
        }
      }
      if (obj.type === oids.extensionRequest) {
        obj.extensions = [];
        for (var ei = 0; ei < obj.value.length; ++ei) {
          obj.extensions.push(pki$1.certificateExtensionFromAsn1(obj.value[ei]));
        }
      }
      rval.push(obj);
    }
  }
  return rval;
};
function _getAttribute(obj, options) {
  if (typeof options === "string") {
    options = { shortName: options };
  }
  var rval = null;
  var attr;
  for (var i2 = 0; rval === null && i2 < obj.attributes.length; ++i2) {
    attr = obj.attributes[i2];
    if (options.type && options.type === attr.type) {
      rval = attr;
    } else if (options.name && options.name === attr.name) {
      rval = attr;
    } else if (options.shortName && options.shortName === attr.shortName) {
      rval = attr;
    }
  }
  return rval;
}
var _readSignatureParameters = function(oid, obj, fillDefaults) {
  var params = {};
  if (oid !== oids["RSASSA-PSS"]) {
    return params;
  }
  if (fillDefaults) {
    params = {
      hash: {
        algorithmOid: oids["sha1"]
      },
      mgf: {
        algorithmOid: oids["mgf1"],
        hash: {
          algorithmOid: oids["sha1"]
        }
      },
      saltLength: 20
    };
  }
  var capture = {};
  var errors2 = [];
  if (!asn1$1.validate(obj, rsassaPssParameterValidator, capture, errors2)) {
    var error2 = new Error("Cannot read RSASSA-PSS parameter block.");
    error2.errors = errors2;
    throw error2;
  }
  if (capture.hashOid !== void 0) {
    params.hash = params.hash || {};
    params.hash.algorithmOid = asn1$1.derToOid(capture.hashOid);
  }
  if (capture.maskGenOid !== void 0) {
    params.mgf = params.mgf || {};
    params.mgf.algorithmOid = asn1$1.derToOid(capture.maskGenOid);
    params.mgf.hash = params.mgf.hash || {};
    params.mgf.hash.algorithmOid = asn1$1.derToOid(capture.maskGenHashOid);
  }
  if (capture.saltLength !== void 0) {
    params.saltLength = capture.saltLength.charCodeAt(0);
  }
  return params;
};
var _createSignatureDigest = function(options) {
  switch (oids[options.signatureOid]) {
    case "sha1WithRSAEncryption":
    case "sha1WithRSASignature":
      return forge$1.md.sha1.create();
    case "md5WithRSAEncryption":
      return forge$1.md.md5.create();
    case "sha256WithRSAEncryption":
      return forge$1.md.sha256.create();
    case "sha384WithRSAEncryption":
      return forge$1.md.sha384.create();
    case "sha512WithRSAEncryption":
      return forge$1.md.sha512.create();
    case "RSASSA-PSS":
      return forge$1.md.sha256.create();
    default:
      var error2 = new Error(
        "Could not compute " + options.type + " digest. Unknown signature OID."
      );
      error2.signatureOid = options.signatureOid;
      throw error2;
  }
};
var _verifySignature = function(options) {
  var cert = options.certificate;
  var scheme;
  switch (cert.signatureOid) {
    case oids.sha1WithRSAEncryption:
    case oids.sha1WithRSASignature:
      break;
    case oids["RSASSA-PSS"]:
      var hash2, mgf;
      hash2 = oids[cert.signatureParameters.mgf.hash.algorithmOid];
      if (hash2 === void 0 || forge$1.md[hash2] === void 0) {
        var error2 = new Error("Unsupported MGF hash function.");
        error2.oid = cert.signatureParameters.mgf.hash.algorithmOid;
        error2.name = hash2;
        throw error2;
      }
      mgf = oids[cert.signatureParameters.mgf.algorithmOid];
      if (mgf === void 0 || forge$1.mgf[mgf] === void 0) {
        var error2 = new Error("Unsupported MGF function.");
        error2.oid = cert.signatureParameters.mgf.algorithmOid;
        error2.name = mgf;
        throw error2;
      }
      mgf = forge$1.mgf[mgf].create(forge$1.md[hash2].create());
      hash2 = oids[cert.signatureParameters.hash.algorithmOid];
      if (hash2 === void 0 || forge$1.md[hash2] === void 0) {
        var error2 = new Error("Unsupported RSASSA-PSS hash function.");
        error2.oid = cert.signatureParameters.hash.algorithmOid;
        error2.name = hash2;
        throw error2;
      }
      scheme = forge$1.pss.create(
        forge$1.md[hash2].create(),
        mgf,
        cert.signatureParameters.saltLength
      );
      break;
  }
  return cert.publicKey.verify(
    options.md.digest().getBytes(),
    options.signature,
    scheme
  );
};
pki$1.certificateFromPem = function(pem2, computeHash, strict) {
  var msg = forge$1.pem.decode(pem2)[0];
  if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
    var error2 = new Error(
      'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".'
    );
    error2.headerType = msg.type;
    throw error2;
  }
  if (msg.procType && msg.procType.type === "ENCRYPTED") {
    throw new Error(
      "Could not convert certificate from PEM; PEM is encrypted."
    );
  }
  var obj = asn1$1.fromDer(msg.body, strict);
  return pki$1.certificateFromAsn1(obj, computeHash);
};
pki$1.certificateToPem = function(cert, maxline) {
  var msg = {
    type: "CERTIFICATE",
    body: asn1$1.toDer(pki$1.certificateToAsn1(cert)).getBytes()
  };
  return forge$1.pem.encode(msg, { maxline });
};
pki$1.publicKeyFromPem = function(pem2) {
  var msg = forge$1.pem.decode(pem2)[0];
  if (msg.type !== "PUBLIC KEY" && msg.type !== "RSA PUBLIC KEY") {
    var error2 = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
    error2.headerType = msg.type;
    throw error2;
  }
  if (msg.procType && msg.procType.type === "ENCRYPTED") {
    throw new Error("Could not convert public key from PEM; PEM is encrypted.");
  }
  var obj = asn1$1.fromDer(msg.body);
  return pki$1.publicKeyFromAsn1(obj);
};
pki$1.publicKeyToPem = function(key, maxline) {
  var msg = {
    type: "PUBLIC KEY",
    body: asn1$1.toDer(pki$1.publicKeyToAsn1(key)).getBytes()
  };
  return forge$1.pem.encode(msg, { maxline });
};
pki$1.publicKeyToRSAPublicKeyPem = function(key, maxline) {
  var msg = {
    type: "RSA PUBLIC KEY",
    body: asn1$1.toDer(pki$1.publicKeyToRSAPublicKey(key)).getBytes()
  };
  return forge$1.pem.encode(msg, { maxline });
};
pki$1.getPublicKeyFingerprint = function(key, options) {
  options = options || {};
  var md = options.md || forge$1.md.sha1.create();
  var type = options.type || "RSAPublicKey";
  var bytes2;
  switch (type) {
    case "RSAPublicKey":
      bytes2 = asn1$1.toDer(pki$1.publicKeyToRSAPublicKey(key)).getBytes();
      break;
    case "SubjectPublicKeyInfo":
      bytes2 = asn1$1.toDer(pki$1.publicKeyToAsn1(key)).getBytes();
      break;
    default:
      throw new Error('Unknown fingerprint type "' + options.type + '".');
  }
  md.start();
  md.update(bytes2);
  var digest2 = md.digest();
  if (options.encoding === "hex") {
    var hex = digest2.toHex();
    if (options.delimiter) {
      return hex.match(/.{2}/g).join(options.delimiter);
    }
    return hex;
  } else if (options.encoding === "binary") {
    return digest2.getBytes();
  } else if (options.encoding) {
    throw new Error('Unknown encoding "' + options.encoding + '".');
  }
  return digest2;
};
pki$1.certificationRequestFromPem = function(pem2, computeHash, strict) {
  var msg = forge$1.pem.decode(pem2)[0];
  if (msg.type !== "CERTIFICATE REQUEST") {
    var error2 = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
    error2.headerType = msg.type;
    throw error2;
  }
  if (msg.procType && msg.procType.type === "ENCRYPTED") {
    throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
  }
  var obj = asn1$1.fromDer(msg.body, strict);
  return pki$1.certificationRequestFromAsn1(obj, computeHash);
};
pki$1.certificationRequestToPem = function(csr, maxline) {
  var msg = {
    type: "CERTIFICATE REQUEST",
    body: asn1$1.toDer(pki$1.certificationRequestToAsn1(csr)).getBytes()
  };
  return forge$1.pem.encode(msg, { maxline });
};
pki$1.createCertificate = function() {
  var cert = {};
  cert.version = 2;
  cert.serialNumber = "00";
  cert.signatureOid = null;
  cert.signature = null;
  cert.siginfo = {};
  cert.siginfo.algorithmOid = null;
  cert.validity = {};
  cert.validity.notBefore = new Date();
  cert.validity.notAfter = new Date();
  cert.issuer = {};
  cert.issuer.getField = function(sn) {
    return _getAttribute(cert.issuer, sn);
  };
  cert.issuer.addField = function(attr) {
    _fillMissingFields([attr]);
    cert.issuer.attributes.push(attr);
  };
  cert.issuer.attributes = [];
  cert.issuer.hash = null;
  cert.subject = {};
  cert.subject.getField = function(sn) {
    return _getAttribute(cert.subject, sn);
  };
  cert.subject.addField = function(attr) {
    _fillMissingFields([attr]);
    cert.subject.attributes.push(attr);
  };
  cert.subject.attributes = [];
  cert.subject.hash = null;
  cert.extensions = [];
  cert.publicKey = null;
  cert.md = null;
  cert.setSubject = function(attrs, uniqueId) {
    _fillMissingFields(attrs);
    cert.subject.attributes = attrs;
    delete cert.subject.uniqueId;
    if (uniqueId) {
      cert.subject.uniqueId = uniqueId;
    }
    cert.subject.hash = null;
  };
  cert.setIssuer = function(attrs, uniqueId) {
    _fillMissingFields(attrs);
    cert.issuer.attributes = attrs;
    delete cert.issuer.uniqueId;
    if (uniqueId) {
      cert.issuer.uniqueId = uniqueId;
    }
    cert.issuer.hash = null;
  };
  cert.setExtensions = function(exts) {
    for (var i2 = 0; i2 < exts.length; ++i2) {
      _fillMissingExtensionFields(exts[i2], { cert });
    }
    cert.extensions = exts;
  };
  cert.getExtension = function(options) {
    if (typeof options === "string") {
      options = { name: options };
    }
    var rval = null;
    var ext;
    for (var i2 = 0; rval === null && i2 < cert.extensions.length; ++i2) {
      ext = cert.extensions[i2];
      if (options.id && ext.id === options.id) {
        rval = ext;
      } else if (options.name && ext.name === options.name) {
        rval = ext;
      }
    }
    return rval;
  };
  cert.sign = function(key, md) {
    cert.md = md || forge$1.md.sha1.create();
    var algorithmOid = oids[cert.md.algorithm + "WithRSAEncryption"];
    if (!algorithmOid) {
      var error2 = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
      error2.algorithm = cert.md.algorithm;
      throw error2;
    }
    cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;
    cert.tbsCertificate = pki$1.getTBSCertificate(cert);
    var bytes2 = asn1$1.toDer(cert.tbsCertificate);
    cert.md.update(bytes2.getBytes());
    cert.signature = key.sign(cert.md);
  };
  cert.verify = function(child) {
    var rval = false;
    if (!cert.issued(child)) {
      var issuer = child.issuer;
      var subject = cert.subject;
      var error2 = new Error(
        "The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject."
      );
      error2.expectedIssuer = subject.attributes;
      error2.actualIssuer = issuer.attributes;
      throw error2;
    }
    var md = child.md;
    if (md === null) {
      md = _createSignatureDigest({
        signatureOid: child.signatureOid,
        type: "certificate"
      });
      var tbsCertificate = child.tbsCertificate || pki$1.getTBSCertificate(child);
      var bytes2 = asn1$1.toDer(tbsCertificate);
      md.update(bytes2.getBytes());
    }
    if (md !== null) {
      rval = _verifySignature({
        certificate: cert,
        md,
        signature: child.signature
      });
    }
    return rval;
  };
  cert.isIssuer = function(parent2) {
    var rval = false;
    var i2 = cert.issuer;
    var s2 = parent2.subject;
    if (i2.hash && s2.hash) {
      rval = i2.hash === s2.hash;
    } else if (i2.attributes.length === s2.attributes.length) {
      rval = true;
      var iattr, sattr;
      for (var n = 0; rval && n < i2.attributes.length; ++n) {
        iattr = i2.attributes[n];
        sattr = s2.attributes[n];
        if (iattr.type !== sattr.type || iattr.value !== sattr.value) {
          rval = false;
        }
      }
    }
    return rval;
  };
  cert.issued = function(child) {
    return child.isIssuer(cert);
  };
  cert.generateSubjectKeyIdentifier = function() {
    return pki$1.getPublicKeyFingerprint(cert.publicKey, { type: "RSAPublicKey" });
  };
  cert.verifySubjectKeyIdentifier = function() {
    var oid = oids["subjectKeyIdentifier"];
    for (var i2 = 0; i2 < cert.extensions.length; ++i2) {
      var ext = cert.extensions[i2];
      if (ext.id === oid) {
        var ski = cert.generateSubjectKeyIdentifier().getBytes();
        return forge$1.util.hexToBytes(ext.subjectKeyIdentifier) === ski;
      }
    }
    return false;
  };
  return cert;
};
pki$1.certificateFromAsn1 = function(obj, computeHash) {
  var capture = {};
  var errors2 = [];
  if (!asn1$1.validate(obj, x509CertificateValidator, capture, errors2)) {
    var error2 = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
    error2.errors = errors2;
    throw error2;
  }
  var oid = asn1$1.derToOid(capture.publicKeyOid);
  if (oid !== pki$1.oids.rsaEncryption) {
    throw new Error("Cannot read public key. OID is not RSA.");
  }
  var cert = pki$1.createCertificate();
  cert.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;
  var serial = forge$1.util.createBuffer(capture.certSerialNumber);
  cert.serialNumber = serial.toHex();
  cert.signatureOid = forge$1.asn1.derToOid(capture.certSignatureOid);
  cert.signatureParameters = _readSignatureParameters(
    cert.signatureOid,
    capture.certSignatureParams,
    true
  );
  cert.siginfo.algorithmOid = forge$1.asn1.derToOid(capture.certinfoSignatureOid);
  cert.siginfo.parameters = _readSignatureParameters(
    cert.siginfo.algorithmOid,
    capture.certinfoSignatureParams,
    false
  );
  cert.signature = capture.certSignature;
  var validity = [];
  if (capture.certValidity1UTCTime !== void 0) {
    validity.push(asn1$1.utcTimeToDate(capture.certValidity1UTCTime));
  }
  if (capture.certValidity2GeneralizedTime !== void 0) {
    validity.push(asn1$1.generalizedTimeToDate(
      capture.certValidity2GeneralizedTime
    ));
  }
  if (capture.certValidity3UTCTime !== void 0) {
    validity.push(asn1$1.utcTimeToDate(capture.certValidity3UTCTime));
  }
  if (capture.certValidity4GeneralizedTime !== void 0) {
    validity.push(asn1$1.generalizedTimeToDate(
      capture.certValidity4GeneralizedTime
    ));
  }
  if (validity.length > 2) {
    throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
  }
  if (validity.length < 2) {
    throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
  }
  cert.validity.notBefore = validity[0];
  cert.validity.notAfter = validity[1];
  cert.tbsCertificate = capture.tbsCertificate;
  if (computeHash) {
    cert.md = _createSignatureDigest({
      signatureOid: cert.signatureOid,
      type: "certificate"
    });
    var bytes2 = asn1$1.toDer(cert.tbsCertificate);
    cert.md.update(bytes2.getBytes());
  }
  var imd = forge$1.md.sha1.create();
  var ibytes = asn1$1.toDer(capture.certIssuer);
  imd.update(ibytes.getBytes());
  cert.issuer.getField = function(sn) {
    return _getAttribute(cert.issuer, sn);
  };
  cert.issuer.addField = function(attr) {
    _fillMissingFields([attr]);
    cert.issuer.attributes.push(attr);
  };
  cert.issuer.attributes = pki$1.RDNAttributesAsArray(capture.certIssuer);
  if (capture.certIssuerUniqueId) {
    cert.issuer.uniqueId = capture.certIssuerUniqueId;
  }
  cert.issuer.hash = imd.digest().toHex();
  var smd = forge$1.md.sha1.create();
  var sbytes = asn1$1.toDer(capture.certSubject);
  smd.update(sbytes.getBytes());
  cert.subject.getField = function(sn) {
    return _getAttribute(cert.subject, sn);
  };
  cert.subject.addField = function(attr) {
    _fillMissingFields([attr]);
    cert.subject.attributes.push(attr);
  };
  cert.subject.attributes = pki$1.RDNAttributesAsArray(capture.certSubject);
  if (capture.certSubjectUniqueId) {
    cert.subject.uniqueId = capture.certSubjectUniqueId;
  }
  cert.subject.hash = smd.digest().toHex();
  if (capture.certExtensions) {
    cert.extensions = pki$1.certificateExtensionsFromAsn1(capture.certExtensions);
  } else {
    cert.extensions = [];
  }
  cert.publicKey = pki$1.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
  return cert;
};
pki$1.certificateExtensionsFromAsn1 = function(exts) {
  var rval = [];
  for (var i2 = 0; i2 < exts.value.length; ++i2) {
    var extseq = exts.value[i2];
    for (var ei = 0; ei < extseq.value.length; ++ei) {
      rval.push(pki$1.certificateExtensionFromAsn1(extseq.value[ei]));
    }
  }
  return rval;
};
pki$1.certificateExtensionFromAsn1 = function(ext) {
  var e = {};
  e.id = asn1$1.derToOid(ext.value[0].value);
  e.critical = false;
  if (ext.value[1].type === asn1$1.Type.BOOLEAN) {
    e.critical = ext.value[1].value.charCodeAt(0) !== 0;
    e.value = ext.value[2].value;
  } else {
    e.value = ext.value[1].value;
  }
  if (e.id in oids) {
    e.name = oids[e.id];
    if (e.name === "keyUsage") {
      var ev = asn1$1.fromDer(e.value);
      var b2 = 0;
      var b3 = 0;
      if (ev.value.length > 1) {
        b2 = ev.value.charCodeAt(1);
        b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;
      }
      e.digitalSignature = (b2 & 128) === 128;
      e.nonRepudiation = (b2 & 64) === 64;
      e.keyEncipherment = (b2 & 32) === 32;
      e.dataEncipherment = (b2 & 16) === 16;
      e.keyAgreement = (b2 & 8) === 8;
      e.keyCertSign = (b2 & 4) === 4;
      e.cRLSign = (b2 & 2) === 2;
      e.encipherOnly = (b2 & 1) === 1;
      e.decipherOnly = (b3 & 128) === 128;
    } else if (e.name === "basicConstraints") {
      var ev = asn1$1.fromDer(e.value);
      if (ev.value.length > 0 && ev.value[0].type === asn1$1.Type.BOOLEAN) {
        e.cA = ev.value[0].value.charCodeAt(0) !== 0;
      } else {
        e.cA = false;
      }
      var value2 = null;
      if (ev.value.length > 0 && ev.value[0].type === asn1$1.Type.INTEGER) {
        value2 = ev.value[0].value;
      } else if (ev.value.length > 1) {
        value2 = ev.value[1].value;
      }
      if (value2 !== null) {
        e.pathLenConstraint = asn1$1.derToInteger(value2);
      }
    } else if (e.name === "extKeyUsage") {
      var ev = asn1$1.fromDer(e.value);
      for (var vi = 0; vi < ev.value.length; ++vi) {
        var oid = asn1$1.derToOid(ev.value[vi].value);
        if (oid in oids) {
          e[oids[oid]] = true;
        } else {
          e[oid] = true;
        }
      }
    } else if (e.name === "nsCertType") {
      var ev = asn1$1.fromDer(e.value);
      var b2 = 0;
      if (ev.value.length > 1) {
        b2 = ev.value.charCodeAt(1);
      }
      e.client = (b2 & 128) === 128;
      e.server = (b2 & 64) === 64;
      e.email = (b2 & 32) === 32;
      e.objsign = (b2 & 16) === 16;
      e.reserved = (b2 & 8) === 8;
      e.sslCA = (b2 & 4) === 4;
      e.emailCA = (b2 & 2) === 2;
      e.objCA = (b2 & 1) === 1;
    } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
      e.altNames = [];
      var gn;
      var ev = asn1$1.fromDer(e.value);
      for (var n = 0; n < ev.value.length; ++n) {
        gn = ev.value[n];
        var altName = {
          type: gn.type,
          value: gn.value
        };
        e.altNames.push(altName);
        switch (gn.type) {
          case 1:
          case 2:
          case 6:
            break;
          case 7:
            altName.ip = forge$1.util.bytesToIP(gn.value);
            break;
          case 8:
            altName.oid = asn1$1.derToOid(gn.value);
            break;
        }
      }
    } else if (e.name === "subjectKeyIdentifier") {
      var ev = asn1$1.fromDer(e.value);
      e.subjectKeyIdentifier = forge$1.util.bytesToHex(ev.value);
    }
  }
  return e;
};
pki$1.certificationRequestFromAsn1 = function(obj, computeHash) {
  var capture = {};
  var errors2 = [];
  if (!asn1$1.validate(obj, certificationRequestValidator, capture, errors2)) {
    var error2 = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
    error2.errors = errors2;
    throw error2;
  }
  var oid = asn1$1.derToOid(capture.publicKeyOid);
  if (oid !== pki$1.oids.rsaEncryption) {
    throw new Error("Cannot read public key. OID is not RSA.");
  }
  var csr = pki$1.createCertificationRequest();
  csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;
  csr.signatureOid = forge$1.asn1.derToOid(capture.csrSignatureOid);
  csr.signatureParameters = _readSignatureParameters(
    csr.signatureOid,
    capture.csrSignatureParams,
    true
  );
  csr.siginfo.algorithmOid = forge$1.asn1.derToOid(capture.csrSignatureOid);
  csr.siginfo.parameters = _readSignatureParameters(
    csr.siginfo.algorithmOid,
    capture.csrSignatureParams,
    false
  );
  csr.signature = capture.csrSignature;
  csr.certificationRequestInfo = capture.certificationRequestInfo;
  if (computeHash) {
    csr.md = _createSignatureDigest({
      signatureOid: csr.signatureOid,
      type: "certification request"
    });
    var bytes2 = asn1$1.toDer(csr.certificationRequestInfo);
    csr.md.update(bytes2.getBytes());
  }
  var smd = forge$1.md.sha1.create();
  csr.subject.getField = function(sn) {
    return _getAttribute(csr.subject, sn);
  };
  csr.subject.addField = function(attr) {
    _fillMissingFields([attr]);
    csr.subject.attributes.push(attr);
  };
  csr.subject.attributes = pki$1.RDNAttributesAsArray(
    capture.certificationRequestInfoSubject,
    smd
  );
  csr.subject.hash = smd.digest().toHex();
  csr.publicKey = pki$1.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
  csr.getAttribute = function(sn) {
    return _getAttribute(csr, sn);
  };
  csr.addAttribute = function(attr) {
    _fillMissingFields([attr]);
    csr.attributes.push(attr);
  };
  csr.attributes = pki$1.CRIAttributesAsArray(
    capture.certificationRequestInfoAttributes || []
  );
  return csr;
};
pki$1.createCertificationRequest = function() {
  var csr = {};
  csr.version = 0;
  csr.signatureOid = null;
  csr.signature = null;
  csr.siginfo = {};
  csr.siginfo.algorithmOid = null;
  csr.subject = {};
  csr.subject.getField = function(sn) {
    return _getAttribute(csr.subject, sn);
  };
  csr.subject.addField = function(attr) {
    _fillMissingFields([attr]);
    csr.subject.attributes.push(attr);
  };
  csr.subject.attributes = [];
  csr.subject.hash = null;
  csr.publicKey = null;
  csr.attributes = [];
  csr.getAttribute = function(sn) {
    return _getAttribute(csr, sn);
  };
  csr.addAttribute = function(attr) {
    _fillMissingFields([attr]);
    csr.attributes.push(attr);
  };
  csr.md = null;
  csr.setSubject = function(attrs) {
    _fillMissingFields(attrs);
    csr.subject.attributes = attrs;
    csr.subject.hash = null;
  };
  csr.setAttributes = function(attrs) {
    _fillMissingFields(attrs);
    csr.attributes = attrs;
  };
  csr.sign = function(key, md) {
    csr.md = md || forge$1.md.sha1.create();
    var algorithmOid = oids[csr.md.algorithm + "WithRSAEncryption"];
    if (!algorithmOid) {
      var error2 = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
      error2.algorithm = csr.md.algorithm;
      throw error2;
    }
    csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;
    csr.certificationRequestInfo = pki$1.getCertificationRequestInfo(csr);
    var bytes2 = asn1$1.toDer(csr.certificationRequestInfo);
    csr.md.update(bytes2.getBytes());
    csr.signature = key.sign(csr.md);
  };
  csr.verify = function() {
    var rval = false;
    var md = csr.md;
    if (md === null) {
      md = _createSignatureDigest({
        signatureOid: csr.signatureOid,
        type: "certification request"
      });
      var cri = csr.certificationRequestInfo || pki$1.getCertificationRequestInfo(csr);
      var bytes2 = asn1$1.toDer(cri);
      md.update(bytes2.getBytes());
    }
    if (md !== null) {
      rval = _verifySignature({
        certificate: csr,
        md,
        signature: csr.signature
      });
    }
    return rval;
  };
  return csr;
};
function _dnToAsn1(obj) {
  var rval = asn1$1.create(
    asn1$1.Class.UNIVERSAL,
    asn1$1.Type.SEQUENCE,
    true,
    []
  );
  var attr, set2;
  var attrs = obj.attributes;
  for (var i2 = 0; i2 < attrs.length; ++i2) {
    attr = attrs[i2];
    var value2 = attr.value;
    var valueTagClass = asn1$1.Type.PRINTABLESTRING;
    if ("valueTagClass" in attr) {
      valueTagClass = attr.valueTagClass;
      if (valueTagClass === asn1$1.Type.UTF8) {
        value2 = forge$1.util.encodeUtf8(value2);
      }
    }
    set2 = asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SET, true, [
      asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
        asn1$1.create(
          asn1$1.Class.UNIVERSAL,
          asn1$1.Type.OID,
          false,
          asn1$1.oidToDer(attr.type).getBytes()
        ),
        asn1$1.create(asn1$1.Class.UNIVERSAL, valueTagClass, false, value2)
      ])
    ]);
    rval.value.push(set2);
  }
  return rval;
}
function _fillMissingFields(attrs) {
  var attr;
  for (var i2 = 0; i2 < attrs.length; ++i2) {
    attr = attrs[i2];
    if (typeof attr.name === "undefined") {
      if (attr.type && attr.type in pki$1.oids) {
        attr.name = pki$1.oids[attr.type];
      } else if (attr.shortName && attr.shortName in _shortNames) {
        attr.name = pki$1.oids[_shortNames[attr.shortName]];
      }
    }
    if (typeof attr.type === "undefined") {
      if (attr.name && attr.name in pki$1.oids) {
        attr.type = pki$1.oids[attr.name];
      } else {
        var error2 = new Error("Attribute type not specified.");
        error2.attribute = attr;
        throw error2;
      }
    }
    if (typeof attr.shortName === "undefined") {
      if (attr.name && attr.name in _shortNames) {
        attr.shortName = _shortNames[attr.name];
      }
    }
    if (attr.type === oids.extensionRequest) {
      attr.valueConstructed = true;
      attr.valueTagClass = asn1$1.Type.SEQUENCE;
      if (!attr.value && attr.extensions) {
        attr.value = [];
        for (var ei = 0; ei < attr.extensions.length; ++ei) {
          attr.value.push(pki$1.certificateExtensionToAsn1(
            _fillMissingExtensionFields(attr.extensions[ei])
          ));
        }
      }
    }
    if (typeof attr.value === "undefined") {
      var error2 = new Error("Attribute value not specified.");
      error2.attribute = attr;
      throw error2;
    }
  }
}
function _fillMissingExtensionFields(e, options) {
  options = options || {};
  if (typeof e.name === "undefined") {
    if (e.id && e.id in pki$1.oids) {
      e.name = pki$1.oids[e.id];
    }
  }
  if (typeof e.id === "undefined") {
    if (e.name && e.name in pki$1.oids) {
      e.id = pki$1.oids[e.name];
    } else {
      var error2 = new Error("Extension ID not specified.");
      error2.extension = e;
      throw error2;
    }
  }
  if (typeof e.value !== "undefined") {
    return e;
  }
  if (e.name === "keyUsage") {
    var unused = 0;
    var b2 = 0;
    var b3 = 0;
    if (e.digitalSignature) {
      b2 |= 128;
      unused = 7;
    }
    if (e.nonRepudiation) {
      b2 |= 64;
      unused = 6;
    }
    if (e.keyEncipherment) {
      b2 |= 32;
      unused = 5;
    }
    if (e.dataEncipherment) {
      b2 |= 16;
      unused = 4;
    }
    if (e.keyAgreement) {
      b2 |= 8;
      unused = 3;
    }
    if (e.keyCertSign) {
      b2 |= 4;
      unused = 2;
    }
    if (e.cRLSign) {
      b2 |= 2;
      unused = 1;
    }
    if (e.encipherOnly) {
      b2 |= 1;
      unused = 0;
    }
    if (e.decipherOnly) {
      b3 |= 128;
      unused = 7;
    }
    var value2 = String.fromCharCode(unused);
    if (b3 !== 0) {
      value2 += String.fromCharCode(b2) + String.fromCharCode(b3);
    } else if (b2 !== 0) {
      value2 += String.fromCharCode(b2);
    }
    e.value = asn1$1.create(
      asn1$1.Class.UNIVERSAL,
      asn1$1.Type.BITSTRING,
      false,
      value2
    );
  } else if (e.name === "basicConstraints") {
    e.value = asn1$1.create(
      asn1$1.Class.UNIVERSAL,
      asn1$1.Type.SEQUENCE,
      true,
      []
    );
    if (e.cA) {
      e.value.value.push(asn1$1.create(
        asn1$1.Class.UNIVERSAL,
        asn1$1.Type.BOOLEAN,
        false,
        String.fromCharCode(255)
      ));
    }
    if ("pathLenConstraint" in e) {
      e.value.value.push(asn1$1.create(
        asn1$1.Class.UNIVERSAL,
        asn1$1.Type.INTEGER,
        false,
        asn1$1.integerToDer(e.pathLenConstraint).getBytes()
      ));
    }
  } else if (e.name === "extKeyUsage") {
    e.value = asn1$1.create(
      asn1$1.Class.UNIVERSAL,
      asn1$1.Type.SEQUENCE,
      true,
      []
    );
    var seq = e.value.value;
    for (var key in e) {
      if (e[key] !== true) {
        continue;
      }
      if (key in oids) {
        seq.push(asn1$1.create(
          asn1$1.Class.UNIVERSAL,
          asn1$1.Type.OID,
          false,
          asn1$1.oidToDer(oids[key]).getBytes()
        ));
      } else if (key.indexOf(".") !== -1) {
        seq.push(asn1$1.create(
          asn1$1.Class.UNIVERSAL,
          asn1$1.Type.OID,
          false,
          asn1$1.oidToDer(key).getBytes()
        ));
      }
    }
  } else if (e.name === "nsCertType") {
    var unused = 0;
    var b2 = 0;
    if (e.client) {
      b2 |= 128;
      unused = 7;
    }
    if (e.server) {
      b2 |= 64;
      unused = 6;
    }
    if (e.email) {
      b2 |= 32;
      unused = 5;
    }
    if (e.objsign) {
      b2 |= 16;
      unused = 4;
    }
    if (e.reserved) {
      b2 |= 8;
      unused = 3;
    }
    if (e.sslCA) {
      b2 |= 4;
      unused = 2;
    }
    if (e.emailCA) {
      b2 |= 2;
      unused = 1;
    }
    if (e.objCA) {
      b2 |= 1;
      unused = 0;
    }
    var value2 = String.fromCharCode(unused);
    if (b2 !== 0) {
      value2 += String.fromCharCode(b2);
    }
    e.value = asn1$1.create(
      asn1$1.Class.UNIVERSAL,
      asn1$1.Type.BITSTRING,
      false,
      value2
    );
  } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
    e.value = asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, []);
    var altName;
    for (var n = 0; n < e.altNames.length; ++n) {
      altName = e.altNames[n];
      var value2 = altName.value;
      if (altName.type === 7 && altName.ip) {
        value2 = forge$1.util.bytesFromIP(altName.ip);
        if (value2 === null) {
          var error2 = new Error(
            'Extension "ip" value is not a valid IPv4 or IPv6 address.'
          );
          error2.extension = e;
          throw error2;
        }
      } else if (altName.type === 8) {
        if (altName.oid) {
          value2 = asn1$1.oidToDer(asn1$1.oidToDer(altName.oid));
        } else {
          value2 = asn1$1.oidToDer(value2);
        }
      }
      e.value.value.push(asn1$1.create(
        asn1$1.Class.CONTEXT_SPECIFIC,
        altName.type,
        false,
        value2
      ));
    }
  } else if (e.name === "nsComment" && options.cert) {
    if (!/^[\x00-\x7F]*$/.test(e.comment) || e.comment.length < 1 || e.comment.length > 128) {
      throw new Error('Invalid "nsComment" content.');
    }
    e.value = asn1$1.create(
      asn1$1.Class.UNIVERSAL,
      asn1$1.Type.IA5STRING,
      false,
      e.comment
    );
  } else if (e.name === "subjectKeyIdentifier" && options.cert) {
    var ski = options.cert.generateSubjectKeyIdentifier();
    e.subjectKeyIdentifier = ski.toHex();
    e.value = asn1$1.create(
      asn1$1.Class.UNIVERSAL,
      asn1$1.Type.OCTETSTRING,
      false,
      ski.getBytes()
    );
  } else if (e.name === "authorityKeyIdentifier" && options.cert) {
    e.value = asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, []);
    var seq = e.value.value;
    if (e.keyIdentifier) {
      var keyIdentifier = e.keyIdentifier === true ? options.cert.generateSubjectKeyIdentifier().getBytes() : e.keyIdentifier;
      seq.push(
        asn1$1.create(asn1$1.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier)
      );
    }
    if (e.authorityCertIssuer) {
      var authorityCertIssuer = [
        asn1$1.create(asn1$1.Class.CONTEXT_SPECIFIC, 4, true, [
          _dnToAsn1(e.authorityCertIssuer === true ? options.cert.issuer : e.authorityCertIssuer)
        ])
      ];
      seq.push(
        asn1$1.create(asn1$1.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer)
      );
    }
    if (e.serialNumber) {
      var serialNumber = forge$1.util.hexToBytes(e.serialNumber === true ? options.cert.serialNumber : e.serialNumber);
      seq.push(
        asn1$1.create(asn1$1.Class.CONTEXT_SPECIFIC, 2, false, serialNumber)
      );
    }
  } else if (e.name === "cRLDistributionPoints") {
    e.value = asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, []);
    var seq = e.value.value;
    var subSeq = asn1$1.create(
      asn1$1.Class.UNIVERSAL,
      asn1$1.Type.SEQUENCE,
      true,
      []
    );
    var fullNameGeneralNames = asn1$1.create(
      asn1$1.Class.CONTEXT_SPECIFIC,
      0,
      true,
      []
    );
    var altName;
    for (var n = 0; n < e.altNames.length; ++n) {
      altName = e.altNames[n];
      var value2 = altName.value;
      if (altName.type === 7 && altName.ip) {
        value2 = forge$1.util.bytesFromIP(altName.ip);
        if (value2 === null) {
          var error2 = new Error(
            'Extension "ip" value is not a valid IPv4 or IPv6 address.'
          );
          error2.extension = e;
          throw error2;
        }
      } else if (altName.type === 8) {
        if (altName.oid) {
          value2 = asn1$1.oidToDer(asn1$1.oidToDer(altName.oid));
        } else {
          value2 = asn1$1.oidToDer(value2);
        }
      }
      fullNameGeneralNames.value.push(asn1$1.create(
        asn1$1.Class.CONTEXT_SPECIFIC,
        altName.type,
        false,
        value2
      ));
    }
    subSeq.value.push(asn1$1.create(
      asn1$1.Class.CONTEXT_SPECIFIC,
      0,
      true,
      [fullNameGeneralNames]
    ));
    seq.push(subSeq);
  }
  if (typeof e.value === "undefined") {
    var error2 = new Error("Extension value not specified.");
    error2.extension = e;
    throw error2;
  }
  return e;
}
function _signatureParametersToAsn1(oid, params) {
  switch (oid) {
    case oids["RSASSA-PSS"]:
      var parts2 = [];
      if (params.hash.algorithmOid !== void 0) {
        parts2.push(asn1$1.create(asn1$1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
            asn1$1.create(
              asn1$1.Class.UNIVERSAL,
              asn1$1.Type.OID,
              false,
              asn1$1.oidToDer(params.hash.algorithmOid).getBytes()
            ),
            asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.NULL, false, "")
          ])
        ]));
      }
      if (params.mgf.algorithmOid !== void 0) {
        parts2.push(asn1$1.create(asn1$1.Class.CONTEXT_SPECIFIC, 1, true, [
          asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
            asn1$1.create(
              asn1$1.Class.UNIVERSAL,
              asn1$1.Type.OID,
              false,
              asn1$1.oidToDer(params.mgf.algorithmOid).getBytes()
            ),
            asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
              asn1$1.create(
                asn1$1.Class.UNIVERSAL,
                asn1$1.Type.OID,
                false,
                asn1$1.oidToDer(params.mgf.hash.algorithmOid).getBytes()
              ),
              asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.NULL, false, "")
            ])
          ])
        ]));
      }
      if (params.saltLength !== void 0) {
        parts2.push(asn1$1.create(asn1$1.Class.CONTEXT_SPECIFIC, 2, true, [
          asn1$1.create(
            asn1$1.Class.UNIVERSAL,
            asn1$1.Type.INTEGER,
            false,
            asn1$1.integerToDer(params.saltLength).getBytes()
          )
        ]));
      }
      return asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, parts2);
    default:
      return asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.NULL, false, "");
  }
}
function _CRIAttributesToAsn1(csr) {
  var rval = asn1$1.create(asn1$1.Class.CONTEXT_SPECIFIC, 0, true, []);
  if (csr.attributes.length === 0) {
    return rval;
  }
  var attrs = csr.attributes;
  for (var i2 = 0; i2 < attrs.length; ++i2) {
    var attr = attrs[i2];
    var value2 = attr.value;
    var valueTagClass = asn1$1.Type.UTF8;
    if ("valueTagClass" in attr) {
      valueTagClass = attr.valueTagClass;
    }
    if (valueTagClass === asn1$1.Type.UTF8) {
      value2 = forge$1.util.encodeUtf8(value2);
    }
    var valueConstructed = false;
    if ("valueConstructed" in attr) {
      valueConstructed = attr.valueConstructed;
    }
    var seq = asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
      asn1$1.create(
        asn1$1.Class.UNIVERSAL,
        asn1$1.Type.OID,
        false,
        asn1$1.oidToDer(attr.type).getBytes()
      ),
      asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SET, true, [
        asn1$1.create(
          asn1$1.Class.UNIVERSAL,
          valueTagClass,
          valueConstructed,
          value2
        )
      ])
    ]);
    rval.value.push(seq);
  }
  return rval;
}
var jan_1_1950 = new Date("1950-01-01T00:00:00Z");
var jan_1_2050 = new Date("2050-01-01T00:00:00Z");
function _dateToAsn1(date) {
  if (date >= jan_1_1950 && date < jan_1_2050) {
    return asn1$1.create(
      asn1$1.Class.UNIVERSAL,
      asn1$1.Type.UTCTIME,
      false,
      asn1$1.dateToUtcTime(date)
    );
  } else {
    return asn1$1.create(
      asn1$1.Class.UNIVERSAL,
      asn1$1.Type.GENERALIZEDTIME,
      false,
      asn1$1.dateToGeneralizedTime(date)
    );
  }
}
pki$1.getTBSCertificate = function(cert) {
  var notBefore = _dateToAsn1(cert.validity.notBefore);
  var notAfter = _dateToAsn1(cert.validity.notAfter);
  var tbs = asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
    asn1$1.create(asn1$1.Class.CONTEXT_SPECIFIC, 0, true, [
      asn1$1.create(
        asn1$1.Class.UNIVERSAL,
        asn1$1.Type.INTEGER,
        false,
        asn1$1.integerToDer(cert.version).getBytes()
      )
    ]),
    asn1$1.create(
      asn1$1.Class.UNIVERSAL,
      asn1$1.Type.INTEGER,
      false,
      forge$1.util.hexToBytes(cert.serialNumber)
    ),
    asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
      asn1$1.create(
        asn1$1.Class.UNIVERSAL,
        asn1$1.Type.OID,
        false,
        asn1$1.oidToDer(cert.siginfo.algorithmOid).getBytes()
      ),
      _signatureParametersToAsn1(
        cert.siginfo.algorithmOid,
        cert.siginfo.parameters
      )
    ]),
    _dnToAsn1(cert.issuer),
    asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
      notBefore,
      notAfter
    ]),
    _dnToAsn1(cert.subject),
    pki$1.publicKeyToAsn1(cert.publicKey)
  ]);
  if (cert.issuer.uniqueId) {
    tbs.value.push(
      asn1$1.create(asn1$1.Class.CONTEXT_SPECIFIC, 1, true, [
        asn1$1.create(
          asn1$1.Class.UNIVERSAL,
          asn1$1.Type.BITSTRING,
          false,
          String.fromCharCode(0) + cert.issuer.uniqueId
        )
      ])
    );
  }
  if (cert.subject.uniqueId) {
    tbs.value.push(
      asn1$1.create(asn1$1.Class.CONTEXT_SPECIFIC, 2, true, [
        asn1$1.create(
          asn1$1.Class.UNIVERSAL,
          asn1$1.Type.BITSTRING,
          false,
          String.fromCharCode(0) + cert.subject.uniqueId
        )
      ])
    );
  }
  if (cert.extensions.length > 0) {
    tbs.value.push(pki$1.certificateExtensionsToAsn1(cert.extensions));
  }
  return tbs;
};
pki$1.getCertificationRequestInfo = function(csr) {
  var cri = asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
    asn1$1.create(
      asn1$1.Class.UNIVERSAL,
      asn1$1.Type.INTEGER,
      false,
      asn1$1.integerToDer(csr.version).getBytes()
    ),
    _dnToAsn1(csr.subject),
    pki$1.publicKeyToAsn1(csr.publicKey),
    _CRIAttributesToAsn1(csr)
  ]);
  return cri;
};
pki$1.distinguishedNameToAsn1 = function(dn) {
  return _dnToAsn1(dn);
};
pki$1.certificateToAsn1 = function(cert) {
  var tbsCertificate = cert.tbsCertificate || pki$1.getTBSCertificate(cert);
  return asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
    tbsCertificate,
    asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
      asn1$1.create(
        asn1$1.Class.UNIVERSAL,
        asn1$1.Type.OID,
        false,
        asn1$1.oidToDer(cert.signatureOid).getBytes()
      ),
      _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)
    ]),
    asn1$1.create(
      asn1$1.Class.UNIVERSAL,
      asn1$1.Type.BITSTRING,
      false,
      String.fromCharCode(0) + cert.signature
    )
  ]);
};
pki$1.certificateExtensionsToAsn1 = function(exts) {
  var rval = asn1$1.create(asn1$1.Class.CONTEXT_SPECIFIC, 3, true, []);
  var seq = asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, []);
  rval.value.push(seq);
  for (var i2 = 0; i2 < exts.length; ++i2) {
    seq.value.push(pki$1.certificateExtensionToAsn1(exts[i2]));
  }
  return rval;
};
pki$1.certificateExtensionToAsn1 = function(ext) {
  var extseq = asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, []);
  extseq.value.push(asn1$1.create(
    asn1$1.Class.UNIVERSAL,
    asn1$1.Type.OID,
    false,
    asn1$1.oidToDer(ext.id).getBytes()
  ));
  if (ext.critical) {
    extseq.value.push(asn1$1.create(
      asn1$1.Class.UNIVERSAL,
      asn1$1.Type.BOOLEAN,
      false,
      String.fromCharCode(255)
    ));
  }
  var value2 = ext.value;
  if (typeof ext.value !== "string") {
    value2 = asn1$1.toDer(value2).getBytes();
  }
  extseq.value.push(asn1$1.create(
    asn1$1.Class.UNIVERSAL,
    asn1$1.Type.OCTETSTRING,
    false,
    value2
  ));
  return extseq;
};
pki$1.certificationRequestToAsn1 = function(csr) {
  var cri = csr.certificationRequestInfo || pki$1.getCertificationRequestInfo(csr);
  return asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
    cri,
    asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
      asn1$1.create(
        asn1$1.Class.UNIVERSAL,
        asn1$1.Type.OID,
        false,
        asn1$1.oidToDer(csr.signatureOid).getBytes()
      ),
      _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)
    ]),
    asn1$1.create(
      asn1$1.Class.UNIVERSAL,
      asn1$1.Type.BITSTRING,
      false,
      String.fromCharCode(0) + csr.signature
    )
  ]);
};
pki$1.createCaStore = function(certs) {
  var caStore = {
    certs: {}
  };
  caStore.getIssuer = function(cert2) {
    var rval = getBySubject(cert2.issuer);
    return rval;
  };
  caStore.addCertificate = function(cert2) {
    if (typeof cert2 === "string") {
      cert2 = forge$1.pki.certificateFromPem(cert2);
    }
    ensureSubjectHasHash(cert2.subject);
    if (!caStore.hasCertificate(cert2)) {
      if (cert2.subject.hash in caStore.certs) {
        var tmp = caStore.certs[cert2.subject.hash];
        if (!forge$1.util.isArray(tmp)) {
          tmp = [tmp];
        }
        tmp.push(cert2);
        caStore.certs[cert2.subject.hash] = tmp;
      } else {
        caStore.certs[cert2.subject.hash] = cert2;
      }
    }
  };
  caStore.hasCertificate = function(cert2) {
    if (typeof cert2 === "string") {
      cert2 = forge$1.pki.certificateFromPem(cert2);
    }
    var match = getBySubject(cert2.subject);
    if (!match) {
      return false;
    }
    if (!forge$1.util.isArray(match)) {
      match = [match];
    }
    var der1 = asn1$1.toDer(pki$1.certificateToAsn1(cert2)).getBytes();
    for (var i3 = 0; i3 < match.length; ++i3) {
      var der2 = asn1$1.toDer(pki$1.certificateToAsn1(match[i3])).getBytes();
      if (der1 === der2) {
        return true;
      }
    }
    return false;
  };
  caStore.listAllCertificates = function() {
    var certList = [];
    for (var hash2 in caStore.certs) {
      if (caStore.certs.hasOwnProperty(hash2)) {
        var value2 = caStore.certs[hash2];
        if (!forge$1.util.isArray(value2)) {
          certList.push(value2);
        } else {
          for (var i3 = 0; i3 < value2.length; ++i3) {
            certList.push(value2[i3]);
          }
        }
      }
    }
    return certList;
  };
  caStore.removeCertificate = function(cert2) {
    var result;
    if (typeof cert2 === "string") {
      cert2 = forge$1.pki.certificateFromPem(cert2);
    }
    ensureSubjectHasHash(cert2.subject);
    if (!caStore.hasCertificate(cert2)) {
      return null;
    }
    var match = getBySubject(cert2.subject);
    if (!forge$1.util.isArray(match)) {
      result = caStore.certs[cert2.subject.hash];
      delete caStore.certs[cert2.subject.hash];
      return result;
    }
    var der1 = asn1$1.toDer(pki$1.certificateToAsn1(cert2)).getBytes();
    for (var i3 = 0; i3 < match.length; ++i3) {
      var der2 = asn1$1.toDer(pki$1.certificateToAsn1(match[i3])).getBytes();
      if (der1 === der2) {
        result = match[i3];
        match.splice(i3, 1);
      }
    }
    if (match.length === 0) {
      delete caStore.certs[cert2.subject.hash];
    }
    return result;
  };
  function getBySubject(subject) {
    ensureSubjectHasHash(subject);
    return caStore.certs[subject.hash] || null;
  }
  function ensureSubjectHasHash(subject) {
    if (!subject.hash) {
      var md = forge$1.md.sha1.create();
      subject.attributes = pki$1.RDNAttributesAsArray(_dnToAsn1(subject), md);
      subject.hash = md.digest().toHex();
    }
  }
  if (certs) {
    for (var i2 = 0; i2 < certs.length; ++i2) {
      var cert = certs[i2];
      caStore.addCertificate(cert);
    }
  }
  return caStore;
};
pki$1.certificateError = {
  bad_certificate: "forge.pki.BadCertificate",
  unsupported_certificate: "forge.pki.UnsupportedCertificate",
  certificate_revoked: "forge.pki.CertificateRevoked",
  certificate_expired: "forge.pki.CertificateExpired",
  certificate_unknown: "forge.pki.CertificateUnknown",
  unknown_ca: "forge.pki.UnknownCertificateAuthority"
};
pki$1.verifyCertificateChain = function(caStore, chain, options) {
  if (typeof options === "function") {
    options = { verify: options };
  }
  options = options || {};
  chain = chain.slice(0);
  var certs = chain.slice(0);
  var validityCheckDate = options.validityCheckDate;
  if (typeof validityCheckDate === "undefined") {
    validityCheckDate = new Date();
  }
  var first2 = true;
  var error2 = null;
  var depth = 0;
  do {
    var cert = chain.shift();
    var parent2 = null;
    var selfSigned = false;
    if (validityCheckDate) {
      if (validityCheckDate < cert.validity.notBefore || validityCheckDate > cert.validity.notAfter) {
        error2 = {
          message: "Certificate is not valid yet or has expired.",
          error: pki$1.certificateError.certificate_expired,
          notBefore: cert.validity.notBefore,
          notAfter: cert.validity.notAfter,
          now: validityCheckDate
        };
      }
    }
    if (error2 === null) {
      parent2 = chain[0] || caStore.getIssuer(cert);
      if (parent2 === null) {
        if (cert.isIssuer(cert)) {
          selfSigned = true;
          parent2 = cert;
        }
      }
      if (parent2) {
        var parents = parent2;
        if (!forge$1.util.isArray(parents)) {
          parents = [parents];
        }
        var verified = false;
        while (!verified && parents.length > 0) {
          parent2 = parents.shift();
          try {
            verified = parent2.verify(cert);
          } catch (ex) {
          }
        }
        if (!verified) {
          error2 = {
            message: "Certificate signature is invalid.",
            error: pki$1.certificateError.bad_certificate
          };
        }
      }
      if (error2 === null && (!parent2 || selfSigned) && !caStore.hasCertificate(cert)) {
        error2 = {
          message: "Certificate is not trusted.",
          error: pki$1.certificateError.unknown_ca
        };
      }
    }
    if (error2 === null && parent2 && !cert.isIssuer(parent2)) {
      error2 = {
        message: "Certificate issuer is invalid.",
        error: pki$1.certificateError.bad_certificate
      };
    }
    if (error2 === null) {
      var se = {
        keyUsage: true,
        basicConstraints: true
      };
      for (var i2 = 0; error2 === null && i2 < cert.extensions.length; ++i2) {
        var ext = cert.extensions[i2];
        if (ext.critical && !(ext.name in se)) {
          error2 = {
            message: "Certificate has an unsupported critical extension.",
            error: pki$1.certificateError.unsupported_certificate
          };
        }
      }
    }
    if (error2 === null && (!first2 || chain.length === 0 && (!parent2 || selfSigned))) {
      var bcExt = cert.getExtension("basicConstraints");
      var keyUsageExt = cert.getExtension("keyUsage");
      if (keyUsageExt !== null) {
        if (!keyUsageExt.keyCertSign || bcExt === null) {
          error2 = {
            message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
            error: pki$1.certificateError.bad_certificate
          };
        }
      }
      if (error2 === null && bcExt !== null && !bcExt.cA) {
        error2 = {
          message: "Certificate basicConstraints indicates the certificate is not a CA.",
          error: pki$1.certificateError.bad_certificate
        };
      }
      if (error2 === null && keyUsageExt !== null && "pathLenConstraint" in bcExt) {
        var pathLen = depth - 1;
        if (pathLen > bcExt.pathLenConstraint) {
          error2 = {
            message: "Certificate basicConstraints pathLenConstraint violated.",
            error: pki$1.certificateError.bad_certificate
          };
        }
      }
    }
    var vfd = error2 === null ? true : error2.error;
    var ret = options.verify ? options.verify(vfd, depth, certs) : vfd;
    if (ret === true) {
      error2 = null;
    } else {
      if (vfd === true) {
        error2 = {
          message: "The application rejected the certificate.",
          error: pki$1.certificateError.bad_certificate
        };
      }
      if (ret || ret === 0) {
        if (typeof ret === "object" && !forge$1.util.isArray(ret)) {
          if (ret.message) {
            error2.message = ret.message;
          }
          if (ret.error) {
            error2.error = ret.error;
          }
        } else if (typeof ret === "string") {
          error2.error = ret;
        }
      }
      throw error2;
    }
    first2 = false;
    ++depth;
  } while (chain.length > 0);
  return true;
};
var forge = forge$s;
var asn1 = forge.asn1;
var p7 = forge.pkcs7 = forge.pkcs7 || {};
p7.messageFromPem = function(pem2) {
  var msg = forge.pem.decode(pem2)[0];
  if (msg.type !== "PKCS7") {
    var error2 = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
    error2.headerType = msg.type;
    throw error2;
  }
  if (msg.procType && msg.procType.type === "ENCRYPTED") {
    throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
  }
  var obj = asn1.fromDer(msg.body);
  return p7.messageFromAsn1(obj);
};
p7.messageToPem = function(msg, maxline) {
  var pemObj = {
    type: "PKCS7",
    body: asn1.toDer(msg.toAsn1()).getBytes()
  };
  return forge.pem.encode(pemObj, { maxline });
};
p7.messageFromAsn1 = function(obj) {
  var capture = {};
  var errors2 = [];
  if (!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors2)) {
    var error2 = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
    error2.errors = errors2;
    throw error2;
  }
  var contentType = asn1.derToOid(capture.contentType);
  var msg;
  switch (contentType) {
    case forge.pki.oids.envelopedData:
      msg = p7.createEnvelopedData();
      break;
    case forge.pki.oids.encryptedData:
      msg = p7.createEncryptedData();
      break;
    case forge.pki.oids.signedData:
      msg = p7.createSignedData();
      break;
    default:
      throw new Error("Cannot read PKCS#7 message. ContentType with OID " + contentType + " is not (yet) supported.");
  }
  msg.fromAsn1(capture.content.value[0]);
  return msg;
};
p7.createSignedData = function() {
  var msg = null;
  msg = {
    type: forge.pki.oids.signedData,
    version: 1,
    certificates: [],
    crls: [],
    signers: [],
    digestAlgorithmIdentifiers: [],
    contentInfo: null,
    signerInfos: [],
    fromAsn1: function(obj) {
      _fromAsn1(msg, obj, p7.asn1.signedDataValidator);
      msg.certificates = [];
      msg.crls = [];
      msg.digestAlgorithmIdentifiers = [];
      msg.contentInfo = null;
      msg.signerInfos = [];
      if (msg.rawCapture.certificates) {
        var certs = msg.rawCapture.certificates.value;
        for (var i2 = 0; i2 < certs.length; ++i2) {
          msg.certificates.push(forge.pki.certificateFromAsn1(certs[i2]));
        }
      }
    },
    toAsn1: function() {
      if (!msg.contentInfo) {
        msg.sign();
      }
      var certs = [];
      for (var i2 = 0; i2 < msg.certificates.length; ++i2) {
        certs.push(forge.pki.certificateToAsn1(msg.certificates[i2]));
      }
      var crls = [];
      var signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            asn1.integerToDer(msg.version).getBytes()
          ),
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.SET,
            true,
            msg.digestAlgorithmIdentifiers
          ),
          msg.contentInfo
        ])
      ]);
      if (certs.length > 0) {
        signedData.value[0].value.push(
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs)
        );
      }
      if (crls.length > 0) {
        signedData.value[0].value.push(
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls)
        );
      }
      signedData.value[0].value.push(
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SET,
          true,
          msg.signerInfos
        )
      );
      return asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(msg.type).getBytes()
          ),
          signedData
        ]
      );
    },
    addSigner: function(signer) {
      var issuer = signer.issuer;
      var serialNumber = signer.serialNumber;
      if (signer.certificate) {
        var cert = signer.certificate;
        if (typeof cert === "string") {
          cert = forge.pki.certificateFromPem(cert);
        }
        issuer = cert.issuer.attributes;
        serialNumber = cert.serialNumber;
      }
      var key = signer.key;
      if (!key) {
        throw new Error(
          "Could not add PKCS#7 signer; no private key specified."
        );
      }
      if (typeof key === "string") {
        key = forge.pki.privateKeyFromPem(key);
      }
      var digestAlgorithm = signer.digestAlgorithm || forge.pki.oids.sha1;
      switch (digestAlgorithm) {
        case forge.pki.oids.sha1:
        case forge.pki.oids.sha256:
        case forge.pki.oids.sha384:
        case forge.pki.oids.sha512:
        case forge.pki.oids.md5:
          break;
        default:
          throw new Error(
            "Could not add PKCS#7 signer; unknown message digest algorithm: " + digestAlgorithm
          );
      }
      var authenticatedAttributes = signer.authenticatedAttributes || [];
      if (authenticatedAttributes.length > 0) {
        var contentType = false;
        var messageDigest = false;
        for (var i2 = 0; i2 < authenticatedAttributes.length; ++i2) {
          var attr = authenticatedAttributes[i2];
          if (!contentType && attr.type === forge.pki.oids.contentType) {
            contentType = true;
            if (messageDigest) {
              break;
            }
            continue;
          }
          if (!messageDigest && attr.type === forge.pki.oids.messageDigest) {
            messageDigest = true;
            if (contentType) {
              break;
            }
            continue;
          }
        }
        if (!contentType || !messageDigest) {
          throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
        }
      }
      msg.signers.push({
        key,
        version: 1,
        issuer,
        serialNumber,
        digestAlgorithm,
        signatureAlgorithm: forge.pki.oids.rsaEncryption,
        signature: null,
        authenticatedAttributes,
        unauthenticatedAttributes: []
      });
    },
    sign: function(options) {
      options = options || {};
      if (typeof msg.content !== "object" || msg.contentInfo === null) {
        msg.contentInfo = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(forge.pki.oids.data).getBytes()
            )
          ]
        );
        if ("content" in msg) {
          var content;
          if (msg.content instanceof forge.util.ByteBuffer) {
            content = msg.content.bytes();
          } else if (typeof msg.content === "string") {
            content = forge.util.encodeUtf8(msg.content);
          }
          if (options.detached) {
            msg.detachedContent = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content);
          } else {
            msg.contentInfo.value.push(
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OCTETSTRING,
                  false,
                  content
                )
              ])
            );
          }
        }
      }
      if (msg.signers.length === 0) {
        return;
      }
      var mds = addDigestAlgorithmIds();
      addSignerInfos(mds);
    },
    verify: function() {
      throw new Error("PKCS#7 signature verification not yet implemented.");
    },
    addCertificate: function(cert) {
      if (typeof cert === "string") {
        cert = forge.pki.certificateFromPem(cert);
      }
      msg.certificates.push(cert);
    },
    addCertificateRevokationList: function(crl) {
      throw new Error("PKCS#7 CRL support not yet implemented.");
    }
  };
  return msg;
  function addDigestAlgorithmIds() {
    var mds = {};
    for (var i2 = 0; i2 < msg.signers.length; ++i2) {
      var signer = msg.signers[i2];
      var oid = signer.digestAlgorithm;
      if (!(oid in mds)) {
        mds[oid] = forge.md[forge.pki.oids[oid]].create();
      }
      if (signer.authenticatedAttributes.length === 0) {
        signer.md = mds[oid];
      } else {
        signer.md = forge.md[forge.pki.oids[oid]].create();
      }
    }
    msg.digestAlgorithmIdentifiers = [];
    for (var oid in mds) {
      msg.digestAlgorithmIdentifiers.push(
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(oid).getBytes()
          ),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ])
      );
    }
    return mds;
  }
  function addSignerInfos(mds) {
    var content;
    if (msg.detachedContent) {
      content = msg.detachedContent;
    } else {
      content = msg.contentInfo.value[1];
      content = content.value[0];
    }
    if (!content) {
      throw new Error(
        "Could not sign PKCS#7 message; there is no content to sign."
      );
    }
    var contentType = asn1.derToOid(msg.contentInfo.value[0].value);
    var bytes2 = asn1.toDer(content);
    bytes2.getByte();
    asn1.getBerValueLength(bytes2);
    bytes2 = bytes2.getBytes();
    for (var oid in mds) {
      mds[oid].start().update(bytes2);
    }
    var signingTime = new Date();
    for (var i2 = 0; i2 < msg.signers.length; ++i2) {
      var signer = msg.signers[i2];
      if (signer.authenticatedAttributes.length === 0) {
        if (contentType !== forge.pki.oids.data) {
          throw new Error(
            "Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data."
          );
        }
      } else {
        signer.authenticatedAttributesAsn1 = asn1.create(
          asn1.Class.CONTEXT_SPECIFIC,
          0,
          true,
          []
        );
        var attrsAsn1 = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SET,
          true,
          []
        );
        for (var ai = 0; ai < signer.authenticatedAttributes.length; ++ai) {
          var attr = signer.authenticatedAttributes[ai];
          if (attr.type === forge.pki.oids.messageDigest) {
            attr.value = mds[signer.digestAlgorithm].digest();
          } else if (attr.type === forge.pki.oids.signingTime) {
            if (!attr.value) {
              attr.value = signingTime;
            }
          }
          attrsAsn1.value.push(_attributeToAsn1(attr));
          signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));
        }
        bytes2 = asn1.toDer(attrsAsn1).getBytes();
        signer.md.start().update(bytes2);
      }
      signer.signature = signer.key.sign(signer.md, "RSASSA-PKCS1-V1_5");
    }
    msg.signerInfos = _signersToAsn1(msg.signers);
  }
};
p7.createEncryptedData = function() {
  var msg = null;
  msg = {
    type: forge.pki.oids.encryptedData,
    version: 0,
    encryptedContent: {
      algorithm: forge.pki.oids["aes256-CBC"]
    },
    fromAsn1: function(obj) {
      _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);
    },
    decrypt: function(key) {
      if (key !== void 0) {
        msg.encryptedContent.key = key;
      }
      _decryptContent(msg);
    }
  };
  return msg;
};
p7.createEnvelopedData = function() {
  var msg = null;
  msg = {
    type: forge.pki.oids.envelopedData,
    version: 0,
    recipients: [],
    encryptedContent: {
      algorithm: forge.pki.oids["aes256-CBC"]
    },
    fromAsn1: function(obj) {
      var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);
      msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);
    },
    toAsn1: function() {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(msg.type).getBytes()
        ),
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.INTEGER,
              false,
              asn1.integerToDer(msg.version).getBytes()
            ),
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SET,
              true,
              _recipientsToAsn1(msg.recipients)
            ),
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SEQUENCE,
              true,
              _encryptedContentToAsn1(msg.encryptedContent)
            )
          ])
        ])
      ]);
    },
    findRecipient: function(cert) {
      var sAttr = cert.issuer.attributes;
      for (var i2 = 0; i2 < msg.recipients.length; ++i2) {
        var r = msg.recipients[i2];
        var rAttr = r.issuer;
        if (r.serialNumber !== cert.serialNumber) {
          continue;
        }
        if (rAttr.length !== sAttr.length) {
          continue;
        }
        var match = true;
        for (var j = 0; j < sAttr.length; ++j) {
          if (rAttr[j].type !== sAttr[j].type || rAttr[j].value !== sAttr[j].value) {
            match = false;
            break;
          }
        }
        if (match) {
          return r;
        }
      }
      return null;
    },
    decrypt: function(recipient, privKey) {
      if (msg.encryptedContent.key === void 0 && recipient !== void 0 && privKey !== void 0) {
        switch (recipient.encryptedContent.algorithm) {
          case forge.pki.oids.rsaEncryption:
          case forge.pki.oids.desCBC:
            var key = privKey.decrypt(recipient.encryptedContent.content);
            msg.encryptedContent.key = forge.util.createBuffer(key);
            break;
          default:
            throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
        }
      }
      _decryptContent(msg);
    },
    addRecipient: function(cert) {
      msg.recipients.push({
        version: 0,
        issuer: cert.issuer.attributes,
        serialNumber: cert.serialNumber,
        encryptedContent: {
          algorithm: forge.pki.oids.rsaEncryption,
          key: cert.publicKey
        }
      });
    },
    encrypt: function(key, cipher) {
      if (msg.encryptedContent.content === void 0) {
        cipher = cipher || msg.encryptedContent.algorithm;
        key = key || msg.encryptedContent.key;
        var keyLen, ivLen, ciphFn;
        switch (cipher) {
          case forge.pki.oids["aes128-CBC"]:
            keyLen = 16;
            ivLen = 16;
            ciphFn = forge.aes.createEncryptionCipher;
            break;
          case forge.pki.oids["aes192-CBC"]:
            keyLen = 24;
            ivLen = 16;
            ciphFn = forge.aes.createEncryptionCipher;
            break;
          case forge.pki.oids["aes256-CBC"]:
            keyLen = 32;
            ivLen = 16;
            ciphFn = forge.aes.createEncryptionCipher;
            break;
          case forge.pki.oids["des-EDE3-CBC"]:
            keyLen = 24;
            ivLen = 8;
            ciphFn = forge.des.createEncryptionCipher;
            break;
          default:
            throw new Error("Unsupported symmetric cipher, OID " + cipher);
        }
        if (key === void 0) {
          key = forge.util.createBuffer(forge.random.getBytes(keyLen));
        } else if (key.length() != keyLen) {
          throw new Error("Symmetric key has wrong length; got " + key.length() + " bytes, expected " + keyLen + ".");
        }
        msg.encryptedContent.algorithm = cipher;
        msg.encryptedContent.key = key;
        msg.encryptedContent.parameter = forge.util.createBuffer(
          forge.random.getBytes(ivLen)
        );
        var ciph = ciphFn(key);
        ciph.start(msg.encryptedContent.parameter.copy());
        ciph.update(msg.content);
        if (!ciph.finish()) {
          throw new Error("Symmetric encryption failed.");
        }
        msg.encryptedContent.content = ciph.output;
      }
      for (var i2 = 0; i2 < msg.recipients.length; ++i2) {
        var recipient = msg.recipients[i2];
        if (recipient.encryptedContent.content !== void 0) {
          continue;
        }
        switch (recipient.encryptedContent.algorithm) {
          case forge.pki.oids.rsaEncryption:
            recipient.encryptedContent.content = recipient.encryptedContent.key.encrypt(
              msg.encryptedContent.key.data
            );
            break;
          default:
            throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
        }
      }
    }
  };
  return msg;
};
function _recipientFromAsn1(obj) {
  var capture = {};
  var errors2 = [];
  if (!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors2)) {
    var error2 = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
    error2.errors = errors2;
    throw error2;
  }
  return {
    version: capture.version.charCodeAt(0),
    issuer: forge.pki.RDNAttributesAsArray(capture.issuer),
    serialNumber: forge.util.createBuffer(capture.serial).toHex(),
    encryptedContent: {
      algorithm: asn1.derToOid(capture.encAlgorithm),
      parameter: capture.encParameter ? capture.encParameter.value : void 0,
      content: capture.encKey
    }
  };
}
function _recipientToAsn1(obj) {
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.INTEGER,
      false,
      asn1.integerToDer(obj.version).getBytes()
    ),
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      forge.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
      asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.INTEGER,
        false,
        forge.util.hexToBytes(obj.serialNumber)
      )
    ]),
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        false,
        asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()
      ),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
    ]),
    asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.OCTETSTRING,
      false,
      obj.encryptedContent.content
    )
  ]);
}
function _recipientsFromAsn1(infos) {
  var ret = [];
  for (var i2 = 0; i2 < infos.length; ++i2) {
    ret.push(_recipientFromAsn1(infos[i2]));
  }
  return ret;
}
function _recipientsToAsn1(recipients) {
  var ret = [];
  for (var i2 = 0; i2 < recipients.length; ++i2) {
    ret.push(_recipientToAsn1(recipients[i2]));
  }
  return ret;
}
function _signerToAsn1(obj) {
  var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.INTEGER,
      false,
      asn1.integerToDer(obj.version).getBytes()
    ),
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      forge.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
      asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.INTEGER,
        false,
        forge.util.hexToBytes(obj.serialNumber)
      )
    ]),
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        false,
        asn1.oidToDer(obj.digestAlgorithm).getBytes()
      ),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
    ])
  ]);
  if (obj.authenticatedAttributesAsn1) {
    rval.value.push(obj.authenticatedAttributesAsn1);
  }
  rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.OID,
      false,
      asn1.oidToDer(obj.signatureAlgorithm).getBytes()
    ),
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
  ]));
  rval.value.push(asn1.create(
    asn1.Class.UNIVERSAL,
    asn1.Type.OCTETSTRING,
    false,
    obj.signature
  ));
  if (obj.unauthenticatedAttributes.length > 0) {
    var attrsAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, []);
    for (var i2 = 0; i2 < obj.unauthenticatedAttributes.length; ++i2) {
      var attr = obj.unauthenticatedAttributes[i2];
      attrsAsn1.values.push(_attributeToAsn1(attr));
    }
    rval.value.push(attrsAsn1);
  }
  return rval;
}
function _signersToAsn1(signers) {
  var ret = [];
  for (var i2 = 0; i2 < signers.length; ++i2) {
    ret.push(_signerToAsn1(signers[i2]));
  }
  return ret;
}
function _attributeToAsn1(attr) {
  var value2;
  if (attr.type === forge.pki.oids.contentType) {
    value2 = asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.OID,
      false,
      asn1.oidToDer(attr.value).getBytes()
    );
  } else if (attr.type === forge.pki.oids.messageDigest) {
    value2 = asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.OCTETSTRING,
      false,
      attr.value.bytes()
    );
  } else if (attr.type === forge.pki.oids.signingTime) {
    var jan_1_19502 = new Date("1950-01-01T00:00:00Z");
    var jan_1_20502 = new Date("2050-01-01T00:00:00Z");
    var date = attr.value;
    if (typeof date === "string") {
      var timestamp2 = Date.parse(date);
      if (!isNaN(timestamp2)) {
        date = new Date(timestamp2);
      } else if (date.length === 13) {
        date = asn1.utcTimeToDate(date);
      } else {
        date = asn1.generalizedTimeToDate(date);
      }
    }
    if (date >= jan_1_19502 && date < jan_1_20502) {
      value2 = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.UTCTIME,
        false,
        asn1.dateToUtcTime(date)
      );
    } else {
      value2 = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.GENERALIZEDTIME,
        false,
        asn1.dateToGeneralizedTime(date)
      );
    }
  }
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.OID,
      false,
      asn1.oidToDer(attr.type).getBytes()
    ),
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
      value2
    ])
  ]);
}
function _encryptedContentToAsn1(ec) {
  return [
    asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.OID,
      false,
      asn1.oidToDer(forge.pki.oids.data).getBytes()
    ),
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        false,
        asn1.oidToDer(ec.algorithm).getBytes()
      ),
      !ec.parameter ? void 0 : asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        ec.parameter.getBytes()
      )
    ]),
    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
      asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        ec.content.getBytes()
      )
    ])
  ];
}
function _fromAsn1(msg, obj, validator) {
  var capture = {};
  var errors2 = [];
  if (!asn1.validate(obj, validator, capture, errors2)) {
    var error2 = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
    error2.errors = error2;
    throw error2;
  }
  var contentType = asn1.derToOid(capture.contentType);
  if (contentType !== forge.pki.oids.data) {
    throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
  }
  if (capture.encryptedContent) {
    var content = "";
    if (forge.util.isArray(capture.encryptedContent)) {
      for (var i2 = 0; i2 < capture.encryptedContent.length; ++i2) {
        if (capture.encryptedContent[i2].type !== asn1.Type.OCTETSTRING) {
          throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
        }
        content += capture.encryptedContent[i2].value;
      }
    } else {
      content = capture.encryptedContent;
    }
    msg.encryptedContent = {
      algorithm: asn1.derToOid(capture.encAlgorithm),
      parameter: forge.util.createBuffer(capture.encParameter.value),
      content: forge.util.createBuffer(content)
    };
  }
  if (capture.content) {
    var content = "";
    if (forge.util.isArray(capture.content)) {
      for (var i2 = 0; i2 < capture.content.length; ++i2) {
        if (capture.content[i2].type !== asn1.Type.OCTETSTRING) {
          throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
        }
        content += capture.content[i2].value;
      }
    } else {
      content = capture.content;
    }
    msg.content = forge.util.createBuffer(content);
  }
  msg.version = capture.version.charCodeAt(0);
  msg.rawCapture = capture;
  return capture;
}
function _decryptContent(msg) {
  if (msg.encryptedContent.key === void 0) {
    throw new Error("Symmetric key not available.");
  }
  if (msg.content === void 0) {
    var ciph;
    switch (msg.encryptedContent.algorithm) {
      case forge.pki.oids["aes128-CBC"]:
      case forge.pki.oids["aes192-CBC"]:
      case forge.pki.oids["aes256-CBC"]:
        ciph = forge.aes.createDecryptionCipher(msg.encryptedContent.key);
        break;
      case forge.pki.oids["desCBC"]:
      case forge.pki.oids["des-EDE3-CBC"]:
        ciph = forge.des.createDecryptionCipher(msg.encryptedContent.key);
        break;
      default:
        throw new Error("Unsupported symmetric cipher, OID " + msg.encryptedContent.algorithm);
    }
    ciph.start(msg.encryptedContent.parameter);
    ciph.update(msg.encryptedContent.content);
    if (!ciph.finish()) {
      throw new Error("Symmetric decryption failed.");
    }
    msg.content = ciph.output;
  }
}
const pki = forge$s.pki;
const certificateForKey = (key, privateKey) => {
  const publicKey = pki.rsa.setPublicKey(privateKey.n, privateKey.e);
  const cert = pki.createCertificate();
  cert.publicKey = publicKey;
  cert.serialNumber = "01";
  cert.validity.notBefore = new Date();
  cert.validity.notAfter = new Date();
  cert.validity.notAfter.setFullYear(cert.validity.notBefore.getFullYear() + 10);
  const attrs = [{
    name: "organizationName",
    value: "ipfs"
  }, {
    shortName: "OU",
    value: "keystore"
  }, {
    name: "commonName",
    value: key.id
  }];
  cert.setSubject(attrs);
  cert.setIssuer(attrs);
  cert.setExtensions([{
    name: "basicConstraints",
    cA: true
  }, {
    name: "keyUsage",
    keyCertSign: true,
    digitalSignature: true,
    nonRepudiation: true,
    keyEncipherment: true,
    dataEncipherment: true
  }, {
    name: "extKeyUsage",
    serverAuth: true,
    clientAuth: true,
    codeSigning: true,
    emailProtection: true,
    timeStamping: true
  }, {
    name: "nsCertType",
    client: true,
    server: true,
    email: true,
    objsign: true,
    sslCA: true,
    emailCA: true,
    objCA: true
  }]);
  cert.sign(privateKey);
  return cert;
};
async function findAsync(array, asyncCompare) {
  const promises = array.map(asyncCompare);
  const results = await Promise.all(promises);
  const index = results.findIndex((result) => result);
  return array[index];
}
const log$B = logger$1("libp2p:keychain:cms");
const privates$1 = /* @__PURE__ */ new WeakMap();
class CMS {
  constructor(keychain, dek) {
    if (keychain == null) {
      throw errCode(new Error("keychain is required"), codes$1.ERR_KEYCHAIN_REQUIRED);
    }
    this.keychain = keychain;
    privates$1.set(this, { dek });
  }
  async encrypt(name2, plain) {
    if (!(plain instanceof Uint8Array)) {
      throw errCode(new Error("Plain data must be a Uint8Array"), codes$1.ERR_INVALID_PARAMETERS);
    }
    const key = await this.keychain.findKeyByName(name2);
    const pem2 = await this.keychain.getPrivateKey(name2);
    const cached = privates$1.get(this);
    if (cached == null) {
      throw errCode(new Error("dek missing"), codes$1.ERR_INVALID_PARAMETERS);
    }
    const dek = cached.dek;
    const privateKey = forge$s.pki.decryptRsaPrivateKey(pem2, dek);
    const certificate = await certificateForKey(key, privateKey);
    const p72 = forge$s.pkcs7.createEnvelopedData();
    p72.addRecipient(certificate);
    p72.content = forge$s.util.createBuffer(plain);
    p72.encrypt();
    const der = forge$s.asn1.toDer(p72.toAsn1()).getBytes();
    return fromString$3(der, "ascii");
  }
  async decrypt(cmsData) {
    if (!(cmsData instanceof Uint8Array)) {
      throw errCode(new Error("CMS data is required"), codes$1.ERR_INVALID_PARAMETERS);
    }
    let cms;
    try {
      const buf2 = forge$s.util.createBuffer(toString$5(cmsData, "ascii"));
      const obj = forge$s.asn1.fromDer(buf2);
      cms = forge$s.pkcs7.messageFromAsn1(obj);
    } catch (err2) {
      log$B.error(err2);
      throw errCode(new Error("Invalid CMS"), codes$1.ERR_INVALID_CMS);
    }
    const recipients = cms.recipients.filter((r2) => r2.issuer.find((a) => a.shortName === "O" && a.value === "ipfs")).filter((r2) => r2.issuer.find((a) => a.shortName === "CN")).map((r2) => {
      return {
        recipient: r2,
        keyId: r2.issuer.find((a) => a.shortName === "CN").value
      };
    });
    const r = await findAsync(recipients, async (recipient) => {
      try {
        const key2 = await this.keychain.findKeyById(recipient.keyId);
        if (key2 != null) {
          return true;
        }
      } catch (err2) {
        return false;
      }
      return false;
    });
    if (r == null) {
      const missingKeys = recipients.map((r2) => r2.keyId);
      throw errCode(new Error(`Decryption needs one of the key(s): ${missingKeys.join(", ")}`), codes$1.ERR_MISSING_KEYS, {
        missingKeys
      });
    }
    const key = await this.keychain.findKeyById(r.keyId);
    if (key == null) {
      throw errCode(new Error("No key available to decrypto"), codes$1.ERR_NO_KEY);
    }
    const pem2 = await this.keychain.getPrivateKey(key.name);
    const cached = privates$1.get(this);
    if (cached == null) {
      throw errCode(new Error("dek missing"), codes$1.ERR_INVALID_PARAMETERS);
    }
    const dek = cached.dek;
    const privateKey = forge$s.pki.decryptRsaPrivateKey(pem2, dek);
    cms.decrypt(r.recipient, privateKey);
    return fromString$3(cms.content.getBytes(), "ascii");
  }
}
const log$A = logger$1("libp2p:keychain");
const keyPrefix = "/pkcs8/";
const infoPrefix = "/info/";
const privates = /* @__PURE__ */ new WeakMap();
const NIST = {
  minKeyLength: 112 / 8,
  minSaltLength: 128 / 8,
  minIterationCount: 1e3
};
const defaultOptions$2 = {
  dek: {
    keyLength: 512 / 8,
    iterationCount: 1e4,
    salt: "you should override this value with a crypto secure random number",
    hash: "sha2-512"
  }
};
function validateKeyName(name2) {
  if (name2 == null) {
    return false;
  }
  if (typeof name2 !== "string") {
    return false;
  }
  return name2 === sanitizeFilename(name2.trim()) && name2.length > 0;
}
async function randomDelay() {
  const min = 200;
  const max = 1e3;
  const delay2 = Math.random() * (max - min) + min;
  await new Promise((resolve2) => setTimeout(resolve2, delay2));
}
function DsName(name2) {
  return new Key(keyPrefix + name2);
}
function DsInfoName(name2) {
  return new Key(infoPrefix + name2);
}
class KeyChain {
  constructor(components, init2) {
    this.components = components;
    this.init = mergeOptions$g(defaultOptions$2, init2);
    if (this.init.pass != null && this.init.pass?.length < 20) {
      throw new Error("pass must be least 20 characters");
    }
    if (this.init.dek?.keyLength != null && this.init.dek.keyLength < NIST.minKeyLength) {
      throw new Error(`dek.keyLength must be least ${NIST.minKeyLength} bytes`);
    }
    if (this.init.dek?.salt?.length != null && this.init.dek.salt.length < NIST.minSaltLength) {
      throw new Error(`dek.saltLength must be least ${NIST.minSaltLength} bytes`);
    }
    if (this.init.dek?.iterationCount != null && this.init.dek.iterationCount < NIST.minIterationCount) {
      throw new Error(`dek.iterationCount must be least ${NIST.minIterationCount}`);
    }
    const dek = this.init.pass != null && this.init.dek?.salt != null ? pbkdf2(this.init.pass, this.init.dek?.salt, this.init.dek?.iterationCount, this.init.dek?.keyLength, this.init.dek?.hash) : "";
    privates.set(this, { dek });
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    const dsname = DsInfoName("self");
    if (!await this.components.datastore.has(dsname)) {
      await this.importPeer("self", this.components.peerId);
    }
    this.started = true;
  }
  stop() {
    this.started = false;
  }
  get cms() {
    const cached = privates.get(this);
    if (cached == null) {
      throw errCode(new Error("dek missing"), codes$1.ERR_INVALID_PARAMETERS);
    }
    const dek = cached.dek;
    return new CMS(this, dek);
  }
  static generateOptions() {
    const options = Object.assign({}, defaultOptions$2);
    const saltLength = Math.ceil(NIST.minSaltLength / 3) * 3;
    options.dek.salt = toString$5(randomBytes$3(saltLength), "base64");
    return options;
  }
  static get options() {
    return defaultOptions$2;
  }
  async createKey(name2, type, size2 = 2048) {
    if (!validateKeyName(name2) || name2 === "self") {
      await randomDelay();
      throw errCode(new Error("Invalid key name"), codes$1.ERR_INVALID_KEY_NAME);
    }
    if (typeof type !== "string") {
      await randomDelay();
      throw errCode(new Error("Invalid key type"), codes$1.ERR_INVALID_KEY_TYPE);
    }
    const dsname = DsName(name2);
    const exists2 = await this.components.datastore.has(dsname);
    if (exists2) {
      await randomDelay();
      throw errCode(new Error("Key name already exists"), codes$1.ERR_KEY_ALREADY_EXISTS);
    }
    switch (type.toLowerCase()) {
      case "rsa":
        if (!Number.isSafeInteger(size2) || size2 < 2048) {
          await randomDelay();
          throw errCode(new Error("Invalid RSA key size"), codes$1.ERR_INVALID_KEY_SIZE);
        }
        break;
    }
    let keyInfo;
    try {
      const keypair = await generateKeyPair(type, size2);
      const kid = await keypair.id();
      const cached = privates.get(this);
      if (cached == null) {
        throw errCode(new Error("dek missing"), codes$1.ERR_INVALID_PARAMETERS);
      }
      const dek = cached.dek;
      const pem2 = await keypair.export(dek);
      keyInfo = {
        name: name2,
        id: kid
      };
      const batch2 = this.components.datastore.batch();
      batch2.put(dsname, fromString$3(pem2));
      batch2.put(DsInfoName(name2), fromString$3(JSON.stringify(keyInfo)));
      await batch2.commit();
    } catch (err2) {
      await randomDelay();
      throw err2;
    }
    return keyInfo;
  }
  async listKeys() {
    const query = {
      prefix: infoPrefix
    };
    const info = [];
    for await (const value2 of this.components.datastore.query(query)) {
      info.push(JSON.parse(toString$5(value2.value)));
    }
    return info;
  }
  async findKeyById(id) {
    try {
      const keys = await this.listKeys();
      return keys.find((k) => k.id === id);
    } catch (err2) {
      await randomDelay();
      throw err2;
    }
  }
  async findKeyByName(name2) {
    if (!validateKeyName(name2)) {
      await randomDelay();
      throw errCode(new Error(`Invalid key name '${name2}'`), codes$1.ERR_INVALID_KEY_NAME);
    }
    const dsname = DsInfoName(name2);
    try {
      const res = await this.components.datastore.get(dsname);
      return JSON.parse(toString$5(res));
    } catch (err2) {
      await randomDelay();
      log$A.error(err2);
      throw errCode(new Error(`Key '${name2}' does not exist.`), codes$1.ERR_KEY_NOT_FOUND);
    }
  }
  async removeKey(name2) {
    if (!validateKeyName(name2) || name2 === "self") {
      await randomDelay();
      throw errCode(new Error(`Invalid key name '${name2}'`), codes$1.ERR_INVALID_KEY_NAME);
    }
    const dsname = DsName(name2);
    const keyInfo = await this.findKeyByName(name2);
    const batch2 = this.components.datastore.batch();
    batch2.delete(dsname);
    batch2.delete(DsInfoName(name2));
    await batch2.commit();
    return keyInfo;
  }
  async renameKey(oldName, newName) {
    if (!validateKeyName(oldName) || oldName === "self") {
      await randomDelay();
      throw errCode(new Error(`Invalid old key name '${oldName}'`), codes$1.ERR_OLD_KEY_NAME_INVALID);
    }
    if (!validateKeyName(newName) || newName === "self") {
      await randomDelay();
      throw errCode(new Error(`Invalid new key name '${newName}'`), codes$1.ERR_NEW_KEY_NAME_INVALID);
    }
    const oldDsname = DsName(oldName);
    const newDsname = DsName(newName);
    const oldInfoName = DsInfoName(oldName);
    const newInfoName = DsInfoName(newName);
    const exists2 = await this.components.datastore.has(newDsname);
    if (exists2) {
      await randomDelay();
      throw errCode(new Error(`Key '${newName}' already exists`), codes$1.ERR_KEY_ALREADY_EXISTS);
    }
    try {
      const pem2 = await this.components.datastore.get(oldDsname);
      const res = await this.components.datastore.get(oldInfoName);
      const keyInfo = JSON.parse(toString$5(res));
      keyInfo.name = newName;
      const batch2 = this.components.datastore.batch();
      batch2.put(newDsname, pem2);
      batch2.put(newInfoName, fromString$3(JSON.stringify(keyInfo)));
      batch2.delete(oldDsname);
      batch2.delete(oldInfoName);
      await batch2.commit();
      return keyInfo;
    } catch (err2) {
      await randomDelay();
      throw err2;
    }
  }
  async exportKey(name2, password) {
    if (!validateKeyName(name2)) {
      await randomDelay();
      throw errCode(new Error(`Invalid key name '${name2}'`), codes$1.ERR_INVALID_KEY_NAME);
    }
    if (password == null) {
      await randomDelay();
      throw errCode(new Error("Password is required"), codes$1.ERR_PASSWORD_REQUIRED);
    }
    const dsname = DsName(name2);
    try {
      const res = await this.components.datastore.get(dsname);
      const pem2 = toString$5(res);
      const cached = privates.get(this);
      if (cached == null) {
        throw errCode(new Error("dek missing"), codes$1.ERR_INVALID_PARAMETERS);
      }
      const dek = cached.dek;
      const privateKey = await importKey(pem2, dek);
      return await privateKey.export(password);
    } catch (err2) {
      await randomDelay();
      throw err2;
    }
  }
  async importKey(name2, pem2, password) {
    if (!validateKeyName(name2) || name2 === "self") {
      await randomDelay();
      throw errCode(new Error(`Invalid key name '${name2}'`), codes$1.ERR_INVALID_KEY_NAME);
    }
    if (pem2 == null) {
      await randomDelay();
      throw errCode(new Error("PEM encoded key is required"), codes$1.ERR_PEM_REQUIRED);
    }
    const dsname = DsName(name2);
    const exists2 = await this.components.datastore.has(dsname);
    if (exists2) {
      await randomDelay();
      throw errCode(new Error(`Key '${name2}' already exists`), codes$1.ERR_KEY_ALREADY_EXISTS);
    }
    let privateKey;
    try {
      privateKey = await importKey(pem2, password);
    } catch (err2) {
      await randomDelay();
      throw errCode(new Error("Cannot read the key, most likely the password is wrong"), codes$1.ERR_CANNOT_READ_KEY);
    }
    let kid;
    try {
      kid = await privateKey.id();
      const cached = privates.get(this);
      if (cached == null) {
        throw errCode(new Error("dek missing"), codes$1.ERR_INVALID_PARAMETERS);
      }
      const dek = cached.dek;
      pem2 = await privateKey.export(dek);
    } catch (err2) {
      await randomDelay();
      throw err2;
    }
    const keyInfo = {
      name: name2,
      id: kid
    };
    const batch2 = this.components.datastore.batch();
    batch2.put(dsname, fromString$3(pem2));
    batch2.put(DsInfoName(name2), fromString$3(JSON.stringify(keyInfo)));
    await batch2.commit();
    return keyInfo;
  }
  async importPeer(name2, peer) {
    try {
      if (!validateKeyName(name2)) {
        throw errCode(new Error(`Invalid key name '${name2}'`), codes$1.ERR_INVALID_KEY_NAME);
      }
      if (peer == null) {
        throw errCode(new Error("PeerId is required"), codes$1.ERR_MISSING_PRIVATE_KEY);
      }
      if (peer.privateKey == null) {
        throw errCode(new Error("PeerId.privKey is required"), codes$1.ERR_MISSING_PRIVATE_KEY);
      }
      const privateKey = await unmarshalPrivateKey(peer.privateKey);
      const dsname = DsName(name2);
      const exists2 = await this.components.datastore.has(dsname);
      if (exists2) {
        await randomDelay();
        throw errCode(new Error(`Key '${name2}' already exists`), codes$1.ERR_KEY_ALREADY_EXISTS);
      }
      const cached = privates.get(this);
      if (cached == null) {
        throw errCode(new Error("dek missing"), codes$1.ERR_INVALID_PARAMETERS);
      }
      const dek = cached.dek;
      const pem2 = await privateKey.export(dek);
      const keyInfo = {
        name: name2,
        id: peer.toString()
      };
      const batch2 = this.components.datastore.batch();
      batch2.put(dsname, fromString$3(pem2));
      batch2.put(DsInfoName(name2), fromString$3(JSON.stringify(keyInfo)));
      await batch2.commit();
      return keyInfo;
    } catch (err2) {
      await randomDelay();
      throw err2;
    }
  }
  async getPrivateKey(name2) {
    if (!validateKeyName(name2)) {
      await randomDelay();
      throw errCode(new Error(`Invalid key name '${name2}'`), codes$1.ERR_INVALID_KEY_NAME);
    }
    try {
      const dsname = DsName(name2);
      const res = await this.components.datastore.get(dsname);
      return toString$5(res);
    } catch (err2) {
      await randomDelay();
      log$A.error(err2);
      throw errCode(new Error(`Key '${name2}' does not exist.`), codes$1.ERR_KEY_NOT_FOUND);
    }
  }
  async rotateKeychainPass(oldPass, newPass) {
    if (typeof oldPass !== "string") {
      await randomDelay();
      throw errCode(new Error(`Invalid old pass type '${typeof oldPass}'`), codes$1.ERR_INVALID_OLD_PASS_TYPE);
    }
    if (typeof newPass !== "string") {
      await randomDelay();
      throw errCode(new Error(`Invalid new pass type '${typeof newPass}'`), codes$1.ERR_INVALID_NEW_PASS_TYPE);
    }
    if (newPass.length < 20) {
      await randomDelay();
      throw errCode(new Error(`Invalid pass length ${newPass.length}`), codes$1.ERR_INVALID_PASS_LENGTH);
    }
    log$A("recreating keychain");
    const cached = privates.get(this);
    if (cached == null) {
      throw errCode(new Error("dek missing"), codes$1.ERR_INVALID_PARAMETERS);
    }
    const oldDek = cached.dek;
    this.init.pass = newPass;
    const newDek = newPass != null && this.init.dek?.salt != null ? pbkdf2(newPass, this.init.dek.salt, this.init.dek?.iterationCount, this.init.dek?.keyLength, this.init.dek?.hash) : "";
    privates.set(this, { dek: newDek });
    const keys = await this.listKeys();
    for (const key of keys) {
      const res = await this.components.datastore.get(DsName(key.name));
      const pem2 = toString$5(res);
      const privateKey = await importKey(pem2, oldDek);
      const password = newDek.toString();
      const keyAsPEM = await privateKey.export(password);
      const batch2 = this.components.datastore.batch();
      const keyInfo = {
        name: key.name,
        id: key.id
      };
      batch2.put(DsName(key.name), fromString$3(keyAsPEM));
      batch2.put(DsInfoName(key.name), fromString$3(JSON.stringify(keyInfo)));
      await batch2.commit();
    }
    log$A("keychain reconstructed");
  }
}
async function* forEach(source2, fn) {
  for await (const thing of source2) {
    await fn(thing);
    yield thing;
  }
}
const DIAL_TIMEOUT = 3e4;
const INBOUND_UPGRADE_TIMEOUT = 3e4;
const MAX_PARALLEL_DIALS = 100;
const MAX_PER_PEER_DIALS = 4;
const MAX_ADDRS_TO_DIAL = 25;
const METRICS = {
  computeThrottleMaxQueueSize: 1e3,
  computeThrottleTimeout: 2e3,
  movingAverageIntervals: [
    60 * 1e3,
    5 * 60 * 1e3,
    15 * 60 * 1e3
  ],
  maxOldPeersRetention: 50
};
class DefaultMovingAverage {
  constructor(timespan) {
    if (typeof timespan !== "number") {
      throw new Error("must provide a timespan to the moving average constructor");
    }
    if (timespan <= 0) {
      throw new Error("must provide a timespan > 0 to the moving average constructor");
    }
    this.timespan = timespan;
    this.movingAverage = 0;
    this.variance = 0;
    this.deviation = 0;
    this.forecast = 0;
  }
  alpha(t, pt) {
    return 1 - Math.exp(-(t - pt) / this.timespan);
  }
  push(time, value2) {
    if (this.previousTime != null) {
      const a = this.alpha(time, this.previousTime);
      const diff = value2 - this.movingAverage;
      const incr = a * diff;
      this.movingAverage = a * value2 + (1 - a) * this.movingAverage;
      this.variance = (1 - a) * (this.variance + diff * incr);
      this.deviation = Math.sqrt(this.variance);
      this.forecast = this.movingAverage + a * diff;
    } else {
      this.movingAverage = value2;
    }
    this.previousTime = time;
  }
}
function createMovingAverage(timespan) {
  return new DefaultMovingAverage(timespan);
}
class DefaultStats extends EventEmitter$1 {
  constructor(init2) {
    super();
    this.enabled = init2.enabled;
    this.queue = [];
    this.stats = {
      dataReceived: 0n,
      dataSent: 0n
    };
    this.frequencyLastTime = Date.now();
    this.frequencyAccumulators = {};
    this.movingAverages = {
      dataReceived: [],
      dataSent: []
    };
    this.computeThrottleMaxQueueSize = init2.computeThrottleMaxQueueSize;
    this.computeThrottleTimeout = init2.computeThrottleTimeout;
    this._update = this._update.bind(this);
    this.movingAverageIntervals = init2.movingAverageIntervals;
    for (let i2 = 0; i2 < init2.initialCounters.length; i2++) {
      const key = init2.initialCounters[i2];
      this.stats[key] = 0n;
      this.movingAverages[key] = [];
      for (let k = 0; k < this.movingAverageIntervals.length; k++) {
        const interval = this.movingAverageIntervals[k];
        const ma = this.movingAverages[key][interval] = createMovingAverage(interval);
        ma.push(this.frequencyLastTime, 0);
      }
    }
  }
  start() {
    if (!this.enabled) {
      return;
    }
    if (this.queue.length > 0) {
      this._resetComputeTimeout();
    }
  }
  stop() {
    if (this.timeout != null) {
      this.timeout.clear();
      this.timeout = null;
    }
  }
  getSnapshot() {
    return Object.assign({}, this.stats);
  }
  getMovingAverages() {
    return Object.assign({}, this.movingAverages);
  }
  push(counter2, inc) {
    this.queue.push([counter2, inc, Date.now()]);
    this._resetComputeTimeout();
  }
  _resetComputeTimeout() {
    this.timeout = retimer_1(this._update, this._nextTimeout());
  }
  _nextTimeout() {
    const urgency = this.queue.length / this.computeThrottleMaxQueueSize;
    const timeout2 = Math.max(this.computeThrottleTimeout * (1 - urgency), 0);
    return timeout2;
  }
  _update() {
    this.timeout = null;
    if (this.queue.length > 0) {
      let last2 = ["", 0, 0];
      for (last2 of this.queue) {
        this._applyOp(last2);
      }
      this.queue = [];
      if (last2.length > 2 && last2[0] !== "") {
        this._updateFrequency(last2[2]);
      }
      this.dispatchEvent(new CustomEvent("update", {
        detail: this.stats
      }));
    }
  }
  _updateFrequency(latestTime) {
    const timeDiff = latestTime - this.frequencyLastTime;
    this._updateFrequencyFor("dataReceived", timeDiff, latestTime);
    this._updateFrequencyFor("dataSent", timeDiff, latestTime);
    this.frequencyLastTime = latestTime;
  }
  _updateFrequencyFor(key, timeDiffMS, latestTime) {
    const count = this.frequencyAccumulators[key] ?? 0;
    this.frequencyAccumulators[key] = 0;
    const safeTimeDiff = timeDiffMS ?? 1;
    const hz = count / safeTimeDiff * 1e3;
    let movingAverages = this.movingAverages[key];
    if (movingAverages == null) {
      movingAverages = this.movingAverages[key] = [];
    }
    const intervals2 = this.movingAverageIntervals;
    for (let i2 = 0; i2 < intervals2.length; i2++) {
      const movingAverageInterval = intervals2[i2];
      let movingAverage2 = movingAverages[movingAverageInterval];
      if (movingAverage2 == null) {
        movingAverage2 = movingAverages[movingAverageInterval] = createMovingAverage(movingAverageInterval);
      }
      movingAverage2.push(latestTime, hz);
    }
  }
  _applyOp(op) {
    const key = op[0];
    const inc = op[1];
    if (typeof inc !== "number") {
      throw new Error("invalid increment number");
    }
    let n;
    if (!Object.prototype.hasOwnProperty.call(this.stats, key)) {
      n = this.stats[key] = 0n;
    } else {
      n = this.stats[key];
    }
    this.stats[key] = n + BigInt(inc);
    if (this.frequencyAccumulators[key] == null) {
      this.frequencyAccumulators[key] = 0;
    }
    this.frequencyAccumulators[key] += inc;
  }
}
const initialCounters = [
  "dataReceived",
  "dataSent"
];
const directionToEvent = {
  in: "dataReceived",
  out: "dataSent"
};
class DefaultMetrics {
  constructor(init2) {
    this.enabled = init2.enabled;
    this.statsInit = {
      ...init2,
      initialCounters
    };
    this.globalStats = new DefaultStats(this.statsInit);
    this.peerStats = /* @__PURE__ */ new Map();
    this.protocolStats = /* @__PURE__ */ new Map();
    this.oldPeers = hashlru(init2.maxOldPeersRetention ?? METRICS.maxOldPeersRetention);
    this.running = false;
    this._onMessage = this._onMessage.bind(this);
    this.systems = /* @__PURE__ */ new Map();
  }
  isStarted() {
    return this.running;
  }
  async start() {
    if (!this.enabled) {
      return;
    }
    this.running = true;
  }
  async stop() {
    if (!this.running) {
      return;
    }
    this.running = false;
    this.globalStats.stop();
    for (const stats of this.peerStats.values()) {
      stats.stop();
    }
    for (const stats of this.protocolStats.values()) {
      stats.stop();
    }
  }
  getGlobal() {
    return this.globalStats;
  }
  getPeers() {
    return Array.from(this.peerStats.keys());
  }
  getComponentMetrics() {
    return this.systems;
  }
  updateComponentMetric(update) {
    const { system: system2 = "libp2p", component, metric, value: value2, label, help } = update;
    if (!this.systems.has(system2)) {
      this.systems.set(system2, /* @__PURE__ */ new Map());
    }
    const systemMetrics = this.systems.get(system2);
    if (systemMetrics == null) {
      throw new Error("Unknown metric system");
    }
    if (!systemMetrics.has(component)) {
      systemMetrics.set(component, /* @__PURE__ */ new Map());
    }
    const componentMetrics = systemMetrics.get(component);
    if (componentMetrics == null) {
      throw new Error("Unknown metric component");
    }
    componentMetrics.set(metric, {
      label,
      help,
      calculate: typeof value2 !== "function" ? () => value2 : value2
    });
  }
  forPeer(peerId) {
    const idString = peerId.toString();
    return this.peerStats.get(idString) ?? this.oldPeers.get(idString);
  }
  getProtocols() {
    return Array.from(this.protocolStats.keys());
  }
  forProtocol(protocol2) {
    return this.protocolStats.get(protocol2);
  }
  onPeerDisconnected(peerId) {
    const idString = peerId.toString();
    const peerStats = this.peerStats.get(idString);
    if (peerStats != null) {
      peerStats.stop();
      this.peerStats.delete(idString);
      this.oldPeers.set(idString, peerStats);
    }
  }
  _onMessage(opts) {
    if (!this.running) {
      return;
    }
    const { remotePeer, protocol: protocol2, direction, dataLength } = opts;
    const key = directionToEvent[direction];
    let peerStats = this.forPeer(remotePeer);
    if (peerStats == null) {
      const stats = new DefaultStats(this.statsInit);
      this.peerStats.set(remotePeer.toString(), stats);
      peerStats = stats;
    }
    peerStats.push(key, dataLength);
    this.globalStats.push(key, dataLength);
    if (protocol2 != null) {
      let protocolStats = this.forProtocol(protocol2);
      if (protocolStats == null) {
        const stats = new DefaultStats(this.statsInit);
        this.protocolStats.set(protocol2, stats);
        protocolStats = stats;
      }
      protocolStats.push(key, dataLength);
    }
  }
  updatePlaceholder(placeholder, peerId) {
    if (!this.running) {
      return;
    }
    const placeholderString = placeholder.toString();
    const placeholderStats = this.peerStats.get(placeholderString) ?? this.oldPeers.get(placeholderString);
    const peerIdString = peerId.toString();
    const existingStats = this.peerStats.get(peerIdString) ?? this.oldPeers.get(peerIdString);
    let mergedStats = placeholderStats;
    if (existingStats != null) {
      mergedStats = mergeStats(existingStats, mergedStats);
      this.oldPeers.remove(peerIdString);
    }
    this.peerStats.delete(placeholder.toString());
    this.peerStats.set(peerIdString, mergedStats);
    mergedStats.start();
  }
  trackStream(opts) {
    const { stream: stream2, remotePeer, protocol: protocol2 } = opts;
    if (!this.running) {
      return;
    }
    const source2 = stream2.source;
    stream2.source = forEach(source2, (chunk) => this._onMessage({
      remotePeer,
      protocol: protocol2,
      direction: "in",
      dataLength: chunk.byteLength
    }));
    const sink2 = stream2.sink;
    stream2.sink = async (source3) => {
      return await pipe(source3, (source4) => forEach(source4, (chunk) => {
        this._onMessage({
          remotePeer,
          protocol: protocol2,
          direction: "out",
          dataLength: chunk.byteLength
        });
      }), sink2);
    };
  }
}
function mergeStats(target, other) {
  target.stop();
  other.stop();
  target.queue = [...target.queue, ...other.queue];
  return target;
}
async function pReflect(promise2) {
  try {
    const value2 = await promise2;
    return {
      status: "fulfilled",
      value: value2,
      isFulfilled: true,
      isRejected: false
    };
  } catch (error2) {
    return {
      status: "rejected",
      reason: error2,
      isFulfilled: false,
      isRejected: true
    };
  }
}
class Node {
  constructor(value2) {
    __publicField(this, "value");
    __publicField(this, "next");
    this.value = value2;
  }
}
class Queue {
  constructor() {
    __privateAdd(this, _head, void 0);
    __privateAdd(this, _tail, void 0);
    __privateAdd(this, _size, void 0);
    this.clear();
  }
  enqueue(value2) {
    const node2 = new Node(value2);
    if (__privateGet(this, _head)) {
      __privateGet(this, _tail).next = node2;
      __privateSet(this, _tail, node2);
    } else {
      __privateSet(this, _head, node2);
      __privateSet(this, _tail, node2);
    }
    __privateWrapper(this, _size)._++;
  }
  dequeue() {
    const current = __privateGet(this, _head);
    if (!current) {
      return;
    }
    __privateSet(this, _head, __privateGet(this, _head).next);
    __privateWrapper(this, _size)._--;
    return current.value;
  }
  clear() {
    __privateSet(this, _head, void 0);
    __privateSet(this, _tail, void 0);
    __privateSet(this, _size, 0);
  }
  get size() {
    return __privateGet(this, _size);
  }
  *[Symbol.iterator]() {
    let current = __privateGet(this, _head);
    while (current) {
      yield current.value;
      current = current.next;
    }
  }
}
_head = new WeakMap();
_tail = new WeakMap();
_size = new WeakMap();
function pLimit(concurrency) {
  if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {
    throw new TypeError("Expected `concurrency` to be a number from 1 and up");
  }
  const queue = new Queue();
  let activeCount = 0;
  const next = () => {
    activeCount--;
    if (queue.size > 0) {
      queue.dequeue()();
    }
  };
  const run = async (fn, resolve2, args) => {
    activeCount++;
    const result = (async () => fn(...args))();
    resolve2(result);
    try {
      await result;
    } catch {
    }
    next();
  };
  const enqueue = (fn, resolve2, args) => {
    queue.enqueue(run.bind(void 0, fn, resolve2, args));
    (async () => {
      await Promise.resolve();
      if (activeCount < concurrency && queue.size > 0) {
        queue.dequeue()();
      }
    })();
  };
  const generator = (fn, ...args) => new Promise((resolve2) => {
    enqueue(fn, resolve2, args);
  });
  Object.defineProperties(generator, {
    activeCount: {
      get: () => activeCount
    },
    pendingCount: {
      get: () => queue.size
    },
    clearQueue: {
      value: () => {
        queue.clear();
      }
    }
  });
  return generator;
}
async function pSettle(array, options = {}) {
  const { concurrency = Number.POSITIVE_INFINITY } = options;
  const limit = pLimit(concurrency);
  return Promise.all(array.map((element) => {
    if (element && typeof element.then === "function") {
      return pReflect(element);
    }
    if (typeof element === "function") {
      return pReflect(limit(() => element()));
    }
    return pReflect(Promise.resolve(element));
  }));
}
class TrackedMap extends Map {
  constructor(init2) {
    super();
    const { system: system2, component, metric, metrics } = init2;
    this.system = system2 ?? "libp2p";
    this.component = component;
    this.metric = metric;
    this.metrics = metrics;
    this.updateComponentMetric();
  }
  set(key, value2) {
    super.set(key, value2);
    this.updateComponentMetric();
    return this;
  }
  delete(key) {
    const deleted = super.delete(key);
    this.updateComponentMetric();
    return deleted;
  }
  clear() {
    super.clear();
    this.updateComponentMetric();
  }
  updateComponentMetric() {
    this.metrics.updateComponentMetric({
      system: this.system,
      component: this.component,
      metric: this.metric,
      value: this.size
    });
  }
}
function trackedMap(config2) {
  const { system: system2, component, metric, metrics } = config2;
  let map2;
  if (metrics != null) {
    map2 = new TrackedMap({ system: system2, component, metric, metrics });
  } else {
    map2 = /* @__PURE__ */ new Map();
  }
  return map2;
}
const log$z = logger$1("libp2p:transports");
class DefaultTransportManager extends EventEmitter$1 {
  constructor(components, init2 = {}) {
    super();
    this.components = components;
    this.started = false;
    this.transports = /* @__PURE__ */ new Map();
    this.listeners = trackedMap({
      component: "transport-manager",
      metric: "listeners",
      metrics: this.components.metrics
    });
    this.faultTolerance = init2.faultTolerance ?? FaultTolerance.FATAL_ALL;
  }
  add(transport) {
    const tag = transport[Symbol.toStringTag];
    if (tag == null) {
      throw errCode(new Error("Transport must have a valid tag"), codes$1.ERR_INVALID_KEY);
    }
    if (this.transports.has(tag)) {
      throw errCode(new Error("There is already a transport with this tag"), codes$1.ERR_DUPLICATE_TRANSPORT);
    }
    log$z("adding transport %s", tag);
    this.transports.set(tag, transport);
    if (!this.listeners.has(tag)) {
      this.listeners.set(tag, []);
    }
  }
  isStarted() {
    return this.started;
  }
  async start() {
    const addrs = this.components.addressManager.getListenAddrs();
    await this.listen(addrs);
    this.started = true;
  }
  async stop() {
    const tasks = [];
    for (const [key, listeners2] of this.listeners) {
      log$z("closing listeners for %s", key);
      while (listeners2.length > 0) {
        const listener = listeners2.pop();
        if (listener == null) {
          continue;
        }
        tasks.push(listener.close());
      }
    }
    await Promise.all(tasks);
    log$z("all listeners closed");
    for (const key of this.listeners.keys()) {
      this.listeners.set(key, []);
    }
    this.started = false;
  }
  async dial(ma, options) {
    const transport = this.transportForMultiaddr(ma);
    if (transport == null) {
      throw errCode(new Error(`No transport available for address ${String(ma)}`), codes$1.ERR_TRANSPORT_UNAVAILABLE);
    }
    try {
      return await transport.dial(ma, {
        ...options,
        upgrader: this.components.upgrader
      });
    } catch (err2) {
      if (err2.code == null) {
        err2.code = codes$1.ERR_TRANSPORT_DIAL_FAILED;
      }
      throw err2;
    }
  }
  getAddrs() {
    let addrs = [];
    for (const listeners2 of this.listeners.values()) {
      for (const listener of listeners2) {
        addrs = [...addrs, ...listener.getAddrs()];
      }
    }
    return addrs;
  }
  getTransports() {
    return Array.of(...this.transports.values());
  }
  transportForMultiaddr(ma) {
    for (const transport of this.transports.values()) {
      const addrs = transport.filter([ma]);
      if (addrs.length > 0) {
        return transport;
      }
    }
  }
  async listen(addrs) {
    if (addrs == null || addrs.length === 0) {
      log$z("no addresses were provided for listening, this node is dial only");
      return;
    }
    const couldNotListen = [];
    for (const [key, transport] of this.transports.entries()) {
      const supportedAddrs = transport.filter(addrs);
      const tasks = [];
      for (const addr of supportedAddrs) {
        log$z("creating listener for %s on %s", key, addr);
        const listener = transport.createListener({
          upgrader: this.components.upgrader
        });
        let listeners2 = this.listeners.get(key);
        if (listeners2 == null) {
          listeners2 = [];
          this.listeners.set(key, listeners2);
        }
        listeners2.push(listener);
        listener.addEventListener("listening", () => {
          this.dispatchEvent(new CustomEvent("listener:listening", {
            detail: listener
          }));
        });
        listener.addEventListener("close", () => {
          this.dispatchEvent(new CustomEvent("listener:close", {
            detail: listener
          }));
        });
        tasks.push(listener.listen(addr));
      }
      if (tasks.length === 0) {
        couldNotListen.push(key);
        continue;
      }
      const results = await pSettle(tasks);
      const isListening = results.find((r) => r.isFulfilled);
      if (isListening == null && this.faultTolerance !== FaultTolerance.NO_FATAL) {
        throw errCode(new Error(`Transport (${key}) could not listen on any available address`), codes$1.ERR_NO_VALID_ADDRESSES);
      }
    }
    if (couldNotListen.length === this.transports.size) {
      const message2 = `no valid addresses were provided for transports [${couldNotListen.join(", ")}]`;
      if (this.faultTolerance === FaultTolerance.FATAL_ALL) {
        throw errCode(new Error(message2), codes$1.ERR_NO_VALID_ADDRESSES);
      }
      log$z(`libp2p in dial mode only: ${message2}`);
    }
  }
  async remove(key) {
    log$z("removing %s", key);
    for (const listener of this.listeners.get(key) ?? []) {
      await listener.close();
    }
    this.transports.delete(key);
    this.listeners.delete(key);
  }
  async removeAll() {
    const tasks = [];
    for (const key of this.transports.keys()) {
      tasks.push(this.remove(key));
    }
    await Promise.all(tasks);
  }
}
var FaultTolerance;
(function(FaultTolerance2) {
  FaultTolerance2[FaultTolerance2["FATAL_ALL"] = 0] = "FATAL_ALL";
  FaultTolerance2[FaultTolerance2["NO_FATAL"] = 1] = "NO_FATAL";
})(FaultTolerance || (FaultTolerance = {}));
const PROTOCOL_ID = "/multistream/1.0.0";
const MAX_PROTOCOL_LENGTH = 1024;
const first = async (source2) => {
  for await (const entry of source2) {
    return entry;
  }
  return void 0;
};
var itFirst = first;
const NewLine = fromString$3("\n");
function encode$2(buffer2) {
  const list = new Uint8ArrayList(buffer2, NewLine);
  return encode$5.single(list);
}
function write(writer2, buffer2, options = {}) {
  const encoded = encode$2(buffer2);
  if (options.writeBytes === true) {
    writer2.push(encoded.subarray());
  } else {
    writer2.push(encoded);
  }
}
function writeAll(writer2, buffers, options = {}) {
  const list = new Uint8ArrayList();
  for (const buf2 of buffers) {
    list.append(encode$2(buf2));
  }
  if (options.writeBytes === true) {
    writer2.push(list.subarray());
  } else {
    writer2.push(list);
  }
}
async function read$1(reader2, options) {
  let byteLength2 = 1;
  const varByteSource = {
    [Symbol.asyncIterator]: () => varByteSource,
    next: async () => await reader2.next(byteLength2)
  };
  let input = varByteSource;
  if (options?.signal != null) {
    input = abortableSource(varByteSource, options.signal);
  }
  const onLength = (l) => {
    byteLength2 = l;
  };
  const buf2 = await pipe(input, decode$3({ onLength, maxDataLength: MAX_PROTOCOL_LENGTH }), async (source2) => await itFirst(source2));
  if (buf2 == null || buf2.length === 0) {
    throw errCode(new Error("no buffer returned"), "ERR_INVALID_MULTISTREAM_SELECT_MESSAGE");
  }
  if (buf2.get(buf2.byteLength - 1) !== NewLine[0]) {
    throw errCode(new Error("missing newline"), "ERR_INVALID_MULTISTREAM_SELECT_MESSAGE");
  }
  return buf2.sublist(0, -1);
}
async function readString(reader2, options) {
  const buf2 = await read$1(reader2, options);
  return toString$5(buf2.subarray());
}
const log$y = logger$1("libp2p:mss:select");
async function select$1(stream2, protocols, options = {}) {
  protocols = Array.isArray(protocols) ? [...protocols] : [protocols];
  const { reader: reader2, writer: writer2, rest, stream: shakeStream } = handshake(stream2);
  const protocol2 = protocols.shift();
  if (protocol2 == null) {
    throw new Error("At least one protocol must be specified");
  }
  log$y('select: write ["%s", "%s"]', PROTOCOL_ID, protocol2);
  const p1 = fromString$3(PROTOCOL_ID);
  const p2 = fromString$3(protocol2);
  writeAll(writer2, [p1, p2], options);
  let response = await readString(reader2, options);
  log$y('select: read "%s"', response);
  if (response === PROTOCOL_ID) {
    response = await readString(reader2, options);
    log$y('select: read "%s"', response);
  }
  if (response === protocol2) {
    rest();
    return { stream: shakeStream, protocol: protocol2 };
  }
  for (const protocol3 of protocols) {
    log$y('select: write "%s"', protocol3);
    write(writer2, fromString$3(protocol3), options);
    const response2 = await readString(reader2, options);
    log$y('select: read "%s" for "%s"', response2, protocol3);
    if (response2 === protocol3) {
      rest();
      return { stream: shakeStream, protocol: protocol3 };
    }
  }
  rest();
  throw errCode(new Error("protocol selection failed"), "ERR_UNSUPPORTED_PROTOCOL");
}
const log$x = logger$1("libp2p:mss:handle");
async function handle(stream2, protocols, options) {
  protocols = Array.isArray(protocols) ? protocols : [protocols];
  const { writer: writer2, reader: reader2, rest, stream: shakeStream } = handshake(stream2);
  while (true) {
    const protocol2 = await readString(reader2, options);
    log$x('read "%s"', protocol2);
    if (protocol2 === PROTOCOL_ID) {
      log$x('respond with "%s" for "%s"', PROTOCOL_ID, protocol2);
      write(writer2, fromString$3(PROTOCOL_ID), options);
      continue;
    }
    if (protocols.includes(protocol2)) {
      write(writer2, fromString$3(protocol2), options);
      log$x('respond with "%s" for "%s"', protocol2, protocol2);
      rest();
      return { stream: shakeStream, protocol: protocol2 };
    }
    if (protocol2 === "ls") {
      write(writer2, new Uint8ArrayList(...protocols.map((p) => encode$2(fromString$3(p)))), options);
      log$x('respond with "%s" for %s', protocols, protocol2);
      continue;
    }
    write(writer2, fromString$3("na"), options);
    log$x('respond with "na" for "%s"', protocol2);
  }
}
function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i2 = 0, arr2 = Array(arr.length); i2 < arr.length; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  } else {
    return Array.from(arr);
  }
}
var build = function mutableProxyFactory(defaultTarget) {
  var mutableHandler = void 0;
  var mutableTarget = void 0;
  function setTarget(target) {
    if (!(target instanceof Object)) {
      throw new Error('Target "' + target + '" is not an object');
    }
    mutableTarget = target;
  }
  function setHandler(handler2) {
    Object.keys(handler2).forEach(function(key) {
      var value2 = handler2[key];
      if (typeof value2 !== "function") {
        throw new Error('Trap "' + key + ": " + value2 + '" is not a function');
      }
      if (!Reflect[key]) {
        throw new Error('Trap "' + key + ": " + value2 + '" is not a valid trap');
      }
    });
    mutableHandler = handler2;
  }
  setTarget(function() {
  });
  if (defaultTarget) {
    setTarget(defaultTarget);
  }
  setHandler(Reflect);
  var handler = new Proxy({}, {
    get: function get3(target, property) {
      return function() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return mutableHandler[property].apply(null, [mutableTarget].concat(_toConsumableArray(args.slice(1))));
      };
    }
  });
  return {
    setTarget,
    setHandler,
    getTarget: function getTarget() {
      return mutableTarget;
    },
    getHandler: function getHandler() {
      return mutableHandler;
    },
    proxy: new Proxy(mutableTarget, handler)
  };
};
const symbol = Symbol.for("@libp2p/connection");
const log$w = logger$1("libp2p:connection");
class ConnectionImpl {
  constructor(init2) {
    const { remoteAddr, remotePeer, newStream, close, getStreams, stat } = init2;
    this.id = `${parseInt(String(Math.random() * 1e9)).toString(36)}${Date.now()}`;
    this.remoteAddr = remoteAddr;
    this.remotePeer = remotePeer;
    this.stat = {
      ...stat,
      status: OPEN
    };
    this._newStream = newStream;
    this._close = close;
    this._getStreams = getStreams;
    this.tags = [];
    this._closing = false;
  }
  get [Symbol.toStringTag]() {
    return "Connection";
  }
  get [symbol]() {
    return true;
  }
  get streams() {
    return this._getStreams();
  }
  async newStream(protocols, options) {
    if (this.stat.status === CLOSING) {
      throw errCode(new Error("the connection is being closed"), "ERR_CONNECTION_BEING_CLOSED");
    }
    if (this.stat.status === CLOSED) {
      throw errCode(new Error("the connection is closed"), "ERR_CONNECTION_CLOSED");
    }
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    const stream2 = await this._newStream(protocols, options);
    stream2.stat.direction = "outbound";
    return stream2;
  }
  addStream(stream2) {
    stream2.stat.direction = "inbound";
  }
  removeStream(id) {
  }
  async close() {
    if (this.stat.status === CLOSED || this._closing) {
      return;
    }
    this.stat.status = CLOSING;
    try {
      this.streams.forEach((s2) => s2.close());
    } catch (err2) {
      log$w.error(err2);
    }
    this._closing = true;
    await this._close();
    this._closing = false;
    this.stat.timeline.close = Date.now();
    this.stat.status = CLOSED;
  }
}
function createConnection(init2) {
  return new ConnectionImpl(init2);
}
const log$v = logger$1("libp2p:registrar");
const DEFAULT_MAX_INBOUND_STREAMS$2 = 32;
const DEFAULT_MAX_OUTBOUND_STREAMS$2 = 64;
class DefaultRegistrar {
  constructor(components) {
    this.topologies = /* @__PURE__ */ new Map();
    this.handlers = /* @__PURE__ */ new Map();
    this.components = components;
    this._onDisconnect = this._onDisconnect.bind(this);
    this._onProtocolChange = this._onProtocolChange.bind(this);
    this.components.connectionManager.addEventListener("peer:disconnect", this._onDisconnect);
    this.components.peerStore.addEventListener("change:protocols", this._onProtocolChange);
  }
  getProtocols() {
    return Array.from(/* @__PURE__ */ new Set([
      ...this.topologies.keys(),
      ...this.handlers.keys()
    ])).sort();
  }
  getHandler(protocol2) {
    const handler = this.handlers.get(protocol2);
    if (handler == null) {
      throw errCode(new Error(`No handler registered for protocol ${protocol2}`), codes$1.ERR_NO_HANDLER_FOR_PROTOCOL);
    }
    return handler;
  }
  getTopologies(protocol2) {
    const topologies = this.topologies.get(protocol2);
    if (topologies == null) {
      return [];
    }
    return [
      ...topologies.values()
    ];
  }
  async handle(protocol2, handler, opts) {
    if (this.handlers.has(protocol2)) {
      throw errCode(new Error(`Handler already registered for protocol ${protocol2}`), codes$1.ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED);
    }
    const options = mergeOptions$g.bind({ ignoreUndefined: true })({
      maxInboundStreams: DEFAULT_MAX_INBOUND_STREAMS$2,
      maxOutboundStreams: DEFAULT_MAX_OUTBOUND_STREAMS$2
    }, opts);
    this.handlers.set(protocol2, {
      handler,
      options
    });
    await this.components.peerStore.protoBook.add(this.components.peerId, [protocol2]);
  }
  async unhandle(protocols) {
    const protocolList = Array.isArray(protocols) ? protocols : [protocols];
    protocolList.forEach((protocol2) => {
      this.handlers.delete(protocol2);
    });
    await this.components.peerStore.protoBook.remove(this.components.peerId, protocolList);
  }
  async register(protocol2, topology) {
    if (!isTopology(topology)) {
      log$v.error("topology must be an instance of interfaces/topology");
      throw errCode(new Error("topology must be an instance of interfaces/topology"), codes$1.ERR_INVALID_PARAMETERS);
    }
    const id = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;
    let topologies = this.topologies.get(protocol2);
    if (topologies == null) {
      topologies = /* @__PURE__ */ new Map();
      this.topologies.set(protocol2, topologies);
    }
    topologies.set(id, topology);
    await topology.setRegistrar(this);
    return id;
  }
  unregister(id) {
    for (const [protocol2, topologies] of this.topologies.entries()) {
      if (topologies.has(id)) {
        topologies.delete(id);
        if (topologies.size === 0) {
          this.topologies.delete(protocol2);
        }
      }
    }
  }
  _onDisconnect(evt) {
    const connection = evt.detail;
    void this.components.peerStore.protoBook.get(connection.remotePeer).then((peerProtocols) => {
      for (const protocol2 of peerProtocols) {
        const topologies = this.topologies.get(protocol2);
        if (topologies == null) {
          continue;
        }
        for (const topology of topologies.values()) {
          topology.onDisconnect(connection.remotePeer);
        }
      }
    }).catch((err2) => {
      log$v.error(err2);
    });
  }
  _onProtocolChange(evt) {
    const { peerId, protocols, oldProtocols } = evt.detail;
    const removed = oldProtocols.filter((protocol2) => !protocols.includes(protocol2));
    const added = protocols.filter((protocol2) => !oldProtocols.includes(protocol2));
    for (const protocol2 of removed) {
      const topologies = this.topologies.get(protocol2);
      if (topologies == null) {
        continue;
      }
      for (const topology of topologies.values()) {
        topology.onDisconnect(peerId);
      }
    }
    for (const protocol2 of added) {
      const topologies = this.topologies.get(protocol2);
      if (topologies == null) {
        continue;
      }
      for (const topology of topologies.values()) {
        const connection = this.components.connectionManager.getConnections(peerId)[0];
        if (connection == null) {
          continue;
        }
        topology.onConnect(peerId, connection);
      }
    }
  }
}
const log$u = logger$1("libp2p:upgrader");
function findIncomingStreamLimit(protocol2, registrar) {
  try {
    const { options } = registrar.getHandler(protocol2);
    return options.maxInboundStreams;
  } catch (err2) {
    if (err2.code !== codes$1.ERR_NO_HANDLER_FOR_PROTOCOL) {
      throw err2;
    }
  }
  return DEFAULT_MAX_INBOUND_STREAMS$2;
}
function findOutgoingStreamLimit(protocol2, registrar) {
  try {
    const { options } = registrar.getHandler(protocol2);
    return options.maxOutboundStreams;
  } catch (err2) {
    if (err2.code !== codes$1.ERR_NO_HANDLER_FOR_PROTOCOL) {
      throw err2;
    }
  }
  return DEFAULT_MAX_OUTBOUND_STREAMS$2;
}
function countStreams(protocol2, direction, connection) {
  let streamCount = 0;
  connection.streams.forEach((stream2) => {
    if (stream2.stat.direction === direction && stream2.stat.protocol === protocol2) {
      streamCount++;
    }
  });
  return streamCount;
}
class DefaultUpgrader extends EventEmitter$1 {
  constructor(components, init2) {
    super();
    this.components = components;
    this.connectionEncryption = /* @__PURE__ */ new Map();
    init2.connectionEncryption.forEach((encrypter) => {
      this.connectionEncryption.set(encrypter.protocol, encrypter);
    });
    this.muxers = /* @__PURE__ */ new Map();
    init2.muxers.forEach((muxer) => {
      this.muxers.set(muxer.protocol, muxer);
    });
    this.inboundUpgradeTimeout = init2.inboundUpgradeTimeout;
  }
  async upgradeInbound(maConn) {
    const accept = await this.components.connectionManager.acceptIncomingConnection(maConn);
    if (!accept) {
      throw errCode(new Error("connection denied"), codes$1.ERR_CONNECTION_DENIED);
    }
    let encryptedConn;
    let remotePeer;
    let upgradedConn;
    let muxerFactory;
    let cryptoProtocol;
    let setPeer;
    let proxyPeer;
    const metrics = this.components.metrics;
    const timeoutController = new timeoutAbortController.TimeoutController(this.inboundUpgradeTimeout);
    try {
      events.exports.setMaxListeners?.(Infinity, timeoutController.signal);
    } catch {
    }
    try {
      const abortableStream = abortableDuplex(maConn, timeoutController.signal);
      maConn.source = abortableStream.source;
      maConn.sink = abortableStream.sink;
      if (await this.components.connectionGater.denyInboundConnection(maConn)) {
        throw errCode(new Error("The multiaddr connection is blocked by gater.acceptConnection"), codes$1.ERR_CONNECTION_INTERCEPTED);
      }
      if (metrics != null) {
        ({ setTarget: setPeer, proxy: proxyPeer } = build());
        const idString = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;
        setPeer({ toString: () => idString });
        metrics.trackStream({ stream: maConn, remotePeer: proxyPeer });
      }
      log$u("starting the inbound connection upgrade");
      let protectedConn = maConn;
      const protector = this.components.connectionProtector;
      if (protector != null) {
        log$u("protecting the inbound connection");
        protectedConn = await protector.protect(maConn);
      }
      try {
        ({
          conn: encryptedConn,
          remotePeer,
          protocol: cryptoProtocol
        } = await this._encryptInbound(protectedConn));
        if (await this.components.connectionGater.denyInboundEncryptedConnection(remotePeer, {
          ...protectedConn,
          ...encryptedConn
        })) {
          throw errCode(new Error("The multiaddr connection is blocked by gater.acceptEncryptedConnection"), codes$1.ERR_CONNECTION_INTERCEPTED);
        }
        if (this.muxers.size > 0) {
          const multiplexed = await this._multiplexInbound({
            ...protectedConn,
            ...encryptedConn
          }, this.muxers);
          muxerFactory = multiplexed.muxerFactory;
          upgradedConn = multiplexed.stream;
        } else {
          upgradedConn = encryptedConn;
        }
      } catch (err2) {
        log$u.error("Failed to upgrade inbound connection", err2);
        throw err2;
      }
      if (await this.components.connectionGater.denyInboundUpgradedConnection(remotePeer, {
        ...protectedConn,
        ...encryptedConn
      })) {
        throw errCode(new Error("The multiaddr connection is blocked by gater.acceptEncryptedConnection"), codes$1.ERR_CONNECTION_INTERCEPTED);
      }
      if (metrics != null) {
        metrics.updatePlaceholder(proxyPeer, remotePeer);
        setPeer(remotePeer);
      }
      log$u("Successfully upgraded inbound connection");
      return this._createConnection({
        cryptoProtocol,
        direction: "inbound",
        maConn,
        upgradedConn,
        muxerFactory,
        remotePeer
      });
    } finally {
      this.components.connectionManager.afterUpgradeInbound();
      timeoutController.clear();
    }
  }
  async upgradeOutbound(maConn, opts) {
    const idStr = maConn.remoteAddr.getPeerId();
    if (idStr == null) {
      throw errCode(new Error("outbound connection must have a peer id"), codes$1.ERR_INVALID_MULTIADDR);
    }
    const remotePeerId = peerIdFromString(idStr);
    if (await this.components.connectionGater.denyOutboundConnection(remotePeerId, maConn)) {
      throw errCode(new Error("The multiaddr connection is blocked by connectionGater.denyOutboundConnection"), codes$1.ERR_CONNECTION_INTERCEPTED);
    }
    let encryptedConn;
    let remotePeer;
    let upgradedConn;
    let cryptoProtocol;
    let muxerFactory;
    let setPeer;
    let proxyPeer;
    const metrics = this.components.metrics;
    if (metrics != null) {
      ({ setTarget: setPeer, proxy: proxyPeer } = build());
      const idString = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;
      setPeer({ toB58String: () => idString });
      metrics.trackStream({ stream: maConn, remotePeer: proxyPeer });
    }
    log$u("Starting the outbound connection upgrade");
    let protectedConn = maConn;
    if (opts?.skipProtection !== true) {
      const protector = this.components.connectionProtector;
      if (protector != null) {
        protectedConn = await protector.protect(maConn);
      }
    }
    try {
      encryptedConn = protectedConn;
      if (opts?.skipEncryption !== true) {
        ({
          conn: encryptedConn,
          remotePeer,
          protocol: cryptoProtocol
        } = await this._encryptOutbound(protectedConn, remotePeerId));
        if (await this.components.connectionGater.denyOutboundEncryptedConnection(remotePeer, {
          ...protectedConn,
          ...encryptedConn
        })) {
          throw errCode(new Error("The multiaddr connection is blocked by gater.acceptEncryptedConnection"), codes$1.ERR_CONNECTION_INTERCEPTED);
        }
      } else {
        cryptoProtocol = "native";
        remotePeer = remotePeerId;
      }
      upgradedConn = encryptedConn;
      if (opts?.muxerFactory != null) {
        muxerFactory = opts.muxerFactory;
      } else if (this.muxers.size > 0) {
        const multiplexed = await this._multiplexOutbound({
          ...protectedConn,
          ...encryptedConn
        }, this.muxers);
        muxerFactory = multiplexed.muxerFactory;
        upgradedConn = multiplexed.stream;
      }
    } catch (err2) {
      log$u.error("Failed to upgrade outbound connection", err2);
      await maConn.close(err2);
      throw err2;
    }
    if (await this.components.connectionGater.denyOutboundUpgradedConnection(remotePeer, {
      ...protectedConn,
      ...encryptedConn
    })) {
      throw errCode(new Error("The multiaddr connection is blocked by gater.acceptEncryptedConnection"), codes$1.ERR_CONNECTION_INTERCEPTED);
    }
    if (metrics != null) {
      metrics.updatePlaceholder(proxyPeer, remotePeer);
      setPeer(remotePeer);
    }
    log$u("Successfully upgraded outbound connection");
    return this._createConnection({
      cryptoProtocol,
      direction: "outbound",
      maConn,
      upgradedConn,
      muxerFactory,
      remotePeer
    });
  }
  _createConnection(opts) {
    const { cryptoProtocol, direction, maConn, upgradedConn, remotePeer, muxerFactory } = opts;
    let muxer;
    let newStream;
    let connection;
    if (muxerFactory != null) {
      muxer = muxerFactory.createStreamMuxer({
        direction,
        onIncomingStream: (muxedStream) => {
          if (connection == null) {
            return;
          }
          void Promise.resolve().then(async () => {
            const protocols = this.components.registrar.getProtocols();
            const { stream: stream2, protocol: protocol2 } = await handle(muxedStream, protocols);
            log$u("%s: incoming stream opened on %s", direction, protocol2);
            const metrics = this.components.metrics;
            if (metrics != null) {
              metrics.trackStream({ stream: stream2, remotePeer, protocol: protocol2 });
            }
            if (connection == null) {
              return;
            }
            const incomingLimit = findIncomingStreamLimit(protocol2, this.components.registrar);
            const streamCount = countStreams(protocol2, "inbound", connection);
            if (streamCount === incomingLimit) {
              muxedStream.abort(errCode(new Error(`Too many inbound protocol streams for protocol "${protocol2}" - limit ${incomingLimit}`), codes$1.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS));
              return;
            }
            muxedStream.source = stream2.source;
            muxedStream.sink = stream2.sink;
            muxedStream.stat.protocol = protocol2;
            this.components.peerStore.protoBook.add(remotePeer, [protocol2]).catch((err2) => log$u.error(err2));
            connection.addStream(muxedStream);
            this._onStream({ connection, stream: muxedStream, protocol: protocol2 });
          }).catch((err2) => {
            log$u.error(err2);
            if (muxedStream.stat.timeline.close == null) {
              muxedStream.close();
            }
          });
        },
        onStreamEnd: (muxedStream) => {
          connection?.removeStream(muxedStream.id);
        }
      });
      newStream = async (protocols, options = {}) => {
        if (muxer == null) {
          throw errCode(new Error("Stream is not multiplexed"), codes$1.ERR_MUXER_UNAVAILABLE);
        }
        log$u("%s: starting new stream on %s", direction, protocols);
        const muxedStream = await muxer.newStream();
        const metrics = this.components.metrics;
        let controller;
        try {
          if (options.signal == null) {
            log$u("No abort signal was passed while trying to negotiate protocols %s falling back to default timeout", protocols);
            controller = new timeoutAbortController.TimeoutController(3e4);
            options.signal = controller.signal;
            try {
              events.exports.setMaxListeners?.(Infinity, controller.signal);
            } catch {
            }
          }
          const { stream: stream2, protocol: protocol2 } = await select$1(muxedStream, protocols, options);
          if (metrics != null) {
            metrics.trackStream({ stream: stream2, remotePeer, protocol: protocol2 });
          }
          const outgoingLimit = findOutgoingStreamLimit(protocol2, this.components.registrar);
          const streamCount = countStreams(protocol2, "outbound", connection);
          if (streamCount === outgoingLimit) {
            const err2 = errCode(new Error(`Too many outbound protocol streams for protocol "${protocol2}" - limit ${outgoingLimit}`), codes$1.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS);
            muxedStream.abort(err2);
            throw err2;
          }
          this.components.peerStore.protoBook.add(remotePeer, [protocol2]).catch((err2) => log$u.error(err2));
          muxedStream.source = stream2.source;
          muxedStream.sink = stream2.sink;
          muxedStream.stat.protocol = protocol2;
          return muxedStream;
        } catch (err2) {
          log$u.error("could not create new stream", err2);
          if (muxedStream.stat.timeline.close == null) {
            muxedStream.close();
          }
          if (err2.code != null) {
            throw err2;
          }
          throw errCode(err2, codes$1.ERR_UNSUPPORTED_PROTOCOL);
        } finally {
          if (controller != null) {
            controller.clear();
          }
        }
      };
      pipe(upgradedConn, muxer, upgradedConn).catch(log$u.error);
    }
    const _timeline = maConn.timeline;
    maConn.timeline = new Proxy(_timeline, {
      set: (...args) => {
        if (connection != null && args[1] === "close" && args[2] != null && _timeline.close == null) {
          (async () => {
            try {
              if (connection.stat.status === "OPEN") {
                await connection.close();
              }
            } catch (err2) {
              log$u.error(err2);
            } finally {
              this.dispatchEvent(new CustomEvent("connectionEnd", {
                detail: connection
              }));
            }
          })().catch((err2) => {
            log$u.error(err2);
          });
        }
        return Reflect.set(...args);
      }
    });
    maConn.timeline.upgraded = Date.now();
    const errConnectionNotMultiplexed = () => {
      throw errCode(new Error("connection is not multiplexed"), codes$1.ERR_CONNECTION_NOT_MULTIPLEXED);
    };
    connection = createConnection({
      remoteAddr: maConn.remoteAddr,
      remotePeer,
      stat: {
        status: "OPEN",
        direction,
        timeline: maConn.timeline,
        multiplexer: muxer?.protocol,
        encryption: cryptoProtocol
      },
      newStream: newStream ?? errConnectionNotMultiplexed,
      getStreams: () => muxer != null ? muxer.streams : errConnectionNotMultiplexed(),
      close: async () => {
        await maConn.close();
        if (muxer != null) {
          muxer.close();
        }
      }
    });
    this.dispatchEvent(new CustomEvent("connection", {
      detail: connection
    }));
    return connection;
  }
  _onStream(opts) {
    const { connection, stream: stream2, protocol: protocol2 } = opts;
    const { handler } = this.components.registrar.getHandler(protocol2);
    handler({ connection, stream: stream2 });
  }
  async _encryptInbound(connection) {
    const protocols = Array.from(this.connectionEncryption.keys());
    log$u("handling inbound crypto protocol selection", protocols);
    try {
      const { stream: stream2, protocol: protocol2 } = await handle(connection, protocols, {
        writeBytes: true
      });
      const encrypter = this.connectionEncryption.get(protocol2);
      if (encrypter == null) {
        throw new Error(`no crypto module found for ${protocol2}`);
      }
      log$u("encrypting inbound connection...");
      return {
        ...await encrypter.secureInbound(this.components.peerId, stream2),
        protocol: protocol2
      };
    } catch (err2) {
      throw errCode(err2, codes$1.ERR_ENCRYPTION_FAILED);
    }
  }
  async _encryptOutbound(connection, remotePeerId) {
    const protocols = Array.from(this.connectionEncryption.keys());
    log$u("selecting outbound crypto protocol", protocols);
    try {
      const { stream: stream2, protocol: protocol2 } = await select$1(connection, protocols, {
        writeBytes: true
      });
      const encrypter = this.connectionEncryption.get(protocol2);
      if (encrypter == null) {
        throw new Error(`no crypto module found for ${protocol2}`);
      }
      log$u("encrypting outbound connection to %p", remotePeerId);
      return {
        ...await encrypter.secureOutbound(this.components.peerId, stream2, remotePeerId),
        protocol: protocol2
      };
    } catch (err2) {
      throw errCode(err2, codes$1.ERR_ENCRYPTION_FAILED);
    }
  }
  async _multiplexOutbound(connection, muxers) {
    const protocols = Array.from(muxers.keys());
    log$u("outbound selecting muxer %s", protocols);
    try {
      const { stream: stream2, protocol: protocol2 } = await select$1(connection, protocols, {
        writeBytes: true
      });
      log$u("%s selected as muxer protocol", protocol2);
      const muxerFactory = muxers.get(protocol2);
      return { stream: stream2, muxerFactory };
    } catch (err2) {
      log$u.error("error multiplexing outbound stream", err2);
      throw errCode(err2, codes$1.ERR_MUXER_UNAVAILABLE);
    }
  }
  async _multiplexInbound(connection, muxers) {
    const protocols = Array.from(muxers.keys());
    log$u("inbound handling muxers %s", protocols);
    try {
      const { stream: stream2, protocol: protocol2 } = await handle(connection, protocols, {
        writeBytes: true
      });
      const muxerFactory = muxers.get(protocol2);
      return { stream: stream2, muxerFactory };
    } catch (err2) {
      log$u.error("error multiplexing inbound stream", err2);
      throw errCode(err2, codes$1.ERR_MUXER_UNAVAILABLE);
    }
  }
}
var Identify;
(function(Identify2) {
  let _codec;
  Identify2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.protocolVersion != null) {
          w.uint32(42);
          w.string(obj.protocolVersion);
        }
        if (obj.agentVersion != null) {
          w.uint32(50);
          w.string(obj.agentVersion);
        }
        if (obj.publicKey != null) {
          w.uint32(10);
          w.bytes(obj.publicKey);
        }
        if (obj.listenAddrs != null) {
          for (const value2 of obj.listenAddrs) {
            w.uint32(18);
            w.bytes(value2);
          }
        }
        if (obj.observedAddr != null) {
          w.uint32(34);
          w.bytes(obj.observedAddr);
        }
        if (obj.protocols != null) {
          for (const value2 of obj.protocols) {
            w.uint32(26);
            w.string(value2);
          }
        }
        if (obj.signedPeerRecord != null) {
          w.uint32(66);
          w.bytes(obj.signedPeerRecord);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length3) => {
        const obj = {
          listenAddrs: [],
          protocols: []
        };
        const end2 = length3 == null ? reader2.len : reader2.pos + length3;
        while (reader2.pos < end2) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 5:
              obj.protocolVersion = reader2.string();
              break;
            case 6:
              obj.agentVersion = reader2.string();
              break;
            case 1:
              obj.publicKey = reader2.bytes();
              break;
            case 2:
              obj.listenAddrs.push(reader2.bytes());
              break;
            case 4:
              obj.observedAddr = reader2.bytes();
              break;
            case 3:
              obj.protocols.push(reader2.string());
              break;
            case 8:
              obj.signedPeerRecord = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Identify2.encode = (obj) => {
    return encodeMessage(obj, Identify2.codec());
  };
  Identify2.decode = (buf2) => {
    return decodeMessage(buf2, Identify2.codec());
  };
})(Identify || (Identify = {}));
const version = "0.0.0";
const name = "libp2p";
const AGENT_VERSION = `js-libp2p/${version}`;
const IDENTIFY_PROTOCOL_VERSION = "0.1.0";
const MULTICODEC_IDENTIFY_PROTOCOL_NAME = "id";
const MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME = "id/push";
const MULTICODEC_IDENTIFY_PROTOCOL_VERSION = "1.0.0";
const MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION = "1.0.0";
const log$t = logger$1("libp2p:identify");
const MAX_IDENTIFY_MESSAGE_SIZE = 1024 * 8;
class IdentifyService {
  constructor(components, init2) {
    this.components = components;
    this.started = false;
    this.init = init2;
    this.identifyProtocolStr = `/${init2.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`;
    this.identifyPushProtocolStr = `/${init2.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`;
    this.host = {
      protocolVersion: `${init2.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,
      ...init2.host
    };
    this.components.connectionManager.addEventListener("peer:connect", (evt) => {
      const connection = evt.detail;
      this.identify(connection).catch(log$t.error);
    });
    this.components.peerStore.addEventListener("change:multiaddrs", (evt) => {
      const { peerId } = evt.detail;
      if (this.components.peerId.equals(peerId)) {
        void this.pushToPeerStore().catch((err2) => log$t.error(err2));
      }
    });
    this.components.peerStore.addEventListener("change:protocols", (evt) => {
      const { peerId } = evt.detail;
      if (this.components.peerId.equals(peerId)) {
        void this.pushToPeerStore().catch((err2) => log$t.error(err2));
      }
    });
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.started) {
      return;
    }
    await this.components.peerStore.metadataBook.setValue(this.components.peerId, "AgentVersion", fromString$3(this.host.agentVersion));
    await this.components.peerStore.metadataBook.setValue(this.components.peerId, "ProtocolVersion", fromString$3(this.host.protocolVersion));
    await this.components.registrar.handle(this.identifyProtocolStr, (data) => {
      void this._handleIdentify(data).catch((err2) => {
        log$t.error(err2);
      });
    }, {
      maxInboundStreams: this.init.maxInboundStreams,
      maxOutboundStreams: this.init.maxOutboundStreams
    });
    await this.components.registrar.handle(this.identifyPushProtocolStr, (data) => {
      void this._handlePush(data).catch((err2) => {
        log$t.error(err2);
      });
    }, {
      maxInboundStreams: this.init.maxPushIncomingStreams,
      maxOutboundStreams: this.init.maxPushOutgoingStreams
    });
    this.started = true;
  }
  async stop() {
    await this.components.registrar.unhandle(this.identifyProtocolStr);
    await this.components.registrar.unhandle(this.identifyPushProtocolStr);
    this.started = false;
  }
  async push(connections) {
    const signedPeerRecord = await this.components.peerStore.addressBook.getRawEnvelope(this.components.peerId);
    const listenAddrs = this.components.addressManager.getAddresses().map((ma) => ma.bytes);
    const protocols = await this.components.peerStore.protoBook.get(this.components.peerId);
    const pushes = connections.map(async (connection) => {
      let stream2;
      const timeoutController = new timeoutAbortController.TimeoutController(this.init.timeout);
      try {
        events.exports.setMaxListeners?.(Infinity, timeoutController.signal);
      } catch {
      }
      try {
        stream2 = await connection.newStream([this.identifyPushProtocolStr], {
          signal: timeoutController.signal
        });
        const source2 = abortableDuplex(stream2, timeoutController.signal);
        await source2.sink(pipe([Identify.encode({
          listenAddrs,
          signedPeerRecord,
          protocols
        })], encode$5()));
      } catch (err2) {
        log$t.error("could not push identify update to peer", err2);
      } finally {
        if (stream2 != null) {
          stream2.close();
        }
        timeoutController.clear();
      }
    });
    await Promise.all(pushes);
  }
  async pushToPeerStore() {
    if (!this.isStarted()) {
      return;
    }
    const connections = [];
    for (const conn of this.components.connectionManager.getConnections()) {
      const peerId = conn.remotePeer;
      const peer = await this.components.peerStore.get(peerId);
      if (!peer.protocols.includes(this.identifyPushProtocolStr)) {
        continue;
      }
      connections.push(conn);
    }
    await this.push(connections);
  }
  async _identify(connection, options = {}) {
    let timeoutController;
    let signal = options.signal;
    let stream2;
    if (signal == null) {
      timeoutController = new timeoutAbortController.TimeoutController(this.init.timeout);
      signal = timeoutController.signal;
      try {
        events.exports.setMaxListeners?.(Infinity, timeoutController.signal);
      } catch {
      }
    }
    try {
      stream2 = await connection.newStream([this.identifyProtocolStr], {
        signal
      });
      const source2 = abortableDuplex(stream2, signal);
      const data = await pipe([], source2, decode$3({
        maxDataLength: this.init.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE
      }), async (source3) => await first$1(source3));
      if (data == null) {
        throw errCode(new Error("No data could be retrieved"), codes$1.ERR_CONNECTION_ENDED);
      }
      try {
        return Identify.decode(data);
      } catch (err2) {
        throw errCode(err2, codes$1.ERR_INVALID_MESSAGE);
      }
    } finally {
      if (timeoutController != null) {
        timeoutController.clear();
      }
      if (stream2 != null) {
        stream2.close();
      }
    }
  }
  async identify(connection, options = {}) {
    const message2 = await this._identify(connection, options);
    const { publicKey, listenAddrs, protocols, observedAddr, signedPeerRecord, agentVersion, protocolVersion } = message2;
    if (publicKey == null) {
      throw errCode(new Error("public key was missing from identify message"), codes$1.ERR_MISSING_PUBLIC_KEY);
    }
    const id = await peerIdFromKeys(publicKey);
    if (!connection.remotePeer.equals(id)) {
      throw errCode(new Error("identified peer does not match the expected peer"), codes$1.ERR_INVALID_PEER);
    }
    if (this.components.peerId.equals(id)) {
      throw errCode(new Error("identified peer is our own peer id?"), codes$1.ERR_INVALID_PEER);
    }
    const cleanObservedAddr = IdentifyService.getCleanMultiaddr(observedAddr);
    if (signedPeerRecord != null) {
      log$t("received signed peer record from %p", id);
      try {
        const envelope = await RecordEnvelope.openAndCertify(signedPeerRecord, PeerRecord.DOMAIN);
        if (!envelope.peerId.equals(id)) {
          throw errCode(new Error("identified peer does not match the expected peer"), codes$1.ERR_INVALID_PEER);
        }
        if (await this.components.peerStore.addressBook.consumePeerRecord(envelope)) {
          await this.components.peerStore.protoBook.set(id, protocols);
          if (agentVersion != null) {
            await this.components.peerStore.metadataBook.setValue(id, "AgentVersion", fromString$3(agentVersion));
          }
          if (protocolVersion != null) {
            await this.components.peerStore.metadataBook.setValue(id, "ProtocolVersion", fromString$3(protocolVersion));
          }
          log$t("identify completed for peer %p and protocols %o", id, protocols);
          return;
        }
      } catch (err2) {
        log$t("received invalid envelope, discard it and fallback to listenAddrs is available", err2);
      }
    } else {
      log$t("no signed peer record received from %p", id);
    }
    log$t("falling back to legacy addresses from %p", id);
    try {
      await this.components.peerStore.addressBook.set(id, listenAddrs.map((addr) => multiaddr(addr)));
    } catch (err2) {
      log$t.error("received invalid addrs", err2);
    }
    await this.components.peerStore.protoBook.set(id, protocols);
    if (agentVersion != null) {
      await this.components.peerStore.metadataBook.setValue(id, "AgentVersion", fromString$3(agentVersion));
    }
    if (protocolVersion != null) {
      await this.components.peerStore.metadataBook.setValue(id, "ProtocolVersion", fromString$3(protocolVersion));
    }
    log$t("identify completed for peer %p and protocols %o", id, protocols);
    log$t("received observed address of %s", cleanObservedAddr?.toString());
  }
  async _handleIdentify(data) {
    const { connection, stream: stream2 } = data;
    const timeoutController = new timeoutAbortController.TimeoutController(this.init.timeout);
    try {
      events.exports.setMaxListeners?.(Infinity, timeoutController.signal);
    } catch {
    }
    try {
      const publicKey = this.components.peerId.publicKey ?? new Uint8Array(0);
      const peerData = await this.components.peerStore.get(this.components.peerId);
      const multiaddrs = this.components.addressManager.getAddresses().map((ma) => ma.decapsulateCode(getProtocol("p2p").code));
      let signedPeerRecord = peerData.peerRecordEnvelope;
      if (multiaddrs.length > 0 && signedPeerRecord == null) {
        const peerRecord = new PeerRecord({
          peerId: this.components.peerId,
          multiaddrs
        });
        const envelope = await RecordEnvelope.seal(peerRecord, this.components.peerId);
        await this.components.peerStore.addressBook.consumePeerRecord(envelope);
        signedPeerRecord = envelope.marshal().subarray();
      }
      const message2 = Identify.encode({
        protocolVersion: this.host.protocolVersion,
        agentVersion: this.host.agentVersion,
        publicKey,
        listenAddrs: multiaddrs.map((addr) => addr.bytes),
        signedPeerRecord,
        observedAddr: connection.remoteAddr.bytes,
        protocols: peerData.protocols
      });
      const source2 = abortableDuplex(stream2, timeoutController.signal);
      const msgWithLenPrefix = pipe([message2], encode$5());
      await source2.sink(msgWithLenPrefix);
    } catch (err2) {
      log$t.error("could not respond to identify request", err2);
    } finally {
      stream2.close();
      timeoutController.clear();
    }
  }
  async _handlePush(data) {
    const { connection, stream: stream2 } = data;
    const timeoutController = new timeoutAbortController.TimeoutController(this.init.timeout);
    try {
      events.exports.setMaxListeners?.(Infinity, timeoutController.signal);
    } catch {
    }
    let message2;
    try {
      const source2 = abortableDuplex(stream2, timeoutController.signal);
      const data2 = await pipe([], source2, decode$3({
        maxDataLength: this.init.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE
      }), async (source3) => await first$1(source3));
      if (data2 != null) {
        message2 = Identify.decode(data2);
      }
    } catch (err2) {
      return log$t.error("received invalid message", err2);
    } finally {
      stream2.close();
      timeoutController.clear();
    }
    if (message2 == null) {
      return log$t.error("received invalid message");
    }
    const id = connection.remotePeer;
    if (this.components.peerId.equals(id)) {
      log$t("received push from ourselves?");
      return;
    }
    log$t("received push from %p", id);
    if (message2.signedPeerRecord != null) {
      log$t("received signedPeerRecord in push");
      try {
        const envelope = await RecordEnvelope.openAndCertify(message2.signedPeerRecord, PeerRecord.DOMAIN);
        if (await this.components.peerStore.addressBook.consumePeerRecord(envelope)) {
          log$t("consumed signedPeerRecord sent in push");
          await this.components.peerStore.protoBook.set(id, message2.protocols);
          return;
        } else {
          log$t("failed to consume signedPeerRecord sent in push");
        }
      } catch (err2) {
        log$t("received invalid envelope, discard it and fallback to listenAddrs is available", err2);
      }
    } else {
      log$t("did not receive signedPeerRecord in push");
    }
    try {
      await this.components.peerStore.addressBook.set(id, message2.listenAddrs.map((addr) => multiaddr(addr)));
    } catch (err2) {
      log$t.error("received invalid addrs", err2);
    }
    try {
      await this.components.peerStore.protoBook.set(id, message2.protocols);
    } catch (err2) {
      log$t.error("received invalid protocols", err2);
    }
    log$t("handled push from %p", id);
  }
  static getCleanMultiaddr(addr) {
    if (addr != null && addr.length > 0) {
      try {
        return multiaddr(addr);
      } catch {
      }
    }
  }
}
var FetchRequest;
(function(FetchRequest2) {
  let _codec;
  FetchRequest2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (opts.writeDefaults === true || obj.identifier !== "") {
          w.uint32(10);
          w.string(obj.identifier);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length3) => {
        const obj = {
          identifier: ""
        };
        const end2 = length3 == null ? reader2.len : reader2.pos + length3;
        while (reader2.pos < end2) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.identifier = reader2.string();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  FetchRequest2.encode = (obj) => {
    return encodeMessage(obj, FetchRequest2.codec());
  };
  FetchRequest2.decode = (buf2) => {
    return decodeMessage(buf2, FetchRequest2.codec());
  };
})(FetchRequest || (FetchRequest = {}));
var FetchResponse;
(function(FetchResponse2) {
  let StatusCode;
  (function(StatusCode2) {
    StatusCode2["OK"] = "OK";
    StatusCode2["NOT_FOUND"] = "NOT_FOUND";
    StatusCode2["ERROR"] = "ERROR";
  })(StatusCode = FetchResponse2.StatusCode || (FetchResponse2.StatusCode = {}));
  let __StatusCodeValues;
  (function(__StatusCodeValues2) {
    __StatusCodeValues2[__StatusCodeValues2["OK"] = 0] = "OK";
    __StatusCodeValues2[__StatusCodeValues2["NOT_FOUND"] = 1] = "NOT_FOUND";
    __StatusCodeValues2[__StatusCodeValues2["ERROR"] = 2] = "ERROR";
  })(__StatusCodeValues || (__StatusCodeValues = {}));
  (function(StatusCode2) {
    StatusCode2.codec = () => {
      return enumeration(__StatusCodeValues);
    };
  })(StatusCode = FetchResponse2.StatusCode || (FetchResponse2.StatusCode = {}));
  let _codec;
  FetchResponse2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (opts.writeDefaults === true || obj.status != null && __StatusCodeValues[obj.status] !== 0) {
          w.uint32(8);
          FetchResponse2.StatusCode.codec().encode(obj.status, w);
        }
        if (opts.writeDefaults === true || obj.data != null && obj.data.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length3) => {
        const obj = {
          status: StatusCode.OK,
          data: new Uint8Array(0)
        };
        const end2 = length3 == null ? reader2.len : reader2.pos + length3;
        while (reader2.pos < end2) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.status = FetchResponse2.StatusCode.codec().decode(reader2);
              break;
            case 2:
              obj.data = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  FetchResponse2.encode = (obj) => {
    return encodeMessage(obj, FetchResponse2.codec());
  };
  FetchResponse2.decode = (buf2) => {
    return decodeMessage(buf2, FetchResponse2.codec());
  };
})(FetchResponse || (FetchResponse = {}));
const PROTOCOL_VERSION$1 = "0.0.1";
const PROTOCOL_NAME$1 = "fetch";
const log$s = logger$1("libp2p:fetch");
class FetchService {
  constructor(components, init2) {
    this.started = false;
    this.components = components;
    this.protocol = `/${init2.protocolPrefix ?? "libp2p"}/${PROTOCOL_NAME$1}/${PROTOCOL_VERSION$1}`;
    this.lookupFunctions = /* @__PURE__ */ new Map();
    this.handleMessage = this.handleMessage.bind(this);
    this.init = init2;
  }
  async start() {
    await this.components.registrar.handle(this.protocol, (data) => {
      void this.handleMessage(data).catch((err2) => {
        log$s.error(err2);
      }).finally(() => {
        data.stream.close();
      });
    }, {
      maxInboundStreams: this.init.maxInboundStreams,
      maxOutboundStreams: this.init.maxOutboundStreams
    });
    this.started = true;
  }
  async stop() {
    await this.components.registrar.unhandle(this.protocol);
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  async fetch(peer, key, options = {}) {
    log$s("dialing %s to %p", this.protocol, peer);
    const connection = await this.components.connectionManager.openConnection(peer, options);
    let timeoutController;
    let signal = options.signal;
    let stream2;
    if (signal == null) {
      timeoutController = new timeoutAbortController.TimeoutController(this.init.timeout);
      signal = timeoutController.signal;
      try {
        events.exports.setMaxListeners?.(Infinity, timeoutController.signal);
      } catch {
      }
    }
    try {
      stream2 = await connection.newStream([this.protocol], {
        signal
      });
      const source2 = abortableDuplex(stream2, signal);
      const result = await pipe([FetchRequest.encode({ identifier: key })], encode$5(), source2, decode$3(), async function(source3) {
        const buf2 = await first$1(source3);
        if (buf2 == null) {
          throw errCode(new Error("No data received"), codes$1.ERR_INVALID_MESSAGE);
        }
        const response = FetchResponse.decode(buf2);
        switch (response.status) {
          case FetchResponse.StatusCode.OK: {
            return response.data;
          }
          case FetchResponse.StatusCode.NOT_FOUND: {
            return null;
          }
          case FetchResponse.StatusCode.ERROR: {
            const errmsg = new TextDecoder().decode(response.data);
            throw errCode(new Error("Error in fetch protocol response: " + errmsg), codes$1.ERR_INVALID_PARAMETERS);
          }
          default: {
            throw errCode(new Error("Unknown response status"), codes$1.ERR_INVALID_MESSAGE);
          }
        }
      });
      return result ?? null;
    } finally {
      if (timeoutController != null) {
        timeoutController.clear();
      }
      if (stream2 != null) {
        stream2.close();
      }
    }
  }
  async handleMessage(data) {
    const { stream: stream2 } = data;
    const self2 = this;
    await pipe(stream2, decode$3(), async function* (source2) {
      const buf2 = await first$1(source2);
      if (buf2 == null) {
        throw errCode(new Error("No data received"), codes$1.ERR_INVALID_MESSAGE);
      }
      const request2 = FetchRequest.decode(buf2);
      let response;
      const lookup2 = self2._getLookupFunction(request2.identifier);
      if (lookup2 != null) {
        const data2 = await lookup2(request2.identifier);
        if (data2 != null) {
          response = { status: FetchResponse.StatusCode.OK, data: data2 };
        } else {
          response = { status: FetchResponse.StatusCode.NOT_FOUND, data: new Uint8Array(0) };
        }
      } else {
        const errmsg = new TextEncoder().encode("No lookup function registered for key: " + request2.identifier);
        response = { status: FetchResponse.StatusCode.ERROR, data: errmsg };
      }
      yield FetchResponse.encode(response);
    }, encode$5(), stream2);
  }
  _getLookupFunction(key) {
    for (const prefix of this.lookupFunctions.keys()) {
      if (key.startsWith(prefix)) {
        return this.lookupFunctions.get(prefix);
      }
    }
  }
  registerLookupFunction(prefix, lookup2) {
    if (this.lookupFunctions.has(prefix)) {
      throw errCode(new Error("Fetch protocol handler for key prefix '" + prefix + "' already registered"), codes$1.ERR_KEY_ALREADY_EXISTS);
    }
    this.lookupFunctions.set(prefix, lookup2);
  }
  unregisterLookupFunction(prefix, lookup2) {
    if (lookup2 != null) {
      const existingLookup = this.lookupFunctions.get(prefix);
      if (existingLookup !== lookup2) {
        return;
      }
    }
    this.lookupFunctions.delete(prefix);
  }
}
const PING_LENGTH = 32;
const PROTOCOL_VERSION = "1.0.0";
const PROTOCOL_NAME = "ping";
const log$r = logger$1("libp2p:ping");
class PingService {
  constructor(components, init2) {
    this.components = components;
    this.started = false;
    this.protocol = `/${init2.protocolPrefix}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`;
    this.init = init2;
  }
  async start() {
    await this.components.registrar.handle(this.protocol, this.handleMessage, {
      maxInboundStreams: this.init.maxInboundStreams,
      maxOutboundStreams: this.init.maxOutboundStreams
    });
    this.started = true;
  }
  async stop() {
    await this.components.registrar.unhandle(this.protocol);
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  handleMessage(data) {
    const { stream: stream2 } = data;
    void pipe(stream2, stream2).catch((err2) => {
      log$r.error(err2);
    });
  }
  async ping(peer, options = {}) {
    log$r("dialing %s to %p", this.protocol, peer);
    const start = Date.now();
    const data = randomBytes$3(PING_LENGTH);
    const connection = await this.components.connectionManager.openConnection(peer, options);
    let timeoutController;
    let signal = options.signal;
    let stream2;
    if (signal == null) {
      timeoutController = new timeoutAbortController.TimeoutController(this.init.timeout);
      signal = timeoutController.signal;
      try {
        events.exports.setMaxListeners?.(Infinity, timeoutController.signal);
      } catch {
      }
    }
    try {
      stream2 = await connection.newStream([this.protocol], {
        signal
      });
      const source2 = abortableDuplex(stream2, signal);
      const result = await pipe([data], source2, async (source3) => await first$1(source3));
      const end2 = Date.now();
      if (result == null || !equals$1(data, result.subarray())) {
        throw errCode(new Error("Received wrong ping ack"), codes$1.ERR_WRONG_PING_ACK);
      }
      return end2 - start;
    } finally {
      if (timeoutController != null) {
        timeoutController.clear();
      }
      if (stream2 != null) {
        stream2.close();
      }
    }
  }
}
async function upnpNat() {
  throw new Error("Not supported in browsers");
}
const isEnvWithDom = typeof window === "object" && typeof document === "object" && document.nodeType === 9;
const isElectron = isElectron_1();
const isBrowser = isEnvWithDom && !isElectron;
const isElectronMain = isElectron && !isEnvWithDom;
const isElectronRenderer = isElectron && isEnvWithDom;
const isNode = typeof globalThis.process !== "undefined" && typeof globalThis.process.release !== "undefined" && globalThis.process.release.name === "node" && !isElectron;
const isWebWorker = typeof importScripts === "function" && typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
typeof globalThis.process !== "undefined" && typeof globalThis.process.env !== "undefined" && globalThis.process.env["NODE" + (() => "_")() + "ENV"] === "test";
const isReactNative = typeof navigator !== "undefined" && navigator.product === "ReactNative";
var lib = {};
const word = "[a-fA-F\\d:]";
const b = (options) => options && options.includeBoundaries ? `(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` : "";
const v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
const v6seg = "[a-fA-F\\d]{1,4}";
const v6 = `
(?:
(?:${v6seg}:){7}(?:${v6seg}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6seg}:){6}(?:${v4}|:${v6seg}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6seg}:){5}(?::${v4}|(?::${v6seg}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6seg}:){4}(?:(?::${v6seg}){0,1}:${v4}|(?::${v6seg}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6seg}:){3}(?:(?::${v6seg}){0,2}:${v4}|(?::${v6seg}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6seg}:){2}(?:(?::${v6seg}){0,3}:${v4}|(?::${v6seg}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6seg}:){1}(?:(?::${v6seg}){0,4}:${v4}|(?::${v6seg}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6seg}){0,5}:${v4}|(?::${v6seg}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
const v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);
const v4exact = new RegExp(`^${v4}$`);
const v6exact = new RegExp(`^${v6}$`);
const ip = (options) => options && options.exact ? v46Exact : new RegExp(`(?:${b(options)}${v4}${b(options)})|(?:${b(options)}${v6}${b(options)})`, "g");
ip.v4 = (options) => options && options.exact ? v4exact : new RegExp(`${b(options)}${v4}${b(options)}`, "g");
ip.v6 = (options) => options && options.exact ? v6exact : new RegExp(`${b(options)}${v6}${b(options)}`, "g");
var ipRegex$1 = ip;
const ipRegex = ipRegex$1;
const isIp = (string2) => ipRegex({ exact: true }).test(string2);
isIp.v4 = (string2) => ipRegex.v4({ exact: true }).test(string2);
isIp.v6 = (string2) => ipRegex.v6({ exact: true }).test(string2);
isIp.version = (string2) => isIp(string2) ? isIp.v4(string2) ? 4 : 6 : void 0;
var isIp_1 = isIp;
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(lib, "__esModule", { value: true });
const netmask_1 = netmask;
const ip_regex_1 = __importDefault(ipRegex$1);
const is_ip_1 = __importDefault(isIp_1);
const ipaddr_js_1 = ipaddr$1.exports;
const PRIVATE_IP_RANGES = [
  "0.0.0.0/8",
  "10.0.0.0/8",
  "100.64.0.0/10",
  "127.0.0.0/8",
  "169.254.0.0/16",
  "172.16.0.0/12",
  "192.0.0.0/24",
  "192.0.0.0/29",
  "192.0.0.8/32",
  "192.0.0.9/32",
  "192.0.0.10/32",
  "192.0.0.170/32",
  "192.0.0.171/32",
  "192.0.2.0/24",
  "192.31.196.0/24",
  "192.52.193.0/24",
  "192.88.99.0/24",
  "192.168.0.0/16",
  "192.175.48.0/24",
  "198.18.0.0/15",
  "198.51.100.0/24",
  "203.0.113.0/24",
  "240.0.0.0/4",
  "255.255.255.255/32"
];
const NETMASK_RANGES = PRIVATE_IP_RANGES.map((ip_range) => new netmask_1.Netmask(ip_range));
function ipv4_check(ip_addr) {
  for (let r of NETMASK_RANGES) {
    if (r.contains(ip_addr))
      return true;
  }
  return false;
}
function ipv6_check(ip_addr) {
  return /^::$/.test(ip_addr) || /^::1$/.test(ip_addr) || /^::f{4}:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^::f{4}:0.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(ip_addr) || /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(ip_addr) || /^ff([0-9a-fA-F]{2,2}):/i.test(ip_addr);
}
lib.default = (ip2) => {
  if ((0, ipaddr_js_1.isValid)(ip2)) {
    const parsed = (0, ipaddr_js_1.parse)(ip2);
    if (parsed.kind() === "ipv4")
      return ipv4_check(parsed.toNormalizedString());
    else if (parsed.kind() === "ipv6")
      return ipv6_check(ip2);
  } else if ((0, is_ip_1.default)(ip2) && ip_regex_1.default.v6().test(ip2))
    return ipv6_check(ip2);
  return void 0;
};
var privateIp = lib.default;
function isLoopbackAddr(ip2) {
  return /^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(ip2) || /^::1$/.test(ip2);
}
function isLoopback(ma) {
  const { address } = ma.nodeAddress();
  return isLoopbackAddr(address);
}
const log$q = logger$1("libp2p:nat");
const DEFAULT_TTL = 7200;
function highPort(min = 1024, max = 65535) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}
class NatManager {
  constructor(components, init2) {
    this.components = components;
    this.started = false;
    this.enabled = init2.enabled;
    this.externalAddress = init2.externalAddress;
    this.localAddress = init2.localAddress;
    this.description = init2.description ?? `${name}@${version} ${this.components.peerId.toString()}`;
    this.ttl = init2.ttl ?? DEFAULT_TTL;
    this.keepAlive = init2.keepAlive ?? true;
    this.gateway = init2.gateway;
    if (this.ttl < DEFAULT_TTL) {
      throw errCode(new Error(`NatManager ttl should be at least ${DEFAULT_TTL} seconds`), codes$1.ERR_INVALID_PARAMETERS);
    }
  }
  isStarted() {
    return this.started;
  }
  start() {
  }
  afterStart() {
    if (isBrowser || !this.enabled || this.started) {
      return;
    }
    this.started = true;
    void this._start().catch((err2) => {
      log$q.error(err2);
    });
  }
  async _start() {
    const addrs = this.components.transportManager.getAddrs();
    for (const addr of addrs) {
      const { family, host, port, transport } = addr.toOptions();
      if (!addr.isThinWaistAddress() || transport !== "tcp") {
        continue;
      }
      if (isLoopback(addr)) {
        continue;
      }
      if (family !== 4) {
        continue;
      }
      const client = await this._getClient();
      const publicIp = this.externalAddress ?? await client.externalIp();
      if (privateIp(publicIp)) {
        throw new Error(`${publicIp} is private - please set config.nat.externalIp to an externally routable IP or ensure you are not behind a double NAT`);
      }
      const publicPort = highPort();
      log$q(`opening uPnP connection from ${publicIp}:${publicPort} to ${host}:${port}`);
      await client.map({
        publicPort,
        localPort: port,
        localAddress: this.localAddress,
        protocol: transport.toUpperCase() === "TCP" ? "TCP" : "UDP"
      });
      this.components.addressManager.addObservedAddr(fromNodeAddress({
        family: 4,
        address: publicIp,
        port: publicPort
      }, transport));
    }
  }
  async _getClient() {
    if (this.client != null) {
      return this.client;
    }
    this.client = await upnpNat({
      description: this.description,
      ttl: this.ttl,
      keepAlive: this.keepAlive,
      gateway: this.gateway
    });
    return this.client;
  }
  async stop() {
    if (isBrowser || this.client == null) {
      return;
    }
    try {
      await this.client.close();
      this.client = void 0;
    } catch (err2) {
      log$q.error(err2);
    }
  }
}
const log$p = logger$1("libp2p:peer-record-updater");
class PeerRecordUpdater {
  constructor(components) {
    this.components = components;
    this.started = false;
    this.update = this.update.bind(this);
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.started = true;
    this.components.transportManager.addEventListener("listener:listening", this.update);
    this.components.transportManager.addEventListener("listener:close", this.update);
    this.components.addressManager.addEventListener("change:addresses", this.update);
  }
  async stop() {
    this.started = false;
    this.components.transportManager.removeEventListener("listener:listening", this.update);
    this.components.transportManager.removeEventListener("listener:close", this.update);
    this.components.addressManager.removeEventListener("change:addresses", this.update);
  }
  update() {
    Promise.resolve().then(async () => {
      const peerRecord = new PeerRecord({
        peerId: this.components.peerId,
        multiaddrs: this.components.addressManager.getAddresses().map((ma) => ma.decapsulateCode(getProtocol("p2p").code))
      });
      const envelope = await RecordEnvelope.seal(peerRecord, this.components.peerId);
      await this.components.peerStore.addressBook.consumePeerRecord(envelope);
    }).catch((err2) => {
      log$p.error("Could not update self peer record: %o", err2);
    });
  }
}
class DHTPeerRouting {
  constructor(dht) {
    this.dht = dht;
  }
  async findPeer(peerId, options = {}) {
    for await (const event of this.dht.findPeer(peerId, options)) {
      if (event.name === "FINAL_PEER") {
        return event.peer;
      }
    }
    throw errCode(new Error(messages.NOT_FOUND), codes$1.ERR_NOT_FOUND);
  }
  async *getClosestPeers(key, options = {}) {
    for await (const event of this.dht.getClosestPeers(key, options)) {
      if (event.name === "FINAL_PEER") {
        yield event.peer;
      }
    }
  }
}
const codes = {
  ERR_INVALID_PARAMETERS: "ERR_INVALID_PARAMETERS",
  ERR_NOT_FOUND: "ERR_NOT_FOUND"
};
const each = async function* (source2, fn) {
  for await (const thing of source2) {
    await fn(thing);
    yield thing;
  }
};
var itForeach = each;
const log$o = logger$1("libp2p:peer-store:address-book");
const EVENT_NAME$3 = "change:multiaddrs";
async function allowAll() {
  return true;
}
class PeerStoreAddressBook {
  constructor(dispatchEvent, store, addressFilter) {
    this.dispatchEvent = dispatchEvent;
    this.store = store;
    this.addressFilter = addressFilter ?? allowAll;
  }
  async consumePeerRecord(envelope) {
    log$o.trace("consumePeerRecord await write lock");
    const release = await this.store.lock.writeLock();
    log$o.trace("consumePeerRecord got write lock");
    let peerId;
    let peer;
    let updatedPeer;
    try {
      let peerRecord;
      try {
        peerRecord = PeerRecord.createFromProtobuf(envelope.payload);
      } catch (err2) {
        log$o.error("invalid peer record received");
        return false;
      }
      peerId = peerRecord.peerId;
      const multiaddrs = peerRecord.multiaddrs;
      if (!peerId.equals(envelope.peerId)) {
        log$o("signing key does not match PeerId in the PeerRecord");
        return false;
      }
      if (multiaddrs == null || multiaddrs.length === 0) {
        return false;
      }
      if (await this.store.has(peerId)) {
        peer = await this.store.load(peerId);
        if (peer.peerRecordEnvelope != null) {
          const storedEnvelope = await RecordEnvelope.createFromProtobuf(peer.peerRecordEnvelope);
          const storedRecord = PeerRecord.createFromProtobuf(storedEnvelope.payload);
          if (storedRecord.seqNumber >= peerRecord.seqNumber) {
            log$o("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
            return false;
          }
        }
      }
      const addresses = await filterMultiaddrs(peerId, multiaddrs, this.addressFilter, true);
      updatedPeer = await this.store.patchOrCreate(peerId, {
        addresses,
        peerRecordEnvelope: envelope.marshal().subarray()
      });
      log$o("stored provided peer record for %p", peerRecord.peerId);
    } finally {
      log$o.trace("consumePeerRecord release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME$3, {
      detail: {
        peerId,
        multiaddrs: updatedPeer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2),
        oldMultiaddrs: peer == null ? [] : peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
      }
    }));
    return true;
  }
  async getRawEnvelope(peerId) {
    log$o.trace("getRawEnvelope await read lock");
    const release = await this.store.lock.readLock();
    log$o.trace("getRawEnvelope got read lock");
    try {
      const peer = await this.store.load(peerId);
      return peer.peerRecordEnvelope;
    } catch (err2) {
      if (err2.code !== codes.ERR_NOT_FOUND) {
        throw err2;
      }
    } finally {
      log$o.trace("getRawEnvelope release read lock");
      release();
    }
  }
  async getPeerRecord(peerId) {
    const raw2 = await this.getRawEnvelope(peerId);
    if (raw2 == null) {
      return void 0;
    }
    return await RecordEnvelope.createFromProtobuf(raw2);
  }
  async get(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log$o.trace("get wait for read lock");
    const release = await this.store.lock.readLock();
    log$o.trace("get got read lock");
    try {
      const peer = await this.store.load(peerId);
      return peer.addresses;
    } catch (err2) {
      if (err2.code !== codes.ERR_NOT_FOUND) {
        throw err2;
      }
    } finally {
      log$o.trace("get release read lock");
      release();
    }
    return [];
  }
  async set(peerId, multiaddrs) {
    peerId = peerIdFromPeerId(peerId);
    if (!Array.isArray(multiaddrs)) {
      log$o.error("multiaddrs must be an array of Multiaddrs");
      throw errCode(new Error("multiaddrs must be an array of Multiaddrs"), codes.ERR_INVALID_PARAMETERS);
    }
    log$o.trace("set await write lock");
    const release = await this.store.lock.writeLock();
    log$o.trace("set got write lock");
    let hasPeer = false;
    let peer;
    let updatedPeer;
    try {
      const addresses = await filterMultiaddrs(peerId, multiaddrs, this.addressFilter);
      if (addresses.length === 0) {
        return;
      }
      try {
        peer = await this.store.load(peerId);
        hasPeer = true;
        if ((/* @__PURE__ */ new Set([
          ...addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()),
          ...peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString())
        ])).size === peer.addresses.length && addresses.length === peer.addresses.length) {
          return;
        }
      } catch (err2) {
        if (err2.code !== codes.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      updatedPeer = await this.store.patchOrCreate(peerId, { addresses });
      log$o("set multiaddrs for %p", peerId);
    } finally {
      log$o.trace("set multiaddrs for %p", peerId);
      log$o("set release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME$3, {
      detail: {
        peerId,
        multiaddrs: updatedPeer.addresses.map((addr) => addr.multiaddr),
        oldMultiaddrs: peer == null ? [] : peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
      }
    }));
    if (!hasPeer) {
      this.dispatchEvent(new CustomEvent("peer", {
        detail: {
          id: peerId,
          multiaddrs: updatedPeer.addresses.map((addr) => addr.multiaddr),
          protocols: updatedPeer.protocols
        }
      }));
    }
  }
  async add(peerId, multiaddrs) {
    peerId = peerIdFromPeerId(peerId);
    if (!Array.isArray(multiaddrs)) {
      log$o.error("multiaddrs must be an array of Multiaddrs");
      throw errCode(new Error("multiaddrs must be an array of Multiaddrs"), codes.ERR_INVALID_PARAMETERS);
    }
    log$o.trace("add await write lock");
    const release = await this.store.lock.writeLock();
    log$o.trace("add got write lock");
    let hasPeer;
    let peer;
    let updatedPeer;
    try {
      const addresses = await filterMultiaddrs(peerId, multiaddrs, this.addressFilter);
      if (addresses.length === 0) {
        return;
      }
      try {
        peer = await this.store.load(peerId);
        hasPeer = true;
        if ((/* @__PURE__ */ new Set([
          ...addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()),
          ...peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString())
        ])).size === peer.addresses.length) {
          return;
        }
      } catch (err2) {
        if (err2.code !== codes.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      updatedPeer = await this.store.mergeOrCreate(peerId, { addresses });
      log$o("added multiaddrs for %p", peerId);
    } finally {
      log$o.trace("set release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME$3, {
      detail: {
        peerId,
        multiaddrs: updatedPeer.addresses.map((addr) => addr.multiaddr),
        oldMultiaddrs: peer == null ? [] : peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
      }
    }));
    if (hasPeer === true) {
      this.dispatchEvent(new CustomEvent("peer", {
        detail: {
          id: peerId,
          multiaddrs: updatedPeer.addresses.map((addr) => addr.multiaddr),
          protocols: updatedPeer.protocols
        }
      }));
    }
  }
  async delete(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log$o.trace("delete await write lock");
    const release = await this.store.lock.writeLock();
    log$o.trace("delete got write lock");
    let peer;
    try {
      try {
        peer = await this.store.load(peerId);
      } catch (err2) {
        if (err2.code !== codes.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      await this.store.patchOrCreate(peerId, {
        addresses: []
      });
    } finally {
      log$o.trace("delete release write lock");
      release();
    }
    if (peer != null) {
      this.dispatchEvent(new CustomEvent(EVENT_NAME$3, {
        detail: {
          peerId,
          multiaddrs: [],
          oldMultiaddrs: peer == null ? [] : peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
        }
      }));
    }
  }
}
async function filterMultiaddrs(peerId, multiaddrs, addressFilter, isCertified = false) {
  return await pipe(multiaddrs, (source2) => itForeach(source2, (multiaddr2) => {
    if (!isMultiaddr(multiaddr2)) {
      log$o.error("multiaddr must be an instance of Multiaddr");
      throw errCode(new Error("multiaddr must be an instance of Multiaddr"), codes.ERR_INVALID_PARAMETERS);
    }
  }), (source2) => itFilter(source2, async (multiaddr2) => await addressFilter(peerId, multiaddr2)), (source2) => itMap(source2, (multiaddr2) => {
    return {
      multiaddr: multiaddr2,
      isCertified
    };
  }), async (source2) => await itAll(source2));
}
const log$n = logger$1("libp2p:peer-store:key-book");
const EVENT_NAME$2 = "change:pubkey";
class PeerStoreKeyBook {
  constructor(dispatchEvent, store) {
    this.dispatchEvent = dispatchEvent;
    this.store = store;
  }
  async set(peerId, publicKey) {
    peerId = peerIdFromPeerId(peerId);
    if (!(publicKey instanceof Uint8Array)) {
      log$n.error("publicKey must be an instance of Uint8Array to store data");
      throw errCode(new Error("publicKey must be an instance of PublicKey"), codes.ERR_INVALID_PARAMETERS);
    }
    log$n.trace("set await write lock");
    const release = await this.store.lock.writeLock();
    log$n.trace("set got write lock");
    let updatedKey = false;
    let peer;
    try {
      try {
        peer = await this.store.load(peerId);
        if (peer.pubKey != null && equals$1(peer.pubKey, publicKey)) {
          return;
        }
      } catch (err2) {
        if (err2.code !== codes.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      await this.store.patchOrCreate(peerId, {
        pubKey: publicKey
      });
      updatedKey = true;
    } finally {
      log$n.trace("set release write lock");
      release();
    }
    if (updatedKey) {
      this.dispatchEvent(new CustomEvent(EVENT_NAME$2, {
        detail: {
          peerId,
          publicKey,
          oldPublicKey: peer == null ? void 0 : peer.pubKey
        }
      }));
    }
  }
  async get(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log$n.trace("get await write lock");
    const release = await this.store.lock.readLock();
    log$n.trace("get got write lock");
    try {
      const peer = await this.store.load(peerId);
      return peer.pubKey;
    } catch (err2) {
      if (err2.code !== codes.ERR_NOT_FOUND) {
        throw err2;
      }
    } finally {
      log$n("get release write lock");
      release();
    }
  }
  async delete(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log$n.trace("delete await write lock");
    const release = await this.store.lock.writeLock();
    log$n.trace("delete got write lock");
    let peer;
    try {
      try {
        peer = await this.store.load(peerId);
      } catch (err2) {
        if (err2.code !== codes.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      await this.store.patchOrCreate(peerId, {
        pubKey: void 0
      });
    } catch (err2) {
      if (err2.code !== codes.ERR_NOT_FOUND) {
        throw err2;
      }
    } finally {
      log$n.trace("delete release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME$2, {
      detail: {
        peerId,
        publicKey: void 0,
        oldPublicKey: peer == null ? void 0 : peer.pubKey
      }
    }));
  }
}
const log$m = logger$1("libp2p:peer-store:metadata-book");
const EVENT_NAME$1 = "change:metadata";
class PeerStoreMetadataBook {
  constructor(dispatchEvent, store) {
    this.dispatchEvent = dispatchEvent;
    this.store = store;
  }
  async get(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log$m.trace("get await read lock");
    const release = await this.store.lock.readLock();
    log$m.trace("get got read lock");
    try {
      const peer = await this.store.load(peerId);
      return peer.metadata;
    } catch (err2) {
      if (err2.code !== codes.ERR_NOT_FOUND) {
        throw err2;
      }
    } finally {
      log$m.trace("get release read lock");
      release();
    }
    return /* @__PURE__ */ new Map();
  }
  async getValue(peerId, key) {
    peerId = peerIdFromPeerId(peerId);
    log$m.trace("getValue await read lock");
    const release = await this.store.lock.readLock();
    log$m.trace("getValue got read lock");
    try {
      const peer = await this.store.load(peerId);
      return peer.metadata.get(key);
    } catch (err2) {
      if (err2.code !== codes.ERR_NOT_FOUND) {
        throw err2;
      }
    } finally {
      log$m.trace("getValue release write lock");
      release();
    }
  }
  async set(peerId, metadata) {
    peerId = peerIdFromPeerId(peerId);
    if (!(metadata instanceof Map)) {
      log$m.error("valid metadata must be provided to store data");
      throw errCode(new Error("valid metadata must be provided"), codes.ERR_INVALID_PARAMETERS);
    }
    log$m.trace("set await write lock");
    const release = await this.store.lock.writeLock();
    log$m.trace("set got write lock");
    let peer;
    try {
      try {
        peer = await this.store.load(peerId);
      } catch (err2) {
        if (err2.code !== codes.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      await this.store.mergeOrCreate(peerId, {
        metadata
      });
    } finally {
      log$m.trace("set release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME$1, {
      detail: {
        peerId,
        metadata,
        oldMetadata: peer == null ? /* @__PURE__ */ new Map() : peer.metadata
      }
    }));
  }
  async setValue(peerId, key, value2) {
    peerId = peerIdFromPeerId(peerId);
    if (typeof key !== "string" || !(value2 instanceof Uint8Array)) {
      log$m.error("valid key and value must be provided to store data");
      throw errCode(new Error("valid key and value must be provided"), codes.ERR_INVALID_PARAMETERS);
    }
    log$m.trace("setValue await write lock");
    const release = await this.store.lock.writeLock();
    log$m.trace("setValue got write lock");
    let peer;
    let updatedPeer;
    try {
      try {
        peer = await this.store.load(peerId);
        const existingValue = peer.metadata.get(key);
        if (existingValue != null && equals$1(value2, existingValue)) {
          return;
        }
      } catch (err2) {
        if (err2.code !== codes.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      updatedPeer = await this.store.mergeOrCreate(peerId, {
        metadata: /* @__PURE__ */ new Map([[key, value2]])
      });
    } finally {
      log$m.trace("setValue release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME$1, {
      detail: {
        peerId,
        metadata: updatedPeer.metadata,
        oldMetadata: peer == null ? /* @__PURE__ */ new Map() : peer.metadata
      }
    }));
  }
  async delete(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log$m.trace("delete await write lock");
    const release = await this.store.lock.writeLock();
    log$m.trace("delete got write lock");
    let peer;
    try {
      try {
        peer = await this.store.load(peerId);
      } catch (err2) {
        if (err2.code !== codes.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      if (peer != null) {
        await this.store.patch(peerId, {
          metadata: /* @__PURE__ */ new Map()
        });
      }
    } finally {
      log$m.trace("delete release write lock");
      release();
    }
    if (peer != null) {
      this.dispatchEvent(new CustomEvent(EVENT_NAME$1, {
        detail: {
          peerId,
          metadata: /* @__PURE__ */ new Map(),
          oldMetadata: peer.metadata
        }
      }));
    }
  }
  async deleteValue(peerId, key) {
    peerId = peerIdFromPeerId(peerId);
    log$m.trace("deleteValue await write lock");
    const release = await this.store.lock.writeLock();
    log$m.trace("deleteValue got write lock");
    let metadata;
    let peer;
    try {
      peer = await this.store.load(peerId);
      metadata = peer.metadata;
      metadata.delete(key);
      await this.store.patch(peerId, {
        metadata
      });
    } catch (err2) {
      if (err2.code !== codes.ERR_NOT_FOUND) {
        throw err2;
      }
    } finally {
      log$m.trace("deleteValue release write lock");
      release();
    }
    if (metadata != null) {
      this.dispatchEvent(new CustomEvent(EVENT_NAME$1, {
        detail: {
          peerId,
          metadata,
          oldMetadata: peer == null ? /* @__PURE__ */ new Map() : peer.metadata
        }
      }));
    }
  }
}
const log$l = logger$1("libp2p:peer-store:proto-book");
const EVENT_NAME = "change:protocols";
class PeerStoreProtoBook {
  constructor(dispatchEvent, store) {
    this.dispatchEvent = dispatchEvent;
    this.store = store;
  }
  async get(peerId) {
    log$l.trace("get wait for read lock");
    const release = await this.store.lock.readLock();
    log$l.trace("get got read lock");
    try {
      const peer = await this.store.load(peerId);
      return peer.protocols;
    } catch (err2) {
      if (err2.code !== codes.ERR_NOT_FOUND) {
        throw err2;
      }
    } finally {
      log$l.trace("get release read lock");
      release();
    }
    return [];
  }
  async set(peerId, protocols) {
    peerId = peerIdFromPeerId(peerId);
    if (!Array.isArray(protocols)) {
      log$l.error("protocols must be provided to store data");
      throw errCode(new Error("protocols must be provided"), codes.ERR_INVALID_PARAMETERS);
    }
    log$l.trace("set await write lock");
    const release = await this.store.lock.writeLock();
    log$l.trace("set got write lock");
    let peer;
    let updatedPeer;
    try {
      try {
        peer = await this.store.load(peerId);
        if ((/* @__PURE__ */ new Set([
          ...protocols
        ])).size === peer.protocols.length) {
          return;
        }
      } catch (err2) {
        if (err2.code !== codes.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      updatedPeer = await this.store.patchOrCreate(peerId, {
        protocols
      });
      log$l("stored provided protocols for %p", peerId);
    } finally {
      log$l.trace("set release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME, {
      detail: {
        peerId,
        protocols: updatedPeer.protocols,
        oldProtocols: peer == null ? [] : peer.protocols
      }
    }));
  }
  async add(peerId, protocols) {
    peerId = peerIdFromPeerId(peerId);
    if (!Array.isArray(protocols)) {
      log$l.error("protocols must be provided to store data");
      throw errCode(new Error("protocols must be provided"), codes.ERR_INVALID_PARAMETERS);
    }
    log$l.trace("add await write lock");
    const release = await this.store.lock.writeLock();
    log$l.trace("add got write lock");
    let peer;
    let updatedPeer;
    try {
      try {
        peer = await this.store.load(peerId);
        if ((/* @__PURE__ */ new Set([
          ...peer.protocols,
          ...protocols
        ])).size === peer.protocols.length) {
          return;
        }
      } catch (err2) {
        if (err2.code !== codes.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      updatedPeer = await this.store.mergeOrCreate(peerId, {
        protocols
      });
      log$l("added provided protocols for %p", peerId);
    } finally {
      log$l.trace("add release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME, {
      detail: {
        peerId,
        protocols: updatedPeer.protocols,
        oldProtocols: peer == null ? [] : peer.protocols
      }
    }));
  }
  async remove(peerId, protocols) {
    peerId = peerIdFromPeerId(peerId);
    if (!Array.isArray(protocols)) {
      log$l.error("protocols must be provided to store data");
      throw errCode(new Error("protocols must be provided"), codes.ERR_INVALID_PARAMETERS);
    }
    log$l.trace("remove await write lock");
    const release = await this.store.lock.writeLock();
    log$l.trace("remove got write lock");
    let peer;
    let updatedPeer;
    try {
      try {
        peer = await this.store.load(peerId);
        const protocolSet = new Set(peer.protocols);
        for (const protocol2 of protocols) {
          protocolSet.delete(protocol2);
        }
        if (peer.protocols.length === protocolSet.size) {
          return;
        }
        protocols = Array.from(protocolSet);
      } catch (err2) {
        if (err2.code !== codes.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      updatedPeer = await this.store.patchOrCreate(peerId, {
        protocols
      });
    } finally {
      log$l.trace("remove release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME, {
      detail: {
        peerId,
        protocols: updatedPeer.protocols,
        oldProtocols: peer == null ? [] : peer.protocols
      }
    }));
  }
  async delete(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log$l.trace("delete await write lock");
    const release = await this.store.lock.writeLock();
    log$l.trace("delete got write lock");
    let peer;
    try {
      try {
        peer = await this.store.load(peerId);
      } catch (err2) {
        if (err2.code !== codes.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      await this.store.patchOrCreate(peerId, {
        protocols: []
      });
    } finally {
      log$l.trace("delete release write lock");
      release();
    }
    if (peer != null) {
      this.dispatchEvent(new CustomEvent(EVENT_NAME, {
        detail: {
          peerId,
          protocols: [],
          oldProtocols: peer.protocols
        }
      }));
    }
  }
}
var Peer;
(function(Peer2) {
  let _codec;
  Peer2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.addresses != null) {
          for (const value2 of obj.addresses) {
            w.uint32(10);
            Address.codec().encode(value2, w, {
              writeDefaults: true
            });
          }
        }
        if (obj.protocols != null) {
          for (const value2 of obj.protocols) {
            w.uint32(18);
            w.string(value2);
          }
        }
        if (obj.metadata != null) {
          for (const value2 of obj.metadata) {
            w.uint32(26);
            Metadata.codec().encode(value2, w, {
              writeDefaults: true
            });
          }
        }
        if (obj.pubKey != null) {
          w.uint32(34);
          w.bytes(obj.pubKey);
        }
        if (obj.peerRecordEnvelope != null) {
          w.uint32(42);
          w.bytes(obj.peerRecordEnvelope);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length3) => {
        const obj = {
          addresses: [],
          protocols: [],
          metadata: []
        };
        const end2 = length3 == null ? reader2.len : reader2.pos + length3;
        while (reader2.pos < end2) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.addresses.push(Address.codec().decode(reader2, reader2.uint32()));
              break;
            case 2:
              obj.protocols.push(reader2.string());
              break;
            case 3:
              obj.metadata.push(Metadata.codec().decode(reader2, reader2.uint32()));
              break;
            case 4:
              obj.pubKey = reader2.bytes();
              break;
            case 5:
              obj.peerRecordEnvelope = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Peer2.encode = (obj) => {
    return encodeMessage(obj, Peer2.codec());
  };
  Peer2.decode = (buf2) => {
    return decodeMessage(buf2, Peer2.codec());
  };
})(Peer || (Peer = {}));
var Address;
(function(Address2) {
  let _codec;
  Address2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (opts.writeDefaults === true || obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.multiaddr);
        }
        if (obj.isCertified != null) {
          w.uint32(16);
          w.bool(obj.isCertified);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length3) => {
        const obj = {
          multiaddr: new Uint8Array(0)
        };
        const end2 = length3 == null ? reader2.len : reader2.pos + length3;
        while (reader2.pos < end2) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.multiaddr = reader2.bytes();
              break;
            case 2:
              obj.isCertified = reader2.bool();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Address2.encode = (obj) => {
    return encodeMessage(obj, Address2.codec());
  };
  Address2.decode = (buf2) => {
    return decodeMessage(buf2, Address2.codec());
  };
})(Address || (Address = {}));
var Metadata;
(function(Metadata2) {
  let _codec;
  Metadata2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (opts.writeDefaults === true || obj.key !== "") {
          w.uint32(10);
          w.string(obj.key);
        }
        if (opts.writeDefaults === true || obj.value != null && obj.value.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.value);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length3) => {
        const obj = {
          key: "",
          value: new Uint8Array(0)
        };
        const end2 = length3 == null ? reader2.len : reader2.pos + length3;
        while (reader2.pos < end2) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.key = reader2.string();
              break;
            case 2:
              obj.value = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Metadata2.encode = (obj) => {
    return encodeMessage(obj, Metadata2.codec());
  };
  Metadata2.decode = (buf2) => {
    return decodeMessage(buf2, Metadata2.codec());
  };
})(Metadata || (Metadata = {}));
const log$k = logger$1("libp2p:peer-store:store");
const NAMESPACE_COMMON = "/peers/";
class PersistentStore {
  constructor(components) {
    this.components = components;
    this.lock = createMortice({
      name: "peer-store",
      singleProcess: true
    });
  }
  _peerIdToDatastoreKey(peerId) {
    if (peerId.type == null) {
      log$k.error("peerId must be an instance of peer-id to store data");
      throw errCode(new Error("peerId must be an instance of peer-id"), codes.ERR_INVALID_PARAMETERS);
    }
    const b32key = peerId.toCID().toString();
    return new Key(`${NAMESPACE_COMMON}${b32key}`);
  }
  async has(peerId) {
    return await this.components.datastore.has(this._peerIdToDatastoreKey(peerId));
  }
  async delete(peerId) {
    await this.components.datastore.delete(this._peerIdToDatastoreKey(peerId));
  }
  async load(peerId) {
    const buf2 = await this.components.datastore.get(this._peerIdToDatastoreKey(peerId));
    const peer = Peer.decode(buf2);
    const metadata = /* @__PURE__ */ new Map();
    for (const meta of peer.metadata) {
      metadata.set(meta.key, meta.value);
    }
    return {
      ...peer,
      id: peerId,
      addresses: peer.addresses.map(({ multiaddr: ma, isCertified }) => {
        return {
          multiaddr: multiaddr(ma),
          isCertified: isCertified ?? false
        };
      }),
      metadata,
      pubKey: peer.pubKey ?? void 0,
      peerRecordEnvelope: peer.peerRecordEnvelope ?? void 0
    };
  }
  async save(peer) {
    if (peer.pubKey != null && peer.id.publicKey != null && !equals$1(peer.pubKey, peer.id.publicKey)) {
      log$k.error("peer publicKey bytes do not match peer id publicKey bytes");
      throw errCode(new Error("publicKey bytes do not match peer id publicKey bytes"), codes.ERR_INVALID_PARAMETERS);
    }
    const addressSet = /* @__PURE__ */ new Set();
    const addresses = peer.addresses.filter((address) => {
      if (addressSet.has(address.multiaddr.toString())) {
        return false;
      }
      addressSet.add(address.multiaddr.toString());
      return true;
    }).sort((a, b2) => {
      return a.multiaddr.toString().localeCompare(b2.multiaddr.toString());
    }).map(({ multiaddr: multiaddr2, isCertified }) => ({
      multiaddr: multiaddr2.bytes,
      isCertified
    }));
    const metadata = [];
    [...peer.metadata.keys()].sort().forEach((key) => {
      const value2 = peer.metadata.get(key);
      if (value2 != null) {
        metadata.push({ key, value: value2 });
      }
    });
    const buf2 = Peer.encode({
      addresses,
      protocols: peer.protocols.sort(),
      pubKey: peer.pubKey,
      metadata,
      peerRecordEnvelope: peer.peerRecordEnvelope
    });
    await this.components.datastore.put(this._peerIdToDatastoreKey(peer.id), buf2.subarray());
    return await this.load(peer.id);
  }
  async patch(peerId, data) {
    const peer = await this.load(peerId);
    return await this._patch(peerId, data, peer);
  }
  async patchOrCreate(peerId, data) {
    let peer;
    try {
      peer = await this.load(peerId);
    } catch (err2) {
      if (err2.code !== codes.ERR_NOT_FOUND) {
        throw err2;
      }
      peer = { id: peerId, addresses: [], protocols: [], metadata: /* @__PURE__ */ new Map() };
    }
    return await this._patch(peerId, data, peer);
  }
  async _patch(peerId, data, peer) {
    return await this.save({
      ...peer,
      ...data,
      id: peerId
    });
  }
  async merge(peerId, data) {
    const peer = await this.load(peerId);
    return await this._merge(peerId, data, peer);
  }
  async mergeOrCreate(peerId, data) {
    let peer;
    try {
      peer = await this.load(peerId);
    } catch (err2) {
      if (err2.code !== codes.ERR_NOT_FOUND) {
        throw err2;
      }
      peer = { id: peerId, addresses: [], protocols: [], metadata: /* @__PURE__ */ new Map() };
    }
    return await this._merge(peerId, data, peer);
  }
  async _merge(peerId, data, peer) {
    const addresses = /* @__PURE__ */ new Map();
    peer.addresses.forEach((addr) => {
      addresses.set(addr.multiaddr.toString(), addr.isCertified);
    });
    (data.addresses ?? []).forEach((addr) => {
      const addrString = addr.multiaddr.toString();
      const isAlreadyCertified = Boolean(addresses.get(addrString));
      const isCertified = isAlreadyCertified || addr.isCertified;
      addresses.set(addrString, isCertified);
    });
    return await this.save({
      id: peerId,
      addresses: Array.from(addresses.entries()).map(([addrStr, isCertified]) => {
        return {
          multiaddr: multiaddr(addrStr),
          isCertified
        };
      }),
      protocols: Array.from(/* @__PURE__ */ new Set([
        ...peer.protocols ?? [],
        ...data.protocols ?? []
      ])),
      metadata: new Map([
        ...peer.metadata?.entries() ?? [],
        ...data.metadata?.entries() ?? []
      ]),
      pubKey: data.pubKey ?? (peer != null ? peer.pubKey : void 0),
      peerRecordEnvelope: data.peerRecordEnvelope ?? (peer != null ? peer.peerRecordEnvelope : void 0)
    });
  }
  async *all() {
    for await (const key of this.components.datastore.queryKeys({
      prefix: NAMESPACE_COMMON
    })) {
      const base32Str = key.toString().split("/")[2];
      const buf2 = base32$2.decode(base32Str);
      yield this.load(peerIdFromBytes(buf2));
    }
  }
}
var Tags;
(function(Tags2) {
  let _codec;
  Tags2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.tags != null) {
          for (const value2 of obj.tags) {
            w.uint32(10);
            Tag.codec().encode(value2, w, {
              writeDefaults: true
            });
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length3) => {
        const obj = {
          tags: []
        };
        const end2 = length3 == null ? reader2.len : reader2.pos + length3;
        while (reader2.pos < end2) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.tags.push(Tag.codec().decode(reader2, reader2.uint32()));
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Tags2.encode = (obj) => {
    return encodeMessage(obj, Tags2.codec());
  };
  Tags2.decode = (buf2) => {
    return decodeMessage(buf2, Tags2.codec());
  };
})(Tags || (Tags = {}));
var Tag;
(function(Tag2) {
  let _codec;
  Tag2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (opts.writeDefaults === true || obj.name !== "") {
          w.uint32(10);
          w.string(obj.name);
        }
        if (obj.value != null) {
          w.uint32(16);
          w.uint32(obj.value);
        }
        if (obj.expiry != null) {
          w.uint32(24);
          w.uint64(obj.expiry);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length3) => {
        const obj = {
          name: ""
        };
        const end2 = length3 == null ? reader2.len : reader2.pos + length3;
        while (reader2.pos < end2) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.name = reader2.string();
              break;
            case 2:
              obj.value = reader2.uint32();
              break;
            case 3:
              obj.expiry = reader2.uint64();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Tag2.encode = (obj) => {
    return encodeMessage(obj, Tag2.codec());
  };
  Tag2.decode = (buf2) => {
    return decodeMessage(buf2, Tag2.codec());
  };
})(Tag || (Tag = {}));
const log$j = logger$1("libp2p:peer-store");
class PersistentPeerStore extends EventEmitter$1 {
  constructor(components, init2 = {}) {
    super();
    this.components = components;
    this.store = new PersistentStore(components);
    this.addressBook = new PeerStoreAddressBook(this.dispatchEvent.bind(this), this.store, init2.addressFilter);
    this.keyBook = new PeerStoreKeyBook(this.dispatchEvent.bind(this), this.store);
    this.metadataBook = new PeerStoreMetadataBook(this.dispatchEvent.bind(this), this.store);
    this.protoBook = new PeerStoreProtoBook(this.dispatchEvent.bind(this), this.store);
  }
  async forEach(fn) {
    log$j.trace("getPeers await read lock");
    const release = await this.store.lock.readLock();
    log$j.trace("getPeers got read lock");
    try {
      for await (const peer of this.store.all()) {
        if (peer.id.equals(this.components.peerId)) {
          continue;
        }
        fn(peer);
      }
    } finally {
      log$j.trace("getPeers release read lock");
      release();
    }
  }
  async all() {
    const output = [];
    await this.forEach((peer) => {
      output.push(peer);
    });
    return output;
  }
  async delete(peerId) {
    log$j.trace("delete await write lock");
    const release = await this.store.lock.writeLock();
    log$j.trace("delete got write lock");
    try {
      await this.store.delete(peerId);
    } finally {
      log$j.trace("delete release write lock");
      release();
    }
  }
  async get(peerId) {
    log$j.trace("get await read lock");
    const release = await this.store.lock.readLock();
    log$j.trace("get got read lock");
    try {
      return await this.store.load(peerId);
    } finally {
      log$j.trace("get release read lock");
      release();
    }
  }
  async has(peerId) {
    log$j.trace("has await read lock");
    const release = await this.store.lock.readLock();
    log$j.trace("has got read lock");
    try {
      return await this.store.has(peerId);
    } finally {
      log$j.trace("has release read lock");
      release();
    }
  }
  async tagPeer(peerId, tag, options = {}) {
    const providedValue = options.value ?? 0;
    const value2 = Math.round(providedValue);
    const ttl2 = options.ttl ?? void 0;
    if (value2 !== providedValue || value2 < 0 || value2 > 100) {
      throw errCode(new Error("Tag value must be between 0-100"), "ERR_TAG_VALUE_OUT_OF_BOUNDS");
    }
    const buf2 = await this.metadataBook.getValue(peerId, "tags");
    let tags = [];
    if (buf2 != null) {
      tags = Tags.decode(buf2).tags;
    }
    for (const t of tags) {
      if (t.name === tag) {
        throw errCode(new Error("Peer already tagged"), "ERR_DUPLICATE_TAG");
      }
    }
    tags.push({
      name: tag,
      value: value2,
      expiry: ttl2 == null ? void 0 : BigInt(Date.now() + ttl2)
    });
    await this.metadataBook.setValue(peerId, "tags", Tags.encode({ tags }).subarray());
  }
  async unTagPeer(peerId, tag) {
    const buf2 = await this.metadataBook.getValue(peerId, "tags");
    let tags = [];
    if (buf2 != null) {
      tags = Tags.decode(buf2).tags;
    }
    tags = tags.filter((t) => t.name !== tag);
    await this.metadataBook.setValue(peerId, "tags", Tags.encode({ tags }).subarray());
  }
  async getTags(peerId) {
    const buf2 = await this.metadataBook.getValue(peerId, "tags");
    let tags = [];
    if (buf2 != null) {
      tags = Tags.decode(buf2).tags;
    }
    const now = BigInt(Date.now());
    const unexpiredTags = tags.filter((tag) => tag.expiry == null || tag.expiry > now);
    if (unexpiredTags.length !== tags.length) {
      await this.metadataBook.setValue(peerId, "tags", Tags.encode({ tags: unexpiredTags }).subarray());
    }
    return unexpiredTags.map((t) => ({
      name: t.name,
      value: t.value ?? 0
    }));
  }
}
class DHTContentRouting {
  constructor(dht) {
    this.dht = dht;
  }
  async provide(cid) {
    await drain(this.dht.provide(cid));
  }
  async *findProviders(cid, options = {}) {
    for await (const event of this.dht.findProviders(cid, options)) {
      if (event.name === "PROVIDER") {
        yield* event.providers;
      }
    }
  }
  async put(key, value2, options) {
    await drain(this.dht.put(key, value2, options));
  }
  async get(key, options) {
    for await (const event of this.dht.get(key, options)) {
      if (event.name === "VALUE") {
        return event.value;
      }
    }
    throw errCode(new Error("Not found"), "ERR_NOT_FOUND");
  }
}
class DefaultComponents {
  constructor(init2 = {}) {
    this._started = false;
    this._peerId = init2.peerId;
    this._addressManager = init2.addressManager;
    this._peerStore = init2.peerStore;
    this._upgrader = init2.upgrader;
    this._metrics = init2.metrics;
    this._registrar = init2.registrar;
    this._connectionManager = init2.connectionManager;
    this._transportManager = init2.transportManager;
    this._connectionGater = init2.connectionGater;
    this._contentRouting = init2.contentRouting;
    this._peerRouting = init2.peerRouting;
    this._datastore = init2.datastore;
    this._connectionProtector = init2.connectionProtector;
    this._dht = init2.dht;
    this._pubsub = init2.pubsub;
    this._dialer = init2.dialer;
  }
  isStarted() {
    return this._started;
  }
  async beforeStart() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      if (startable.beforeStart != null) {
        await startable.beforeStart();
      }
    }));
  }
  async start() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      await startable.start();
    }));
    this._started = true;
  }
  async afterStart() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      if (startable.afterStart != null) {
        await startable.afterStart();
      }
    }));
  }
  async beforeStop() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      if (startable.beforeStop != null) {
        await startable.beforeStop();
      }
    }));
  }
  async stop() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      await startable.stop();
    }));
    this._started = false;
  }
  async afterStop() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      if (startable.afterStop != null) {
        await startable.afterStop();
      }
    }));
  }
  get peerId() {
    if (this._peerId == null) {
      throw errCode(new Error("peerId not set"), "ERR_SERVICE_MISSING");
    }
    return this._peerId;
  }
  set peerId(peerId) {
    this._peerId = peerId;
  }
  get addressManager() {
    if (this._addressManager == null) {
      throw errCode(new Error("addressManager not set"), "ERR_SERVICE_MISSING");
    }
    return this._addressManager;
  }
  set addressManager(addressManager) {
    this._addressManager = addressManager;
  }
  get peerStore() {
    if (this._peerStore == null) {
      throw errCode(new Error("peerStore not set"), "ERR_SERVICE_MISSING");
    }
    return this._peerStore;
  }
  set peerStore(peerStore) {
    this._peerStore = peerStore;
  }
  get upgrader() {
    if (this._upgrader == null) {
      throw errCode(new Error("upgrader not set"), "ERR_SERVICE_MISSING");
    }
    return this._upgrader;
  }
  set upgrader(upgrader) {
    this._upgrader = upgrader;
  }
  get registrar() {
    if (this._registrar == null) {
      throw errCode(new Error("registrar not set"), "ERR_SERVICE_MISSING");
    }
    return this._registrar;
  }
  set registrar(registrar) {
    this._registrar = registrar;
  }
  get connectionManager() {
    if (this._connectionManager == null) {
      throw errCode(new Error("connectionManager not set"), "ERR_SERVICE_MISSING");
    }
    return this._connectionManager;
  }
  set connectionManager(connectionManager) {
    this._connectionManager = connectionManager;
  }
  get transportManager() {
    if (this._transportManager == null) {
      throw errCode(new Error("transportManager not set"), "ERR_SERVICE_MISSING");
    }
    return this._transportManager;
  }
  set transportManager(transportManager) {
    this._transportManager = transportManager;
  }
  get connectionGater() {
    if (this._connectionGater == null) {
      throw errCode(new Error("connectionGater not set"), "ERR_SERVICE_MISSING");
    }
    return this._connectionGater;
  }
  set connectionGater(connectionGater) {
    this._connectionGater = connectionGater;
  }
  get contentRouting() {
    if (this._contentRouting == null) {
      throw errCode(new Error("contentRouting not set"), "ERR_SERVICE_MISSING");
    }
    return this._contentRouting;
  }
  set contentRouting(contentRouting) {
    this._contentRouting = contentRouting;
  }
  get peerRouting() {
    if (this._peerRouting == null) {
      throw errCode(new Error("peerRouting not set"), "ERR_SERVICE_MISSING");
    }
    return this._peerRouting;
  }
  set peerRouting(peerRouting) {
    this._peerRouting = peerRouting;
  }
  get datastore() {
    if (this._datastore == null) {
      throw errCode(new Error("datastore not set"), "ERR_SERVICE_MISSING");
    }
    return this._datastore;
  }
  set datastore(datastore) {
    this._datastore = datastore;
  }
  get connectionProtector() {
    return this._connectionProtector;
  }
  set connectionProtector(connectionProtector) {
    this._connectionProtector = connectionProtector;
  }
  get dialer() {
    if (this._dialer == null) {
      throw errCode(new Error("dialer not set"), "ERR_SERVICE_MISSING");
    }
    return this._dialer;
  }
  set dialer(dialer) {
    this._dialer = dialer;
  }
  get metrics() {
    return this._metrics;
  }
  set metrics(metrics) {
    this._metrics = metrics;
  }
  get dht() {
    return this._dht;
  }
  set dht(dht) {
    this._dht = dht;
  }
  get pubsub() {
    return this._pubsub;
  }
  set pubsub(pubsub) {
    this._pubsub = pubsub;
  }
}
var receptacle = Receptacle;
var toMS = requireMs();
var cache = Receptacle.prototype;
var counter = new Date() % 1e9;
function getUID() {
  return (Math.random() * 1e9 >>> 0) + counter++;
}
function Receptacle(options) {
  options = options || {};
  this.id = options.id || getUID();
  this.max = options.max || Infinity;
  this.items = options.items || [];
  this._lookup = {};
  this.size = this.items.length;
  this.lastModified = new Date(options.lastModified || new Date());
  for (var item, ttl2, i2 = this.items.length; i2--; ) {
    item = this.items[i2];
    ttl2 = new Date(item.expires) - new Date();
    this._lookup[item.key] = item;
    if (ttl2 > 0)
      this.expire(item.key, ttl2);
    else if (ttl2 <= 0)
      this.delete(item.key);
  }
}
cache.has = function(key) {
  return key in this._lookup;
};
cache.get = function(key) {
  if (!this.has(key))
    return null;
  var record = this._lookup[key];
  if (record.refresh)
    this.expire(key, record.refresh);
  this.items.splice(this.items.indexOf(record), 1);
  this.items.push(record);
  return record.value;
};
cache.meta = function(key) {
  if (!this.has(key))
    return null;
  var record = this._lookup[key];
  if (!("meta" in record))
    return null;
  return record.meta;
};
cache.set = function(key, value2, options) {
  var oldRecord = this._lookup[key];
  var record = this._lookup[key] = { key, value: value2 };
  this.lastModified = new Date();
  if (oldRecord) {
    clearTimeout(oldRecord.timeout);
    this.items.splice(this.items.indexOf(oldRecord), 1, record);
  } else {
    if (this.size >= this.max)
      this.delete(this.items[0].key);
    this.items.push(record);
    this.size++;
  }
  if (options) {
    if ("ttl" in options)
      this.expire(key, options.ttl);
    if ("meta" in options)
      record.meta = options.meta;
    if (options.refresh)
      record.refresh = options.ttl;
  }
  return this;
};
cache.delete = function(key) {
  var record = this._lookup[key];
  if (!record)
    return false;
  this.lastModified = new Date();
  this.items.splice(this.items.indexOf(record), 1);
  clearTimeout(record.timeout);
  delete this._lookup[key];
  this.size--;
  return this;
};
cache.expire = function(key, ttl2) {
  var ms2 = ttl2 || 0;
  var record = this._lookup[key];
  if (!record)
    return this;
  if (typeof ms2 === "string")
    ms2 = toMS(ttl2);
  if (typeof ms2 !== "number")
    throw new TypeError("Expiration time must be a string or number.");
  clearTimeout(record.timeout);
  record.timeout = setTimeout(this.delete.bind(this, record.key), ms2);
  record.expires = Number(new Date()) + ms2;
  return this;
};
cache.clear = function() {
  for (var i2 = this.items.length; i2--; )
    this.delete(this.items[i2].key);
  return this;
};
cache.toJSON = function() {
  var items = new Array(this.items.length);
  var item;
  for (var i2 = items.length; i2--; ) {
    item = this.items[i2];
    items[i2] = {
      key: item.key,
      meta: item.meta,
      value: item.value,
      expires: item.expires,
      refresh: item.refresh
    };
  }
  return {
    id: this.id,
    max: isFinite(this.max) ? this.max : void 0,
    lastModified: this.lastModified,
    items
  };
};
const globalFetch = globalThis.fetch;
const globalHeaders = globalThis.Headers;
function buildResource(serverResolver, hostname, recordType) {
  return `${serverResolver}?name=${hostname}&type=${recordType}`;
}
async function request(resource, signal) {
  const req = await globalFetch(resource, {
    headers: new globalHeaders({
      accept: "application/dns-json"
    }),
    signal
  });
  const res = await req.json();
  return res;
}
function getCacheKey(hostname, recordType) {
  return `${recordType}_${hostname}`;
}
const log$i = Object.assign(debug("dns-over-http-resolver"), {
  error: debug("dns-over-http-resolver:error")
});
class Resolver {
  constructor(options = {}) {
    this._cache = new receptacle({ max: options?.maxCache ?? 100 });
    this._TXTcache = new receptacle({ max: options?.maxCache ?? 100 });
    this._servers = [
      "https://cloudflare-dns.com/dns-query",
      "https://dns.google/resolve"
    ];
    this._request = options.request ?? request;
    this._abortControllers = [];
  }
  cancel() {
    this._abortControllers.forEach((controller) => controller.abort());
  }
  getServers() {
    return this._servers;
  }
  _getShuffledServers() {
    const newServers = [...this._servers];
    for (let i2 = newServers.length - 1; i2 > 0; i2--) {
      const j = Math.floor(Math.random() * i2);
      const temp = newServers[i2];
      newServers[i2] = newServers[j];
      newServers[j] = temp;
    }
    return newServers;
  }
  setServers(servers) {
    this._servers = servers;
  }
  async resolve(hostname, rrType = "A") {
    switch (rrType) {
      case "A":
        return await this.resolve4(hostname);
      case "AAAA":
        return await this.resolve6(hostname);
      case "TXT":
        return await this.resolveTxt(hostname);
      default:
        throw new Error(`${rrType} is not supported`);
    }
  }
  async resolve4(hostname) {
    const recordType = "A";
    const cached = this._cache.get(getCacheKey(hostname, recordType));
    if (cached != null) {
      return cached;
    }
    let aborted = false;
    for (const server of this._getShuffledServers()) {
      const controller = new AbortController();
      this._abortControllers.push(controller);
      try {
        const response = await this._request(buildResource(server, hostname, recordType), controller.signal);
        const data = response.Answer.map((a) => a.data);
        const ttl2 = Math.min(...response.Answer.map((a) => a.TTL));
        this._cache.set(getCacheKey(hostname, recordType), data, { ttl: ttl2 });
        return data;
      } catch (err2) {
        if (controller.signal.aborted) {
          aborted = true;
        }
        log$i.error(`${server} could not resolve ${hostname} record ${recordType}`);
      } finally {
        this._abortControllers = this._abortControllers.filter((c) => c !== controller);
      }
    }
    if (aborted) {
      throw Object.assign(new Error("queryA ECANCELLED"), {
        code: "ECANCELLED"
      });
    }
    throw new Error(`Could not resolve ${hostname} record ${recordType}`);
  }
  async resolve6(hostname) {
    const recordType = "AAAA";
    const cached = this._cache.get(getCacheKey(hostname, recordType));
    if (cached != null) {
      return cached;
    }
    let aborted = false;
    for (const server of this._getShuffledServers()) {
      const controller = new AbortController();
      this._abortControllers.push(controller);
      try {
        const response = await this._request(buildResource(server, hostname, recordType), controller.signal);
        const data = response.Answer.map((a) => a.data);
        const ttl2 = Math.min(...response.Answer.map((a) => a.TTL));
        this._cache.set(getCacheKey(hostname, recordType), data, { ttl: ttl2 });
        return data;
      } catch (err2) {
        if (controller.signal.aborted) {
          aborted = true;
        }
        log$i.error(`${server} could not resolve ${hostname} record ${recordType}`);
      } finally {
        this._abortControllers = this._abortControllers.filter((c) => c !== controller);
      }
    }
    if (aborted) {
      throw Object.assign(new Error("queryAaaa ECANCELLED"), {
        code: "ECANCELLED"
      });
    }
    throw new Error(`Could not resolve ${hostname} record ${recordType}`);
  }
  async resolveTxt(hostname) {
    const recordType = "TXT";
    const cached = this._TXTcache.get(getCacheKey(hostname, recordType));
    if (cached != null) {
      return cached;
    }
    let aborted = false;
    for (const server of this._getShuffledServers()) {
      const controller = new AbortController();
      this._abortControllers.push(controller);
      try {
        const response = await this._request(buildResource(server, hostname, recordType), controller.signal);
        const data = response.Answer.map((a) => [a.data.replace(/['"]+/g, "")]);
        const ttl2 = Math.min(...response.Answer.map((a) => a.TTL));
        this._TXTcache.set(getCacheKey(hostname, recordType), data, { ttl: ttl2 });
        return data;
      } catch (err2) {
        if (controller.signal.aborted) {
          aborted = true;
        }
        log$i.error(`${server} could not resolve ${hostname} record ${recordType}`);
      } finally {
        this._abortControllers = this._abortControllers.filter((c) => c !== controller);
      }
    }
    if (aborted) {
      throw Object.assign(new Error("queryTxt ECANCELLED"), {
        code: "ECANCELLED"
      });
    }
    throw new Error(`Could not resolve ${hostname} record ${recordType}`);
  }
  clearCache() {
    this._cache.clear();
    this._TXTcache.clear();
  }
}
const { code: dnsaddrCode } = getProtocol("dnsaddr");
async function dnsaddrResolver(addr, options = {}) {
  const resolver = new Resolver();
  if (options.signal != null) {
    options.signal.addEventListener("abort", () => {
      resolver.cancel();
    });
  }
  const peerId = addr.getPeerId();
  const [, hostname] = addr.stringTuples().find(([proto]) => proto === dnsaddrCode) ?? [];
  if (hostname == null) {
    throw new Error("No hostname found in multiaddr");
  }
  const records = await resolver.resolveTxt(`_dnsaddr.${hostname}`);
  let addresses = records.flat().map((a) => a.split("=")[1]);
  if (peerId != null) {
    addresses = addresses.filter((entry) => entry.includes(peerId));
  }
  return addresses;
}
const DefaultConfig = {
  addresses: {
    listen: [],
    announce: [],
    noAnnounce: [],
    announceFilter: (multiaddrs) => multiaddrs
  },
  connectionManager: {
    maxConnections: 300,
    minConnections: 50,
    autoDial: true,
    autoDialInterval: 1e4,
    maxParallelDials: MAX_PARALLEL_DIALS,
    maxDialsPerPeer: MAX_PER_PEER_DIALS,
    dialTimeout: DIAL_TIMEOUT,
    inboundUpgradeTimeout: INBOUND_UPGRADE_TIMEOUT,
    resolvers: {
      dnsaddr: dnsaddrResolver
    },
    addressSorter: publicAddressesFirst
  },
  connectionGater: {},
  transportManager: {
    faultTolerance: FaultTolerance.FATAL_ALL
  },
  metrics: {
    enabled: false,
    computeThrottleMaxQueueSize: 1e3,
    computeThrottleTimeout: 2e3,
    movingAverageIntervals: [
      60 * 1e3,
      5 * 60 * 1e3,
      15 * 60 * 1e3
    ],
    maxOldPeersRetention: 50
  },
  peerRouting: {
    refreshManager: {
      enabled: true,
      interval: 6e5,
      bootDelay: 1e4
    }
  },
  nat: {
    enabled: true,
    ttl: 7200,
    keepAlive: true
  },
  relay: {
    enabled: true,
    advertise: {
      bootDelay: ADVERTISE_BOOT_DELAY,
      enabled: false,
      ttl: ADVERTISE_TTL
    },
    hop: {
      enabled: false,
      active: false,
      timeout: 3e4
    },
    autoRelay: {
      enabled: false,
      maxListeners: 2
    }
  },
  identify: {
    protocolPrefix: "ipfs",
    host: {
      agentVersion: AGENT_VERSION
    },
    timeout: 6e4,
    maxInboundStreams: 1,
    maxOutboundStreams: 1,
    maxPushIncomingStreams: 1,
    maxPushOutgoingStreams: 1
  },
  ping: {
    protocolPrefix: "ipfs",
    maxInboundStreams: 1,
    maxOutboundStreams: 1,
    timeout: 1e4
  },
  fetch: {
    protocolPrefix: "libp2p",
    maxInboundStreams: 1,
    maxOutboundStreams: 1,
    timeout: 1e4
  }
};
function validateConfig(opts) {
  const resultingOptions = mergeOptions$g(DefaultConfig, opts);
  if (resultingOptions.transports == null || resultingOptions.transports.length < 1) {
    throw errCode(new Error(messages.ERR_TRANSPORTS_REQUIRED), codes$1.ERR_TRANSPORTS_REQUIRED);
  }
  if (resultingOptions.connectionEncryption == null || resultingOptions.connectionEncryption.length === 0) {
    throw errCode(new Error(messages.CONN_ENCRYPTION_REQUIRED), codes$1.CONN_ENCRYPTION_REQUIRED);
  }
  if (resultingOptions.connectionProtector === null && globalThis.process?.env?.LIBP2P_FORCE_PNET != null) {
    throw errCode(new Error(messages.ERR_PROTECTOR_REQUIRED), codes$1.ERR_PROTECTOR_REQUIRED);
  }
  if (resultingOptions.identify.host.agentVersion === AGENT_VERSION) {
    if (isNode || isElectronMain) {
      resultingOptions.identify.host.agentVersion += ` UserAgent=${globalThis.process.version}`;
    } else if (isBrowser || isWebWorker || isElectronRenderer || isReactNative) {
      resultingOptions.identify.host.agentVersion += ` UserAgent=${globalThis.navigator.userAgent}`;
    }
  }
  return resultingOptions;
}
var PeerIdProto;
(function(PeerIdProto2) {
  let _codec;
  PeerIdProto2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (opts.writeDefaults === true || obj.id != null && obj.id.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.id);
        }
        if (obj.pubKey != null) {
          w.uint32(18);
          w.bytes(obj.pubKey);
        }
        if (obj.privKey != null) {
          w.uint32(26);
          w.bytes(obj.privKey);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length3) => {
        const obj = {
          id: new Uint8Array(0)
        };
        const end2 = length3 == null ? reader2.len : reader2.pos + length3;
        while (reader2.pos < end2) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.id = reader2.bytes();
              break;
            case 2:
              obj.pubKey = reader2.bytes();
              break;
            case 3:
              obj.privKey = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PeerIdProto2.encode = (obj) => {
    return encodeMessage(obj, PeerIdProto2.codec());
  };
  PeerIdProto2.decode = (buf2) => {
    return decodeMessage(buf2, PeerIdProto2.codec());
  };
})(PeerIdProto || (PeerIdProto = {}));
const createEd25519PeerId = async () => {
  const key = await generateKeyPair("Ed25519");
  const id = await createFromPrivKey(key);
  if (id.type === "Ed25519") {
    return id;
  }
  throw new Error(`Generated unexpected PeerId type "${id.type}"`);
};
const createRSAPeerId = async (opts) => {
  const key = await generateKeyPair("RSA", opts?.bits ?? 2048);
  const id = await createFromPrivKey(key);
  if (id.type === "RSA") {
    return id;
  }
  throw new Error(`Generated unexpected PeerId type "${id.type}"`);
};
async function createFromPrivKey(privateKey) {
  return await peerIdFromKeys(marshalPublicKey(privateKey.public), marshalPrivateKey(privateKey));
}
class DummyDHT extends EventEmitter$1 {
  get [symbol$1]() {
    return true;
  }
  get [Symbol.toStringTag]() {
    return "@libp2p/dummy-dht";
  }
  get wan() {
    throw errCode(new Error(messages.DHT_DISABLED), codes$1.DHT_DISABLED);
  }
  get lan() {
    throw errCode(new Error(messages.DHT_DISABLED), codes$1.DHT_DISABLED);
  }
  get() {
    throw errCode(new Error(messages.DHT_DISABLED), codes$1.DHT_DISABLED);
  }
  findProviders() {
    throw errCode(new Error(messages.DHT_DISABLED), codes$1.DHT_DISABLED);
  }
  findPeer() {
    throw errCode(new Error(messages.DHT_DISABLED), codes$1.DHT_DISABLED);
  }
  getClosestPeers() {
    throw errCode(new Error(messages.DHT_DISABLED), codes$1.DHT_DISABLED);
  }
  provide() {
    throw errCode(new Error(messages.DHT_DISABLED), codes$1.DHT_DISABLED);
  }
  put() {
    throw errCode(new Error(messages.DHT_DISABLED), codes$1.DHT_DISABLED);
  }
  async getMode() {
    throw errCode(new Error(messages.DHT_DISABLED), codes$1.DHT_DISABLED);
  }
  async setMode() {
    throw errCode(new Error(messages.DHT_DISABLED), codes$1.DHT_DISABLED);
  }
  async refreshRoutingTable() {
    throw errCode(new Error(messages.DHT_DISABLED), codes$1.DHT_DISABLED);
  }
}
class DummyPubSub extends EventEmitter$1 {
  constructor() {
    super(...arguments);
    this.topicValidators = /* @__PURE__ */ new Map();
  }
  isStarted() {
    return false;
  }
  start() {
  }
  stop() {
  }
  get globalSignaturePolicy() {
    throw errCode(new Error(messages.PUBSUB_DISABLED), codes$1.ERR_PUBSUB_DISABLED);
  }
  get multicodecs() {
    throw errCode(new Error(messages.PUBSUB_DISABLED), codes$1.ERR_PUBSUB_DISABLED);
  }
  getPeers() {
    throw errCode(new Error(messages.PUBSUB_DISABLED), codes$1.ERR_PUBSUB_DISABLED);
  }
  getTopics() {
    throw errCode(new Error(messages.PUBSUB_DISABLED), codes$1.ERR_PUBSUB_DISABLED);
  }
  subscribe() {
    throw errCode(new Error(messages.PUBSUB_DISABLED), codes$1.ERR_PUBSUB_DISABLED);
  }
  unsubscribe() {
    throw errCode(new Error(messages.PUBSUB_DISABLED), codes$1.ERR_PUBSUB_DISABLED);
  }
  getSubscribers() {
    throw errCode(new Error(messages.PUBSUB_DISABLED), codes$1.ERR_PUBSUB_DISABLED);
  }
  async publish() {
    throw errCode(new Error(messages.PUBSUB_DISABLED), codes$1.ERR_PUBSUB_DISABLED);
  }
}
class AbortError extends Error {
  constructor(message2 = "The operation was aborted") {
    super(message2);
    this.code = AbortError.code;
    this.type = AbortError.type;
  }
  static get code() {
    return "ABORT_ERR";
  }
  static get type() {
    return "aborted";
  }
}
const pDefer = () => {
  const deferred = {};
  deferred.promise = new Promise((resolve2, reject) => {
    deferred.resolve = resolve2;
    deferred.reject = reject;
  });
  return deferred;
};
var pDefer_1 = pDefer;
const Fifo = fastFifo;
const defer = pDefer_1;
var pFifo = class PFifo {
  constructor() {
    this._buffer = new Fifo();
    this._waitingConsumers = new Fifo();
  }
  push(chunk) {
    const { promise: promise2, resolve: resolve2 } = defer();
    this._buffer.push({ chunk, resolve: resolve2 });
    this._consume();
    return promise2;
  }
  _consume() {
    while (!this._waitingConsumers.isEmpty() && !this._buffer.isEmpty()) {
      const nextConsumer = this._waitingConsumers.shift();
      const nextChunk = this._buffer.shift();
      nextConsumer.resolve(nextChunk.chunk);
      nextChunk.resolve();
    }
  }
  shift() {
    const { promise: promise2, resolve: resolve2 } = defer();
    this._waitingConsumers.push({ resolve: resolve2 });
    this._consume();
    return promise2;
  }
  isEmpty() {
    return this._buffer.isEmpty();
  }
};
const log$h = logger$1("libp2p:dialer:dial-request");
class DialRequest {
  constructor(options) {
    const { addrs, dialAction, dialer } = options;
    this.addrs = addrs;
    this.dialer = dialer;
    this.dialAction = dialAction;
  }
  async run(options = {}) {
    const tokens = this.dialer.getTokens(this.addrs.length);
    if (tokens.length < 1) {
      throw errCode(new Error("No dial tokens available"), codes$1.ERR_NO_DIAL_TOKENS);
    }
    const tokenHolder = new pFifo();
    for (const token of tokens) {
      void tokenHolder.push(token).catch((err2) => {
        log$h.error(err2);
      });
    }
    const dialAbortControllers = this.addrs.map(() => {
      const controller = new AbortController();
      try {
        events.exports.setMaxListeners?.(Infinity, controller.signal);
      } catch {
      }
      return controller;
    });
    if (options.signal != null) {
      try {
        events.exports.setMaxListeners?.(Infinity, options.signal);
      } catch {
      }
    }
    let completedDials = 0;
    let done = false;
    try {
      return await Promise.any(this.addrs.map(async (addr, i2) => {
        const token = await tokenHolder.shift();
        if (done) {
          this.dialer.releaseToken(tokens.splice(tokens.indexOf(token), 1)[0]);
          throw errCode(new Error("dialAction already succeeded"), codes$1.ERR_ALREADY_SUCCEEDED);
        }
        const controller = dialAbortControllers[i2];
        if (controller == null) {
          throw errCode(new Error("dialAction did not come with an AbortController"), codes$1.ERR_INVALID_PARAMETERS);
        }
        let conn;
        try {
          const signal = controller.signal;
          conn = await this.dialAction(addr, { ...options, signal: options.signal != null ? anySignal_2([signal, options.signal]) : signal });
          dialAbortControllers[i2] = void 0;
        } finally {
          completedDials++;
          if (this.addrs.length - completedDials >= tokens.length) {
            void tokenHolder.push(token).catch((err2) => {
              log$h.error(err2);
            });
          } else {
            this.dialer.releaseToken(tokens.splice(tokens.indexOf(token), 1)[0]);
          }
        }
        if (conn == null) {
          throw errCode(new Error("dialAction led to empty object"), codes$1.ERR_TRANSPORT_DIAL_FAILED);
        } else {
          done = true;
        }
        return conn;
      }));
    } finally {
      dialAbortControllers.forEach((c) => {
        if (c !== void 0) {
          c.abort();
        }
      });
      tokens.forEach((token) => this.dialer.releaseToken(token));
    }
  }
}
const log$g = logger$1("libp2p:dialer");
const METRICS_COMPONENT = "dialler";
const METRICS_PENDING_DIALS = "pending-dials";
const METRICS_PENDING_DIAL_TARGETS = "pending-dial-targets";
class DefaultDialer {
  constructor(components, init2 = {}) {
    this.started = false;
    this.addressSorter = init2.addressSorter ?? publicAddressesFirst;
    this.maxAddrsToDial = init2.maxAddrsToDial ?? MAX_ADDRS_TO_DIAL;
    this.timeout = init2.dialTimeout ?? DIAL_TIMEOUT;
    this.maxDialsPerPeer = init2.maxDialsPerPeer ?? MAX_PER_PEER_DIALS;
    this.tokens = [...new Array(init2.maxParallelDials ?? MAX_PARALLEL_DIALS)].map((_, index) => index);
    this.components = components;
    this.pendingDials = trackedMap({
      component: METRICS_COMPONENT,
      metric: METRICS_PENDING_DIALS,
      metrics: init2.metrics
    });
    this.pendingDialTargets = trackedMap({
      component: METRICS_COMPONENT,
      metric: METRICS_PENDING_DIAL_TARGETS,
      metrics: components.metrics
    });
    for (const [key, value2] of Object.entries(init2.resolvers ?? {})) {
      resolvers$1.set(key, value2);
    }
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.started = true;
  }
  async stop() {
    this.started = false;
    for (const dial of this.pendingDials.values()) {
      try {
        dial.controller.abort();
      } catch (err2) {
        log$g.error(err2);
      }
    }
    this.pendingDials.clear();
    for (const pendingTarget of this.pendingDialTargets.values()) {
      pendingTarget.reject(new AbortError("Dialer was destroyed"));
    }
    this.pendingDialTargets.clear();
  }
  async dial(peer, options = {}) {
    const { id, multiaddrs } = getPeer(peer);
    if (this.components.peerId.equals(id)) {
      throw errCode(new Error("Tried to dial self"), codes$1.ERR_DIALED_SELF);
    }
    log$g("check multiaddrs %p", id);
    if (multiaddrs != null && multiaddrs.length > 0) {
      log$g("storing multiaddrs %p", id, multiaddrs);
      await this.components.peerStore.addressBook.add(id, multiaddrs);
    }
    if (await this.components.connectionGater.denyDialPeer(id)) {
      throw errCode(new Error("The dial request is blocked by gater.allowDialPeer"), codes$1.ERR_PEER_DIAL_INTERCEPTED);
    }
    log$g("creating dial target for %p", id);
    const dialTarget = await this._createCancellableDialTarget(id, options);
    if (dialTarget.addrs.length === 0) {
      throw errCode(new Error("The dial request has no valid addresses"), codes$1.ERR_NO_VALID_ADDRESSES);
    }
    const pendingDial = this.pendingDials.get(dialTarget.id) ?? this._createPendingDial(dialTarget, options);
    try {
      const connection = await pendingDial.promise;
      log$g("dial succeeded to %s", dialTarget.id);
      return connection;
    } catch (err2) {
      log$g("dial failed to %s", dialTarget.id, err2);
      if (pendingDial.controller.signal.aborted) {
        err2.code = codes$1.ERR_TIMEOUT;
      }
      log$g.error(err2);
      throw err2;
    } finally {
      pendingDial.destroy();
    }
  }
  async _createCancellableDialTarget(peer, options) {
    const id = `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;
    const cancellablePromise = new Promise((resolve2, reject) => {
      this.pendingDialTargets.set(id, { resolve: resolve2, reject });
    });
    try {
      const dialTarget = await Promise.race([
        this._createDialTarget(peer, options),
        cancellablePromise
      ]);
      return dialTarget;
    } finally {
      this.pendingDialTargets.delete(id);
    }
  }
  async _createDialTarget(peer, options) {
    const _resolve = this._resolve.bind(this);
    const addrs = await pipe(
      await this.components.peerStore.addressBook.get(peer),
      (source2) => filter$1(source2, async (address) => {
        return !await this.components.connectionGater.denyDialMultiaddr(peer, address.multiaddr);
      }),
      (source2) => sort(source2, this.addressSorter),
      async function* resolve2(source2) {
        for await (const a of source2) {
          yield* await _resolve(a.multiaddr, options);
        }
      },
      (source2) => filter$1(source2, (ma) => Boolean(this.components.transportManager.transportForMultiaddr(ma))),
      (source2) => map$3(source2, (ma) => {
        if (peer.toString() === ma.getPeerId()) {
          return ma;
        }
        return ma.encapsulate(`/p2p/${peer.toString()}`);
      }),
      async (source2) => await all$1(source2)
    );
    if (addrs.length > this.maxAddrsToDial) {
      await this.components.peerStore.delete(peer);
      throw errCode(new Error("dial with more addresses than allowed"), codes$1.ERR_TOO_MANY_ADDRESSES);
    }
    return {
      id: peer.toString(),
      addrs
    };
  }
  _createPendingDial(dialTarget, options = {}) {
    const dialAction = async (addr, options2 = {}) => {
      if (options2.signal?.aborted === true) {
        throw errCode(new Error("already aborted"), codes$1.ERR_ALREADY_ABORTED);
      }
      return await this.components.transportManager.dial(addr, options2).catch((err2) => {
        log$g.error("dial to %s failed", addr, err2);
        throw err2;
      });
    };
    const dialRequest = new DialRequest({
      addrs: dialTarget.addrs,
      dialAction,
      dialer: this
    });
    const timeoutController = new timeoutAbortController.TimeoutController(this.timeout);
    const signals = [timeoutController.signal];
    options.signal != null && signals.push(options.signal);
    const signal = anySignal_2(signals);
    try {
      events.exports.setMaxListeners?.(Infinity, signal);
    } catch {
    }
    const pendingDial = {
      dialRequest,
      controller: timeoutController,
      promise: dialRequest.run({ ...options, signal }),
      destroy: () => {
        timeoutController.clear();
        this.pendingDials.delete(dialTarget.id);
      }
    };
    this.pendingDials.set(dialTarget.id, pendingDial);
    return pendingDial;
  }
  getTokens(num) {
    const total = Math.min(num, this.maxDialsPerPeer, this.tokens.length);
    const tokens = this.tokens.splice(0, total);
    log$g("%d tokens request, returning %d, %d remaining", num, total, this.tokens.length);
    return tokens;
  }
  releaseToken(token) {
    if (this.tokens.includes(token)) {
      return;
    }
    log$g("token %d released", token);
    this.tokens.push(token);
  }
  async _resolve(ma, options) {
    const resolvableProto = ma.protoNames().includes("dnsaddr");
    if (!resolvableProto) {
      return [ma];
    }
    const resolvedMultiaddrs = await this._resolveRecord(ma, options);
    const recursiveMultiaddrs = await Promise.all(resolvedMultiaddrs.map(async (nm) => {
      return await this._resolve(nm, options);
    }));
    const addrs = recursiveMultiaddrs.flat();
    return addrs.reduce((array, newM) => {
      if (array.find((m) => m.equals(newM)) == null) {
        array.push(newM);
      }
      return array;
    }, []);
  }
  async _resolveRecord(ma, options) {
    try {
      ma = multiaddr(ma.toString());
      const multiaddrs = await ma.resolve(options);
      return multiaddrs;
    } catch (err2) {
      log$g.error(`multiaddr ${ma.toString()} could not be resolved`, err2);
      return [];
    }
  }
}
const log$f = logger$1("libp2p");
class Libp2pNode extends EventEmitter$1 {
  constructor(init2) {
    super();
    this.started = false;
    this.peerId = init2.peerId;
    const components = this.components = new DefaultComponents({
      peerId: init2.peerId,
      datastore: init2.datastore ?? new MemoryDatastore(),
      connectionGater: {
        denyDialPeer: async () => await Promise.resolve(false),
        denyDialMultiaddr: async () => await Promise.resolve(false),
        denyInboundConnection: async () => await Promise.resolve(false),
        denyOutboundConnection: async () => await Promise.resolve(false),
        denyInboundEncryptedConnection: async () => await Promise.resolve(false),
        denyOutboundEncryptedConnection: async () => await Promise.resolve(false),
        denyInboundUpgradedConnection: async () => await Promise.resolve(false),
        denyOutboundUpgradedConnection: async () => await Promise.resolve(false),
        filterMultiaddrForPeer: async () => await Promise.resolve(true),
        ...init2.connectionGater
      }
    });
    components.peerStore = new PersistentPeerStore(components, {
      addressFilter: this.components.connectionGater.filterMultiaddrForPeer,
      ...init2.peerStore
    });
    this.services = [
      components
    ];
    if (init2.metrics.enabled) {
      this.metrics = this.components.metrics = new DefaultMetrics(init2.metrics);
    }
    this.peerStore = this.components.peerStore;
    this.peerStore.addEventListener("peer", (evt) => {
      const { detail: peerData } = evt;
      this.dispatchEvent(new CustomEvent("peer:discovery", { detail: peerData }));
    });
    if (init2.connectionProtector != null) {
      this.components.connectionProtector = init2.connectionProtector(components);
    }
    this.components.upgrader = new DefaultUpgrader(this.components, {
      connectionEncryption: (init2.connectionEncryption ?? []).map((fn) => this.configureComponent(fn(this.components))),
      muxers: (init2.streamMuxers ?? []).map((fn) => this.configureComponent(fn(this.components))),
      inboundUpgradeTimeout: init2.connectionManager.inboundUpgradeTimeout
    });
    this.components.dialer = new DefaultDialer(this.components, init2.connectionManager);
    this.connectionManager = this.components.connectionManager = new DefaultConnectionManager(this.components, init2.connectionManager);
    this.registrar = this.components.registrar = new DefaultRegistrar(this.components);
    this.components.transportManager = new DefaultTransportManager(this.components, init2.transportManager);
    this.components.addressManager = new DefaultAddressManager(this.components, init2.addresses);
    this.configureComponent(new PeerRecordUpdater(this.components));
    this.configureComponent(new AutoDialler(this.components, {
      enabled: init2.connectionManager.autoDial,
      minConnections: init2.connectionManager.minConnections,
      autoDialInterval: init2.connectionManager.autoDialInterval
    }));
    const keychainOpts = KeyChain.generateOptions();
    this.keychain = this.configureComponent(new KeyChain(this.components, {
      ...keychainOpts,
      ...init2.keychain
    }));
    this.services.push(new NatManager(this.components, init2.nat));
    init2.transports.forEach((fn) => {
      this.components.transportManager.add(this.configureComponent(fn(this.components)));
    });
    this.identifyService = new IdentifyService(this.components, {
      ...init2.identify
    });
    this.configureComponent(this.identifyService);
    if (init2.dht != null) {
      this.dht = this.components.dht = init2.dht(this.components);
    } else {
      this.dht = new DummyDHT();
    }
    if (init2.pubsub != null) {
      this.pubsub = this.components.pubsub = init2.pubsub(this.components);
    } else {
      this.pubsub = new DummyPubSub();
    }
    const peerRouters = (init2.peerRouters ?? []).map((fn) => this.configureComponent(fn(this.components)));
    if (init2.dht != null) {
      peerRouters.push(this.configureComponent(new DHTPeerRouting(this.dht)));
      this.dht.addEventListener("peer", (evt) => {
        this.onDiscoveryPeer(evt);
      });
    }
    this.peerRouting = this.components.peerRouting = this.configureComponent(new DefaultPeerRouting(this.components, {
      ...init2.peerRouting,
      routers: peerRouters
    }));
    const contentRouters = (init2.contentRouters ?? []).map((fn) => this.configureComponent(fn(this.components)));
    if (init2.dht != null) {
      contentRouters.push(this.configureComponent(new DHTContentRouting(this.dht)));
    }
    this.contentRouting = this.components.contentRouting = this.configureComponent(new CompoundContentRouting(this.components, {
      routers: contentRouters
    }));
    if (init2.relay.enabled) {
      this.components.transportManager.add(this.configureComponent(new Circuit(this.components, init2.relay)));
      this.configureComponent(new Relay(this.components, {
        addressSorter: init2.connectionManager.addressSorter,
        ...init2.relay
      }));
    }
    this.fetchService = this.configureComponent(new FetchService(this.components, {
      ...init2.fetch
    }));
    this.pingService = this.configureComponent(new PingService(this.components, {
      ...init2.ping
    }));
    for (const fn of init2.peerDiscovery ?? []) {
      const service2 = this.configureComponent(fn(this.components));
      service2.addEventListener("peer", (evt) => {
        this.onDiscoveryPeer(evt);
      });
    }
  }
  configureComponent(component) {
    if (isStartable(component)) {
      this.services.push(component);
    }
    return component;
  }
  async start() {
    if (this.started) {
      return;
    }
    this.started = true;
    log$f("libp2p is starting");
    try {
      await Promise.all(this.services.map(async (service2) => {
        if (service2.beforeStart != null) {
          await service2.beforeStart();
        }
      }));
      await Promise.all(this.services.map((service2) => service2.start()));
      await Promise.all(this.services.map(async (service2) => {
        if (service2.afterStart != null) {
          await service2.afterStart();
        }
      }));
      log$f("libp2p has started");
    } catch (err2) {
      log$f.error("An error occurred starting libp2p", err2);
      await this.stop();
      throw err2;
    }
  }
  async stop() {
    if (!this.started) {
      return;
    }
    log$f("libp2p is stopping");
    this.started = false;
    await Promise.all(this.services.map(async (service2) => {
      if (service2.beforeStop != null) {
        await service2.beforeStop();
      }
    }));
    await Promise.all(this.services.map((service2) => service2.stop()));
    await Promise.all(this.services.map(async (service2) => {
      if (service2.afterStop != null) {
        await service2.afterStop();
      }
    }));
    log$f("libp2p has stopped");
  }
  isStarted() {
    return this.started;
  }
  getConnections(peerId) {
    return this.components.connectionManager.getConnections(peerId);
  }
  getPeers() {
    const peerSet = new PeerSet();
    for (const conn of this.components.connectionManager.getConnections()) {
      peerSet.add(conn.remotePeer);
    }
    return Array.from(peerSet);
  }
  async dial(peer, options = {}) {
    const { id, multiaddrs } = getPeer(peer);
    await this.components.peerStore.addressBook.add(id, multiaddrs);
    return await this.components.connectionManager.openConnection(id, options);
  }
  async dialProtocol(peer, protocols, options = {}) {
    if (protocols == null) {
      throw errCode(new Error("no protocols were provided to open a stream"), codes$1.ERR_INVALID_PROTOCOLS_FOR_STREAM);
    }
    protocols = Array.isArray(protocols) ? protocols : [protocols];
    if (protocols.length === 0) {
      throw errCode(new Error("no protocols were provided to open a stream"), codes$1.ERR_INVALID_PROTOCOLS_FOR_STREAM);
    }
    const connection = await this.dial(peer, options);
    return await connection.newStream(protocols, options);
  }
  getMultiaddrs() {
    return this.components.addressManager.getAddresses();
  }
  async hangUp(peer) {
    const { id } = getPeer(peer);
    await this.components.connectionManager.closeConnections(id);
  }
  async getPublicKey(peer, options = {}) {
    log$f("getPublicKey %p", peer);
    if (peer.publicKey != null) {
      return peer.publicKey;
    }
    const peerInfo = await this.peerStore.get(peer);
    if (peerInfo.pubKey != null) {
      return peerInfo.pubKey;
    }
    if (this.dht == null) {
      throw errCode(new Error("Public key was not in the peer store and the DHT is not enabled"), codes$1.ERR_NO_ROUTERS_AVAILABLE);
    }
    const peerKey = concat$1([
      fromString$3("/pk/"),
      peer.multihash.digest
    ]);
    for await (const event of this.dht.get(peerKey, options)) {
      if (event.name === "VALUE") {
        const key = unmarshalPublicKey(event.value);
        await this.peerStore.keyBook.set(peer, event.value);
        return key.bytes;
      }
    }
    throw errCode(new Error(`Node not responding with its public key: ${peer.toString()}`), codes$1.ERR_INVALID_RECORD);
  }
  async fetch(peer, key, options = {}) {
    const { id, multiaddrs } = getPeer(peer);
    if (multiaddrs != null) {
      await this.components.peerStore.addressBook.add(id, multiaddrs);
    }
    return await this.fetchService.fetch(id, key, options);
  }
  async ping(peer, options = {}) {
    const { id, multiaddrs } = getPeer(peer);
    if (multiaddrs.length > 0) {
      await this.components.peerStore.addressBook.add(id, multiaddrs);
    }
    return await this.pingService.ping(id, options);
  }
  async handle(protocols, handler, options) {
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    await Promise.all(protocols.map(async (protocol2) => {
      await this.components.registrar.handle(protocol2, handler, options);
    }));
  }
  async unhandle(protocols) {
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    await Promise.all(protocols.map(async (protocol2) => {
      await this.components.registrar.unhandle(protocol2);
    }));
  }
  onDiscoveryPeer(evt) {
    const { detail: peer } = evt;
    if (peer.id.toString() === this.peerId.toString()) {
      log$f.error(new Error(codes$1.ERR_DISCOVERED_SELF));
      return;
    }
    if (peer.multiaddrs.length > 0) {
      void this.components.peerStore.addressBook.add(peer.id, peer.multiaddrs).catch((err2) => log$f.error(err2));
    }
    if (peer.protocols.length > 0) {
      void this.components.peerStore.protoBook.set(peer.id, peer.protocols).catch((err2) => log$f.error(err2));
    }
    this.dispatchEvent(new CustomEvent("peer:discovery", { detail: peer }));
  }
}
async function createLibp2pNode(options) {
  if (options.peerId == null) {
    options.peerId = await createEd25519PeerId();
  }
  return new Libp2pNode(validateConfig(options));
}
async function createLibp2p$1(options) {
  return await createLibp2pNode(options);
}
var browser$1 = { exports: {} };
var safeBuffer = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(module, exports) {
  var buffer$12 = buffer;
  var Buffer2 = buffer$12.Buffer;
  function copyProps(src2, dst) {
    for (var key in src2) {
      dst[key] = src2[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer$12;
  } else {
    copyProps(buffer$12, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length3) {
    return Buffer2(arg, encodingOrOffset, length3);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length3) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length3);
  };
  SafeBuffer.alloc = function(size2, fill, encoding2) {
    if (typeof size2 !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf2 = Buffer2(size2);
    if (fill !== void 0) {
      if (typeof encoding2 === "string") {
        buf2.fill(fill, encoding2);
      } else {
        buf2.fill(fill);
      }
    } else {
      buf2.fill(0);
    }
    return buf2;
  };
  SafeBuffer.allocUnsafe = function(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size2);
  };
  SafeBuffer.allocUnsafeSlow = function(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer$12.SlowBuffer(size2);
  };
})(safeBuffer, safeBuffer.exports);
var MAX_BYTES = 65536;
var MAX_UINT32 = 4294967295;
function oldBrowser() {
  throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
}
var Buffer$1 = safeBuffer.exports.Buffer;
var crypto$1 = globalThis.crypto || globalThis.msCrypto;
if (crypto$1 && crypto$1.getRandomValues) {
  browser$1.exports = randomBytes$1;
} else {
  browser$1.exports = oldBrowser;
}
function randomBytes$1(size2, cb) {
  if (size2 > MAX_UINT32)
    throw new RangeError("requested too many random bytes");
  var bytes2 = Buffer$1.allocUnsafe(size2);
  if (size2 > 0) {
    if (size2 > MAX_BYTES) {
      for (var generated = 0; generated < size2; generated += MAX_BYTES) {
        crypto$1.getRandomValues(bytes2.slice(generated, generated + MAX_BYTES));
      }
    } else {
      crypto$1.getRandomValues(bytes2);
    }
  }
  if (typeof cb === "function") {
    return process.nextTick(function() {
      cb(null, bytes2);
    });
  }
  return bytes2;
}
const randomBytes = browser$1.exports;
const { EventEmitter } = events.exports;
function arrayEquals(array1, array2) {
  if (array1 === array2) {
    return true;
  }
  if (array1.length !== array2.length) {
    return false;
  }
  for (let i2 = 0, length3 = array1.length; i2 < length3; ++i2) {
    if (array1[i2] !== array2[i2]) {
      return false;
    }
  }
  return true;
}
function createNode() {
  return { contacts: [], dontSplit: false, left: null, right: null };
}
function ensureInt8(name2, val) {
  if (!(val instanceof Uint8Array)) {
    throw new TypeError(name2 + " is not a Uint8Array");
  }
}
class KBucket extends EventEmitter {
  constructor(options = {}) {
    super();
    this.localNodeId = options.localNodeId || randomBytes(20);
    this.numberOfNodesPerKBucket = options.numberOfNodesPerKBucket || 20;
    this.numberOfNodesToPing = options.numberOfNodesToPing || 3;
    this.distance = options.distance || KBucket.distance;
    this.arbiter = options.arbiter || KBucket.arbiter;
    this.metadata = Object.assign({}, options.metadata);
    ensureInt8("option.localNodeId as parameter 1", this.localNodeId);
    this.root = createNode();
  }
  static arbiter(incumbent, candidate) {
    return incumbent.vectorClock > candidate.vectorClock ? incumbent : candidate;
  }
  static distance(firstId, secondId) {
    let distance = 0;
    let i2 = 0;
    const min = Math.min(firstId.length, secondId.length);
    const max = Math.max(firstId.length, secondId.length);
    for (; i2 < min; ++i2) {
      distance = distance * 256 + (firstId[i2] ^ secondId[i2]);
    }
    for (; i2 < max; ++i2)
      distance = distance * 256 + 255;
    return distance;
  }
  add(contact) {
    ensureInt8("contact.id", (contact || {}).id);
    let bitIndex = 0;
    let node2 = this.root;
    while (node2.contacts === null) {
      node2 = this._determineNode(node2, contact.id, bitIndex++);
    }
    const index = this._indexOf(node2, contact.id);
    if (index >= 0) {
      this._update(node2, index, contact);
      return this;
    }
    if (node2.contacts.length < this.numberOfNodesPerKBucket) {
      node2.contacts.push(contact);
      this.emit("added", contact);
      return this;
    }
    if (node2.dontSplit) {
      this.emit("ping", node2.contacts.slice(0, this.numberOfNodesToPing), contact);
      return this;
    }
    this._split(node2, bitIndex);
    return this.add(contact);
  }
  closest(id, n = Infinity) {
    ensureInt8("id", id);
    if (!Number.isInteger(n) && n !== Infinity || n <= 0) {
      throw new TypeError("n is not positive number");
    }
    let contacts = [];
    for (let nodes = [this.root], bitIndex = 0; nodes.length > 0 && contacts.length < n; ) {
      const node2 = nodes.pop();
      if (node2.contacts === null) {
        const detNode = this._determineNode(node2, id, bitIndex++);
        nodes.push(node2.left === detNode ? node2.right : node2.left);
        nodes.push(detNode);
      } else {
        contacts = contacts.concat(node2.contacts);
      }
    }
    return contacts.map((a) => [this.distance(a.id, id), a]).sort((a, b2) => a[0] - b2[0]).slice(0, n).map((a) => a[1]);
  }
  count() {
    let count = 0;
    for (const nodes = [this.root]; nodes.length > 0; ) {
      const node2 = nodes.pop();
      if (node2.contacts === null)
        nodes.push(node2.right, node2.left);
      else
        count += node2.contacts.length;
    }
    return count;
  }
  _determineNode(node2, id, bitIndex) {
    const bytesDescribedByBitIndex = bitIndex >> 3;
    const bitIndexWithinByte = bitIndex % 8;
    if (id.length <= bytesDescribedByBitIndex && bitIndexWithinByte !== 0) {
      return node2.left;
    }
    const byteUnderConsideration = id[bytesDescribedByBitIndex];
    if (byteUnderConsideration & 1 << 7 - bitIndexWithinByte) {
      return node2.right;
    }
    return node2.left;
  }
  get(id) {
    ensureInt8("id", id);
    let bitIndex = 0;
    let node2 = this.root;
    while (node2.contacts === null) {
      node2 = this._determineNode(node2, id, bitIndex++);
    }
    const index = this._indexOf(node2, id);
    return index >= 0 ? node2.contacts[index] : null;
  }
  _indexOf(node2, id) {
    for (let i2 = 0; i2 < node2.contacts.length; ++i2) {
      if (arrayEquals(node2.contacts[i2].id, id))
        return i2;
    }
    return -1;
  }
  remove(id) {
    ensureInt8("the id as parameter 1", id);
    let bitIndex = 0;
    let node2 = this.root;
    while (node2.contacts === null) {
      node2 = this._determineNode(node2, id, bitIndex++);
    }
    const index = this._indexOf(node2, id);
    if (index >= 0) {
      const contact = node2.contacts.splice(index, 1)[0];
      this.emit("removed", contact);
    }
    return this;
  }
  _split(node2, bitIndex) {
    node2.left = createNode();
    node2.right = createNode();
    for (const contact of node2.contacts) {
      this._determineNode(node2, contact.id, bitIndex).contacts.push(contact);
    }
    node2.contacts = null;
    const detNode = this._determineNode(node2, this.localNodeId, bitIndex);
    const otherNode = node2.left === detNode ? node2.right : node2.left;
    otherNode.dontSplit = true;
  }
  toArray() {
    let result = [];
    for (const nodes = [this.root]; nodes.length > 0; ) {
      const node2 = nodes.pop();
      if (node2.contacts === null)
        nodes.push(node2.right, node2.left);
      else
        result = result.concat(node2.contacts);
    }
    return result;
  }
  *toIterable() {
    for (const nodes = [this.root]; nodes.length > 0; ) {
      const node2 = nodes.pop();
      if (node2.contacts === null) {
        nodes.push(node2.right, node2.left);
      } else {
        yield* node2.contacts;
      }
    }
  }
  _update(node2, index, contact) {
    if (!arrayEquals(node2.contacts[index].id, contact.id)) {
      throw new Error("wrong index for _update");
    }
    const incumbent = node2.contacts[index];
    const selection = this.arbiter(incumbent, contact);
    if (selection === incumbent && incumbent !== contact)
      return;
    node2.contacts.splice(index, 1);
    node2.contacts.push(selection);
    this.emit("updated", incumbent, selection);
  }
}
var kBucket = KBucket;
const second = 1e3;
const minute = 60 * second;
const hour = 60 * minute;
const MAX_RECORD_AGE = 36 * hour;
const LAN_PREFIX = "/lan";
const PROTOCOL_PREFIX = "/ipfs";
const PROTOCOL_DHT = "/kad/1.0.0";
const RECORD_KEY_PREFIX = "/dht/record";
const PROVIDER_KEY_PREFIX = "/dht/provider";
const PROVIDERS_LRU_CACHE_SIZE = 256;
const PROVIDERS_VALIDITY = 24 * hour;
const PROVIDERS_CLEANUP_INTERVAL = hour;
const K = 20;
const ALPHA = 3;
const QUERY_SELF_INTERVAL = Number(5 * minute);
const QUERY_SELF_TIMEOUT = Number(30 * second);
const TABLE_REFRESH_INTERVAL = Number(5 * minute);
const TABLE_REFRESH_QUERY_TIMEOUT = Number(30 * second);
const DEFAULT_QUERY_TIMEOUT = Number(30 * second);
const PK_PREFIX = fromString$3("/pk/");
function removePrivateAddresses(peer) {
  return {
    ...peer,
    multiaddrs: peer.multiaddrs.filter((multiaddr2) => {
      const [[type, addr]] = multiaddr2.stringTuples();
      if (type !== 4 && type !== 6) {
        return false;
      }
      if (addr == null) {
        return false;
      }
      return !privateIp(addr);
    })
  };
}
function removePublicAddresses(peer) {
  return {
    ...peer,
    multiaddrs: peer.multiaddrs.filter((multiaddr2) => {
      const [[type, addr]] = multiaddr2.stringTuples();
      if (type !== 4 && type !== 6) {
        return false;
      }
      if (addr == null) {
        return false;
      }
      return privateIp(addr);
    })
  };
}
async function convertBuffer(buf2) {
  const multihash = await sha256$3.digest(buf2);
  return multihash.digest;
}
async function convertPeerId(peerId) {
  return await convertBuffer(peerId.toBytes());
}
function bufferToRecordKey(buf2) {
  return new Key(`${RECORD_KEY_PREFIX}/${toString$5(buf2, "base32")}`, false);
}
function keyForPublicKey(peer) {
  return concat$1([
    PK_PREFIX,
    peer.toBytes()
  ]);
}
function isPublicKeyKey(key) {
  return toString$5(key.subarray(0, 4)) === "/pk/";
}
function fromPublicKeyKey(key) {
  return peerIdFromBytes(key.subarray(4));
}
function createPutRecord(key, value2) {
  const timeReceived = new Date();
  const rec = new Libp2pRecord(key, value2, timeReceived);
  return rec.serialize();
}
function debounce$1(callback, wait = 100) {
  let timeout2;
  return () => {
    clearTimeout(timeout2);
    timeout2 = setTimeout(() => callback(), wait);
  };
}
const KAD_CLOSE_TAG_NAME = "kad-close";
const KAD_CLOSE_TAG_VALUE = 50;
const KBUCKET_SIZE = 20;
const PING_TIMEOUT = 1e4;
const PING_CONCURRENCY = 10;
const METRIC_ROUTING_TABLE_SIZE = "routing-table-size";
const METRIC_PING_QUEUE_SIZE = "ping-queue-size";
const METRIC_PING_RUNNING = "ping-running";
class RoutingTable {
  constructor(components, init2) {
    const { kBucketSize, pingTimeout, lan, pingConcurrency, protocol: protocol2, tagName, tagValue } = init2;
    this.components = components;
    this.log = logger$1(`libp2p:kad-dht:${lan ? "lan" : "wan"}:routing-table`);
    this.kBucketSize = kBucketSize ?? KBUCKET_SIZE;
    this.pingTimeout = pingTimeout ?? PING_TIMEOUT;
    this.pingConcurrency = pingConcurrency ?? PING_CONCURRENCY;
    this.lan = lan;
    this.running = false;
    this.protocol = protocol2;
    this.tagName = tagName ?? KAD_CLOSE_TAG_NAME;
    this.tagValue = tagValue ?? KAD_CLOSE_TAG_VALUE;
    const updatePingQueueSizeMetric = () => {
      this.components.metrics?.updateComponentMetric({
        system: "libp2p",
        component: `kad-dht-${this.lan ? "lan" : "wan"}`,
        metric: METRIC_PING_QUEUE_SIZE,
        value: this.pingQueue.size
      });
      this.components.metrics?.updateComponentMetric({
        system: "libp2p",
        component: `kad-dht-${this.lan ? "lan" : "wan"}`,
        metric: METRIC_PING_RUNNING,
        value: this.pingQueue.pending
      });
    };
    this.pingQueue = new PQueue({ concurrency: this.pingConcurrency });
    this.pingQueue.addListener("add", updatePingQueueSizeMetric);
    this.pingQueue.addListener("next", updatePingQueueSizeMetric);
    this._onPing = this._onPing.bind(this);
  }
  isStarted() {
    return this.running;
  }
  async start() {
    this.running = true;
    const kBuck = new kBucket({
      localNodeId: await convertPeerId(this.components.peerId),
      numberOfNodesPerKBucket: this.kBucketSize,
      numberOfNodesToPing: 1
    });
    this.kb = kBuck;
    kBuck.on("ping", this._onPing);
    this._tagPeers(kBuck);
  }
  async stop() {
    this.running = false;
    this.pingQueue.clear();
    this.kb = void 0;
  }
  _tagPeers(kBuck) {
    let kClosest = new PeerSet();
    const updatePeerTags = debounce$1(() => {
      const newClosest = new PeerSet(kBuck.closest(kBuck.localNodeId, KBUCKET_SIZE).map((contact) => contact.peer));
      const addedPeers = newClosest.difference(kClosest);
      const removedPeers = kClosest.difference(newClosest);
      Promise.resolve().then(async () => {
        for (const peer of addedPeers) {
          await this.components.peerStore.tagPeer(peer, this.tagName, {
            value: this.tagValue
          });
        }
        for (const peer of removedPeers) {
          await this.components.peerStore.unTagPeer(peer, this.tagName);
        }
      }).catch((err2) => {
        this.log.error("Could not update peer tags", err2);
      });
      kClosest = newClosest;
    });
    kBuck.on("added", () => {
      updatePeerTags();
    });
    kBuck.on("removed", () => {
      updatePeerTags();
    });
  }
  _onPing(oldContacts, newContact) {
    this.pingQueue.add(async () => {
      if (!this.running) {
        return;
      }
      let responded = 0;
      try {
        await Promise.all(oldContacts.map(async (oldContact) => {
          let timeoutController;
          try {
            timeoutController = new timeoutAbortController.TimeoutController(this.pingTimeout);
            const options = {
              signal: timeoutController.signal
            };
            this.log("pinging old contact %p", oldContact.peer);
            const connection = await this.components.connectionManager.openConnection(oldContact.peer, options);
            const stream2 = await connection.newStream(this.protocol, options);
            stream2.close();
            responded++;
          } catch (err2) {
            if (this.running && this.kb != null) {
              this.log.error("could not ping peer %p", oldContact.peer, err2);
              this.log("evicting old contact after ping failed %p", oldContact);
              this.kb.remove(oldContact.id);
            }
          } finally {
            if (timeoutController != null) {
              timeoutController.clear();
            }
            this.components.metrics?.updateComponentMetric({
              system: "libp2p",
              component: `kad-dht-${this.lan ? "lan" : "wan"}`,
              metric: METRIC_ROUTING_TABLE_SIZE,
              value: this.size
            });
          }
        }));
        if (this.running && responded < oldContacts.length && this.kb != null) {
          this.log("adding new contact %p", newContact.peer);
          this.kb.add(newContact);
        }
      } catch (err2) {
        this.log.error("could not process k-bucket ping event", err2);
      }
    }).catch((err2) => {
      this.log.error("could not process k-bucket ping event", err2);
    });
  }
  get size() {
    if (this.kb == null) {
      return 0;
    }
    return this.kb.count();
  }
  async find(peer) {
    const key = await convertPeerId(peer);
    const closest = this.closestPeer(key);
    if (closest != null && peer.equals(closest)) {
      return closest;
    }
    return void 0;
  }
  closestPeer(key) {
    const res = this.closestPeers(key, 1);
    if (res.length > 0) {
      return res[0];
    }
    return void 0;
  }
  closestPeers(key, count = this.kBucketSize) {
    if (this.kb == null) {
      return [];
    }
    const closest = this.kb.closest(key, count);
    return closest.map((p) => p.peer);
  }
  async add(peer) {
    if (this.kb == null) {
      throw new Error("RoutingTable is not started");
    }
    const id = await convertPeerId(peer);
    this.kb.add({ id, peer });
    this.log("added %p with kad id %b", peer, id);
    this.components.metrics?.updateComponentMetric({
      system: "libp2p",
      component: `kad-dht-${this.lan ? "lan" : "wan"}`,
      metric: METRIC_ROUTING_TABLE_SIZE,
      value: this.size
    });
  }
  async remove(peer) {
    if (this.kb == null) {
      throw new Error("RoutingTable is not started");
    }
    const id = await convertPeerId(peer);
    this.kb.remove(id);
    this.components.metrics?.updateComponentMetric({
      system: "libp2p",
      component: `kad-dht-${this.lan ? "lan" : "wan"}`,
      metric: METRIC_ROUTING_TABLE_SIZE,
      value: this.size
    });
  }
}
const GENERATED_PREFIXES = [
  77591,
  22417,
  43971,
  28421,
  740,
  29829,
  71467,
  228973,
  196661,
  78537,
  27689,
  36431,
  44415,
  14362,
  19456,
  106025,
  96308,
  2882,
  49509,
  21149,
  87173,
  131409,
  75844,
  23676,
  121838,
  30291,
  17492,
  2953,
  7564,
  110620,
  129477,
  127283,
  53113,
  72417,
  165166,
  109690,
  21200,
  102125,
  24049,
  71504,
  90342,
  25307,
  72039,
  26812,
  26715,
  32264,
  133800,
  71161,
  88956,
  171987,
  51779,
  24425,
  16671,
  30251,
  186294,
  247761,
  14202,
  2121,
  8465,
  35024,
  4876,
  85917,
  169730,
  3638,
  256836,
  96184,
  943,
  18678,
  6583,
  52907,
  35807,
  112254,
  214097,
  18796,
  11595,
  9243,
  23554,
  887,
  268203,
  382004,
  24590,
  111335,
  11625,
  16619,
  29039,
  102425,
  69006,
  97976,
  92362,
  32552,
  63717,
  41433,
  128974,
  137630,
  59943,
  10019,
  13986,
  35430,
  33665,
  108037,
  43799,
  43280,
  38195,
  29078,
  58629,
  18265,
  14425,
  46832,
  235538,
  40830,
  77881,
  110717,
  58937,
  3463,
  325358,
  51300,
  47623,
  117252,
  19007,
  10170,
  20540,
  91237,
  294813,
  4951,
  79841,
  56232,
  36270,
  128547,
  69209,
  66275,
  100156,
  32063,
  73531,
  34439,
  80937,
  28892,
  44466,
  88595,
  216307,
  32583,
  49620,
  16605,
  82127,
  45807,
  21630,
  78726,
  20235,
  40163,
  111007,
  96926,
  5567,
  72083,
  21665,
  58844,
  39419,
  179767,
  48328,
  42662,
  51550,
  5251,
  37811,
  49608,
  81056,
  50854,
  55513,
  20922,
  18891,
  197409,
  164656,
  32593,
  71449,
  220474,
  58919,
  85682,
  67854,
  13758,
  35066,
  3565,
  61905,
  214793,
  119572,
  141419,
  21504,
  10302,
  27354,
  67003,
  46131,
  32668,
  15165,
  64871,
  34450,
  17821,
  2757,
  11452,
  34189,
  5160,
  12257,
  85523,
  560,
  53385,
  65887,
  119549,
  135620,
  312353,
  115979,
  122356,
  10867,
  193231,
  124537,
  54783,
  90675,
  120791,
  4715,
  142253,
  50943,
  17271,
  43358,
  25331,
  4917,
  120566,
  34580,
  12878,
  33786,
  160528,
  32523,
  4869,
  301307,
  104817,
  81491,
  23276,
  8832,
  97911,
  31265,
  52065,
  7998,
  49622,
  9715,
  43998,
  34091,
  84587,
  20664,
  69041,
  29419,
  53205,
  10838,
  58288,
  116145,
  6185,
  5154,
  141795,
  35924,
  21307,
  144738,
  43730,
  12085,
  8279,
  10002,
  119,
  133779,
  199668,
  72938,
  31768,
  39176,
  67875,
  38453,
  9700,
  44144,
  4121,
  116048,
  41733,
  12868,
  82669,
  92308,
  128,
  34262,
  11332,
  7712,
  90764,
  36141,
  13553,
  71312,
  77470,
  117314,
  96549,
  49135,
  23602,
  54468,
  28605,
  6327,
  62308,
  17171,
  67531,
  21319,
  14105,
  894,
  107722,
  46157,
  8503,
  51069,
  100472,
  45138,
  15246,
  14577,
  35609,
  191464,
  1757,
  13364,
  161349,
  32067,
  91705,
  81144,
  52339,
  5408,
  91066,
  21983,
  14157,
  100545,
  4372,
  26630,
  129112,
  1423,
  29676,
  213626,
  4397,
  88436,
  99190,
  6877,
  49958,
  26122,
  114348,
  60661,
  29818,
  293118,
  50042,
  179738,
  16400,
  163423,
  89627,
  31040,
  43973,
  36638,
  45952,
  5153,
  1894,
  109322,
  1898,
  134021,
  12402,
  112077,
  68309,
  190269,
  69866,
  31938,
  107383,
  11522,
  105232,
  11248,
  14868,
  39852,
  71707,
  186525,
  16530,
  38162,
  106212,
  11700,
  5130,
  16608,
  26998,
  59586,
  108399,
  230033,
  43683,
  48135,
  82179,
  2073,
  5015,
  196684,
  189293,
  16378,
  23452,
  8301,
  35640,
  11632,
  214551,
  29240,
  57644,
  33137,
  91949,
  55157,
  52384,
  117313,
  5090,
  17717,
  89668,
  49363,
  82238,
  241035,
  66216,
  29066,
  184088,
  97206,
  62820,
  26595,
  4241,
  135635,
  173672,
  8202,
  459,
  71355,
  146294,
  29587,
  3008,
  135385,
  141203,
  14803,
  6634,
  45094,
  69362,
  50925,
  546,
  51884,
  62011,
  83296,
  234584,
  44515,
  56050,
  89476,
  87751,
  19373,
  12691,
  149923,
  19794,
  13833,
  35846,
  87557,
  58339,
  2884,
  19145,
  25647,
  12224,
  11024,
  77338,
  64608,
  122297,
  53025,
  7205,
  36189,
  36294,
  170779,
  21750,
  7739,
  173883,
  75192,
  35664,
  224240,
  113121,
  30181,
  26267,
  27036,
  117827,
  92015,
  106516,
  55628,
  203549,
  67949,
  60462,
  60844,
  35911,
  20457,
  1820,
  920,
  19773,
  8738,
  73173,
  181993,
  38521,
  98254,
  76257,
  46008,
  92796,
  5384,
  26868,
  151566,
  22124,
  2411,
  15919,
  186872,
  180021,
  28099,
  152961,
  78811,
  80237,
  62352,
  102653,
  74259,
  184890,
  16792,
  123702,
  224945,
  29940,
  19512,
  75283,
  14059,
  112691,
  92811,
  233329,
  20411,
  138569,
  53341,
  109802,
  50600,
  134528,
  66747,
  5529,
  166531,
  31578,
  64732,
  67189,
  1596,
  126357,
  967,
  167999,
  206598,
  109752,
  119431,
  207825,
  78791,
  91938,
  10301,
  27311,
  24233,
  252343,
  28831,
  32812,
  66002,
  112267,
  90895,
  8786,
  8095,
  16824,
  22866,
  21813,
  60507,
  174833,
  19549,
  130985,
  117051,
  52110,
  6938,
  81923,
  123864,
  38061,
  919,
  18680,
  53534,
  46739,
  112893,
  161529,
  85429,
  26761,
  11900,
  81121,
  91968,
  15390,
  217947,
  56524,
  1713,
  6654,
  37089,
  85630,
  138866,
  61850,
  16491,
  75577,
  16884,
  98296,
  73523,
  6140,
  44645,
  6062,
  36366,
  29844,
  57946,
  37932,
  42472,
  5266,
  20834,
  19309,
  33753,
  127182,
  134259,
  35810,
  41805,
  45878,
  312001,
  14881,
  47757,
  49251,
  120050,
  44252,
  3708,
  25856,
  107864,
  120347,
  1228,
  36550,
  41682,
  34496,
  47025,
  8393,
  173365,
  246526,
  12894,
  161607,
  35670,
  90785,
  126572,
  2095,
  124731,
  157033,
  58694,
  554,
  12786,
  9642,
  4817,
  16136,
  47864,
  174698,
  66992,
  4639,
  69284,
  10625,
  40710,
  27763,
  51738,
  30404,
  264105,
  137904,
  109882,
  52487,
  42824,
  57514,
  2740,
  10479,
  146799,
  107390,
  16586,
  88038,
  174951,
  9410,
  16185,
  44158,
  5568,
  40658,
  46108,
  12763,
  97385,
  26175,
  108859,
  664,
  230732,
  67470,
  46663,
  14395,
  50750,
  141320,
  93140,
  15361,
  47997,
  55784,
  6791,
  307840,
  118569,
  107326,
  18056,
  58281,
  260415,
  54691,
  8790,
  73332,
  45633,
  7511,
  45674,
  143373,
  14031,
  11799,
  94491,
  35646,
  96544,
  14560,
  26049,
  32983,
  25791,
  83814,
  42094,
  231370,
  63955,
  139212,
  2359,
  169908,
  3108,
  183486,
  105867,
  28197,
  32941,
  124968,
  26402,
  88267,
  149768,
  23053,
  3078,
  19091,
  52924,
  25383,
  19209,
  111548,
  97361,
  3959,
  24880,
  235061,
  9099,
  24921,
  161254,
  151405,
  20508,
  7159,
  34381,
  20133,
  11434,
  74036,
  19974,
  34769,
  36585,
  1076,
  22454,
  17354,
  38727,
  235160,
  111547,
  96454,
  117448,
  156940,
  91330,
  37299,
  7310,
  26915,
  117060,
  51369,
  22620,
  61861,
  322264,
  106850,
  111694,
  15091,
  2624,
  40345,
  300446,
  177064,
  1707,
  27389,
  54792,
  327783,
  132669,
  183543,
  59003,
  17744,
  20603,
  151134,
  106923,
  53084,
  71803,
  279424,
  319816,
  11579,
  21946,
  16728,
  38274,
  72711,
  5085,
  83391,
  88646,
  40159,
  25027,
  34680,
  10752,
  12988,
  54126,
  30365,
  18338,
  100445,
  230674,
  44874,
  84974,
  143877,
  123253,
  139372,
  28082,
  91477,
  144002,
  13096,
  219729,
  46016,
  50029,
  42377,
  14601,
  6660,
  58244,
  58978,
  23918,
  88206,
  113611,
  64452,
  17541,
  41032,
  10942,
  12021,
  49189,
  10978,
  40175,
  37156,
  10947,
  71709,
  106894,
  112538,
  57007,
  137486,
  150608,
  152719,
  40615,
  7746,
  279716,
  13101,
  19524,
  28708,
  40578,
  72320,
  1096,
  182051,
  94527,
  51275,
  22833,
  45164,
  81917,
  77519,
  48508,
  5421,
  140302,
  37845,
  149830,
  5587,
  27579,
  5357,
  428725,
  248187,
  6326,
  206760,
  39814,
  32585,
  89923,
  44341,
  288753,
  284443,
  96368,
  31201,
  94189,
  119504,
  20359,
  52073,
  103216,
  179,
  27934,
  32801,
  96035,
  34111,
  34309,
  101326,
  18198,
  20704,
  210266,
  37643,
  27880,
  141873,
  106e3,
  19414,
  56614,
  167714,
  66483,
  107885,
  86602,
  4379,
  20796,
  75467,
  4987,
  5017,
  118857,
  26003,
  34308,
  114428,
  29198,
  6686,
  29697,
  73632,
  3739,
  69795,
  16798,
  41504,
  7207,
  30722,
  21436,
  36735,
  28067,
  28545,
  3239,
  11221,
  36031,
  41889,
  100010,
  19247,
  317673,
  29495,
  174554,
  6424,
  129725,
  53845,
  94986,
  7955,
  59676,
  2604,
  191497,
  19735,
  102214,
  62954,
  23844,
  11872,
  179525,
  261436,
  34492,
  428,
  78404,
  142035,
  16747,
  17246,
  27578,
  37021,
  33672,
  57944,
  26056,
  135760,
  2369,
  61674,
  122066,
  31327,
  19374,
  157065,
  40553,
  130982,
  69619,
  71290,
  38855,
  72100,
  92903,
  95940,
  51422,
  165999,
  65713,
  57873,
  50726,
  7288,
  20272,
  2081,
  42326,
  22624,
  81120,
  57914,
  79352,
  19447,
  1684,
  72302,
  11774,
  302559,
  161481,
  96396,
  13692,
  414988,
  3721,
  79066,
  56627,
  46883,
  21150,
  11747,
  12184,
  5856,
  113458,
  176117,
  84416,
  52079,
  27933,
  3354,
  59765,
  141359,
  2212,
  216309,
  2555,
  23458,
  196722,
  142463,
  45701,
  44548,
  28798,
  19418,
  215,
  29916,
  9396,
  10574,
  114226,
  84475,
  13520,
  18694,
  34056,
  4524,
  90302,
  62930,
  13539,
  19407,
  77209,
  7728,
  38088,
  9535,
  2263,
  23875,
  183945,
  17750,
  26274,
  67172,
  10585,
  28042,
  22199,
  7478,
  51331,
  66030,
  26774,
  192929,
  31434,
  25850,
  50197,
  52926,
  178158,
  4679,
  181256,
  70184,
  229600,
  9959,
  105594,
  72158,
  73974,
  2726,
  35085,
  78087,
  23284,
  35568,
  51713,
  155676,
  5401,
  27254,
  11966,
  17569,
  223253,
  71993,
  103357,
  111477,
  55722,
  30504,
  26034,
  46774,
  35392,
  36285,
  214814,
  41143,
  163465,
  1051,
  16094,
  81044,
  6636,
  76489,
  179102,
  20712,
  39178,
  35683,
  125177,
  54219,
  30617,
  52994,
  25324,
  50123,
  2543,
  87529,
  58995,
  10688,
  125199,
  12388,
  60158,
  125481,
  131646,
  7642,
  133350,
  65874,
  3438,
  97277,
  101450,
  10075,
  56344,
  116821,
  50778,
  60547,
  98016,
  106135,
  13859,
  14255,
  16300,
  77373,
  173521,
  8285,
  45932,
  37426,
  4054,
  114295,
  55947,
  7703,
  39114,
  52,
  51119,
  128135,
  19714,
  60715,
  9554,
  50492,
  88180,
  2823,
  118271,
  52993,
  122625,
  97919,
  23859,
  37895,
  25040,
  33614,
  32102,
  20431,
  3577,
  9275,
  15686,
  43031,
  157741,
  110358,
  1884,
  40291,
  125391,
  13736,
  5008,
  64881,
  87336,
  77381,
  70711,
  43032,
  49155,
  118587,
  70494,
  4318,
  10168,
  30126,
  12580,
  10524,
  280104,
  104001,
  145413,
  2862,
  84140,
  6603,
  106005,
  13566,
  12780,
  11251,
  42830,
  571,
  179910,
  82443,
  13146,
  469,
  42714,
  32591,
  265217,
  424024,
  92553,
  54721,
  134100,
  6007,
  15242,
  114681,
  59030,
  16718,
  85465,
  200214,
  85982,
  55174,
  165013,
  23493,
  56964,
  82529,
  109150,
  32706,
  27568,
  82442,
  5350,
  14976,
  13165,
  44890,
  60021,
  21343,
  33978,
  17264,
  4655,
  22328,
  27819,
  75730,
  16567,
  55483,
  14510,
  17926,
  45827,
  150609,
  3704,
  7385,
  272531,
  161543,
  76904,
  122163,
  52405,
  2039,
  19165,
  41623,
  14423,
  228354,
  3369,
  176360,
  85491,
  7122,
  35789,
  303724,
  4465,
  13628,
  2233,
  55311,
  118771,
  20713,
  10006,
  221519,
  45115,
  71021,
  35650,
  29775,
  7337,
  10864,
  20665,
  21142,
  1746,
  15080,
  1624,
  32449,
  10905,
  105743,
  229797,
  7701,
  3940,
  22997,
  178467,
  57208,
  389057,
  39683,
  59403,
  63344,
  63125,
  54847,
  69691,
  18336,
  56448,
  3362,
  37202,
  18282,
  29648,
  138224,
  35867,
  10495,
  5911,
  28814,
  26653,
  31514,
  176702,
  26550,
  45621,
  11734,
  4525,
  40543,
  73944,
  121080,
  27858,
  155561,
  14887,
  44670,
  30742,
  8796,
  107455,
  113472,
  56369,
  75581,
  183777,
  240095,
  133699,
  153299,
  8768,
  160464,
  26058,
  49078,
  103971,
  21875,
  71486,
  44888,
  17156,
  9678,
  89541,
  123019,
  102337,
  3972,
  83930,
  21245,
  87852,
  109660,
  287918,
  183019,
  686,
  10100,
  39177,
  283941,
  11274,
  24736,
  26793,
  26214,
  25995,
  77011,
  141580,
  4070,
  23742,
  46285,
  46632,
  30700,
  26669,
  19056,
  35951,
  115575,
  174034,
  56097,
  35463,
  87425,
  24575,
  44245,
  38701,
  82317,
  85922,
  281616,
  100333,
  147697,
  61503,
  7730,
  84330,
  8530,
  59917,
  61597,
  17173,
  9092,
  32658,
  90288,
  193136,
  39023,
  20381,
  56654,
  31132,
  7779,
  1919,
  1375,
  117128,
  30819,
  11169,
  40938,
  23935,
  115201,
  101155,
  151034,
  4835,
  11231,
  74550,
  89388,
  59951,
  91704,
  107312,
  167882,
  115062,
  12732,
  72738,
  88703,
  464019,
  158267,
  57995,
  60496,
  737,
  14371,
  123867,
  4174,
  243339,
  159946,
  7568,
  16025,
  134556,
  110916,
  38103,
  191,
  80226,
  88794,
  29688,
  27230,
  10454,
  76308,
  57647,
  77409,
  113483,
  66864,
  14745,
  19808,
  12023,
  46583,
  84805,
  16015,
  17102,
  2231,
  20611,
  3547,
  95740,
  250131,
  34559,
  108894,
  8498,
  15853,
  159169,
  148920,
  20942,
  2813,
  93160,
  45188,
  210613,
  45531,
  52587,
  149062,
  39782,
  28194,
  57849,
  60965,
  84954,
  89766,
  84453,
  100927,
  16501,
  27658,
  165311,
  103841,
  54192,
  207341,
  19558,
  20084,
  319622,
  5672,
  205467,
  98462,
  61849,
  36279,
  13609,
  147177,
  24726,
  165015,
  209489,
  59591,
  31157,
  6551,
  117580,
  75060,
  141146,
  277310,
  21072,
  22023,
  106474,
  63041,
  137443,
  122965,
  68371,
  5383,
  42146,
  98961,
  113467,
  30863,
  23794,
  4843,
  99630,
  30392,
  82679,
  13699,
  241612,
  33601,
  93146,
  24319,
  18643,
  32155,
  95669,
  40440,
  15333,
  34089,
  67799,
  142144,
  58245,
  38633,
  114531,
  117400,
  77861,
  188726,
  5507,
  2568,
  8853,
  10987,
  107222,
  2663,
  2421,
  11530,
  13345,
  30075,
  41785,
  118661,
  104786,
  17459,
  12490,
  16281,
  71936,
  193555,
  17431,
  5944,
  71758,
  26485,
  77317,
  20803,
  367167,
  158,
  7362,
  93430,
  11735,
  172445,
  46002,
  11532,
  54482,
  930,
  62911,
  2235,
  23004,
  179236,
  4764,
  101859,
  208113,
  22477,
  55163,
  95579,
  14098,
  67320,
  162556,
  90709,
  156949,
  3826,
  57492,
  4025,
  34092,
  87442,
  104565,
  6718,
  186015,
  28214,
  14209,
  10039,
  107186,
  233912,
  58877,
  81637,
  55265,
  39828,
  6194,
  145813,
  50831,
  105849,
  4974,
  88319,
  122296,
  10272,
  197216,
  95714,
  51540,
  72418,
  23324,
  91555,
  8743,
  140452,
  250249,
  51666,
  34124,
  7229,
  38592,
  129641,
  78169,
  174242,
  22464,
  149964,
  51450,
  14034,
  10026,
  95376,
  26190,
  120062,
  14401,
  8700,
  265,
  31386,
  143573,
  7203,
  229889,
  61567,
  4227,
  140981,
  2466,
  72052,
  10787,
  10062,
  30958,
  6099,
  38471,
  30103,
  23202,
  208101,
  70847,
  467,
  58934,
  32271,
  32984,
  36637,
  24107,
  30771,
  17109,
  73353,
  13650,
  2098,
  157040,
  67366,
  66904,
  106018,
  265380,
  107238,
  18535,
  44025,
  32681,
  144983,
  62505,
  91295,
  56120,
  3082,
  77508,
  10322,
  63023,
  36700,
  81885,
  224127,
  16721,
  45023,
  239261,
  111272,
  13852,
  7866,
  149243,
  204199,
  32309,
  22084,
  42029,
  38316,
  126644,
  104973,
  14406,
  43454,
  67322,
  61310,
  15789,
  40285,
  24026,
  181047,
  6301,
  70927,
  23319,
  115823,
  27248,
  66693,
  115875,
  278566,
  63007,
  146844,
  56841,
  59007,
  87368,
  180001,
  22370,
  42114,
  80605,
  12022,
  10374,
  308,
  25079,
  14689,
  12618,
  63368,
  7936,
  264973,
  212291,
  136713,
  95999,
  105801,
  18965,
  32075,
  48700,
  52230,
  35119,
  96912,
  32992,
  8586,
  16606,
  101333,
  101812,
  14969,
  39930,
  759,
  193090,
  27387,
  42914,
  12937,
  5058,
  62646,
  64528,
  38624,
  25743,
  37502,
  3716,
  4435,
  30352,
  178687,
  26461,
  132611,
  42002,
  138442,
  35833,
  59582,
  16345,
  8048,
  60319,
  49349,
  309,
  47800,
  49739,
  90482,
  26405,
  34470,
  63786,
  32479,
  85028,
  39866,
  47846,
  11649,
  23934,
  29466,
  2816,
  42864,
  31828,
  7410,
  74885,
  49632,
  47629,
  111801,
  90749,
  19536,
  18767,
  105764,
  59606,
  21223,
  10746,
  76298,
  22220,
  39408,
  7190,
  79654,
  64856,
  11602,
  82156,
  272765,
  17079,
  70089,
  245473,
  51813,
  184407,
  384678,
  1576,
  122249,
  5064,
  27481,
  6188,
  25790,
  74361,
  27541,
  318284,
  45430,
  31488,
  620,
  93579,
  45723,
  192118,
  22670,
  51913,
  4162,
  70244,
  35966,
  26397,
  16199,
  50899,
  209613,
  121702,
  287507,
  2993,
  36101,
  132229,
  67345,
  33062,
  76295,
  118628,
  78705,
  52316,
  34375,
  107083,
  107454,
  44863,
  127561,
  33964,
  3073,
  154010,
  190914,
  55967,
  39074,
  6272,
  31047,
  5550,
  41123,
  26154,
  98638,
  47110,
  19998,
  148091,
  50229,
  31329,
  59900,
  195442,
  19106,
  61347,
  73497,
  70015,
  682,
  45850,
  25776,
  38022,
  148951,
  6288,
  37411,
  232526,
  109277,
  27286,
  32342,
  9262,
  5220,
  16651,
  23175,
  46740,
  129438,
  78614,
  121925,
  66914,
  88710,
  127952,
  5563,
  21500,
  34521,
  10739,
  14863,
  191006,
  62956,
  17359,
  16749,
  67027,
  56284,
  69134,
  43301,
  35039,
  58883,
  54466,
  60823,
  404451,
  75743,
  59856,
  86979,
  7923,
  34273,
  83785,
  32142,
  7693,
  268986,
  197428,
  282681,
  17049,
  22346,
  22990,
  92245,
  107180,
  3357,
  37104,
  96724,
  49153,
  7683,
  31197,
  43267,
  82231,
  164276,
  23696,
  20848,
  188364,
  22309,
  24821,
  158707,
  1018,
  22514,
  70922,
  27792,
  45589,
  59709,
  10765,
  736,
  35218,
  63479,
  51987,
  24275,
  63588,
  55361,
  92929,
  81964,
  4658,
  20122,
  12330,
  44058,
  13065,
  311456,
  72224,
  8337,
  211229,
  38979,
  22590,
  138478,
  52757,
  32595,
  133600,
  8838,
  31549,
  94412,
  43391,
  90056,
  1585,
  94802,
  127271,
  6223,
  31889,
  137038,
  132910,
  2165,
  57616,
  230152,
  6080,
  10748,
  36737,
  74579,
  134062,
  50525,
  180532,
  119270,
  34556,
  76155,
  82394,
  52595,
  29258,
  31435,
  87820,
  67996,
  26943,
  183878,
  38007,
  2410,
  13526,
  180297,
  69856,
  3503,
  187396,
  167700,
  7838,
  16701,
  9199,
  56267,
  3661,
  37407,
  65994,
  23767,
  5708,
  62508,
  221700,
  67088,
  86978,
  46776,
  84434,
  32088,
  5612,
  9149,
  88244,
  21685,
  95151,
  46750,
  189612,
  2979,
  506311,
  2594,
  3628,
  40074,
  105039,
  78243,
  28523,
  6651,
  38058,
  71999,
  30992,
  12764,
  68261,
  108991,
  6165,
  26450,
  61961,
  13400,
  22426,
  7490,
  60890,
  109623,
  2070,
  12958,
  50355,
  67979,
  257096,
  7213,
  42578,
  52121,
  35716,
  65461,
  7516,
  124758,
  39268,
  302,
  64712,
  14977,
  1467,
  219452,
  2840,
  34229,
  11121,
  21602,
  19270,
  63574,
  8024,
  1532,
  17331,
  79839,
  78885,
  52029,
  180767,
  57957,
  6069,
  91265,
  61380,
  55767,
  8927,
  32881,
  287603,
  22149,
  35029,
  68876,
  6428,
  199567,
  46926,
  13412,
  104132,
  21434,
  366616,
  45060,
  110046,
  81924,
  128910,
  45886,
  52821,
  130416,
  29416,
  77342,
  21762,
  67329,
  121432,
  79924,
  11724,
  38625,
  81006,
  102033,
  28338,
  13326,
  3250,
  82056,
  82526,
  38212,
  21112,
  12382,
  111495,
  3263,
  7414,
  86274,
  93490,
  40844,
  30224,
  45212,
  24019,
  48411,
  71367,
  24941,
  76729,
  57776,
  3769,
  38114,
  202019,
  197745,
  31953,
  237533,
  33270,
  201580,
  255648,
  100798,
  44741,
  32241,
  98468,
  106931,
  10085,
  15090,
  170358,
  33154,
  66787,
  18819,
  69760,
  25061,
  234005,
  82660,
  6295,
  131975,
  16874,
  9076,
  4094,
  25005,
  17740,
  40908,
  19533,
  220019,
  44330,
  99792,
  50040,
  19619,
  13950,
  55228,
  24423,
  31253,
  95308,
  103177,
  184795,
  28590,
  82285,
  5059,
  3210,
  75525,
  49894,
  70007,
  56178,
  10580,
  36051,
  139681,
  21617,
  98736,
  3555,
  106306,
  164189,
  37352,
  63915,
  47824,
  24883,
  145530,
  61904,
  28444,
  11483,
  19837,
  145446,
  30420,
  112972,
  85939,
  11835,
  191233,
  2262,
  20705,
  58630,
  1753,
  148334,
  1197,
  144714,
  6887,
  11223,
  107667,
  60879,
  77914,
  4151,
  57417,
  81594,
  96681,
  169430,
  1784,
  20444,
  95138,
  254041,
  27038,
  596,
  7117,
  72808,
  13759,
  3353,
  126776,
  21074,
  55322,
  27081,
  36942,
  39547,
  139830,
  179275,
  4453,
  713,
  8722,
  71399,
  19204,
  25785,
  22794,
  23923,
  104114,
  11291,
  25458,
  102309,
  88396,
  75288,
  230440,
  206396,
  104551,
  58447,
  130857,
  37247,
  94734,
  31548,
  176529,
  226077,
  65159,
  20104,
  10096,
  66881,
  94191,
  237909,
  27109,
  37404,
  1520,
  27421,
  25220,
  113003,
  23423,
  24884,
  50585,
  6286,
  231877,
  150800,
  11789,
  3226,
  90004,
  60642,
  5053,
  202400,
  61442,
  132531,
  175329,
  57138,
  30116,
  103847,
  9973,
  75367,
  16452,
  32360,
  59119,
  21246,
  10191,
  164804,
  23305,
  61051,
  37348,
  154530,
  13214,
  5468,
  50403,
  66754,
  130976,
  50559,
  80515,
  14436,
  155492,
  84017,
  5472,
  43107,
  41240,
  2890,
  90431,
  70188,
  382,
  76234,
  48040,
  50211,
  281038,
  237007,
  32115,
  142178,
  1536,
  22761,
  96429,
  1811,
  31243,
  1679,
  49143,
  55209,
  17402,
  235054,
  61494,
  7462,
  77030,
  34925,
  87609,
  78002,
  9499,
  9027,
  73289,
  201078,
  101379,
  63544,
  27666,
  5469,
  10642,
  30029,
  49816,
  132979,
  95620,
  58086,
  351930,
  116300,
  2110,
  2043,
  30845,
  6154,
  11279,
  16727,
  4122,
  2277,
  27281,
  4971,
  3650,
  39060,
  61970,
  65951,
  39674,
  75686,
  38151,
  11370,
  130809,
  177895,
  32665,
  63725,
  122267,
  7857,
  39618,
  118483,
  44792,
  157755,
  178624,
  136994,
  24260,
  41308,
  22471,
  12404,
  21707,
  12486,
  30473,
  52781,
  50246,
  20247,
  39065,
  909,
  56825,
  103158,
  128603,
  31542,
  1089,
  41935,
  32744,
  12428,
  37963,
  84420,
  33134,
  72921,
  208449,
  42622,
  168151,
  127335,
  147107,
  46699,
  38216,
  12591,
  94342,
  85814,
  31423,
  24944,
  2605,
  87542,
  67473,
  192551,
  4496,
  56321,
  91819,
  17630,
  6300,
  256183,
  114569,
  202090,
  33209,
  35289,
  34897,
  24967,
  40520,
  43470,
  5344,
  10199,
  34810,
  14283,
  10381,
  10017,
  62923,
  49924,
  23233,
  64539,
  13051,
  35686,
  19698,
  11570,
  135555,
  120868,
  44924,
  87065,
  52318,
  52335,
  47586,
  140906,
  245885,
  109834,
  78668,
  9065,
  46990,
  25258,
  72022,
  61243,
  40838,
  4545,
  146387,
  10537,
  11557,
  17470,
  36930,
  68104,
  46711,
  24264,
  79401,
  81043,
  18225,
  120488,
  24746,
  84338,
  81652,
  28266,
  13776,
  21878,
  46973,
  1047,
  230465,
  73357,
  95777,
  24973,
  210160,
  62210,
  58404,
  110633,
  169651,
  6937,
  41870,
  9909,
  26822,
  191062,
  76553,
  27519,
  96256,
  239070,
  2478,
  205678,
  67955,
  58532,
  20601,
  50120,
  19148,
  78501,
  195724,
  110740,
  8249,
  109665,
  27446,
  30568,
  57631,
  31425,
  49752,
  32820,
  65504,
  50079,
  3663,
  102256,
  219898,
  23849,
  211315,
  14645,
  4359,
  91767,
  9528,
  12449,
  49366,
  7941,
  49763,
  107848,
  8930,
  27086,
  50686,
  9744,
  10447,
  81935,
  39513,
  46514,
  1670,
  29229,
  6172,
  22312,
  137280,
  97759,
  9806,
  14445,
  22976,
  56458,
  73391,
  34983,
  93760,
  174219,
  52573,
  33149,
  59747,
  2429,
  136277,
  75123,
  165263,
  91040,
  7446,
  57632,
  48633,
  97140,
  246081,
  84766,
  151684,
  79918,
  93268,
  120346,
  54059,
  54875,
  77858,
  32996,
  103590,
  45276,
  11968,
  19600,
  25849,
  17159,
  132907,
  42828,
  16817,
  4913,
  99462,
  103303,
  27395,
  5737,
  74184,
  20749,
  21160,
  14377,
  77062,
  131403,
  158735,
  10999,
  27799,
  77785,
  9320,
  34366,
  51593,
  61070,
  33746,
  47048,
  29268,
  36675,
  30262,
  53297,
  9832,
  82e3,
  20188,
  122292,
  39917,
  7331,
  18160,
  68301,
  185935,
  134830,
  15031,
  4935,
  10004,
  165845,
  185534,
  46923,
  30109,
  44134,
  122631,
  18874,
  22903,
  112790,
  26561,
  18549,
  348902,
  82871,
  140345,
  255565,
  135390,
  63556,
  103747,
  145055,
  179600,
  145662,
  296111,
  61661,
  211987,
  23952,
  52342,
  126343,
  48450,
  32919,
  44277,
  82185,
  9591,
  62139,
  205363,
  376969,
  394874,
  108461,
  18040,
  120885,
  14798,
  39863,
  16571,
  16794,
  58271,
  81025,
  55206,
  14640,
  118656,
  6361,
  44092,
  85970,
  6262,
  153863,
  108244,
  180200,
  72264,
  79947,
  38044,
  10050,
  5735,
  61221,
  80712,
  5471,
  115689,
  11391,
  11661,
  184257,
  20010,
  60116,
  30320,
  19327,
  134598,
  45455,
  27542,
  18004,
  125092,
  452272,
  1549,
  91523,
  46567,
  180063,
  156026,
  2608,
  11174,
  58848,
  37788,
  65907,
  80194,
  30490,
  5786,
  40775,
  119519,
  106241,
  11323,
  156297,
  8425,
  61495,
  2617,
  29675,
  2425,
  59886,
  112582,
  49142,
  59618,
  4863,
  50597,
  86710,
  50650,
  168632,
  27693,
  85641,
  83643,
  18993,
  25768,
  84284,
  28090,
  93592,
  36627,
  312804,
  43381,
  9887,
  9402,
  100931,
  97165,
  3311,
  173330,
  66805,
  28935,
  4963,
  184460,
  3201,
  78102,
  19126,
  21607,
  37496,
  24938,
  22615,
  16153,
  32862,
  134792,
  153318,
  61120,
  6067,
  2812,
  12826,
  12792,
  23825,
  37559,
  64662,
  202250,
  102694,
  155488,
  85881,
  149193,
  46233,
  65383,
  15521,
  106982,
  11358,
  176786,
  25752,
  39717,
  34208,
  24510,
  32464,
  77742,
  39371,
  72028,
  138229,
  60688,
  71386,
  102834,
  132477,
  2208,
  11548,
  63670,
  271279,
  28351,
  30338,
  38620,
  32491,
  99845,
  143885,
  152266,
  13252,
  2825,
  178663,
  108097,
  1775,
  78201,
  14897,
  113573,
  163346,
  62292,
  171129,
  22183,
  96598,
  38733,
  64971,
  166776,
  117445,
  9968,
  146393,
  44677,
  74867,
  20908,
  97328,
  12761,
  25656,
  26785,
  9148,
  112344,
  26115,
  99176,
  110121,
  22437,
  49547,
  6180,
  79320,
  5835,
  31392,
  43328,
  33377,
  75870,
  119860,
  69497,
  80273,
  7325,
  155219,
  43167,
  111173,
  28347,
  20222,
  3763,
  71752,
  55041,
  47252,
  14618,
  28088,
  15012,
  97805,
  194698,
  54636,
  2036,
  41349,
  6173,
  96604,
  61530,
  51859,
  43782,
  13361,
  24334,
  22668,
  24792,
  7070,
  23441,
  16789,
  3209,
  36211,
  208475,
  26242,
  32880,
  122181,
  182407,
  21444,
  31060,
  88459,
  29929,
  77907,
  12716,
  10934,
  97005,
  20599,
  31690,
  8403,
  58445,
  30303,
  22700,
  10336,
  86731,
  103115,
  337709,
  72556,
  46788,
  112566,
  47684,
  67089,
  53548,
  36874,
  56487,
  41387,
  125985,
  26893,
  40071,
  106683,
  73712,
  18787,
  40105,
  72992,
  67246,
  137276,
  50802,
  36790,
  70328,
  138827,
  22466,
  39263,
  183295,
  29858,
  50975,
  9322,
  57397,
  10654,
  24364,
  30383,
  55799,
  41600,
  23584,
  127295,
  296610,
  129078,
  143558,
  244131,
  86397,
  36049,
  1085,
  80677,
  3820,
  108139,
  5476,
  34767,
  24683,
  7758,
  13060,
  7239,
  131671,
  250593,
  59556,
  103392,
  29810,
  4188,
  252323,
  39404,
  116877,
  7651,
  43600,
  40338,
  13554,
  157253,
  39196,
  25978,
  144387,
  61211,
  234,
  50104,
  6129,
  10449,
  93777,
  9240,
  356378,
  274148,
  4439,
  72970,
  3724,
  147770,
  78680,
  62570,
  115877,
  40027,
  40547,
  36817,
  224392,
  64609,
  34795,
  165027,
  67440,
  2477,
  37206,
  23431,
  50754,
  164797,
  46018,
  94995,
  170982,
  27051,
  7957,
  22767,
  3674,
  27900,
  56419,
  18930,
  60701,
  41302,
  2692,
  84749,
  339721,
  61996,
  111094,
  80221,
  50129,
  1045,
  8153,
  62945,
  19202,
  8250,
  37208,
  37418,
  32560,
  79477,
  41106,
  88569,
  33963,
  36693,
  5892,
  30570,
  1581,
  66471,
  49647,
  11922,
  160717,
  29442,
  5643,
  114865,
  82962,
  95982,
  132098,
  22633,
  22838,
  94726,
  54556,
  28566,
  205039,
  162340,
  33216,
  16849,
  35847,
  221339,
  94851,
  26533,
  71469,
  1805,
  3804,
  12935,
  45483,
  71020,
  36310,
  65381,
  192960,
  34240,
  35165,
  59773,
  1248,
  46954,
  155332,
  96864,
  4246,
  388800,
  16129,
  57133,
  74592,
  44807,
  442014,
  38203,
  42574,
  80818,
  91592,
  26377,
  36424,
  65760,
  977,
  77387,
  22628,
  147610,
  28018,
  30561,
  98454,
  6969,
  119628,
  63648,
  18170,
  36854,
  26601,
  64018,
  22027,
  37279,
  51395,
  152934,
  21153,
  9430,
  58760,
  194742,
  5330,
  55115,
  34158,
  28917,
  174111,
  13171,
  122326,
  1526,
  43896,
  66094,
  25325,
  4234,
  148354,
  11450,
  275,
  18999,
  112191,
  44365,
  22723,
  68409,
  8733,
  57746,
  96565,
  75007,
  14196,
  108844,
  29475,
  88599,
  177563,
  100792,
  106156,
  86323,
  93726,
  14248,
  135341,
  194131,
  40126,
  47099,
  14779,
  8272,
  39597,
  95983,
  171398,
  65882,
  28052,
  10393,
  47213,
  40689,
  22120,
  72212,
  106829,
  34964,
  109146,
  753,
  648,
  21660,
  30047,
  17527,
  181025,
  5619,
  145357,
  4085,
  216883,
  9359,
  186951,
  24779,
  53931,
  24545,
  36197,
  223296,
  62628,
  168101,
  4243,
  107313,
  30321,
  26642,
  13049,
  51059,
  31027,
  107912,
  807,
  73550,
  26551,
  84369,
  122422,
  165872,
  49754,
  74213,
  234264,
  33151,
  52014,
  33100,
  87183,
  22365,
  52500,
  40013,
  23302,
  5652,
  72723,
  21404,
  26107,
  48434,
  587,
  94049,
  168493,
  96418,
  32871,
  70860,
  31709,
  25128,
  443,
  71597,
  166253,
  15670,
  70994,
  26341,
  133675,
  28280,
  75491,
  54756,
  47955,
  56028,
  26182,
  11952,
  113272,
  472197,
  64640,
  110753,
  17919,
  337,
  50642,
  22576,
  142,
  87371,
  53391,
  93210,
  126694,
  15285,
  19642,
  85667,
  14148,
  1506,
  42092,
  52962,
  33243,
  11970,
  20734,
  135843,
  57044,
  58880,
  13002,
  219134,
  22876,
  64754,
  232519,
  4257,
  43120,
  321573,
  24799,
  64526,
  124728,
  52579,
  81472,
  70831,
  276848,
  17403,
  74359,
  23021,
  182101,
  74597,
  23744,
  148267,
  12055,
  7976,
  5349,
  11772,
  67540,
  167347,
  65318,
  18720,
  127832,
  108238,
  22828,
  90233,
  9987,
  259080,
  118185,
  73209,
  79270,
  13775,
  90100,
  137742,
  90799,
  70569,
  15699,
  19961,
  9087,
  67475,
  57872,
  39731,
  8810,
  134897,
  131868,
  146849,
  19898,
  3334,
  2281,
  167061,
  91073,
  60356,
  467742,
  74712,
  188,
  53179,
  137679,
  92769,
  29241,
  9537,
  132595,
  80119,
  1041,
  88962,
  5976,
  40171,
  44911,
  102859,
  139059,
  104558,
  98987,
  47761,
  19272,
  71472,
  113864,
  175377,
  73338,
  10857,
  23402,
  23758,
  1591,
  139864,
  5644,
  4076,
  118760,
  16427,
  134198,
  18853,
  20291,
  100849,
  37423,
  22038,
  36677,
  19071,
  195521,
  57445,
  11069,
  31869,
  55718,
  66882,
  148490,
  44,
  41296,
  75242,
  49704,
  166810,
  9906,
  20943,
  122258,
  49112,
  105667,
  15969,
  10344,
  6408,
  187694,
  21399,
  72742,
  58970,
  14867,
  14376,
  81889,
  41856,
  23225,
  15042,
  56993,
  16074,
  131389,
  74276,
  72407,
  53875,
  383108,
  53597,
  37363,
  68993,
  44854,
  122548,
  430927,
  198279,
  38430,
  80409,
  12245,
  2981,
  628,
  2818,
  17760,
  37437,
  238229,
  7968,
  46892,
  2200,
  3730,
  34190,
  65983,
  37959,
  112291,
  87850,
  70827,
  6522,
  20750,
  73913,
  111621,
  41652,
  19587,
  2780,
  58668,
  25916,
  85259,
  18200,
  168962,
  95781,
  42445,
  102050,
  7776,
  57662,
  103313,
  47742,
  96358,
  41964,
  66174,
  100396,
  29069,
  204735,
  19679,
  27978,
  7479,
  40264,
  22534,
  61183,
  36081,
  107436,
  58223,
  14680,
  23002,
  101311,
  24716,
  124108,
  12908,
  5646,
  31750,
  40380,
  14215,
  232799,
  102772,
  14122,
  96775,
  61398,
  50917,
  12096,
  149880,
  67833,
  598749,
  124194,
  155871,
  49216,
  790,
  14677,
  65319,
  56917,
  7440,
  145744,
  95701,
  12206,
  49405,
  129269,
  76199,
  45732,
  9767,
  11058,
  9047,
  210885,
  11051,
  7392,
  26307,
  2130,
  8132,
  147526,
  20802,
  232698,
  115660,
  50060,
  59789,
  57344,
  107623,
  80343,
  112676,
  23291,
  9866,
  160971,
  34032,
  118291,
  15719,
  59730,
  164911,
  28975,
  2659,
  58046,
  78480,
  21854,
  66209,
  53863,
  109085,
  116045,
  29021,
  46481,
  107552,
  22130,
  18764,
  70254,
  31272,
  11300,
  52460,
  43933,
  84738,
  20721,
  53869,
  190840,
  79673,
  105300,
  7561,
  321817,
  66924,
  13940,
  33281,
  101046,
  183181,
  32176,
  71878,
  5678,
  62924,
  79535,
  56646,
  40303,
  19559,
  27703,
  93042,
  73368,
  42187,
  3670,
  37376,
  46440,
  7023,
  36816,
  109628,
  20680,
  5940,
  276440,
  275233,
  170848,
  112093,
  136996,
  14984,
  20226,
  111441,
  77693,
  112960,
  48577,
  39370,
  55707,
  50314,
  123404,
  26570,
  54281,
  61372,
  123391,
  4857,
  35928,
  246740,
  132507,
  106646,
  44241,
  7196,
  92258,
  9825,
  37688,
  51197,
  303141,
  5590,
  15476,
  132986,
  10955,
  85782,
  34486,
  26696,
  7991,
  28813,
  18858,
  39546,
  11703,
  11365,
  38185,
  5716,
  93555,
  11925,
  40121,
  60002,
  6985,
  10976,
  171384,
  3887,
  43394,
  13337,
  56346,
  6381,
  252336,
  39573,
  75042,
  53711,
  1028,
  31781,
  44295,
  95925,
  131713,
  7214,
  68125,
  43571,
  70954,
  213234,
  1628,
  8760,
  13391,
  65485,
  17320,
  56038,
  1710,
  25248,
  60803,
  57399,
  19839,
  3870,
  326,
  281556,
  50945,
  72400,
  21460,
  316244,
  75619,
  56246,
  98775,
  481,
  13513,
  55765,
  50427,
  7388,
  123519,
  32929,
  57908,
  27124,
  61316,
  101097,
  57467,
  30228,
  48792,
  10788,
  20402,
  37318,
  50526,
  155730,
  34456,
  158065,
  145305,
  17832,
  43733,
  64052,
  4506,
  35072,
  205355,
  177028,
  184004,
  187081,
  68616,
  35938,
  83703,
  10367,
  36892,
  93186,
  260137,
  51934,
  89970,
  4985,
  23445,
  26755,
  21558,
  7948,
  78741,
  23376,
  124405,
  85594,
  68596,
  57536,
  49351,
  12619,
  56593,
  132668,
  99924,
  109728,
  71844,
  71935,
  196018,
  65464,
  17617,
  14987,
  89701,
  143773,
  33997,
  8687,
  22701,
  33258,
  2914,
  4436,
  72108,
  85610,
  9671,
  49067,
  2327,
  82988,
  1361,
  1672,
  44033,
  35777,
  30269,
  24057,
  10605,
  82236,
  616,
  15793,
  13919,
  47249,
  112086,
  116698,
  9484,
  80207,
  90574,
  33304,
  68624,
  93127,
  56101,
  42210,
  160929,
  4827,
  38995,
  38095,
  4701,
  125119,
  5027,
  33680,
  9236,
  231236,
  14135,
  87837,
  23318,
  70261,
  78893,
  30151,
  81482,
  14332,
  1084,
  74256,
  27532,
  46644,
  79185,
  3148,
  62615,
  6981,
  55672,
  31668,
  36825,
  1849,
  14536,
  37446,
  14738,
  23779,
  43058,
  162749,
  72199,
  1168,
  21346,
  5592,
  85932,
  85302,
  9668,
  18351,
  57135,
  150360,
  2080,
  228015,
  77953,
  34670,
  119302,
  151751,
  31009,
  106725,
  84265,
  45214,
  59289,
  74178,
  113071,
  263206,
  111009,
  4021,
  44449,
  188119,
  192629,
  123592,
  392506,
  292847,
  114487,
  12831,
  205858,
  9852,
  20780,
  79648,
  75767,
  357014,
  97721,
  18166,
  21005,
  67950,
  33226,
  204009,
  16536,
  2987,
  11335,
  66717,
  144910,
  47950,
  17262,
  55060,
  15063,
  2934,
  51038,
  26775,
  178497,
  66008,
  3427,
  49433,
  128592,
  20036,
  157553,
  63861,
  3089,
  23015,
  51210,
  28696,
  35933,
  49942,
  71135,
  231518,
  99620,
  17248,
  21835,
  176536,
  20676,
  16944,
  38700,
  165831,
  233253,
  295625,
  36723,
  13023,
  52745,
  10907,
  19423,
  67972,
  125868,
  95473,
  82875,
  1183,
  108455,
  52685,
  33417,
  64095,
  21433,
  52438,
  33191,
  127809,
  44505,
  211823,
  7810,
  2752,
  95548,
  162031,
  7185,
  91196,
  47563,
  61721,
  33359,
  17897,
  23682,
  42806,
  178101,
  22874,
  49707,
  199897,
  75419,
  82456,
  8618,
  11171,
  79712,
  116847,
  18783,
  44190,
  46564,
  5346,
  59046,
  95032,
  7893,
  14916,
  3214,
  26800,
  24172,
  121453,
  34362,
  10250,
  17408,
  18888,
  4840,
  68696,
  22831,
  13162,
  36005,
  32512,
  14800,
  62357,
  41723,
  45046,
  27247,
  37486,
  5372,
  2564,
  34261,
  298500,
  66509,
  133920,
  89138,
  31305,
  117697,
  19097,
  108304,
  81386,
  84106,
  23802,
  46411,
  63304,
  946,
  51417,
  41777,
  41041,
  19501,
  115864,
  60743,
  294354,
  37955,
  94165,
  18116,
  1156,
  17937,
  20645,
  57114,
  90804,
  58042,
  48643,
  92288,
  9861,
  2557,
  88546,
  61333,
  101008,
  12853,
  5148,
  87856,
  4152,
  144503,
  73841,
  18718,
  9789,
  147565,
  10846,
  42085,
  12789,
  30223,
  8993,
  56352,
  67203,
  2448,
  28215,
  6052,
  23540,
  126319,
  75933,
  36689,
  80235,
  23231,
  23561,
  21383,
  38800,
  77548,
  102798,
  21234,
  31468,
  158608,
  46188,
  63960,
  191679,
  8051,
  67014,
  11185,
  170078,
  42186,
  28827,
  34777,
  41930,
  212079,
  12421,
  34750,
  24111,
  110344,
  73918,
  45171,
  70826,
  141949,
  40063,
  23979,
  24254,
  37309,
  26724,
  27179,
  24718,
  83648,
  54938,
  14591,
  17425,
  29525,
  102675,
  48975,
  48654,
  12316,
  8929,
  60640,
  41709,
  50168,
  63264,
  89812,
  50716,
  48632,
  38755,
  138583,
  160123,
  55579,
  71829,
  24230,
  233277,
  46322,
  39650,
  166388,
  34718,
  24108,
  98252,
  7031,
  106695,
  62498,
  18258,
  35062,
  217827,
  78731,
  34824,
  33354,
  19520,
  60852,
  2432,
  60224,
  8587,
  2836,
  62955,
  702,
  20227,
  42285,
  40560,
  95592,
  62486,
  11094,
  53035,
  143291,
  18842,
  46177,
  77994,
  1770,
  9657,
  107422,
  172915,
  32655,
  128716,
  25886,
  25164,
  156740,
  119928,
  165875,
  85817,
  11007,
  89110,
  33956,
  12652,
  65156,
  180266,
  8494,
  36889,
  19958,
  20955,
  96,
  1264,
  118288,
  135769,
  44754,
  86671,
  5632,
  19026,
  168220,
  289120,
  33569,
  93821,
  66144,
  70635,
  7687,
  5642,
  2714,
  55445,
  56636,
  71545,
  184182,
  93133,
  7332,
  37389,
  12643,
  52315,
  22729,
  11014,
  158742,
  17050,
  152889,
  50178,
  34601,
  41945,
  52136,
  9948,
  26914,
  63548,
  95721,
  115951,
  40759,
  8960,
  158258,
  38938,
  49232,
  48325,
  42234,
  81523,
  253019,
  66128,
  40978,
  20048,
  238048,
  38760,
  62928,
  122560,
  118532,
  43687,
  137472,
  163689,
  26680,
  9878,
  17448,
  51035,
  16211,
  60834,
  36749,
  29178,
  14241,
  59868,
  150086,
  2305,
  26477,
  42422,
  34342,
  165341,
  83279,
  33894,
  14257,
  29928,
  12743,
  13957,
  125571,
  89134,
  66712,
  10952,
  16507,
  147839,
  30146,
  7249,
  16565,
  45399,
  39874,
  114565,
  215780,
  31990,
  230881,
  171477,
  102,
  196546,
  44538,
  10880,
  84948,
  281705,
  86651,
  10617,
  31395,
  2342,
  453658,
  43569,
  60561,
  132901,
  21845,
  17727,
  58556,
  258242,
  22262,
  58728,
  4008,
  77997,
  11806,
  37431,
  30599,
  81375,
  109137,
  185787,
  114085,
  217292,
  97453,
  169085,
  30593,
  60212,
  11544,
  102056,
  65580,
  2384,
  91655,
  4855,
  95725,
  7295,
  157994,
  16228,
  20669,
  53276,
  141590,
  105246,
  17334,
  25440,
  76067,
  17967,
  39321,
  38911,
  11362,
  28559,
  63807,
  21627,
  26468,
  85816,
  40120,
  1025,
  15234,
  58319,
  69516,
  66512,
  124548,
  75845,
  78873,
  22137,
  46681,
  51242,
  85683,
  32909,
  76747,
  35555,
  43396,
  101465,
  1765,
  73094,
  1077,
  2962,
  39028,
  66777,
  57831,
  42048,
  15828,
  13962,
  36041,
  63657,
  52412,
  5242,
  58846,
  2141,
  5506,
  219012,
  134451,
  3936,
  182230,
  17558,
  17153,
  152237,
  22621,
  49377,
  170216,
  35257,
  68233,
  65374,
  6510,
  11126,
  212151,
  7184,
  2480,
  22517,
  3437,
  33073,
  30156,
  16557,
  3768,
  55067,
  86829,
  91e3,
  12350,
  148650,
  66017,
  79424,
  70885,
  49066,
  28250,
  21369,
  51213,
  34533,
  11510,
  3258,
  18176,
  18465,
  84413,
  6315,
  36411,
  163765,
  4346,
  356,
  107618,
  598,
  13727,
  285026,
  162695,
  8749,
  14583,
  7132,
  63521,
  184253,
  32378,
  25991,
  5604,
  30961,
  53675,
  4874,
  84693,
  5086,
  34811,
  26978,
  56564,
  7904,
  33519,
  51221,
  113942,
  69253,
  6664,
  125563,
  22055,
  220680,
  102008,
  742,
  51930,
  19494,
  176108,
  44424,
  35123,
  13025,
  75685,
  11759,
  74335,
  22250,
  181453,
  131147,
  16984,
  132115,
  154311,
  11991,
  76452,
  52609,
  85351,
  196,
  30969,
  9198,
  74919,
  2529,
  56838,
  71779,
  29187,
  116304,
  3504,
  62330,
  41190,
  86153,
  28393,
  254926,
  104228,
  105189,
  13264,
  84359,
  3574,
  12415,
  8534,
  57147,
  10175,
  188174,
  59504,
  60932,
  66318,
  16407,
  107921,
  17638,
  99103,
  49278,
  28403,
  39786,
  145865,
  8462,
  3558,
  43406,
  142271,
  29139,
  21989,
  36552,
  93955,
  72365,
  7176,
  13556,
  106185,
  37957,
  321774,
  17782,
  129017,
  51154,
  27938,
  24952,
  1935,
  39366,
  2791,
  33489,
  41582,
  56078,
  24558,
  9311,
  5449,
  218786,
  27808,
  190429,
  68013,
  36020,
  86003,
  29735,
  3404,
  87348,
  119357,
  115714,
  2324,
  86796,
  81973,
  40992,
  43376,
  93621,
  28784,
  16808,
  36367,
  2517,
  2909,
  191926,
  24978,
  55303,
  53308,
  205724,
  60068,
  3098,
  21375,
  64784,
  23949,
  26579,
  63121,
  12319,
  80145,
  39967,
  97861,
  6757,
  70143,
  67642,
  37082,
  34698,
  69140,
  122883,
  46151,
  62187,
  80934,
  429,
  19437,
  135071,
  137885,
  222647,
  13331,
  154065,
  327,
  61778,
  74257,
  40116,
  37493,
  14855,
  85079,
  237641,
  42342,
  102164,
  199965,
  71204,
  4662,
  29368,
  5042,
  113914,
  122214,
  8955,
  13149,
  102503,
  43173,
  5659,
  163787,
  69003,
  307084,
  63392,
  171080,
  21390,
  81918,
  86666,
  36622,
  24126,
  28887,
  5736,
  28054,
  207170,
  163428,
  79891,
  346467,
  95363,
  38980,
  111806,
  80828,
  9200,
  19288,
  294896,
  114468,
  87405,
  111715,
  141705,
  7015,
  72754,
  68463,
  48738,
  243147,
  33397,
  101210,
  37051,
  98801,
  82847,
  20397,
  4940,
  185559,
  18716,
  54718,
  83491,
  11725,
  40803,
  1128,
  12128,
  23060,
  5174,
  7745,
  67007,
  46701,
  1571,
  27807,
  180186,
  256996,
  18975,
  16837,
  7877,
  212758,
  250379,
  15440,
  87954,
  57755,
  24719,
  124057,
  83461,
  258,
  50864,
  8874,
  29038,
  71289,
  31627,
  15429,
  9005,
  4061,
  113851,
  107716,
  82819,
  13651,
  79656,
  117851,
  17539,
  111446,
  12938,
  39724,
  190787,
  4352,
  15402,
  21070,
  62708,
  8539,
  23777,
  73853,
  13552,
  38810,
  86117,
  16285,
  56400,
  1718,
  75342,
  142863,
  29033,
  378,
  110113,
  180321,
  32586,
  23606,
  26393,
  160984,
  207987,
  23783,
  8406,
  16904,
  24596,
  47274,
  11693,
  46539,
  60524,
  78595,
  48423,
  31718,
  20170,
  9009,
  146268,
  15183,
  191060,
  172765,
  1349,
  138436,
  37365,
  10970,
  40509,
  225817,
  20021,
  70394,
  152138,
  21541,
  66559,
  66544,
  89352,
  2725,
  17258,
  91345,
  7313,
  3815,
  115868,
  8660,
  40362,
  4071,
  103524,
  39388,
  118275,
  21950,
  6549,
  38226,
  32754,
  209574,
  29201,
  43495,
  18028,
  20296,
  40597,
  18370,
  47520,
  202450,
  24134,
  2219,
  8195,
  69545,
  38041,
  136934,
  46374,
  19041,
  159811,
  84865,
  58620,
  846,
  98749,
  13569,
  30714,
  97246,
  32186,
  4479,
  27355,
  92973,
  35214,
  151491,
  75963,
  37631,
  1561,
  27200,
  238083,
  23182,
  60756,
  12291,
  25766,
  39355,
  102333,
  87362,
  65741,
  59906,
  19538,
  201575,
  48772,
  102938,
  24438,
  292580,
  39964,
  66366,
  9004,
  61379,
  50548,
  37622,
  38732,
  28379,
  68180,
  76622,
  17488,
  69849,
  5963,
  7219,
  48143,
  43413,
  55358,
  540,
  58691,
  29506,
  19245,
  52193,
  48621,
  5518,
  13048,
  118625,
  44755,
  191081,
  42061,
  89197,
  2259,
  60665,
  66994,
  71210,
  51232,
  3585,
  142096,
  55024,
  7892,
  8345,
  58653,
  463307,
  65658,
  64319,
  137941,
  136323,
  53499,
  12746,
  43492,
  6978,
  95163,
  29925,
  60175,
  5128,
  7352,
  41463,
  184756,
  121146,
  20473,
  18426,
  4598,
  5309,
  54580,
  14277,
  121151,
  10691,
  56711,
  43880,
  63409,
  76682,
  11830,
  172218,
  264898,
  32632,
  66536,
  81062,
  31649,
  25788,
  92774,
  60222,
  11100,
  63159,
  9432,
  224657,
  25240,
  53613,
  152,
  138620,
  163829,
  2397,
  85345,
  12501,
  37507,
  64932,
  38575,
  43522,
  65789,
  80198,
  78796,
  35226,
  3851,
  108891,
  73311,
  3060,
  28391,
  93671,
  39663,
  46142,
  30982,
  66041,
  37281,
  68157,
  26553,
  71872,
  81142,
  211527,
  39747,
  118119,
  22695,
  2859,
  11066,
  20232,
  168911,
  7933,
  197005,
  17066,
  111071,
  44434,
  133994,
  120798,
  12766,
  227798,
  45756,
  132852,
  29917,
  36076,
  55352,
  65281,
  129800,
  41958,
  18944,
  84678,
  18580,
  168093,
  132621,
  39997,
  54092,
  27740,
  32354,
  3770,
  114118,
  103242,
  43918,
  15899,
  18574,
  145944,
  3190,
  123469,
  219903,
  24169,
  100571,
  62403,
  16776,
  92779,
  14535,
  17168,
  16475,
  14304,
  37231,
  1712,
  28218,
  242754,
  61688,
  28980,
  1318,
  51359,
  222657,
  99200,
  67989,
  31772,
  23932,
  35351,
  201251,
  49041,
  27306,
  19128,
  40135,
  3986,
  77333,
  19649,
  120683,
  151927,
  21081,
  7076,
  78375,
  77501,
  101599,
  8011,
  89585,
  96715,
  58179,
  5378,
  102138,
  106793,
  26051,
  217276,
  4197,
  16297,
  27014,
  46721,
  13322,
  22806,
  5278,
  29629,
  70632,
  9647,
  71519,
  58818,
  40603,
  128530,
  8903,
  36770,
  56900,
  31483,
  26935,
  43845,
  34265,
  34920,
  87658,
  6114,
  84767,
  64250,
  47318,
  50720,
  19264,
  162514,
  33357,
  13117,
  6705,
  46696,
  75032,
  71054,
  87004,
  42035,
  69138,
  11903,
  99854,
  102328,
  19611,
  34525,
  69312,
  6431,
  49842,
  101600,
  133178,
  108751,
  41829,
  89939,
  225664,
  48916,
  99556,
  9195,
  130387,
  5960,
  36857,
  116724,
  53518,
  94002,
  39077,
  53996,
  6945,
  22261,
  64291,
  8314,
  152785,
  57588,
  16522,
  9091,
  5048,
  87671,
  35441,
  39509,
  1945,
  12423,
  158923,
  178413,
  37549,
  14095,
  1475,
  73188,
  62878,
  4819,
  24012,
  68534,
  42606,
  4010,
  120809,
  57497,
  59564,
  101758,
  103718,
  32701,
  80116,
  12345,
  95834,
  46918,
  21468,
  53213,
  15665,
  31200,
  3867,
  5140,
  96013,
  250744,
  21016,
  10069,
  13968,
  35449,
  180829,
  27683,
  39704,
  59956,
  22893,
  3115,
  26293,
  32785,
  75934,
  62445,
  141162,
  62720,
  2018,
  83638,
  19949,
  114012,
  95006,
  3330,
  99829,
  130935,
  309272,
  9565,
  55874,
  121727,
  37017,
  23586,
  319858,
  40970,
  27602,
  8625,
  112329,
  61060,
  100088,
  118525,
  25922,
  16232,
  1907,
  60671,
  51583,
  44553,
  80993,
  5262,
  94679,
  8676,
  940,
  20736,
  11823,
  3020,
  16476,
  12340,
  152600,
  97416,
  3703,
  25744,
  66826,
  16245,
  16876,
  46446,
  84798,
  74227,
  176020,
  45192,
  61955,
  75496,
  23946,
  23626,
  40372,
  26036,
  6149,
  11822,
  30582,
  16541,
  41914,
  82385,
  232823,
  40921,
  80773,
  14930,
  3631,
  7517,
  39619,
  4348,
  36180,
  126106,
  138939,
  62611,
  1477,
  113512,
  47321,
  25052,
  14546,
  118881,
  29060,
  23589,
  128322,
  36795,
  18401,
  137921,
  104699,
  267929,
  36194,
  172791,
  18113,
  4766,
  188215,
  30083,
  332586,
  94089,
  5805,
  77909,
  22194,
  68234,
  154976,
  43220,
  40660,
  70001,
  184893,
  138095,
  11128,
  103010,
  22663,
  5108,
  212615,
  8485,
  5565,
  49222,
  54614,
  26530,
  42639,
  16319,
  55062,
  152662,
  105595,
  21114,
  22216,
  10294,
  68158,
  10436,
  86950,
  7206,
  62115,
  3977,
  3657,
  59874,
  456,
  118617,
  18156,
  106663,
  112229,
  80992,
  17442,
  8217,
  55551,
  5133,
  34344,
  251927,
  51153,
  39364,
  201321,
  7816,
  66803,
  23057,
  156724,
  145664,
  14276,
  95705,
  979,
  2796,
  6875,
  13429,
  212525,
  50602,
  26276,
  28284,
  3424,
  19465,
  52397,
  46963,
  31420,
  51399,
  206476,
  92317,
  48851,
  637,
  100820,
  83349,
  10317,
  60227,
  21972,
  6908,
  282439,
  32857,
  224767,
  95629,
  83882,
  42106,
  87338,
  69757,
  29840,
  68709,
  37665,
  45244,
  114577,
  49188,
  175943,
  54009,
  186746,
  106158,
  70168,
  3358,
  234002,
  50555,
  9221,
  129338,
  9562,
  20118,
  32923,
  78479,
  118280,
  65752,
  4977,
  10474,
  102174,
  60947,
  129006,
  10570,
  83451,
  8598,
  8078,
  159367,
  123785,
  80438,
  16742,
  5905,
  5281,
  181513,
  42402,
  6977,
  163136,
  93179,
  42191,
  14968,
  50421,
  112401,
  105440,
  33456,
  57347,
  121611,
  4221,
  94954,
  36517,
  24046,
  27796,
  6255,
  33394,
  72990,
  135408,
  116627,
  1233,
  57874,
  25654,
  95419,
  68156,
  401399,
  313338,
  55208,
  45573,
  93124,
  119251,
  47200,
  38196,
  11909,
  130667,
  45391,
  73904,
  64964,
  167846,
  4137,
  115606,
  52036,
  62214,
  7969,
  160925,
  7187,
  1132,
  134835,
  40309,
  73195,
  64494,
  80472,
  444841,
  61111,
  26500,
  45323,
  40743,
  53625,
  52797,
  22659,
  15631,
  29739,
  36706,
  28841,
  39147,
  102836,
  26794,
  10536,
  14845,
  87305,
  45874,
  12241,
  127587,
  83833,
  57183,
  79722,
  30844,
  41304,
  84655,
  20825,
  92500,
  3722,
  25655,
  27811,
  10157,
  81634,
  31362,
  34088,
  92487,
  70123,
  22190,
  185100,
  72658,
  139035,
  192523,
  88241,
  2078,
  230490,
  44528,
  85638,
  100198,
  22088,
  29982,
  291233,
  241062,
  13865,
  4445,
  137791,
  37835,
  107218,
  31726,
  19718,
  38234,
  72528,
  23046,
  19177,
  66695,
  5109,
  17251,
  28077,
  5617,
  21554,
  47839,
  72425,
  133825,
  1486,
  73065,
  181275,
  141508,
  21768,
  62971,
  63082,
  2512,
  34200,
  9904,
  120309,
  6392,
  91243,
  68416,
  268253,
  41199,
  116757,
  138551,
  185526,
  41246,
  28986,
  4093,
  19057,
  17295,
  4148,
  245766,
  122360,
  35356,
  112075,
  20301,
  75441,
  10998,
  7977,
  19769,
  62922,
  937,
  63547,
  100196,
  26427,
  157820,
  20983,
  236696,
  22935,
  8140,
  90315,
  156004,
  47204,
  140973,
  7726,
  45097,
  52725,
  22636,
  23436,
  257282,
  105247,
  522,
  88389,
  216031,
  202204,
  46812,
  211666,
  19693,
  68828,
  81691,
  45925,
  11256,
  30292,
  372,
  5236,
  167826,
  88328,
  232776,
  151611,
  5360,
  82104,
  18841,
  80393,
  25465,
  18285,
  20320,
  72377,
  31730,
  33160,
  45803,
  38715,
  27705,
  37379,
  24163,
  18360,
  103586,
  4015,
  32305,
  269494,
  91252,
  20080,
  36567,
  54650,
  7797,
  57073,
  12650,
  31164,
  42209,
  6375,
  261663,
  105528,
  81661,
  106002,
  2800,
  5375,
  17247,
  43151,
  4442,
  15727,
  194619,
  100855,
  144898,
  62320,
  78465,
  39929,
  16454,
  1967,
  28311,
  61363,
  17219,
  9395,
  8745,
  121445,
  76939,
  80385,
  162380,
  22009,
  54191,
  44248,
  16299,
  122830,
  48151,
  74429,
  78291,
  64755,
  14238,
  44966,
  2511,
  17712,
  67954,
  93583,
  829,
  105899,
  49935,
  84750,
  11591,
  33185,
  85447,
  42717,
  27409,
  208542,
  28965,
  62052,
  52525,
  5597,
  25694,
  65594,
  16343,
  63224,
  276188,
  12475,
  9331,
  127507,
  38522,
  57287,
  24128,
  133161,
  79723,
  105548,
  133695,
  48917,
  27558,
  43278,
  46520,
  13778,
  141954,
  110785,
  83366,
  17715,
  46317,
  105763,
  66298,
  147013,
  41086,
  94180,
  16478,
  220447,
  44611,
  730,
  19722,
  78975,
  117889,
  125643,
  26254,
  16574,
  18480,
  65006,
  15806,
  38549,
  246418,
  46052,
  36056,
  8440,
  34984,
  30170,
  3163,
  59800,
  4458,
  115442,
  4283,
  41970,
  33507,
  104078,
  1653,
  22,
  121158,
  276486,
  3655,
  6338,
  24048,
  133421,
  23641,
  2161,
  24422,
  36006,
  8086,
  10675,
  181474,
  12307,
  29514,
  59143,
  14729,
  52509,
  87128,
  122470,
  19446,
  80852,
  33314,
  24573,
  119864,
  14237,
  9652,
  57779,
  6612,
  51851,
  15284,
  98871,
  90581,
  124466,
  156831,
  21190,
  22015,
  71380,
  161906,
  87247,
  69201,
  18392,
  17908,
  108470,
  72962,
  40719,
  14338,
  17911,
  95260,
  43339,
  20610,
  78916,
  20710,
  72451,
  11315,
  31448,
  17263,
  58853,
  178878,
  48111,
  116002,
  45497,
  80506,
  82605,
  85880,
  36300,
  121755,
  25215,
  36118,
  301929,
  88728,
  405223,
  276136,
  553,
  34704,
  212438,
  49970,
  78329,
  922,
  20711,
  25036,
  257130,
  38295,
  145369,
  18128,
  15385,
  30829,
  55656,
  48345,
  8012,
  3561,
  28004,
  122041,
  192900,
  58338,
  112508,
  41085,
  29976,
  87040,
  47117,
  23905,
  4336,
  92061,
  138880,
  97407,
  42083,
  172121,
  6256,
  25192,
  172671,
  5,
  93568,
  1420,
  12677,
  31605,
  56743,
  40620,
  6015,
  78415,
  231077,
  31298,
  80026,
  13902,
  19048,
  24924,
  170586,
  32955,
  176119,
  87859,
  36731,
  6773,
  27711,
  24658,
  26475,
  115216,
  133207,
  93250,
  95820,
  88522,
  8317,
  5714,
  124047,
  55219,
  86860,
  19677,
  23961,
  22928,
  162209,
  8904,
  225992,
  359835,
  56084,
  96201,
  29392,
  96558,
  86071,
  93643,
  55114,
  13347,
  8183,
  95129,
  82012,
  2017,
  123336,
  34219,
  115554,
  157159,
  47747,
  101684,
  41008,
  18735,
  193781,
  104151,
  226906,
  7552,
  179874,
  124113,
  31159,
  21162,
  44010,
  14771,
  51268,
  166128,
  31382,
  73124,
  77438,
  92830,
  205709,
  12113,
  1292,
  38937,
  13114,
  1334,
  2118,
  15597,
  69581,
  14449,
  21934,
  76618,
  48728,
  67038,
  14967,
  51495,
  24243,
  87736,
  147249,
  26720,
  11119,
  46063,
  43749,
  5843,
  44147,
  152629,
  133428,
  65703,
  14269,
  45604,
  57982,
  28672,
  55616,
  45957,
  8438,
  95433,
  37698,
  220862,
  132034,
  39456,
  61870,
  4161,
  26501,
  73560,
  56418,
  9845,
  4654,
  20916,
  10456,
  88920,
  119358,
  9015,
  65931,
  96507,
  48029,
  38534,
  21676,
  109081,
  43078,
  34943,
  25089,
  6131,
  28766,
  23665,
  5477,
  10255,
  16695,
  67,
  45778,
  42443,
  42770,
  29534,
  23733,
  100513,
  62617,
  42630,
  48746,
  14191,
  43753,
  50295,
  26007,
  8792,
  57243,
  43119,
  54725,
  164253,
  58250,
  112304,
  131796,
  25165,
  4651,
  3188,
  24831,
  47748,
  3705,
  19540,
  13211,
  102095,
  5593,
  18699,
  23666,
  32005,
  117571,
  33541,
  60584,
  74573,
  86311,
  99443,
  25172,
  27222,
  168938,
  7143,
  11853,
  53560,
  18834,
  19960,
  86522,
  28217,
  53266,
  117700,
  72989,
  34323,
  18721,
  66450,
  34346,
  74056,
  47217,
  202002,
  46269,
  9429,
  68582,
  75458,
  37823,
  82843,
  96652,
  32549,
  145144,
  27958,
  19820,
  158086,
  31955,
  201406,
  135379,
  31207,
  192545,
  12950,
  51704,
  9094,
  248263,
  76147,
  64028,
  110009,
  79407,
  89345,
  99284,
  223492,
  47966,
  26848,
  15359,
  201137,
  2861,
  110507,
  71231,
  72297,
  31851,
  118777,
  71039,
  151051,
  240855,
  16333,
  50766,
  14727,
  7939,
  4149,
  80908,
  418780,
  88378,
  59276,
  1327,
  7284,
  38576,
  79814,
  65820,
  42199,
  84860,
  49574,
  62596,
  12396,
  70598,
  40117,
  8648,
  7994,
  16836,
  7630,
  14047,
  359699,
  106878,
  525,
  29037,
  28064,
  13380,
  11675,
  50669,
  74216,
  103539,
  180314,
  27449,
  56299,
  172344,
  19274,
  7301,
  246099,
  32043,
  19422,
  36506,
  129317,
  6806,
  30140,
  4614,
  46639,
  66926,
  932,
  86600,
  6322,
  27847,
  233103,
  10541,
  39025,
  34887,
  3517,
  12972,
  26220,
  2031,
  66561,
  115015,
  48658,
  47596,
  12714,
  33845,
  3893,
  16165,
  35237,
  89983,
  14769,
  11962,
  147224,
  47018,
  29977,
  27979,
  5552,
  82338,
  86023,
  131368,
  1218,
  24853,
  237840,
  132193,
  15455,
  40873,
  3668,
  65351,
  53388,
  15229,
  59889,
  272245,
  47934,
  11858,
  34347,
  18038,
  90853,
  86981,
  300602,
  19343,
  114181,
  29362,
  84921,
  6095,
  106059,
  79472,
  38015,
  1206,
  48741,
  6208,
  8e4,
  21916,
  17423,
  6002,
  108083,
  24479,
  34931,
  56661,
  9511,
  26995,
  100694,
  163853,
  35997,
  81254,
  58321,
  18919,
  171890,
  86877,
  91341,
  74503,
  70477,
  53412,
  7027,
  59281,
  39892,
  131302,
  5864,
  15947,
  61301,
  67466,
  162369,
  47956,
  27874,
  35624,
  282324,
  21270,
  111847,
  102548,
  41482,
  30955,
  116737,
  28264,
  8592,
  55458,
  22301,
  75090,
  29821,
  30697,
  51709,
  3041,
  19208,
  8038,
  24634,
  30467,
  87509,
  126428,
  19389,
  18814,
  152686,
  20701,
  83474,
  45832,
  80891,
  105808,
  11378,
  153223,
  120770,
  98186,
  150633,
  49838,
  9141,
  12755,
  30962,
  5260,
  74490,
  21256,
  31678,
  65062,
  33326,
  289838,
  187831,
  20595,
  89768,
  2805,
  58535,
  10844,
  70085,
  12090,
  2451,
  138068,
  98544,
  24461,
  4511,
  6754,
  41684,
  28203,
  3383,
  65355,
  82833,
  30161,
  83924,
  234361,
  128424,
  28921,
  222594,
  33975,
  125491,
  34069,
  11508,
  67464,
  144226,
  41850,
  98703,
  34371,
  7901,
  21254,
  38398,
  65651,
  23549,
  53883,
  213340,
  123269,
  12028,
  71764,
  177701,
  28758,
  2623,
  68395,
  11549,
  15232,
  68603,
  9660,
  63116,
  36079,
  57093,
  31198,
  20475,
  48467,
  89984,
  35619,
  186847,
  107469,
  31389,
  43631,
  73867,
  41949,
  68841,
  114250,
  1605,
  30564,
  63403,
  17588,
  27680,
  99533,
  12641,
  70325,
  50428,
  73426,
  78379,
  11855,
  91651,
  72081,
  91720,
  60198,
  15743,
  12065,
  83398,
  140046,
  6761,
  46598,
  45900,
  5068,
  886,
  62448,
  148968,
  37347,
  19405,
  9680,
  15819,
  43496,
  63370,
  75667,
  163700,
  37639,
  3633,
  22774,
  34341,
  183131,
  134335,
  37200,
  23915,
  7054,
  14194,
  12970,
  26438,
  13350,
  285521,
  25594,
  8219,
  104410,
  91039,
  168804,
  138480,
  149734,
  15907,
  33818,
  61132,
  60082,
  4622,
  110187,
  56736,
  13551,
  73571,
  3945,
  73463,
  65498,
  17758,
  263266,
  17593,
  2710,
  27585,
  54469,
  38200,
  45367,
  63754,
  28881,
  3473,
  12791,
  98287,
  31895,
  65787,
  4463,
  94536,
  24951,
  36332,
  59901,
  28803,
  52130,
  86403,
  7668,
  181822,
  74831,
  18977,
  9850,
  177206,
  145485,
  109798,
  7292,
  31421,
  26280,
  77211,
  58511,
  12507,
  127004,
  11113,
  147,
  8729,
  56208,
  43066,
  79926,
  129937,
  31345,
  83947,
  39915,
  46146,
  98763,
  42566,
  1337,
  13192,
  18323,
  105163,
  80570,
  117753,
  16555,
  72883,
  11077,
  159438,
  40764,
  70933,
  83329,
  26066,
  12276,
  72059,
  21655,
  173836,
  126713,
  69454,
  153482,
  91585,
  70644,
  102558,
  110483,
  6764,
  127864,
  190133,
  3961,
  101798,
  20945,
  71138,
  82402,
  90884,
  69669,
  44753,
  923,
  16939,
  59700,
  164258,
  25969,
  27082,
  31399,
  43846,
  6306,
  246093,
  51342,
  6153,
  151581,
  202801,
  182731,
  56475,
  162188,
  89426,
  141356,
  14355,
  121815,
  27536,
  28023,
  65257,
  77523,
  106668,
  127314,
  24947,
  12790,
  38796,
  169698,
  23555,
  10725,
  44573,
  183083,
  42088,
  62716,
  43265,
  105958,
  32050,
  44067,
  50118,
  1668,
  3874,
  6243,
  318411,
  16599,
  1691,
  94999,
  52378,
  28671,
  216728,
  123258,
  2059,
  34969,
  69225,
  5913,
  136280,
  171443,
  141515,
  91662,
  22175,
  135282,
  80020,
  92270,
  1663,
  4808,
  4482,
  3495,
  34691,
  5226,
  109830,
  108512,
  17342,
  107488,
  11606,
  123190,
  100247,
  29666,
  146527,
  113014,
  15794,
  30894,
  13224,
  39585,
  243192,
  22351,
  9903,
  7836,
  47699,
  11078,
  25468,
  122291,
  48821,
  26780,
  122679,
  75521,
  81450,
  630,
  4895,
  92900,
  55074,
  74293,
  17441,
  3563,
  111657,
  103102,
  51613,
  12318,
  52370,
  36191,
  68245,
  34269,
  40445,
  41354,
  122901,
  168604,
  182500,
  62012,
  42557,
  11259,
  24428,
  115113,
  86345,
  12362,
  3909,
  78430,
  86852,
  134602,
  20459,
  47853,
  93879,
  22577,
  7659,
  3688,
  38555,
  13349,
  17381,
  56715,
  91639,
  12493,
  10895,
  92438,
  3142,
  37057,
  28928,
  2004,
  36427,
  32268,
  34222,
  209974,
  10432,
  67436,
  41989,
  173518,
  107930,
  27079,
  62729,
  30908,
  55558,
  5828,
  45031,
  14902,
  53546,
  8204,
  144263,
  60255,
  14520,
  88212,
  86582,
  109589,
  69356,
  8064,
  47449,
  8505,
  66558,
  16886,
  4844,
  52817,
  111260,
  215129,
  12941,
  91118,
  650,
  20770,
  6273,
  73089,
  40618,
  62790,
  2873,
  35002,
  14023,
  97208,
  19386,
  102646,
  36993,
  143736,
  135457,
  35385,
  113601,
  17893,
  32627,
  84439,
  100619,
  56016,
  6581,
  57264,
  172160,
  45452,
  111710,
  203627,
  70131,
  24100,
  322787,
  1996,
  35665,
  70078,
  22358,
  90922,
  83658,
  4097,
  63200,
  58499,
  14542,
  99153,
  52159,
  6615,
  12414,
  63415,
  31986,
  16823,
  1579,
  65405,
  137809,
  8841,
  16898,
  48082,
  259,
  33014,
  42375,
  12260,
  179850,
  73667,
  91389,
  98882,
  29532,
  17311,
  326251,
  41092,
  5928,
  20742,
  44964,
  48019,
  43505,
  9317,
  49265,
  6643,
  192712,
  48424,
  163487,
  19861,
  20113,
  70848,
  31928,
  105333,
  23685,
  78563,
  14638,
  54755,
  7158,
  24142,
  44018,
  20774,
  125255,
  20331,
  24280,
  10163,
  1285,
  2336,
  39851,
  4299,
  117269,
  46714,
  63816,
  87779,
  159624,
  11731,
  9971,
  990,
  137317,
  108831,
  50994,
  74554,
  162680,
  23640,
  131597,
  146962,
  170620,
  34829,
  91205,
  21184,
  1913,
  63616,
  18427,
  93136,
  156592,
  17519,
  67565,
  115882,
  138220,
  78622,
  88535,
  18115,
  2711,
  33554,
  109492,
  54298,
  971,
  24914,
  25863,
  36363,
  45715,
  27099,
  194995,
  14299,
  178181,
  111488,
  72395,
  322385,
  157719,
  130787,
  11897,
  81843,
  83999,
  11369,
  49280,
  118604,
  40922,
  61332,
  110343,
  53407,
  75639,
  40582,
  300440,
  54722,
  25637,
  13694,
  48248,
  48278,
  194521,
  56203,
  52779,
  48783,
  72627,
  10953,
  376,
  16733,
  280238,
  26351,
  230789,
  15132,
  25168,
  137270,
  3588,
  63704,
  73376,
  94031,
  74284,
  19443,
  159557,
  9697,
  39901,
  13351,
  119050,
  15406,
  146455,
  3460,
  29556,
  75195,
  37673,
  102524,
  92329,
  47289,
  98413,
  15311,
  100684,
  56345,
  7116,
  95480,
  11590,
  7200,
  167,
  23610,
  58426,
  17730,
  136656,
  27944,
  53151,
  2701,
  8824,
  103124,
  3017,
  90744,
  113588,
  53216,
  79736,
  65940,
  26931,
  498,
  29568,
  80540,
  143543,
  21292,
  1740,
  59268,
  16561,
  180816,
  42323,
  50174,
  40890,
  52866,
  10703,
  57169,
  4700,
  17191,
  4424,
  93511,
  49698,
  166650,
  26972,
  48631,
  165169,
  82879,
  69326,
  202970,
  4007,
  2376,
  231325,
  139592,
  22119,
  62851,
  37504,
  68816,
  58345,
  67398,
  186643,
  43331,
  277416,
  53749,
  15746,
  23102,
  17432,
  4793,
  151138,
  48822,
  54265,
  48203,
  198688,
  14305,
  54287,
  2291,
  18018,
  113378,
  123260,
  7180,
  97549,
  87027,
  120085,
  2920,
  76080,
  8190,
  102005,
  5641,
  64580,
  14955,
  59802,
  54028,
  58884,
  19367,
  81779,
  412567,
  85957,
  97053,
  103637,
  78871,
  29364,
  27637,
  141728,
  4767,
  30686,
  112738,
  130146,
  42745,
  12730,
  105040,
  14844,
  232,
  210944,
  36581,
  152317,
  135543,
  29744,
  3129,
  55647,
  58149,
  46319,
  27265,
  17499,
  28005,
  59948,
  7170,
  34138,
  5702,
  293047,
  110892,
  408,
  91760,
  218674,
  18469,
  46095,
  81403,
  14389,
  4610,
  35672,
  73060,
  11006,
  74848,
  104820,
  118143,
  190357,
  20043,
  105358,
  141735,
  5115,
  27093,
  45924,
  123073,
  52599,
  29433,
  9616,
  238350,
  78610,
  24851,
  58858,
  26769,
  31969,
  24613,
  18294,
  4982,
  32735,
  39639,
  143563,
  112073,
  202205,
  12567,
  4873,
  88601,
  44897,
  81503,
  101648,
  81362,
  34662,
  85277,
  17574,
  48173,
  21435,
  221188,
  40215,
  39576,
  80786,
  26544,
  64668,
  81841,
  10731,
  37733,
  247986,
  149188,
  127703,
  495,
  18382,
  54388,
  72446,
  43071,
  30974,
  198723,
  89608,
  41360,
  190,
  33045,
  8386,
  31658,
  19992,
  237838,
  119015,
  137622,
  50890,
  100913,
  6460,
  116233,
  267230,
  26621,
  104129,
  65114,
  14190,
  41542,
  14888,
  85962,
  23342,
  23041,
  26453,
  43725,
  71809,
  45186,
  4770,
  46452,
  53894,
  56616,
  221286,
  18973,
  9038,
  109299,
  55365,
  19366,
  26863,
  18808,
  60909,
  69353,
  41738,
  83463,
  12100,
  68561,
  72860,
  3980,
  13796,
  49340,
  12332,
  31311,
  27418,
  4255,
  53430,
  18976,
  45523,
  510,
  14224,
  30477,
  26581,
  4530,
  3651,
  101663,
  139840,
  22709,
  150861,
  31996,
  63923,
  120623,
  262522,
  3076,
  10528,
  2929,
  14672,
  130238,
  18087,
  9816,
  121894,
  100308,
  25085,
  55111,
  14565,
  18952,
  53293,
  2042,
  369988,
  23674,
  61789,
  133529,
  28783,
  108293,
  35477,
  47119,
  36448,
  71049,
  40015,
  33055,
  78598,
  198442,
  1833,
  159937,
  40654,
  77444,
  189245,
  113153,
  8621,
  18599,
  38553,
  35223,
  166072,
  2375,
  11659,
  21786,
  89523,
  6032,
  12116,
  63046,
  159398,
  18454,
  3678,
  32521,
  47626,
  11411,
  103527,
  38896,
  42946,
  15696,
  26370,
  10185,
  8413,
  37080,
  165583,
  4331,
  63555,
  14907,
  72220,
  50056,
  6623,
  62236,
  36565,
  49783,
  10049,
  17503,
  100581,
  55951,
  146244,
  24724,
  9626,
  17969,
  25524,
  109300,
  173965,
  99994,
  101056,
  46459,
  43647,
  53737,
  277968,
  8347,
  123521,
  74858,
  33829,
  44762,
  77574,
  877,
  81377,
  222525,
  123532,
  30602,
  43881,
  53145,
  2973,
  16284,
  81940,
  61281,
  127044,
  63620,
  9875,
  14756,
  114829,
  19032,
  9202,
  52759,
  119141,
  23928,
  120551,
  19607,
  3599,
  33401,
  76821,
  73233,
  117430,
  39968,
  36539,
  7071,
  5446,
  121735,
  194059,
  15206,
  45283,
  6706,
  15603,
  65615,
  1207,
  165723,
  92275,
  34773,
  104447,
  8396,
  32353,
  205240,
  164323,
  13600,
  60555,
  79205,
  25532,
  22907,
  33410,
  57480,
  107111,
  69630,
  32137,
  47832,
  70913,
  33161,
  20321,
  2371,
  117348,
  10714,
  86246,
  1625,
  11763,
  17900,
  268,
  78457,
  99175,
  97940,
  101092,
  86660,
  32221,
  14041,
  128504,
  125080,
  53744,
  124263,
  31017,
  13897,
  403,
  31859,
  21964,
  5633,
  111630,
  5547,
  77329,
  17961,
  18241,
  84995,
  25984,
  12983,
  67491,
  62168,
  47262,
  5241,
  297,
  51191,
  7351,
  8967,
  147212,
  82060,
  16821,
  782,
  11033,
  82431,
  62957,
  5026,
  43459,
  77963,
  203477,
  53528,
  6247,
  191852,
  87774,
  74164,
  215654,
  13467,
  1522,
  219964,
  28589,
  244104,
  16242,
  117821,
  67725,
  72570,
  156792,
  17186,
  15979,
  26990,
  44128,
  193014,
  35276,
  57125,
  16212,
  166451,
  68017,
  6905,
  77608,
  16364,
  53777,
  75921,
  76426,
  37975,
  26203,
  269296,
  64099,
  84122,
  12077,
  38533,
  830,
  4407,
  20139,
  963,
  43028,
  38902,
  42911,
  37503,
  83343,
  85045,
  16979,
  1165,
  60835,
  137387,
  58380,
  86990,
  110066,
  134540,
  56331,
  193845,
  81238,
  17922,
  163093,
  38744,
  110641,
  12502,
  56404,
  34862,
  26865,
  125964,
  12965,
  111648,
  25547,
  7771,
  27196,
  136980,
  9555,
  29551,
  107158,
  57885,
  18831,
  37705,
  35505,
  101742,
  13970,
  102109,
  62548,
  124657,
  23328,
  11124,
  89592,
  146376,
  248050,
  6241,
  22033,
  18337,
  80685,
  29898,
  11908,
  216623,
  67721,
  106162,
  146610,
  21377,
  15085,
  91552,
  42041,
  62560,
  122532,
  125336,
  102365,
  121537,
  142559,
  29693,
  223919,
  11515,
  110495,
  18776,
  22494,
  5895,
  185059,
  103592,
  229351,
  51220,
  100102,
  37027,
  257855,
  29359,
  54123,
  36066,
  106493,
  12244,
  79258,
  32002,
  432,
  56205,
  94836,
  90182,
  6726,
  14762,
  29391,
  48938,
  26864,
  38083,
  60364,
  3310,
  60192,
  14766,
  205567,
  57504,
  110760,
  22649,
  24666,
  46333,
  21517,
  3430,
  13135,
  28873,
  27052,
  158809,
  11597,
  20529,
  6695,
  23138,
  22960,
  37137,
  45574,
  6545,
  305877,
  43423,
  26153,
  24769,
  59844,
  14501,
  10430,
  134352,
  56169,
  13213,
  103432,
  49523,
  35181,
  13435,
  12408,
  129475,
  64620,
  230854,
  77390,
  51990,
  15653,
  83248,
  33466,
  44571,
  117828,
  51481,
  2187,
  10559,
  68019,
  18021,
  54895,
  48247,
  18354,
  33737,
  4554,
  108595,
  37288,
  39767,
  116707,
  9175,
  3726,
  108877,
  21616,
  83684,
  49862,
  1938,
  8543,
  276466,
  20134,
  108498,
  48770,
  102254,
  31914,
  131520,
  185291,
  100559,
  51890,
  209,
  19526,
  76471,
  50544,
  71814,
  99351,
  8172,
  198526,
  28816,
  20419,
  9109,
  98389,
  136777,
  76479,
  75596,
  30635,
  165417,
  48216,
  120220,
  25955,
  211071,
  39314,
  24308,
  32164,
  2559,
  146280,
  43403,
  9233,
  17947,
  90585,
  1786,
  86920,
  125662,
  2457,
  64741,
  32152,
  32918,
  122882,
  78538,
  44001,
  31723,
  56426,
  23375,
  103172,
  88177,
  145697,
  52506,
  49319,
  68016,
  31664,
  41488,
  18486,
  110400,
  7030,
  28241,
  986,
  109199,
  19900,
  42147,
  56864,
  65287,
  49183,
  7858,
  24e3,
  30453,
  840,
  16673,
  25907,
  68916,
  89927,
  6309,
  158335,
  36407,
  199737,
  130464,
  13137,
  59603,
  201778,
  195292,
  21015,
  42466,
  179062,
  172561,
  89492,
  11075,
  180407,
  31868,
  72493,
  20998,
  60217,
  9865,
  19530,
  39274,
  130266,
  54539,
  21623,
  12535,
  13505,
  40641,
  73375,
  4087,
  85633,
  2153,
  3117,
  70680,
  55788,
  92096,
  47509,
  98493,
  37490,
  271936,
  151475,
  3032,
  16171,
  96642,
  34106,
  78425,
  125761,
  19591,
  3366,
  19316,
  54508,
  24183,
  50786,
  194248,
  91528,
  33253,
  34622,
  108355,
  41741,
  705,
  3814,
  3883,
  108929,
  13203,
  67831,
  10142,
  59754,
  68208,
  29128,
  84820,
  56880,
  38794,
  24972,
  48571,
  40821,
  40476,
  18137,
  164254,
  24064,
  236309,
  79181,
  11282,
  395,
  39169,
  2013,
  51587,
  28551,
  9645,
  701,
  109513,
  115899,
  113566,
  12762,
  62045,
  58322,
  103726,
  41343,
  40866,
  244102,
  143816,
  2490,
  70346,
  40973,
  52618,
  15412,
  30720,
  104315,
  38917,
  42027,
  93676,
  17513,
  107418,
  20706,
  123890,
  13399,
  97727,
  24044,
  87962,
  65606,
  44250,
  98044,
  65276,
  74790,
  101473,
  19350,
  91570,
  1326,
  87790,
  172042,
  7577,
  100813,
  86896,
  85891,
  41512,
  108130,
  27794,
  14875,
  71431,
  12835,
  156250,
  58135,
  3759,
  22476,
  42176,
  115873,
  34686,
  56523,
  73643,
  108505,
  51491,
  20838,
  12721,
  32863,
  45700,
  29496,
  13700,
  34294,
  55360,
  29206,
  155942,
  123812,
  7706,
  163234,
  203,
  132720,
  49358,
  144431,
  8130,
  175788,
  35818,
  3270,
  76832,
  25710,
  54095,
  97274,
  28779,
  94621,
  74396,
  19092,
  128242,
  58067,
  20885,
  14670,
  93255,
  15107,
  63291,
  23654,
  126900,
  129421,
  59294,
  262659,
  9798,
  3251,
  67344,
  28600,
  44629,
  50672,
  29072,
  26999,
  31526,
  23183,
  49175,
  165843,
  175455,
  17282,
  175411,
  32022,
  45989,
  30298,
  90690,
  78118,
  83156,
  23749,
  35636,
  31317,
  7069,
  80381,
  94561,
  133756,
  14960,
  97404,
  6138,
  41065,
  78041,
  32843,
  16601,
  34123,
  9559,
  146529,
  123377,
  96395,
  54441,
  42012,
  84257,
  123541,
  10745,
  22139,
  106459,
  11720,
  150883,
  172651,
  154996,
  110538,
  4728,
  53447,
  25704,
  2009,
  71152,
  119354,
  21166,
  66604,
  1429,
  216162,
  8637,
  122250,
  63520,
  27180,
  29172,
  36124,
  276428,
  107787,
  77184,
  4680,
  14952,
  104903,
  24418,
  14793,
  51561,
  52931,
  8371,
  26342,
  48526,
  7118,
  92066,
  67280,
  40653,
  8847,
  34597,
  105438,
  14198,
  50163,
  61188,
  146286,
  50315,
  41205,
  170829,
  161496,
  585,
  197359,
  95056,
  1687,
  365794,
  91349,
  48507,
  5804,
  49263,
  5146,
  104902,
  96365,
  117343,
  132222,
  46084,
  96919,
  16875,
  8073,
  262381,
  79982,
  52663,
  13928,
  16056,
  153908,
  15145,
  109256,
  132308,
  18763,
  24904,
  167644,
  13618,
  40750,
  18686,
  147124,
  114709,
  150038,
  52849,
  2938,
  12568,
  48617,
  8778,
  5459,
  44202,
  44591,
  74914,
  17183,
  248689,
  13878,
  7822,
  80060,
  23116,
  194037,
  18487,
  2067,
  7798,
  43077,
  33678,
  244028,
  31320,
  74273,
  2794,
  19466,
  8218,
  36280,
  183997,
  48124,
  19416,
  29656,
  19280,
  98734,
  7715,
  18311,
  30701,
  133602,
  150307,
  126956,
  7378,
  2933,
  79903,
  13178,
  12593,
  86571,
  26604,
  92446,
  13574,
  44205,
  65699,
  427599,
  21118,
  8245,
  14407,
  27877,
  47936,
  33542,
  7916,
  26460,
  117762,
  21596,
  37818,
  2249,
  127359,
  209394,
  60044,
  47677,
  308089,
  36791,
  154971,
  31417,
  6998,
  150042,
  174360,
  12255,
  43009,
  29335,
  48739,
  3912,
  101398,
  53340,
  2580,
  146939,
  151295,
  45360,
  125275,
  15273,
  45383,
  27456,
  48761,
  23314,
  8750,
  60801,
  85823,
  104759,
  27894,
  123685,
  66968,
  39480,
  26917,
  55290,
  83305,
  2696,
  98390,
  57569,
  145853,
  340733,
  4919,
  20024,
  52268,
  30884,
  7413,
  203685,
  70989,
  112855,
  4129,
  50536,
  349518,
  68205,
  332641,
  159581,
  135361,
  236026,
  37563,
  176404,
  64899,
  6578,
  122033,
  63871,
  1850,
  85234,
  82089,
  66124,
  74145,
  121098,
  107351,
  12687,
  36881,
  117334,
  13136,
  14698,
  85933,
  93866,
  18047,
  32620,
  310,
  15094,
  46e3,
  88451,
  23632,
  36645,
  27940,
  87618,
  80520,
  58892,
  20976,
  27702,
  140090,
  96075,
  67841,
  103292,
  238964,
  87778,
  107338,
  17019,
  83427,
  67522,
  7302,
  8261,
  47570,
  116787,
  8730,
  80484,
  61772,
  174422,
  56005,
  131193,
  52875,
  14588,
  28471,
  59817,
  9586,
  15720,
  158155,
  51307,
  109734,
  15196,
  11025,
  59331,
  3884,
  52626,
  102602,
  84797,
  25158,
  27314,
  4437,
  20488,
  76214,
  189248,
  35023,
  114952,
  157376,
  2827,
  62439,
  102878,
  129749,
  36405,
  10329,
  109339,
  108633,
  36662,
  1254,
  13267,
  5470,
  87105,
  58004,
  15397,
  10434,
  159667,
  21864,
  52022,
  179464,
  3013,
  32147,
  31496,
  116832,
  18494,
  105502,
  129227,
  107267,
  50033,
  13481,
  9954,
  24267,
  22141,
  16257,
  116154,
  36185,
  950,
  115685,
  11305,
  176708,
  2048,
  178671,
  112573,
  287867,
  162328,
  497663,
  95170,
  50979,
  193861,
  50987,
  30368,
  136257,
  31830,
  46549,
  15119,
  169876,
  23788,
  17462,
  249887,
  57377,
  1949,
  35448,
  14791,
  43769,
  210091,
  3783,
  34612,
  282103,
  88380,
  245190,
  5457,
  20491,
  98908,
  11402,
  86899,
  117916,
  16028,
  162584,
  60644,
  320177,
  156096,
  31065,
  55876,
  22e3,
  77655,
  9992,
  23397,
  13757,
  317623,
  63978,
  215255,
  2443,
  17648,
  93231,
  27388,
  104529,
  93807,
  55505,
  140477,
  12046,
  112040,
  70887,
  40152,
  94365,
  112353,
  25063,
  114679,
  266061,
  71248,
  119555,
  15589,
  2244,
  617,
  14129,
  211431,
  70110,
  100652,
  7777,
  4383,
  85911,
  89221,
  21010,
  120615,
  58357,
  86405,
  37554,
  41647,
  18,
  15143,
  69662,
  60491,
  14714,
  186134,
  148344,
  42347,
  5410,
  168175,
  44535,
  42449,
  343894,
  129417,
  99682,
  20659,
  27272,
  140483,
  63455,
  222159,
  17536,
  13722,
  42637,
  62324,
  11976,
  114691,
  148109,
  2283,
  32057,
  182393,
  4295,
  147364,
  33705,
  2075,
  44303,
  30274,
  28331,
  63740,
  69740,
  29148,
  10346,
  44862,
  33716,
  73937,
  153333,
  12930,
  38784,
  247159,
  2515,
  41053,
  20256,
  83368,
  256189,
  54639,
  115240,
  5096,
  24661,
  175419,
  153552,
  26516,
  141,
  138176,
  63885,
  34115,
  47222,
  55709,
  2765,
  28479,
  38875,
  236608,
  12229,
  22921,
  77291,
  54426,
  45388,
  2860,
  57787,
  114579,
  295139,
  105782,
  17826,
  71066,
  19119,
  54364,
  69385,
  16568,
  12323,
  28057,
  33346,
  34919,
  124763,
  155533,
  101386,
  31644,
  8627,
  49001,
  303600,
  29868,
  63213,
  9103,
  77280,
  71333,
  9696,
  138789,
  37059,
  24823,
  5057,
  21352,
  32368,
  114208,
  56803,
  19424,
  10445,
  58514,
  8661,
  209508,
  26187,
  171838,
  10460,
  63454,
  14016,
  122504,
  41328,
  21329,
  46618,
  32493,
  38225,
  7855,
  31763,
  7945,
  29876,
  8734,
  6438,
  24205,
  97490,
  139977,
  130740,
  47323,
  33195,
  85390,
  57194,
  13813,
  60600,
  21313,
  96251,
  7699,
  27584,
  170521,
  139271,
  1363,
  4402,
  336738,
  129223,
  84983,
  69150,
  13147,
  3590,
  163929,
  207225,
  155260,
  55916,
  20288,
  4503,
  8398,
  98490,
  11773,
  27512,
  37113,
  84976,
  86558,
  28365,
  11756,
  116005,
  182148,
  13733,
  115313,
  47644,
  67208,
  85069,
  9347,
  14995,
  226141,
  14704,
  101835,
  41159,
  35314,
  13113,
  63526,
  214039,
  29978,
  50446,
  83339,
  17440,
  129441,
  72522,
  118641,
  97816,
  24907,
  73844,
  15717,
  118884,
  167255,
  96509,
  162793,
  30847,
  36849,
  51297,
  78974,
  77793,
  10427,
  1873,
  2972,
  9999,
  35074,
  28190,
  64297,
  146836,
  46298,
  60038,
  163007,
  108919,
  61219,
  2403,
  75022,
  127339,
  4233,
  110389,
  69022,
  9833,
  128097,
  88016,
  79390,
  222936,
  22570,
  94657,
  28462,
  56956,
  38803,
  81536,
  30474,
  152794,
  19566,
  16481,
  147408,
  74574,
  81895,
  20731,
  1918,
  1366,
  76367,
  187321,
  54494,
  24366,
  21690,
  61696,
  33283,
  107477,
  77499,
  31112,
  414383,
  74362,
  18463,
  218441,
  120929,
  59848,
  258629,
  201924,
  69269,
  454,
  19989,
  13054,
  59894,
  3623,
  58908,
  20681,
  35723,
  78523,
  102680,
  38988,
  184112,
  108087,
  50944,
  132704,
  52966,
  21699,
  18860,
  96349,
  201411,
  82697,
  85395,
  95658,
  5093,
  6427,
  177894,
  44191,
  32755,
  26961,
  155739,
  6249,
  31310,
  81030,
  26574,
  84311,
  120155,
  86730,
  113535,
  7424,
  48888,
  13516,
  45747,
  98098,
  20077,
  183995,
  81945,
  43210,
  26704,
  40420,
  75831,
  45648,
  11180,
  6855,
  57927,
  65528,
  124096,
  34851,
  2598,
  156633,
  107572,
  127352,
  38169,
  123845,
  60142,
  62722,
  105584,
  232364,
  23211,
  68120,
  1601,
  22169,
  89299,
  747,
  258039,
  80572,
  7258,
  152249,
  11862,
  101204,
  8834,
  121434,
  33761,
  19175,
  133142,
  46343,
  40178,
  48723,
  3589,
  41977,
  30210,
  38868,
  62257,
  10087,
  82658,
  87827,
  90646,
  16415,
  47552,
  351723,
  28298,
  72225,
  91146,
  272760,
  1701,
  11295,
  1652,
  109651,
  300747,
  51863,
  198800,
  29446,
  11794,
  32345,
  37538,
  22356,
  33102,
  37590,
  113544,
  37970,
  11478,
  179743,
  25454,
  103417,
  59905,
  221970,
  105196,
  145604,
  7817,
  164809,
  102360,
  16974,
  75840,
  255333,
  56902,
  6659,
  1954,
  645,
  59400,
  67769,
  7689,
  18675,
  5215,
  13793,
  20536,
  27852,
  3387,
  29523,
  259718,
  16860,
  94625,
  43143,
  29245,
  15848,
  233581,
  22685,
  63631,
  78557,
  22836,
  133302,
  84513,
  1348,
  51826,
  47129,
  98836,
  58284,
  1830,
  1749,
  94642,
  10933,
  6145,
  12506,
  10975,
  13879,
  103781,
  144434,
  10268,
  28409,
  32346,
  52968,
  121567,
  107374,
  77268,
  23686,
  35097,
  10501,
  155275,
  15303,
  47136,
  21102,
  168741,
  55332,
  90385,
  15996,
  84817,
  681,
  137803,
  25054,
  142275,
  6163,
  38175,
  8056,
  124296,
  240642,
  65621,
  4934,
  178205,
  16101,
  62803,
  60964,
  18230,
  100622,
  76465,
  44689,
  14545,
  9543,
  47514,
  16852,
  93380,
  28048,
  12047,
  107106,
  37575,
  101485,
  77047,
  57326,
  34819,
  96137,
  76916,
  6469,
  46264,
  115983,
  75768,
  87668,
  69942,
  13027,
  165,
  8373,
  114231,
  26434,
  52844,
  42799,
  182044,
  23580,
  146254,
  38081,
  43236,
  33883,
  146220,
  382894,
  14606,
  46035,
  36481,
  166621,
  35417,
  95382,
  2957,
  59384,
  60428,
  36358,
  66343,
  75378,
  22267,
  22950,
  83528,
  17577,
  56474,
  25285,
  4619,
  179691,
  75355,
  95836,
  53295,
  34588,
  171410,
  4487,
  14679,
  84208,
  44015,
  18562,
  109133,
  54101,
  11531,
  86052,
  174479,
  303157,
  28095,
  9953,
  35642,
  14564,
  39802,
  16145,
  77606,
  117406,
  53038,
  121117,
  53624,
  22062,
  1212,
  7632,
  127157,
  237292,
  189087,
  10478,
  127345,
  102515,
  181997,
  86752,
  87623,
  10966,
  121602,
  68783,
  68681,
  83042,
  114380,
  138349,
  191305,
  67176,
  50085,
  39016,
  1427,
  42384,
  1412,
  67118,
  122616,
  72389,
  25260,
  2237,
  13576,
  137346,
  19938,
  20304,
  2191,
  68759,
  5373,
  61364,
  238507,
  75814,
  23931,
  69565,
  38993,
  131741,
  38364,
  12528,
  87762,
  5679,
  129853,
  5310,
  186831,
  32653,
  90338,
  260176,
  389531,
  108118,
  26843,
  43985,
  50175,
  30563,
  25106,
  56965,
  18130,
  140428,
  4542,
  165503,
  117991,
  24219,
  229605,
  1819,
  129663,
  1240,
  3797,
  76093,
  18398,
  71339,
  51919,
  93043,
  27175,
  47060,
  216257,
  6483,
  35051,
  1217,
  16512,
  80798,
  129064,
  13225,
  69339,
  8548,
  237079,
  72298,
  2575,
  34280,
  51379,
  117910,
  55671,
  53345,
  247552,
  29486,
  39328,
  140821,
  34681,
  57045,
  60177,
  5004,
  90269,
  78522,
  2479,
  322607,
  48474,
  61296,
  13057,
  31558,
  4678,
  59271,
  6699,
  27044,
  31988,
  35944,
  12503,
  83480,
  4389,
  136508,
  3781,
  114121,
  70279,
  4488,
  155829,
  42214,
  2898,
  68191,
  75695,
  305850,
  45041,
  74344,
  106509,
  30087,
  17429,
  93292,
  12477,
  290,
  23080,
  114802,
  35714,
  18751,
  26554,
  105424,
  17775,
  2144,
  2412,
  100610,
  65192,
  113975,
  52975,
  180272,
  135050,
  129815,
  76238,
  106483,
  21440,
  63186,
  4260,
  46189,
  9711,
  28249,
  4169,
  23429,
  23390,
  8324,
  141585,
  63809,
  67668,
  38457,
  38063,
  39226,
  59972,
  1189,
  203916,
  62368,
  14403,
  16949,
  61767,
  85801,
  1739,
  40147,
  35049,
  76757,
  33124,
  62102,
  15780,
  103593,
  103009,
  53484,
  22952,
  67973,
  114645,
  6566,
  5245,
  50462,
  7601,
  8288,
  3513,
  194571,
  80276,
  1908,
  54592,
  5124,
  58571,
  2513,
  6800,
  273997,
  193904,
  1119,
  17991,
  117245,
  2508,
  129156,
  82366,
  26278,
  71465,
  63341,
  56943,
  39662,
  106116,
  94966,
  156875,
  9736,
  2204,
  122308,
  94418,
  27134,
  1280,
  24539,
  49022,
  45314,
  3764,
  50904,
  46424,
  30699,
  28087,
  293839,
  9400,
  33646,
  40165,
  822,
  147499,
  50263,
  116179,
  29085,
  11863,
  31314,
  5578,
  17797,
  5104,
  12454,
  1604,
  15342,
  219206,
  10232,
  67800,
  94261,
  25872,
  13565,
  90339,
  78971,
  75377,
  26649,
  41184,
  47695,
  11514,
  35369,
  20767,
  14227,
  41953,
  309396,
  148270,
  147938,
  33074,
  14453,
  27499,
  109019,
  39018,
  25738,
  240196,
  158931,
  52820,
  8612,
  95853,
  21524,
  137010,
  84901,
  70869,
  70021,
  116794,
  48404,
  38771,
  6732,
  1070,
  70990,
  187297,
  49140,
  5238,
  576,
  3564,
  253975,
  16027,
  16483,
  2811,
  37775,
  19034,
  25259,
  4053,
  2e3,
  70083,
  95774,
  19713,
  33431,
  92703,
  91314,
  42381,
  288770,
  48194,
  95985,
  3991,
  77418,
  13406,
  241328,
  245086,
  56533,
  35275,
  62725,
  9246,
  51924,
  70181,
  95331,
  16163,
  31410,
  79016,
  39312,
  120878,
  119371,
  275987,
  80124,
  27712,
  9186,
  220,
  23598,
  146167,
  85209,
  68238,
  282190,
  57048,
  31273,
  30555,
  80913,
  17594,
  75779,
  59160,
  135002,
  101219,
  189377,
  29225,
  96735,
  60126,
  62522,
  104e3,
  27620,
  86814,
  17240,
  147533,
  11001,
  5425,
  43682,
  410,
  49460,
  87270,
  69480,
  46315,
  59448,
  1816,
  76201,
  9431,
  11788,
  87960,
  29063,
  65539,
  47347,
  11678,
  33846,
  7008,
  196704,
  9895,
  6753,
  8633,
  120892,
  59970,
  572824,
  115934,
  6646,
  202559,
  892,
  48351,
  37611,
  251282,
  57823,
  67263,
  57750,
  26527,
  34485,
  90747,
  7685,
  88370,
  6144,
  64182,
  1709,
  41969,
  21458,
  62327,
  181657,
  49247,
  225330,
  122600,
  114574,
  107124,
  85361,
  111833,
  63243,
  71420,
  15655,
  191178,
  72430,
  18063,
  51425,
  54002,
  12364,
  53225,
  86557,
  18193,
  97580,
  41232,
  138398,
  67821,
  128724,
  8944,
  233212,
  101353,
  52099,
  42127,
  14006,
  120107,
  32789,
  32132,
  3498,
  18123,
  33758,
  56058,
  5779,
  128760,
  59888,
  98869,
  18445,
  84702,
  51911,
  13234,
  218379,
  20093,
  39031,
  8074,
  70195,
  20708,
  23462,
  24355,
  131384,
  60189,
  26390,
  10403,
  41060,
  7140,
  10781,
  49410,
  42261,
  87202,
  82566,
  41663,
  43105,
  60276,
  2768,
  5733,
  74176,
  28329,
  2297,
  145430,
  131632,
  83615,
  122915,
  105441,
  655,
  224102,
  5284,
  136426,
  67763,
  16294,
  188511,
  32538,
  61049,
  27893,
  3394,
  13951,
  159099,
  28542,
  17930,
  145360,
  9492,
  190122,
  32285,
  78855,
  26440,
  13570,
  58648,
  73908,
  4239,
  124561,
  2444,
  74172,
  53131,
  11468,
  10794,
  73566,
  11623,
  35343,
  64710,
  30481,
  4163,
  10328,
  38309,
  29901,
  10538,
  154377,
  76132,
  92405,
  24839,
  11679,
  3465,
  13449,
  11637,
  7824,
  2337,
  57754,
  1260,
  14458,
  41118,
  19878,
  38661,
  13416,
  159180,
  37074,
  163164,
  54137,
  28627,
  52134,
  184900,
  8520,
  40385,
  29546,
  30502,
  22386,
  66527,
  107458,
  6850,
  24022,
  47983,
  30603,
  35083,
  8934,
  304066,
  39500,
  9,
  28261,
  33026,
  77251,
  9374,
  44833,
  116312,
  34990,
  29236,
  63563,
  125639,
  135405,
  165398,
  159055,
  55690,
  88141,
  69643,
  236964,
  31983,
  25572,
  20436,
  36746,
  60896,
  31850,
  16179,
  11828,
  5888,
  3043,
  66368,
  9750,
  31167,
  7915,
  53111,
  36430,
  1333,
  64344,
  93659,
  20061,
  60596,
  180191,
  51630,
  6792,
  30244,
  43509,
  101058,
  22409,
  420,
  44210,
  109783,
  43223,
  27030,
  72477,
  72831,
  32679,
  29235,
  7675,
  47556,
  12258,
  39907,
  149412,
  84926,
  118247,
  24692,
  71717,
  105038,
  86009,
  45941,
  41189,
  89453,
  29856,
  52543,
  30627,
  226798,
  67303,
  59230,
  67415,
  34408,
  1367,
  99685,
  16867,
  128419,
  52147,
  4111,
  125381,
  117881,
  16173,
  44093,
  102224,
  31575,
  23234,
  24870,
  83790,
  127407,
  239098,
  3200,
  994,
  1255,
  100903,
  242275,
  117266,
  55116,
  38205,
  16140,
  29662,
  11307,
  40414,
  208793,
  123355,
  56470,
  4862,
  75600,
  30119,
  58218,
  70828,
  24075,
  26974,
  7802,
  192353,
  4851,
  5475,
  78720,
  66596,
  3409,
  28573,
  64396,
  30381,
  30690,
  59859,
  88256,
  5406,
  99945,
  103064,
  34463,
  37727,
  24238,
  86643,
  60088,
  4057,
  23741,
  5967,
  162904,
  38240,
  28356,
  93858,
  25510,
  122879,
  6897,
  3278,
  7057,
  11971,
  4400,
  35461,
  211413,
  21395,
  59615,
  39471,
  87233,
  55795,
  128426,
  3051,
  22470,
  41950,
  14705,
  3974,
  180108,
  80476,
  78442,
  204996,
  91987,
  15634,
  67610,
  139015,
  142373,
  35611,
  51134,
  10387,
  4353,
  153456,
  57749,
  181039,
  14183,
  68447,
  151532,
  21107,
  36452,
  20551,
  3186,
  46247,
  46383,
  129666,
  88736,
  140662,
  146243,
  2066,
  8360,
  7978,
  64818,
  106963,
  17896,
  47801,
  10723,
  114821,
  223295,
  74192,
  3293,
  3393,
  16987,
  74064,
  11277,
  91622,
  4270,
  29828,
  27951,
  387869,
  103235,
  1374,
  61988,
  120083,
  477,
  145892,
  128378,
  11779,
  211263,
  61354,
  18221,
  17869,
  46530,
  83061,
  108538,
  157981,
  90608,
  67199,
  95080,
  49064,
  195814,
  12302,
  66307,
  10348,
  231346,
  160732,
  112859,
  63633,
  146558,
  21271,
  31037,
  198802,
  47622,
  12862,
  95710,
  3910,
  77850,
  73961,
  85585,
  34752,
  61e3,
  4082,
  24595,
  103679,
  71107,
  8208,
  79568,
  150019,
  16615,
  24961,
  139857,
  32664,
  197366,
  4559,
  54735,
  32696,
  4126,
  162019,
  75698,
  13916,
  70108,
  159638,
  19834,
  9349,
  24675,
  175560,
  49643,
  18206,
  52459,
  27992,
  10809,
  88865,
  401975,
  133172,
  29e3,
  34558,
  30915,
  3658,
  25834,
  42430,
  36562,
  125265,
  18182,
  10155,
  40149,
  97082,
  208980,
  19575,
  60853,
  90529,
  66545,
  9600,
  789,
  46420,
  2317,
  88593,
  55595,
  98980,
  115302,
  5742,
  169155,
  1073,
  177901,
  3472,
  11189,
  63711,
  78643,
  65472,
  50459,
  127979,
  93,
  42202,
  67053,
  21720,
  157650,
  11145,
  141378,
  42033,
  22824,
  85705,
  79114,
  35584,
  15974,
  1510,
  54172,
  28562,
  12451,
  104226,
  19190,
  97151,
  73024,
  20948,
  5151,
  81741,
  21499,
  29006,
  84183,
  198074,
  54003,
  45120,
  170125,
  26240,
  35177,
  28389,
  64863,
  79974,
  60778,
  176915,
  232183,
  45342,
  2038,
  80253,
  41564,
  40703,
  32689,
  5430,
  100689,
  5366,
  23007,
  134279,
  14266,
  26712,
  73993,
  24934,
  64242,
  52113,
  102887,
  61801,
  46415,
  201049,
  54251,
  62133,
  122757,
  164883,
  30815,
  139966,
  2319,
  30842,
  766,
  13362,
  10287,
  134518,
  86111,
  81665,
  82440,
  28333,
  43019,
  18963,
  8804,
  161944,
  23439,
  102144,
  101145,
  80029,
  39052,
  248708,
  30350,
  117340,
  11878,
  128467,
  974,
  138625,
  63961,
  5237,
  74778,
  61834,
  67040,
  43814,
  13690,
  65947,
  33809,
  232476,
  115258,
  181745,
  28824,
  94013,
  9510,
  10246,
  93722,
  81976,
  7217,
  114383,
  3493,
  16014,
  69045,
  72692,
  12145,
  80981,
  9507,
  6692,
  1620,
  60820,
  330444,
  35474,
  33962,
  4797,
  7053,
  295463,
  46445,
  27026,
  12491,
  77988,
  49524,
  35675,
  90947,
  29114,
  166705,
  101385,
  133782,
  32704,
  6186,
  84595,
  176031,
  185623,
  45966,
  151302,
  63069,
  1699,
  107491,
  947,
  15458,
  74452,
  196212,
  6046,
  10498,
  12163,
  10239,
  35191,
  243951,
  9277,
  9090,
  29539,
  54460,
  22820,
  26514,
  112549,
  60372,
  51753,
  48756,
  21812,
  70861,
  260326,
  41,
  44222,
  10441,
  16961,
  48148,
  138771,
  216194,
  5914,
  52153,
  53400,
  212036,
  56519,
  26245,
  10117,
  45888,
  15294,
  138019,
  90913,
  26368,
  43842,
  42111,
  23348,
  6082,
  194845,
  161089,
  156206,
  51546,
  11647,
  30759,
  302912,
  262094,
  8635,
  78876,
  26535,
  35283,
  54183,
  31183,
  85484,
  147873,
  12989,
  5197,
  6356,
  72894,
  65347,
  20150,
  27370,
  73787,
  1493,
  45918,
  12366,
  190217,
  20724,
  13858,
  10981,
  67449,
  81213,
  7553,
  14115,
  72242,
  271517,
  11842,
  48310,
  88743,
  143726,
  22177,
  3290,
  243231,
  58452,
  62937,
  12592,
  1654,
  40066,
  33477,
  13751,
  9921,
  128442,
  15868,
  7106,
  75236,
  83773,
  10775,
  36938,
  10482,
  170465,
  17368,
  17469,
  161508,
  32752,
  98340,
  800,
  19824,
  264456,
  3901,
  87319,
  2867,
  26782,
  9630,
  113102,
  185815,
  24197,
  44584,
  86366,
  40224,
  3636,
  140916,
  31731,
  267731,
  9567,
  53678,
  72984,
  29389,
  27963,
  17106,
  50282,
  284911,
  60170,
  8322,
  12608,
  23374,
  89652,
  5268,
  39044,
  229766,
  8869,
  151350,
  31436,
  177342,
  12269,
  183212,
  120418,
  116270,
  2843,
  78888,
  69192,
  7865,
  184099,
  1086,
  129897,
  18383,
  70508,
  20242,
  18508,
  229924,
  124569,
  35749,
  50589,
  55626,
  9884,
  83115,
  40971,
  30671,
  18135,
  14452,
  38861,
  17844,
  201826,
  5549,
  26413,
  17189,
  13561,
  38539,
  10679,
  143331,
  3314,
  36785,
  171194,
  49685,
  187713,
  67506,
  4618,
  104039,
  17060,
  195080,
  50648,
  33159,
  19238,
  67559,
  134840,
  28599,
  157523,
  17130,
  38064,
  117398,
  94355,
  31918,
  13575,
  34538,
  40326,
  13997,
  3494,
  348283,
  62481,
  26862,
  3603,
  104426,
  244363,
  153709,
  112487,
  304612,
  199674,
  41239,
  35545,
  54869,
  293005,
  28223,
  26277,
  26899,
  4533,
  18518,
  15492,
  38587,
  80488,
  70485,
  160395,
  263,
  60162,
  11382,
  222152,
  4696,
  250751,
  51921,
  182609,
  10707,
  48463,
  46243,
  1227,
  49111,
  111564,
  46502,
  33342,
  56846,
  68541,
  63559,
  858,
  139927,
  16654,
  229375,
  76759,
  26478,
  33205,
  95828,
  23399,
  92945,
  2637,
  35630,
  28470,
  143992,
  50214,
  14174,
  21456,
  166191,
  65665,
  1711,
  21594,
  78019,
  97599,
  111701,
  36,
  147151,
  110246,
  189022,
  43021,
  30397,
  40757,
  131935,
  42065,
  73335,
  48039,
  26596,
  28984,
  15102,
  2361,
  7421,
  202167,
  69744,
  43766,
  52826,
  3642,
  83304,
  33873,
  75140,
  63169,
  192389,
  36551,
  92748,
  13039,
  123959,
  233220,
  21738,
  84447,
  77230,
  20228,
  187852,
  19095,
  25799,
  92136,
  108774,
  29237,
  53947,
  2299,
  118106,
  2687,
  8830,
  42331,
  202924,
  33667,
  2023,
  73763,
  30704,
  19363,
  19779,
  16737,
  35629,
  48081,
  24068,
  101013,
  162338,
  291912,
  13749,
  24745,
  328289,
  167679,
  70086,
  48299,
  23306,
  16732,
  17801,
  43322,
  54589,
  3586,
  63653,
  43624,
  53474,
  925,
  109177,
  251316,
  43805,
  13082,
  19511,
  86565,
  142182,
  92461,
  17117,
  101033,
  103319,
  64589,
  4022,
  4351,
  235897,
  5352,
  82705,
  107142,
  46391,
  156084,
  5860,
  61365,
  10558,
  13045,
  7717,
  18357,
  33922,
  12590,
  33065,
  6928,
  46993,
  783,
  46937,
  67846,
  8952,
  26295,
  6107,
  119656,
  18799,
  17458,
  50747,
  4229,
  179559,
  112727,
  118080,
  20683,
  41464,
  125468,
  51560,
  49749,
  44231,
  7359,
  35339,
  62988,
  136487,
  67015,
  5208,
  29150,
  24956,
  105186,
  48858,
  6143,
  18097,
  6972,
  16404,
  73489,
  58742,
  97196,
  36357,
  164616,
  5834,
  32267,
  13746,
  147733,
  15113,
  132091,
  34127,
  106298,
  39729,
  106426,
  22294,
  9780,
  15602,
  36213,
  71502,
  42808,
  66802,
  599,
  60755,
  5851,
  39120,
  67363,
  108623,
  126368,
  72770,
  91263,
  32486,
  30596,
  151717,
  7951,
  52002,
  43103,
  11768,
  68942,
  40901,
  39344,
  24037,
  127500,
  116890,
  48403,
  16926,
  86750,
  17745,
  48648,
  159545,
  34460,
  58419,
  5634,
  114317,
  67865,
  31462,
  23352,
  24010,
  98185,
  125708,
  69686,
  68337,
  13610,
  26271,
  70691,
  2980,
  4768,
  27225,
  102402,
  75453,
  28106,
  8104,
  6931,
  1176,
  6274,
  6475,
  112635,
  22498,
  6176,
  238686,
  26832,
  28893,
  90319,
  14441,
  15682,
  15087,
  39517,
  45270,
  109134,
  104440,
  45965,
  47645,
  81772,
  7876,
  52683,
  87720,
  12898,
  4505,
  185665,
  2769,
  113401,
  15664,
  57592,
  105229,
  137381,
  97059,
  119268,
  6876,
  43309,
  33886,
  128363,
  35476,
  144249,
  67013,
  143587,
  83367,
  25703,
  91436,
  59347,
  53236,
  2289,
  16519,
  19844,
  46309,
  58558,
  99834,
  23313,
  218816,
  231303,
  36388,
  51333,
  183535,
  109792,
  139277,
  54306,
  90139,
  18235,
  8275,
  32710,
  37677,
  82464,
  86025,
  92204,
  88842,
  117723,
  37570,
  128723,
  234242,
  76350,
  73795,
  34896,
  148247,
  58424,
  11105,
  11744,
  45746,
  63372,
  17118,
  49772,
  199520,
  81902,
  38004,
  22911,
  33752,
  3125,
  1995,
  53792,
  4689,
  26909,
  108150,
  146062,
  69674,
  41811,
  161444,
  84855,
  8999,
  28561,
  16731,
  93937,
  3189,
  21967,
  24890,
  22943,
  1356,
  145300,
  51569,
  28802,
  517,
  118679,
  31703,
  40607,
  48098,
  108854,
  25003,
  10233,
  73969,
  177495,
  5248,
  24516,
  215347,
  146192,
  48712,
  60626,
  69188,
  40735,
  5866,
  586,
  101541,
  6509,
  47590,
  52129,
  5969,
  222045,
  110933,
  25733,
  24223,
  65339,
  62812,
  2414,
  155418,
  35819,
  16022,
  78423,
  43138,
  20995,
  128255,
  240673,
  46745,
  236093,
  72176,
  57085,
  97841,
  61248,
  107,
  36068,
  193177,
  105427,
  55726,
  215229,
  20446,
  47228,
  100420,
  87091,
  14429,
  121708,
  23605,
  21157,
  187721,
  21880,
  2997,
  203976,
  99166,
  95068,
  25877,
  7724,
  98925,
  83401,
  4829,
  13182,
  18229,
  13718,
  239662,
  38653,
  116505,
  153497,
  30589,
  89029,
  38962,
  181302,
  43853,
  78872,
  180301,
  4786,
  248240,
  7401,
  106136,
  112590,
  77745,
  19731,
  60880,
  77789,
  125748,
  135487,
  5975,
  48627,
  34084,
  12419,
  215770,
  47557,
  254582,
  10364,
  106495,
  21856,
  67539,
  88981,
  38805,
  21428,
  48732,
  42316,
  12149,
  16078,
  52808,
  25327,
  51322,
  33850,
  51147,
  12253,
  122354,
  46077,
  56483,
  254553,
  115417,
  81834,
  150991,
  94662,
  86668,
  7381,
  12841,
  100650,
  18218,
  15741,
  22372,
  68294,
  50705,
  15535,
  84660,
  61887,
  22553,
  72299,
  31361,
  24824,
  17743,
  46820,
  64288,
  31582,
  77006,
  111674,
  116384,
  30760,
  80920,
  86149,
  77192,
  51979,
  79691,
  60342,
  122805,
  103800,
  240873,
  160744,
  233114,
  78962,
  54920,
  8608,
  3484,
  316104,
  72548,
  24337,
  5088,
  230040,
  21926,
  10172,
  36838,
  26,
  86221,
  83458,
  102176,
  12062,
  17571,
  41929,
  41170,
  28428,
  68239,
  41750,
  103930,
  2634,
  18313,
  53019,
  34825,
  97837,
  63115,
  24606,
  73157,
  152474,
  14715,
  91439,
  37033,
  109806,
  140259,
  30668,
  174760,
  380,
  135597,
  95673,
  136073,
  65073,
  134249,
  13829,
  17279,
  122305,
  4420,
  46444,
  10237,
  64848,
  203623,
  70728,
  10349,
  182885,
  65075,
  24519,
  25783,
  40318,
  34139,
  22222,
  63394,
  55266,
  102764,
  41422,
  20126,
  65100,
  90408,
  53640,
  35128,
  48932,
  11192,
  38935,
  96839,
  34782,
  39492,
  19396,
  41332,
  6250,
  5511,
  19492,
  51304,
  25936,
  104466,
  54099,
  73771,
  86115,
  5080,
  7669,
  30891,
  111700,
  13931,
  25276,
  72289,
  135447,
  14820,
  258641,
  25265,
  31005,
  281179,
  75286,
  393,
  95359,
  14623,
  13584,
  6680,
  101227,
  80173,
  44933,
  76666,
  54542,
  13244,
  39348,
  458,
  25379,
  109451,
  134348,
  81143,
  6959,
  65554,
  12027,
  51311,
  8716,
  57589,
  140731,
  28467,
  23316,
  17272,
  30458,
  25980,
  55229,
  77197,
  83798,
  28302,
  114784,
  7428,
  34548,
  26241,
  14712,
  39336,
  103304,
  18928,
  54080,
  12870,
  334,
  87722,
  15208,
  16895,
  142098,
  114262,
  39820,
  83913,
  57817,
  28682,
  7721,
  14900,
  108672,
  11250,
  62246,
  42849,
  415188,
  1724,
  26555,
  24549,
  25505,
  26443,
  107450,
  145899,
  61035,
  43528,
  6901,
  60726,
  65906,
  267741,
  21338,
  147590,
  42079,
  18924,
  73017,
  135236,
  15393,
  5206,
  4026,
  84185,
  1531,
  5988,
  113890,
  82647,
  303391,
  7386,
  69844,
  71611,
  189865,
  76523,
  31877,
  13315,
  19314,
  198575,
  32821,
  1928,
  67641,
  25913,
  104475,
  103489,
  3297,
  70391,
  18406,
  15446,
  113347,
  19295,
  93790,
  27856,
  1792,
  167471,
  116449,
  8541,
  4408,
  41757,
  63233,
  25765,
  86680,
  64501,
  27034,
  24816,
  34975,
  6079,
  4486,
  49693,
  36229,
  16917,
  21581,
  62426,
  27862,
  11612,
  54284,
  35702,
  194034,
  355,
  24277,
  48262,
  87411,
  70504,
  310164,
  118018,
  12516,
  47559,
  43502,
  57433,
  107139,
  9290,
  66533,
  80863,
  14634,
  34312,
  91725,
  28606,
  21342,
  67241,
  72355,
  43244,
  375789,
  37402,
  174015,
  105070,
  8342,
  44167,
  67494,
  1890,
  16365,
  11723,
  271002,
  1865,
  47918,
  8350,
  45564,
  27742,
  25110,
  125803,
  8553,
  49504,
  81925,
  62211,
  4534,
  15491,
  19011,
  80373,
  206920,
  667,
  102405,
  128623,
  245524,
  5553,
  113309,
  192739,
  65766,
  19567,
  22832,
  261958,
  29679,
  21293,
  71134,
  20962,
  105123,
  24721,
  860,
  21752,
  33448,
  18372,
  157167,
  94822,
  35770,
  173224,
  232737,
  75729,
  28937,
  46828,
  28062,
  25453,
  5207,
  140366,
  36665,
  30652,
  6169,
  67920,
  150458,
  92040,
  23186,
  184604,
  92330,
  20891,
  176492,
  49427,
  27828,
  38305,
  42495,
  143982,
  49560,
  25503,
  90043,
  29747,
  65328,
  47830,
  12932,
  11068,
  77721,
  9003,
  25213,
  94205,
  140426,
  46090,
  89945,
  138173,
  192691,
  33329,
  112232,
  129905,
  35709,
  27514,
  1841,
  19957,
  31411,
  127476,
  53572,
  17497,
  173549,
  55063,
  175135,
  19841,
  69314,
  5192,
  237921,
  117660,
  150697,
  4060,
  273045,
  50414,
  98940,
  65348,
  153665,
  164423,
  58804,
  156695,
  48994,
  213928,
  86036,
  28608,
  8355,
  39574,
  34540,
  16927,
  135680,
  18374,
  151587,
  10830,
  53805,
  16878,
  16623,
  4282,
  48030,
  8537,
  14986,
  46102,
  13062,
  72897,
  72,
  33050,
  108227,
  39451,
  45935,
  651,
  113320,
  40535,
  95176,
  57450,
  48843,
  5003,
  19019,
  10407,
  211163,
  3848,
  1068,
  4988,
  32091,
  30095,
  41692,
  15099,
  43602,
  107434,
  50744,
  7627,
  171349,
  16313,
  150832,
  352665,
  207750,
  33937,
  38256,
  51091,
  156e3,
  87889,
  90663,
  84175,
  24908,
  114900,
  50365,
  31494,
  83829,
  5398,
  169342,
  47521,
  54818,
  18935,
  8356,
  43094,
  41212,
  174536,
  10082,
  92550,
  6678,
  60614,
  23355,
  69721,
  14796,
  34149,
  128830,
  58187,
  3179,
  208,
  40325,
  28399,
  225029,
  401412,
  51150,
  31580,
  207268,
  6657,
  10993,
  69818,
  64282,
  289845,
  23308,
  12961,
  38447,
  6681,
  52944,
  31855,
  2572,
  47646,
  120728,
  179148,
  37240,
  45196,
  218274,
  4816,
  3695,
  21961,
  50084,
  35209,
  18073,
  51452,
  27004,
  6100,
  33941,
  1377,
  84831,
  171214,
  85,
  141510,
  9078,
  99227,
  32610,
  6417,
  11718,
  49868,
  65579,
  87902,
  73018,
  49062,
  46280,
  61742,
  21512,
  40862,
  107733,
  15941,
  29168,
  157765,
  144919,
  14487,
  5767,
  158014,
  140070,
  7241,
  573,
  71584,
  16921,
  223566,
  40331,
  179473,
  35081,
  47926,
  140885,
  41508,
  52104,
  59180,
  42310,
  32811,
  29048,
  123517,
  102413,
  80208,
  10104,
  14746,
  12649,
  153641,
  126022,
  37965,
  113017,
  4171,
  83,
  142592,
  2809,
  6362,
  50416,
  71323,
  116894,
  260776,
  16204,
  1524,
  5760,
  30351,
  12658,
  20703,
  54403,
  36083,
  45408,
  74772,
  4946,
  14485,
  50759,
  111222,
  10890,
  2195,
  167147,
  92962,
  130534,
  16283,
  177256,
  35016,
  15472,
  210156,
  151187,
  73922,
  117691,
  43250,
  52051,
  37392,
  24811,
  24358,
  30830,
  5775,
  818,
  21969,
  1476,
  127322,
  151783,
  58392,
  31021,
  106913,
  65215,
  89407,
  90802,
  28531,
  11690,
  20234,
  95249,
  44602,
  37256,
  18707,
  11928,
  5161,
  4410,
  26571,
  51903,
  49768,
  22008,
  25252,
  65780,
  209499,
  68769,
  203726,
  13249,
  137363,
  48845,
  86823,
  6658,
  5674,
  31881,
  1083,
  1823,
  108676,
  34518,
  166752,
  13791,
  14287,
  91576,
  91429,
  8665,
  11529,
  26401,
  16191,
  91972,
  30964,
  5254,
  28486,
  54697,
  79613,
  66520,
  18447,
  22870,
  45203,
  194466,
  22822,
  51703,
  12278,
  76716,
  44595,
  73455,
  33546,
  12235,
  144843,
  36154,
  51247,
  11116,
  33040,
  3180,
  225753,
  60864,
  1972,
  28469,
  12891,
  28879,
  10338,
  144157,
  56294,
  353058,
  38302,
  41447,
  87532,
  110616,
  27065,
  168438,
  6557,
  1213,
  50804,
  144643,
  24817,
  2390,
  136531,
  38174,
  247513,
  16190,
  4059,
  122791,
  131994,
  137430,
  39506,
  57650,
  16305,
  5188,
  54309,
  106128,
  20628,
  88071,
  67394,
  395446,
  250285,
  66176,
  91254,
  1399,
  114196,
  43915,
  60230,
  44853,
  27206,
  106353,
  43013,
  18733,
  345105,
  226453,
  51202,
  16607,
  57106,
  117175,
  35492,
  10476,
  89598,
  127439,
  15187,
  39624,
  13688,
  61570,
  10615,
  31111,
  59370,
  6238,
  175252,
  32143,
  224492,
  41388,
  95408,
  34384,
  148238,
  78307,
  38959,
  9340,
  160091,
  61443,
  15737,
  11216,
  41244,
  170,
  38299,
  102443,
  113097,
  26382,
  14027,
  33707,
  3957,
  76300,
  66160,
  19431,
  18900,
  6952,
  1717,
  108656,
  82206,
  188021,
  257335,
  27295,
  43999,
  41210,
  31777,
  46956,
  57457,
  12657,
  11489,
  15697,
  48060,
  204748,
  53583,
  82422,
  284790,
  30503,
  137341,
  8120,
  19615,
  220311,
  15991,
  10217,
  63424,
  9808,
  67431,
  70976,
  98221,
  4491,
  15177,
  28535,
  144789,
  751,
  13230,
  2394,
  1504,
  33977,
  132104,
  30316,
  22230,
  931,
  97193,
  185240,
  24826,
  22687,
  174322,
  15307,
  22988,
  1390,
  188745,
  180325,
  29580,
  59068,
  74903,
  18994,
  29195,
  79,
  15436,
  7622,
  38462,
  11566,
  138710,
  44828,
  45774,
  37768,
  99236,
  68137,
  84083,
  19282,
  22698,
  17134,
  74807,
  126662,
  173497,
  46248,
  16938,
  119735,
  3212,
  28292,
  213652,
  49013,
  9975,
  32180,
  45660,
  86250,
  4801,
  68788,
  95490,
  77482,
  113751,
  11994,
  44624,
  94452,
  46839,
  128497,
  100316,
  5798,
  58588,
  73184,
  202987,
  65417,
  37790,
  88524,
  1606,
  43156,
  97964,
  105717,
  34947,
  11203,
  100060,
  37742,
  130074,
  93653,
  107799,
  94311,
  196106,
  41347,
  8035,
  10780,
  16390,
  27883,
  118236,
  167395,
  1979,
  25006,
  19375,
  31628,
  18916,
  144723,
  78502,
  114047,
  103107,
  86492,
  107686,
  5844,
  20934,
  206963,
  23556,
  22591,
  16562,
  146333,
  20167,
  10471,
  117434,
  33085,
  2863,
  9740,
  36669,
  41849,
  37271,
  22790,
  18209,
  28979,
  8231,
  12952,
  54408,
  21731,
  25130,
  45208,
  55748,
  138120,
  75826,
  414,
  29593,
  9925,
  292865,
  25999,
  683,
  123149,
  7036,
  92159,
  86055,
  61827,
  103680,
  23176,
  54918,
  58466,
  57578,
  13305,
  5709,
  86479,
  16697,
  31064,
  17660,
  200919,
  10770,
  49793,
  33423,
  32370,
  52047,
  16488,
  62555,
  6459,
  8426,
  83493,
  7763,
  59725,
  82812,
  18628,
  67760,
  79405,
  68557,
  9612,
  7673,
  28102,
  56517,
  69620,
  171797,
  32458,
  29541,
  15870,
  81109,
  32080,
  207644,
  71495,
  21202,
  11039,
  91036,
  61230,
  2810,
  130800,
  32260,
  4613,
  60590,
  37112,
  75214,
  33979,
  126402,
  155062,
  30642,
  63875,
  12810,
  194463,
  82799,
  47664,
  16725,
  36685,
  43367,
  61099,
  449,
  172150,
  102867,
  21691,
  301838,
  36745,
  7130,
  18671,
  57316,
  34852,
  38034,
  54182,
  35578,
  65900,
  99486,
  19771,
  3456,
  2658,
  16914,
  99866,
  28390,
  28109,
  8262,
  21147,
  34353,
  20006,
  4228,
  137085,
  1675,
  203023,
  283196,
  198286,
  214375,
  163329,
  290603,
  152574,
  40471,
  83506,
  30068,
  14730,
  23177,
  131539,
  34759,
  27668,
  32178,
  71896,
  104799,
  116305,
  85430,
  119262,
  42860,
  25160,
  8911,
  23428,
  49437,
  105322,
  6519,
  16203,
  6349,
  74711,
  1230,
  38045,
  8540,
  75165,
  44736,
  25909,
  51026,
  317034,
  4984,
  32281,
  91312,
  27060,
  44431,
  17817,
  45363,
  155937,
  239085,
  35697,
  59784,
  91993,
  29531,
  126740,
  213757,
  76560,
  167776,
  285273,
  24262,
  8237,
  65030,
  41160,
  74437,
  48804,
  118916,
  13159,
  37842,
  1031,
  75349,
  1478,
  11655,
  108777,
  23435,
  277425,
  101734,
  67469,
  70231,
  124711,
  43532,
  28514,
  65526,
  54956,
  1e3,
  21882,
  17728,
  25302,
  40952,
  52214,
  149632,
  1999,
  2111,
  3259,
  63362,
  89961,
  220561,
  39777,
  26335,
  9063,
  10572,
  12416,
  34551,
  34623,
  38604,
  24723,
  5947,
  15588,
  69927,
  66252,
  119177,
  69173,
  46629,
  28714,
  70715,
  212408,
  20521,
  406913,
  74380,
  11716,
  50659,
  50862,
  37009,
  88460,
  130101,
  7210,
  53853,
  538,
  65120,
  151950,
  55806,
  163748,
  52837,
  13153,
  21100,
  16674,
  64536,
  6091,
  138201,
  44837,
  58547,
  3723,
  163,
  2177,
  32288,
  85454,
  34033,
  8497,
  14282,
  25742,
  10535,
  10741,
  79559,
  117493,
  243787,
  49337,
  100718,
  79495,
  40139,
  42956,
  7551,
  55433,
  15421,
  31509,
  23034,
  45081,
  547,
  61176,
  53434,
  328001,
  8470,
  36263,
  30145,
  4519,
  74173,
  53935,
  11845,
  73774,
  60211,
  78025,
  3,
  4102,
  73782,
  109293,
  315332,
  48412,
  26683,
  13714,
  6865,
  20128,
  18490,
  104141,
  325,
  39470,
  171970,
  115860,
  15707,
  7268,
  73301,
  74336,
  31370,
  2368,
  111827,
  107757,
  136231,
  142844,
  97138,
  96638,
  84053,
  38691,
  23801,
  1588,
  10573,
  122098,
  77039,
  240,
  186135,
  146101,
  11996,
  18143,
  112963,
  46171,
  155836,
  348769,
  47795,
  121213,
  116266,
  132515,
  3344,
  144804,
  31286,
  99187,
  255838,
  129694,
  35894,
  48779,
  55235,
  148582,
  71967,
  65282,
  15174,
  13920,
  47080,
  6147,
  108242,
  157593,
  125025,
  7136,
  1286,
  28957,
  127956,
  28402,
  98813,
  20805,
  7532,
  109417,
  40610,
  5041,
  32958,
  15142,
  18408,
  108596,
  33543,
  50517,
  27748,
  80114,
  233434,
  91447,
  487,
  37094,
  100048,
  30541,
  43477,
  10639,
  89862,
  155868,
  37667,
  8726,
  60684,
  237903,
  73408,
  99589,
  12190,
  38739,
  97348,
  3914,
  13594,
  2680,
  149016,
  13907,
  30171,
  28343,
  23530,
  115225,
  61104,
  35821,
  147679,
  14337,
  4297,
  244282,
  24085,
  326976,
  56428,
  7851,
  21303,
  131620,
  71446,
  83253,
  68692,
  111870,
  5224,
  15813,
  38197,
  49026,
  45057,
  13660,
  3306,
  76345,
  40671,
  27905,
  91072,
  996,
  68527,
  62085,
  91351,
  122634,
  55109,
  168209,
  2024,
  27560,
  112707,
  17352,
  8306,
  167115,
  169921,
  166958,
  5031,
  46020,
  11844,
  67284,
  19130,
  76185,
  6920,
  32849,
  5450,
  14610,
  22451,
  21002,
  17392,
  31872,
  66682,
  84796,
  13709,
  40210,
  59898,
  12029,
  8719,
  53564,
  21462,
  91884,
  21647,
  88379,
  194428,
  12754,
  37797,
  132826,
  160016,
  22567,
  54383,
  53186,
  77611,
  31107,
  8339,
  4694,
  19185,
  90355,
  23597,
  17222,
  140675,
  28442,
  23668,
  55977,
  9128,
  61555,
  28774,
  155229,
  17658,
  9390,
  24379,
  69357,
  15752,
  127381,
  239631,
  62460,
  93181,
  55913,
  45133,
  140155,
  18676,
  25249,
  33164,
  29581,
  82837,
  67223,
  22362,
  29975,
  7317,
  52813,
  1943,
  29613,
  20012,
  207130,
  49617,
  49651,
  5636,
  15334,
  36313,
  29226,
  28084,
  95247,
  72072,
  19e3,
  224932,
  15811,
  114,
  32127,
  38097,
  37508,
  88507,
  37225,
  27359,
  91626,
  12193,
  69279,
  20608,
  11055,
  88156,
  92808,
  2152,
  57259,
  55275,
  72789,
  24475,
  104414,
  1708,
  9882,
  3818,
  48661,
  66897,
  1631,
  34806,
  227930,
  85815,
  87753,
  18321,
  250664,
  72733,
  25107,
  206797,
  50891,
  8082,
  196411,
  92596,
  96764,
  152823,
  65514,
  22819,
  387277,
  62176,
  51225,
  40329,
  15563,
  189,
  3659,
  73670,
  64357,
  51793,
  275136,
  33482,
  86653,
  74615,
  67058,
  11318,
  125720,
  15388,
  22388,
  8267,
  1730,
  102663,
  170910,
  40784,
  7144,
  85373,
  13040,
  7088,
  94309,
  583,
  44224,
  140424,
  77439,
  18496,
  164026,
  36578,
  4722,
  9151,
  5824,
  63365,
  26510,
  35199,
  40500,
  79277,
  32495,
  44614,
  35233,
  9566,
  203293,
  152144,
  7097,
  2330,
  183480,
  98629,
  13423,
  330887,
  44130,
  68600,
  30939,
  97829,
  31012,
  345465,
  56747,
  94879,
  4939,
  160027,
  149761,
  99423,
  46099,
  32251,
  15332,
  8761,
  96094,
  128555,
  5763,
  235318,
  222223,
  55729,
  30241,
  55420,
  201746,
  3987,
  81382,
  8259,
  49325,
  23287,
  7719,
  24633,
  251100,
  92311,
  18591,
  110533,
  64759,
  170260,
  393860,
  7175,
  21144,
  132887,
  3593,
  75346,
  101277,
  91109,
  16387,
  259187,
  11627,
  57459,
  173829,
  44694,
  55780,
  49797,
  89192,
  120443,
  62622,
  3904,
  14814,
  23887,
  1027,
  112258,
  64955,
  99800,
  11132,
  66353,
  36202,
  48624,
  18158,
  88481,
  96882,
  43059,
  11040,
  2455,
  7077,
  21651,
  181159,
  99126,
  100434,
  61388,
  68186,
  19161,
  110468,
  120052,
  8819,
  55324,
  41494,
  7014,
  37689,
  3618,
  87729,
  92615,
  207943,
  9823,
  128657,
  12587,
  15857,
  6379,
  67628,
  51216,
  71775,
  157617,
  63244,
  1503,
  3864,
  218754,
  110864,
  5769,
  21492,
  7243,
  1192,
  87921,
  85529,
  31512,
  18537,
  42698,
  35350,
  73510,
  84474,
  34301,
  8991,
  21013,
  35034,
  566,
  38832,
  19838,
  35586,
  37216,
  39413,
  55006,
  12178,
  59742,
  856,
  84563,
  6900,
  25632,
  17437,
  49786,
  30723,
  13847,
  70845,
  4044,
  7843,
  23944,
  235976,
  55530,
  48942,
  6518,
  20939,
  73769,
  192653,
  52936,
  95207,
  23895,
  132542,
  142982,
  22632,
  87452,
  48042,
  54018,
  178468,
  10728,
  26230,
  23559,
  363,
  81269,
  142012,
  5718,
  346258,
  31456,
  84333,
  246476,
  51018,
  66692,
  101804,
  120570,
  39962,
  30373,
  70593,
  2864,
  60541,
  19425,
  54209,
  104092,
  7201,
  31545,
  48018,
  25865,
  15442,
  46257,
  40443,
  8328,
  6451,
  111782,
  47527,
  97754,
  33046,
  470,
  245116,
  31095,
  39,
  91934,
  87208,
  73470,
  36708,
  36521,
  12801,
  70624,
  36272,
  8892,
  79768,
  12427,
  55454,
  103756,
  5908,
  52390,
  62962,
  22720,
  141138,
  94634,
  41689,
  128402,
  126390,
  6628,
  106394,
  35527,
  134394,
  82727,
  254651,
  194502,
  148064,
  89549,
  3202,
  28359,
  957,
  21954,
  27906,
  49840,
  142747,
  8307,
  24206,
  48978,
  1186,
  71728,
  133038,
  71474,
  91306,
  6333,
  110959,
  74600,
  70387,
  18983,
  62609,
  56057,
  22970,
  1147,
  135850,
  1321,
  28834,
  3578,
  59715,
  102227,
  32827,
  81415,
  99952,
  55636,
  257598,
  390,
  22702,
  35701,
  85872,
  402916,
  39216,
  189795,
  14929,
  19467,
  10112,
  144422,
  61514,
  5279,
  63421,
  134686,
  41436,
  8424,
  51925,
  10598,
  132295,
  124416,
  4604,
  194739,
  210929,
  57866,
  31829,
  51626,
  50007,
  9976,
  91878,
  61906,
  56168,
  81906,
  60918,
  61859,
  40017,
  23059,
  16887,
  40927,
  62064,
  12785,
  32893,
  32913,
  21782,
  93965,
  20169,
  44387,
  79084,
  38463,
  11457,
  93950,
  27127,
  157050,
  2697,
  337088,
  5116,
  54128,
  48255,
  33279,
  8821,
  27352,
  25515,
  124022,
  65710,
  28906,
  38557,
  33390,
  1722,
  104435,
  72215,
  38551,
  12094,
  30978,
  25113,
  6671,
  37355,
  175109,
  42862,
  98024,
  65406,
  221276,
  59624,
  118012,
  64637,
  78760,
  86697,
  21426,
  1639,
  40350,
  12584,
  67193,
  84144,
  31396,
  7863,
  143011,
  69629,
  63112,
  9454,
  28666,
  65798,
  46372,
  134721,
  6314,
  51402,
  30837,
  151922,
  2847,
  38676,
  38008,
  92823,
  136245,
  17540,
  5504,
  109295,
  205242,
  37606,
  5211,
  214892,
  1586,
  20670,
  208711,
  137743,
  19328,
  40652,
  16995,
  20023,
  14657,
  154919,
  34422,
  12996,
  13918,
  38221,
  47690,
  16398,
  2959,
  37680,
  89122,
  6721,
  198469,
  91876,
  172043,
  83898,
  101992,
  26084,
  94570,
  3635,
  76958,
  22853,
  76497,
  38266,
  176590,
  168403,
  44464,
  142840,
  79180,
  184594,
  1984,
  41806,
  83147,
  11985,
  6546,
  366068,
  59732,
  24533,
  271505,
  8736,
  39084,
  222992,
  93429,
  28962,
  58985,
  86665,
  8432,
  30028,
  14548,
  32439,
  54424,
  165029,
  55175,
  27458,
  69046,
  121277,
  46168,
  33732,
  20661,
  24581,
  135574,
  123110,
  37556,
  79260,
  72611,
  16957,
  12939,
  46162,
  58238,
  44907,
  72936,
  253758,
  41324,
  32518,
  96480,
  11949,
  124438,
  65280,
  43256,
  34107,
  53533,
  43531,
  37037,
  28366,
  45970,
  32741,
  173438,
  6121,
  194202,
  62969,
  26355,
  30314,
  58370,
  28455,
  1848,
  50519,
  82830,
  90393,
  21761,
  295490,
  10936,
  256940,
  133568,
  44050,
  20269,
  4089,
  27457,
  21610,
  219460,
  36743,
  14821,
  101388,
  52005,
  13124,
  30979,
  140816,
  167362,
  26054,
  18458,
  60789,
  34917,
  40447,
  26606,
  33422,
  9066,
  3452,
  83614,
  5761,
  20263,
  137238,
  25038,
  91310,
  101,
  52322,
  74548,
  42572,
  38084,
  214054,
  186568,
  31802,
  17665,
  30620,
  141936,
  37730,
  14420,
  4265,
  187218,
  49640,
  188208,
  51441,
  55388,
  96452,
  66659,
  40869,
  42039,
  60967,
  221027,
  19234,
  178581,
  29105,
  96050,
  9165,
  196118,
  157335,
  3738,
  40354,
  117436,
  2965,
  34136,
  59659,
  15570,
  50843,
  230035,
  31444,
  71260,
  43886,
  18316,
  5387,
  38500,
  168508,
  17406,
  32174,
  8828,
  103373,
  143806,
  90367,
  3560,
  18719,
  122310,
  16508,
  26719,
  2541,
  105429,
  6645,
  37998,
  73190,
  10591,
  235916,
  49737,
  87112,
  233941,
  53188,
  32193,
  79154,
  4544,
  52905,
  126477,
  7580,
  63501,
  57314,
  3216,
  31337,
  6541,
  103083,
  60846,
  49,
  9756,
  15481,
  1355,
  43840,
  14319,
  13743,
  27486,
  10222,
  73114,
  230718,
  418644,
  16706,
  6674,
  279748,
  23058,
  45273,
  295831,
  86306,
  2743,
  5535,
  88773,
  21829,
  35253,
  120938,
  31153,
  3169,
  16839,
  42847,
  8751,
  80974,
  33942,
  36867,
  35514,
  16485,
  26474,
  77775,
  56877,
  5391,
  48346,
  3882,
  108713,
  31403,
  27804,
  55248,
  26235,
  43821,
  136104,
  40118,
  175507,
  28034,
  203908,
  18732,
  1788,
  34030,
  106427,
  36958,
  54359,
  7251,
  44936,
  15356,
  69139,
  455,
  157915,
  22173,
  140291,
  50348,
  43275,
  82066,
  49621,
  54952,
  15216,
  36226,
  96695,
  66855,
  6936,
  1987,
  8227,
  196087,
  4631,
  68827,
  99004,
  47541,
  110265,
  17953,
  147605,
  110242,
  58520,
  31312,
  38724,
  329975,
  642,
  3155,
  34497,
  75937,
  6207,
  73843,
  6120,
  17249,
  51429,
  117746,
  3218,
  910,
  68961,
  319671,
  14938,
  29555,
  34700,
  1649,
  66673,
  72268,
  9655,
  76800,
  153087,
  6941,
  210168,
  27130,
  35398,
  1780,
  73242,
  3135,
  56689,
  19556,
  165307,
  8765,
  35967,
  121458,
  13333,
  70453,
  17350,
  117253,
  22265,
  13340,
  44265,
  39869,
  441,
  3742,
  135025,
  23581,
  33309,
  16543,
  17731,
  13291,
  157637,
  283005,
  21408,
  101360,
  63887,
  52312,
  83873,
  5338,
  233779,
  23759,
  186949,
  34531,
  177320,
  38069,
  156465,
  91004,
  19353,
  59852,
  68160,
  14891,
  1338,
  1072,
  29823,
  1950,
  28901,
  81407,
  313445,
  73038,
  84807,
  162348,
  240257,
  37162,
  138934,
  16111,
  58013,
  41253,
  102951,
  16457,
  96056,
  19541,
  56402,
  67217,
  41638,
  94381,
  89674,
  29481,
  37456,
  80815,
  151579,
  13937,
  13683,
  132537,
  19699,
  134545,
  67020,
  29816,
  222341,
  141235,
  427578,
  48868,
  129557,
  233342,
  23077,
  87871,
  16213,
  18728,
  16184,
  9469,
  37913,
  19680,
  2798,
  171356,
  178328,
  13216,
  50049,
  72690,
  71904,
  124644,
  55455,
  7504,
  29052,
  41036,
  266546,
  19899,
  30391,
  188755,
  8659,
  59469,
  16,
  104298,
  112943,
  53865,
  76203,
  138226,
  68857,
  139953,
  14125,
  107625,
  119795,
  173133,
  4398,
  50273,
  48808,
  54390,
  16466,
  122086,
  31835,
  67035,
  50971,
  48859,
  7508,
  46427,
  66477,
  73021,
  84615,
  39985,
  83076,
  46779,
  201569,
  53336,
  36443,
  60865,
  168164,
  143810,
  51393,
  25548,
  169307,
  32896,
  24485,
  38424,
  21837,
  29087,
  275813,
  51674,
  6714,
  64883,
  46169,
  187369,
  55186,
  76192,
  12852,
  12018,
  62134,
  31067,
  118303,
  16542,
  12125,
  10579,
  4928,
  26291,
  43854,
  7091,
  10946,
  253716,
  109062,
  39283,
  17261,
  113012,
  258512,
  47764,
  125126,
  32646,
  55892,
  80279,
  201623,
  149872,
  3192,
  385,
  1208,
  48750,
  5376,
  58738,
  22335,
  5427,
  82416,
  47811,
  32435,
  143086,
  38930,
  94128,
  59975,
  156037,
  37977,
  38224,
  62485,
  7698,
  50405,
  71027,
  16462,
  21559,
  136153,
  34131,
  107506,
  162069,
  63703,
  3101,
  215029,
  40407,
  4178,
  3774,
  9187,
  80019,
  17880,
  97926,
  67579,
  2600,
  18405,
  8351,
  47924,
  86638,
  70820,
  92206,
  86453,
  29610,
  42241,
  119200,
  3198,
  15466,
  67813,
  57863,
  35454,
  4779,
  99518,
  4649,
  104641,
  144269,
  33730,
  38073,
  65864,
  6838,
  109456,
  193298,
  154007,
  5623,
  45741,
  30846,
  182578,
  25573,
  157224,
  1543,
  58575,
  138703,
  146140,
  44971,
  49356,
  18275,
  59064,
  20300,
  13122,
  11848,
  24453,
  11973,
  9797,
  86843,
  2919,
  25530,
  49210,
  1130,
  161220,
  76788,
  75373,
  85604,
  34926,
  36014,
  17777,
  17255,
  51533,
  11676,
  92226,
  51845,
  119859,
  21525,
  5936,
  18507,
  28050,
  1140,
  31418,
  14857,
  34207,
  47859,
  10750,
  36382,
  32079,
  106909,
  59426,
  87757,
  38393,
  110042,
  15965,
  97104,
  33757,
  35344,
  97993,
  53979,
  33651,
  45407,
  41884,
  82515,
  173089,
  7177,
  58371,
  35365,
  47543,
  51927,
  35587,
  10670,
  23544,
  29306,
  84233,
  39976,
  76076,
  62097,
  9007,
  8668,
  28119,
  78281,
  120790,
  19835,
  143020,
  54968,
  18670,
  64959,
  20649,
  34469,
  42570,
  33001,
  136570,
  87796,
  120044,
  1106,
  58700,
  63951,
  127623,
  12805,
  83057,
  40212,
  31773,
  49850,
  7361,
  54336,
  347524,
  101314,
  23751,
  19569,
  48791,
  29174,
  49369,
  20467,
  7465,
  75842,
  38281,
  623,
  112457,
  60210,
  28849,
  51003,
  94720,
  6426,
  90047,
  85560,
  43761,
  3579,
  85105,
  34607,
  90410,
  118528,
  7224,
  42907,
  111163,
  18168,
  6960,
  161135,
  191298,
  5247,
  100584,
  127552,
  171568,
  20121,
  91173,
  12636,
  54615,
  20199,
  63730,
  98105,
  2396,
  40387,
  14438,
  125012,
  4765,
  33235,
  12865,
  45299,
  37728,
  82098,
  77872,
  114037,
  59253,
  19675,
  24838,
  398016,
  102561,
  11446,
  17069,
  57508,
  178277,
  65836,
  99941,
  26114,
  2585,
  271882,
  136866,
  50126,
  11027,
  155648,
  118367,
  14585,
  8910,
  123015,
  335383,
  40434,
  41016,
  53021,
  14439,
  87098,
  176860,
  201543,
  121888,
  2358,
  9286,
  5739,
  22666,
  54270,
  37884,
  169381,
  33984,
  93859,
  16124,
  89364,
  72207,
  51639,
  76366,
  99029,
  65812,
  2198,
  12147,
  174891,
  194289,
  6986,
  30252,
  88822,
  21284,
  11445,
  288337,
  160821,
  33034,
  100869,
  43852,
  25761,
  52882,
  1144,
  103809,
  1924,
  84458,
  86079,
  43411,
  13542,
  139276,
  18141,
  34978,
  41298,
  7276,
  26481,
  173800,
  33210,
  17951,
  142652,
  33616,
  33677,
  2210,
  19941,
  98568,
  2486,
  192414,
  80136,
  12058,
  235883,
  50963,
  249638,
  29572,
  27221,
  47034,
  6124,
  72107,
  63346,
  97620,
  158513,
  299699,
  40388,
  23235,
  37176,
  224244,
  198386,
  121323,
  67992,
  23827,
  63170,
  17838,
  106622,
  158590,
  26807,
  5345,
  23489,
  91891,
  55474,
  74834,
  37981,
  13058,
  5977,
  72552,
  34706,
  26828,
  145172,
  19904,
  21367,
  34043,
  960,
  77092,
  91381,
  4733,
  47446,
  7680,
  41697,
  5170,
  16960,
  14741,
  46101,
  13656,
  473,
  51842,
  37433,
  11103,
  11551,
  121951,
  13191,
  97536,
  165932,
  50397,
  51628,
  129028,
  9069,
  44885,
  6590,
  59195,
  47045,
  32940,
  225472,
  90345,
  21833,
  13303,
  29407,
  96615,
  141951,
  5198,
  6028,
  18395,
  7181,
  3861,
  14966,
  156358,
  167182,
  36529,
  55253,
  25942,
  173153,
  30959,
  27261,
  50691,
  150176,
  162201,
  38467,
  48462,
  80602,
  42163,
  118482,
  168,
  108756,
  26011,
  17166,
  54149,
  456538,
  22512,
  91374,
  13816,
  90358,
  131615,
  18132,
  226707,
  1824,
  28139,
  26860,
  42253,
  93877,
  77351,
  65575,
  8980,
  80574,
  22020,
  27948,
  40422,
  91324,
  76376,
  13528,
  39281,
  91685,
  82215,
  122541,
  144066,
  1983,
  193851,
  17283,
  26320,
  2739,
  194978,
  4790,
  26845,
  42627,
  61300,
  65815,
  174612,
  55133,
  4200,
  191130,
  79771,
  158321,
  52280,
  166796,
  221620,
  62461,
  11278,
  4067,
  88152,
  83409,
  31717,
  121367,
  13522,
  47325,
  37945,
  10406,
  174348,
  249321,
  154101,
  64912,
  29938,
  51775,
  17220,
  15776,
  166138,
  78890,
  84425,
  54121,
  42861,
  16368,
  24572,
  291647,
  10197,
  32073,
  22651,
  11677,
  97509,
  26952,
  35787,
  18424,
  41910,
  71614,
  94977,
  72318,
  41594,
  70024,
  275419,
  37702,
  60199,
  7335,
  39107,
  61315,
  18271,
  18394,
  33768,
  87884,
  104277,
  123724,
  7277,
  56288,
  71981,
  189803,
  49320,
  3352,
  6798,
  14240,
  8954,
  69220,
  94433,
  57372,
  28620,
  68863,
  193727,
  85575,
  42309,
  41667,
  67689,
  42081,
  22543,
  44824,
  12719,
  28540,
  114236,
  101553,
  27638,
  27296,
  4300,
  5353,
  4663,
  19379,
  94098,
  3758,
  95888,
  95144,
  80344,
  87320,
  28447,
  259518,
  12718,
  71391,
  152731,
  37063,
  24132,
  31911,
  104896,
  15672,
  103782,
  1521,
  4945,
  72541,
  23717,
  122632,
  15619,
  87175,
  206120,
  29428,
  189780,
  61416,
  28350,
  44457,
  972,
  1175,
  47233,
  198738,
  95789,
  41907,
  21953,
  97034,
  59341,
  22864,
  53713,
  16873,
  32971,
  20693,
  20954,
  31336,
  21477,
  16169,
  38370,
  16412,
  9019,
  3841,
  24599,
  21938,
  17085,
  6484,
  81198,
  76413,
  5849,
  72514,
  12320,
  65247,
  276175,
  37234,
  59796,
  52642,
  16312,
  57349,
  198507,
  94148,
  46134,
  18958,
  125552,
  1747,
  18725,
  151873,
  14901,
  5490,
  68287,
  29470,
  3689,
  64794,
  40814,
  26018,
  25692,
  54450,
  2703,
  88278,
  124886,
  173087,
  174e3,
  24159,
  179477,
  24276,
  46004,
  201876,
  209202,
  445,
  52876,
  31948,
  30206,
  157610,
  39180,
  18439,
  44124,
  50469,
  5774,
  96278,
  222758,
  200216,
  50290,
  45486,
  20435,
  46986,
  46276,
  140133,
  142326,
  15569,
  13363,
  47522,
  92583,
  2182,
  7135,
  16853,
  22998,
  30272,
  4952,
  63263,
  35623,
  39096,
  53789,
  44864,
  20053,
  110392,
  124213,
  4630,
  16087,
  28221,
  127787,
  25839,
  77481,
  44693,
  13464,
  113146,
  6983,
  27069,
  55717,
  50102,
  4760,
  7107,
  26186,
  66507,
  59145,
  36032,
  104182,
  71328,
  29425,
  64317,
  50781,
  47465,
  94298,
  69706,
  74899,
  22754,
  120756,
  25108,
  93077,
  56834,
  73286,
  39928,
  16218,
  41699,
  176763,
  7555,
  70819,
  50083,
  26895,
  23315,
  26014,
  16773,
  123079,
  41712,
  5719,
  31516,
  90427,
  158540,
  85051,
  183128,
  40864,
  27505,
  55392,
  9058,
  45224,
  96857,
  30901,
  136622,
  96557,
  56304,
  120061,
  11501,
  151448,
  5773,
  89743,
  7769,
  86069,
  2935,
  18471,
  41628,
  10114,
  33660,
  110170,
  49479,
  26745,
  92846,
  33221,
  26731,
  18795,
  87076,
  8550,
  2100,
  29972,
  120289,
  3077,
  72490,
  33784,
  2630,
  208722,
  50861,
  63483,
  79029,
  6419,
  39467,
  14302,
  45286,
  64207,
  9686,
  67513,
  44170,
  1050,
  77246,
  59266,
  17055,
  53801,
  7150,
  11111,
  42432,
  4278,
  94579,
  362117,
  36175,
  42902,
  41933,
  39002,
  98489,
  22913,
  74161,
  84773,
  57036,
  17556,
  162288,
  74485,
  178760,
  93867,
  73635,
  128860,
  50362,
  261,
  67455,
  80001,
  46080,
  35662,
  4368,
  25247,
  19230,
  74393,
  22588,
  1822,
  27682,
  235324,
  13798,
  85998,
  13194,
  235067,
  23514,
  71669,
  147632,
  23191,
  134748,
  214683,
  105101,
  1518,
  25489,
  247114,
  7380,
  54842,
  26922,
  3971,
  26361,
  20844,
  68642,
  170517,
  77339,
  123255,
  8963,
  77818,
  150998,
  48466,
  36806,
  2732,
  23261,
  11741,
  236162,
  18243,
  126216,
  28690,
  50546,
  16385,
  92760,
  197383,
  246558,
  201295,
  88255,
  67588,
  71687,
  176076,
  172653,
  169058,
  33906,
  63747,
  24835,
  157621,
  43338,
  30050,
  46152,
  132741,
  2770,
  51371,
  94835,
  6614,
  15112,
  11749,
  56936,
  1250,
  19027,
  399017,
  58036,
  100215,
  23388,
  55815,
  308768,
  124152,
  94803,
  9521,
  64186,
  8971,
  28,
  30427,
  62163,
  7616,
  103838,
  35079,
  29203,
  131235,
  7743,
  17389,
  10882,
  37420,
  61460,
  228512,
  85363,
  41581,
  131077,
  62822,
  119647,
  10130,
  54445,
  26925,
  19968,
  29016,
  24446,
  74028,
  24176,
  61448,
  67185,
  9254,
  8563,
  119129,
  9771,
  99184,
  37716,
  39514,
  10532,
  221512,
  258753,
  218630,
  55980,
  23394,
  32141,
  61924,
  66749,
  32411,
  3741,
  36475,
  26678,
  77010,
  44946,
  91203,
  128749,
  116953,
  20476,
  49625,
  53116,
  13735,
  102335,
  29376,
  51946,
  83407,
  67892,
  59212,
  34685,
  21083,
  1546,
  112982,
  32972,
  74397,
  1078,
  190545,
  16082,
  86140,
  58591,
  89611,
  101531,
  10061,
  105104,
  76319,
  20035,
  17551,
  52611,
  169061,
  190842,
  100780,
  23907,
  90413,
  115619,
  9675,
  34710,
  193435,
  49443,
  129734,
  11183,
  258877,
  16318,
  136182,
  126808,
  44635,
  27304,
  192375,
  2599,
  125648,
  47051,
  12091,
  23814,
  721,
  58800,
  40137,
  66726,
  97930,
  60877,
  74487,
  7942,
  54326,
  9841,
  41428,
  13762,
  8211,
  85383,
  6950,
  99177,
  79806,
  201786,
  296464,
  124087,
  13144,
  29741,
  41721,
  47634,
  55088,
  254286,
  106408,
  17041,
  99064,
  12942,
  64086,
  45233,
  14005,
  2612,
  55827,
  255,
  7984,
  13980,
  38574,
  12776,
  46654,
  73499,
  249951,
  2101,
  26676,
  25996,
  132326,
  116415,
  119062,
  50449,
  31033,
  23038,
  11589,
  179252,
  20007,
  14860,
  129270,
  21143,
  17796,
  144715,
  60106,
  70758,
  69842,
  34674,
  282133,
  44014,
  16774,
  57268,
  38528,
  24053,
  46373,
  201667,
  28327,
  471023,
  51889,
  102667,
  21193,
  114909,
  84132,
  69317,
  96723,
  67969,
  16134,
  68145,
  15058,
  28765,
  32035,
  2524,
  101089,
  98664,
  25045,
  76571,
  14957,
  86040,
  118506,
  262428,
  154764,
  81573,
  39681,
  283900,
  73287,
  127825,
  544,
  80448,
  52347,
  38512,
  175971,
  15180,
  45467,
  33086,
  46552,
  48894,
  81107,
  43213,
  36672,
  54025,
  76703,
  8053,
  7608,
  13299,
  56619,
  20752,
  238099,
  54164,
  105133,
  1444,
  32942,
  953,
  37564,
  8e3,
  66316,
  119463,
  106817,
  404,
  13667,
  149108,
  128597,
  31267,
  10269,
  49836,
  106150,
  1484,
  52330,
  76965,
  160486,
  171648,
  38456,
  31263,
  22424,
  37738,
  66245,
  67467,
  143369,
  60471,
  75610,
  20895,
  115528,
  86070,
  60854,
  40796,
  49347,
  18989,
  15030,
  11371,
  37578,
  15779,
  79867,
  10187,
  86462,
  46402,
  155626,
  93200,
  40229,
  7090,
  57547,
  108053,
  99598,
  11088,
  47505,
  41218,
  206017,
  2173,
  20988,
  30219,
  22919,
  80563,
  57566,
  42369,
  93141,
  41675,
  2407,
  182519,
  120495,
  27154,
  16702,
  29456,
  14349,
  7958,
  16688,
  117177,
  140375,
  42467,
  261919,
  74916,
  153569,
  10836,
  34742,
  49526,
  7621,
  105997,
  12212,
  2270,
  392377,
  7755,
  17959,
  25086,
  232152,
  138791,
  33847,
  13860,
  35316,
  5811,
  1344,
  71259,
  50452,
  207539,
  92635,
  50359,
  5821,
  33674,
  30255,
  2086,
  2587,
  96264,
  17543,
  42,
  6029,
  9580,
  43007,
  139248,
  82831,
  12917,
  29607,
  25786,
  51467,
  42137,
  85161,
  100698,
  31561,
  88989,
  121990,
  278500,
  3602,
  109344,
  37982,
  15279,
  116442,
  28936,
  30880,
  87894,
  58079,
  128661,
  126731,
  67392,
  28051,
  146885,
  4861,
  16216,
  97344,
  42827,
  147561,
  153948,
  22684,
  21335,
  47685,
  1853,
  43349,
  15185,
  59642,
  10229,
  25520,
  187921,
  108972,
  5579,
  98037,
  24945,
  6697,
  19193,
  63734,
  137934,
  75056,
  89740,
  19767,
  224268,
  56138,
  63643,
  151661,
  39313,
  70618,
  84031,
  89723,
  84074,
  13703,
  85626,
  35460,
  8867,
  64845,
  3439,
  57906,
  99776,
  63968,
  49270,
  81130,
  34356,
  16210,
  23547,
  36446,
  34090,
  140028,
  72439,
  2221,
  22163,
  57058,
  363492,
  113754,
  18913,
  95451,
  48663,
  54464,
  54037,
  176097,
  68425,
  3023,
  34906,
  29482,
  117389,
  341780,
  80431,
  58330,
  16753,
  92616,
  60907,
  94846,
  147486,
  4498,
  48646,
  7773,
  46801,
  7778,
  18946,
  464978,
  47558,
  33223,
  177444,
  7328,
  15626,
  63337,
  94700,
  11743,
  9351,
  255024,
  39098,
  16447,
  42647,
  96230,
  39769,
  58840,
  10068,
  63439,
  35800,
  65843,
  58823,
  413844,
  9156,
  51258,
  7434,
  61791,
  85018,
  6872,
  3692,
  28096,
  7121,
  33024,
  6009,
  75532,
  31997,
  192535,
  9661,
  3304,
  9547,
  14753,
  31987,
  25314,
  55689,
  15896,
  20430,
  39472,
  31340,
  99744,
  25398,
  115569,
  54883,
  28719,
  205423,
  23071,
  57855,
  64638,
  149867,
  25671,
  82403,
  37616,
  20668,
  39989,
  77996,
  74948,
  140555,
  175248,
  64810,
  36515,
  46595,
  4958,
  248773,
  24045,
  28728,
  136673,
  168704,
  20804,
  114833,
  100325,
  27135,
  21205,
  96151,
  153134,
  45992,
  7093,
  13992,
  76047,
  1980,
  19432,
  145001,
  75159,
  87462,
  17710,
  1013,
  45556,
  34297,
  144882,
  20648,
  26061,
  11319,
  129567,
  108555,
  18872,
  464580,
  33386,
  22717,
  65948,
  167189,
  5603,
  135042,
  79542,
  8801,
  202632,
  18114,
  91882,
  5973,
  5239,
  67315,
  4431,
  60916,
  47819,
  71693,
  32597,
  32606,
  18183,
  45072,
  80329,
  76385,
  24749,
  51305,
  40314,
  156514,
  14693,
  130345,
  13168,
  66214,
  18029,
  12858,
  34801,
  27628,
  14544,
  10823,
  40522,
  40185,
  33739,
  148694,
  23548,
  9923,
  61012,
  28859,
  17933,
  19442,
  34364,
  99849,
  164107,
  141167,
  30629,
  21054,
  6744,
  36491,
  8096,
  42474,
  41706,
  155060,
  30650,
  10600,
  163442,
  1143,
  96655,
  61390,
  52359,
  7559,
  51568,
  64256,
  203854,
  4467,
  22453,
  14504,
  436398,
  7878,
  6980,
  8293,
  63610,
  293747,
  16167,
  35763,
  19627,
  147603,
  15419,
  18032,
  110744,
  51346,
  33681,
  54571,
  40472,
  48615,
  39073,
  21604,
  13754,
  173027,
  92560,
  11083,
  47299,
  63062,
  11813,
  52007,
  29883,
  9734,
  139722,
  15953,
  1550,
  20651,
  13616,
  49306,
  16113,
  90089,
  92326,
  7584,
  30712,
  72424,
  164858,
  6831,
  152871,
  55746,
  197721,
  34167,
  196442,
  6022,
  112107,
  55215,
  7538,
  123381,
  4920,
  43539,
  77165,
  8939,
  50392,
  34192,
  20225,
  79762,
  22505,
  58667,
  40770,
  29788,
  97180,
  82835,
  4568,
  8579,
  13273,
  363569,
  35898,
  49983,
  436,
  36598,
  3237,
  131691,
  62418,
  35591,
  8101,
  4073,
  379438,
  65218,
  76072,
  33887,
  2968,
  27573,
  212619,
  288680,
  68278,
  72851,
  150504,
  217896,
  6913,
  121339,
  22017,
  35340,
  51072,
  43616,
  75043,
  31437,
  10833,
  81487,
  4364,
  22968,
  41454,
  106687,
  85446,
  19863,
  109625,
  149241,
  524,
  141850,
  214404,
  54376,
  657,
  237023,
  9401,
  108137,
  53800,
  32474,
  49712,
  53334,
  126876,
  27337,
  45552,
  177696,
  8269,
  15036,
  12097,
  42240,
  2328,
  125374,
  119295,
  99715,
  2500,
  19624,
  39441,
  27220,
  102691,
  60957,
  94543,
  39101,
  18566,
  67362,
  13975,
  78230,
  25017,
  34017,
  239007,
  90027,
  39351,
  41681,
  35354,
  43822,
  1043,
  916,
  58587,
  141983,
  94818,
  38799,
  75459,
  41114,
  67432,
  16195,
  36606,
  59568,
  22272,
  126769,
  31424,
  68659,
  12287,
  134302,
  257977,
  5756,
  207285,
  95637,
  47248,
  117689,
  19583,
  77451,
  22373,
  12200,
  54993,
  117118,
  34244,
  29386,
  34562,
  53819,
  71267,
  64172,
  77665,
  49368,
  7716,
  59301,
  25749,
  45426,
  194789,
  17297,
  2650,
  1766,
  32501,
  45198,
  20403,
  20984,
  6600,
  14171,
  94604,
  19037,
  5402,
  29896,
  9938,
  59935,
  109708,
  88081,
  145182,
  44844,
  39167,
  352626,
  164173,
  35374,
  45982,
  6122,
  154,
  73419,
  220487,
  53834,
  53601,
  17992,
  8609,
  229321,
  5610,
  68098,
  66815,
  71012,
  95069,
  140968,
  27396,
  8957,
  134489,
  24656,
  86659,
  56598,
  134852,
  17316,
  123838,
  255436,
  6613,
  41610,
  138033,
  81452,
  32023,
  32396,
  123687,
  63398,
  8693,
  29712,
  30407,
  19296,
  121188,
  3551,
  36099,
  20032,
  111948,
  56624,
  16547,
  27453,
  35916,
  15378,
  52039,
  56849,
  13489,
  22214,
  73177,
  53097,
  277349,
  2157,
  14029,
  187886,
  10260,
  141743,
  246460,
  91880,
  50869,
  3788,
  49486,
  133566,
  54950,
  33120,
  129337,
  53768,
  18333,
  9525,
  26902,
  312251,
  10297,
  9020,
  70759,
  16647,
  112432,
  59260,
  84609,
  9818,
  82766,
  73569,
  468,
  46001,
  75780,
  55028,
  52106,
  11498,
  43645,
  108069,
  17150,
  17753,
  29417,
  16705,
  31799,
  9606,
  289,
  122254,
  115975,
  8620,
  6133,
  255357,
  56908,
  14456,
  133464,
  43554,
  79224,
  11247,
  29630,
  160,
  12756,
  25464,
  65960,
  350428,
  62521,
  321796,
  100359,
  67358,
  35169,
  46172,
  113128,
  48988,
  88868,
  31094,
  33266,
  6847,
  60887,
  98188,
  49659,
  69117,
  92977,
  220228,
  13947,
  80181,
  35103,
  62170,
  97351,
  13475,
  2440,
  199768,
  19498,
  36597,
  46971,
  25234,
  67806,
  62881,
  84717,
  73648,
  181966,
  10488,
  94149,
  21550,
  26655,
  63436,
  48375,
  14405,
  165650,
  9621,
  24439,
  28043,
  42735,
  4490,
  29963,
  56674,
  45373,
  1934,
  262446,
  50855,
  67098,
  26898,
  5261,
  52696,
  40644,
  33900,
  9440,
  180286,
  87162,
  22940,
  19704,
  26936,
  69769,
  10254,
  101759,
  27406,
  12243,
  48e3,
  73926,
  113215,
  54935,
  5726,
  192787,
  4312,
  106216,
  9366,
  11550,
  52949,
  23457,
  212271,
  277152,
  133895,
  108374,
  6191,
  96477,
  29980,
  218916,
  58024,
  54696,
  40853,
  91124,
  65894,
  91170,
  65908,
  252552,
  6793,
  29212,
  15389,
  44516,
  122515,
  52617,
  35058,
  9017,
  103536,
  39510,
  49136,
  19242,
  130652,
  662077,
  74699,
  47024,
  31422,
  8517,
  73351,
  24399,
  13867,
  128360,
  4810,
  4434,
  61779,
  111983,
  61036,
  17798,
  110240,
  59722,
  102960,
  39688,
  10001,
  23803,
  23039,
  176498,
  56659,
  44814,
  134295,
  17188,
  77577,
  74466,
  226175,
  102472,
  154333,
  63900,
  111747,
  18062,
  41171,
  79669,
  32773,
  408933,
  42562,
  28931,
  30907,
  107388,
  43487,
  2946,
  240310,
  23938,
  24354,
  319,
  184983,
  7927,
  6488,
  1422,
  10790,
  68809,
  68209,
  64775,
  4361,
  202,
  17123,
  59634,
  51200,
  44391,
  18188,
  17843,
  2619,
  74278,
  3230,
  9540,
  47187,
  21702,
  36274,
  56894,
  43907,
  16310,
  34790,
  16866,
  6150,
  5561,
  13587,
  107545,
  108873,
  126867,
  86986,
  28640,
  33427,
  19017,
  5762,
  80637,
  17430,
  46903,
  2047,
  131055,
  25958,
  13558,
  5444,
  47152,
  13900,
  44563,
  122857,
  45348,
  70863,
  39593,
  54332,
  38068,
  33637,
  318,
  40310,
  143467,
  18502,
  24520,
  11377,
  62013,
  28942,
  27246,
  28269,
  83545,
  17999,
  59015,
  90707,
  30065,
  15161,
  34720,
  1263,
  37008,
  2012,
  6060,
  98575,
  92933,
  5721,
  299,
  199555,
  24578,
  29223,
  2985,
  743,
  115825,
  109523,
  136657,
  47454,
  26378,
  53586,
  3733,
  174945,
  93340,
  244456,
  5693,
  37386,
  28782,
  89767,
  27545,
  23573,
  18798,
  136425,
  34320,
  84778,
  20041,
  48453,
  38215,
  7477,
  71958,
  40621,
  8773,
  5874,
  187927,
  105965,
  51100,
  43533,
  18083,
  8443,
  10180,
  43597,
  2003,
  183999,
  69689,
  12216,
  129696,
  146188,
  62389,
  34044,
  68410,
  12765,
  43273,
  26949,
  266807,
  3345,
  34477,
  79197,
  5688,
  47539,
  213110,
  21634,
  22257,
  50092,
  32222,
  42346,
  39530,
  63668,
  98,
  134978,
  74022,
  5152,
  59088,
  174145,
  37220,
  9934,
  9545,
  118937,
  5724,
  87240,
  19875,
  15784,
  40143,
  23263,
  87513,
  181654,
  285152,
  37881,
  263241,
  4966,
  43934,
  10433,
  186657,
  6470,
  74416,
  225854,
  25908,
  142677,
  246262,
  32280,
  6192,
  75890,
  45546,
  143264,
  135305,
  29742,
  47013,
  77787,
  11732,
  126658,
  8763,
  37950,
  21806,
  57557,
  113464,
  89465,
  108995,
  164574,
  23894,
  22996,
  23169,
  15369,
  23117,
  17642,
  130607,
  40503,
  36239,
  280990,
  44666,
  9981,
  40427,
  147487,
  26869,
  168452,
  32886,
  32991,
  46798,
  240839,
  15111,
  70502,
  65697,
  88548,
  44145,
  28701,
  48767,
  31139,
  206777,
  35659,
  181164,
  166262,
  14554,
  171445,
  31786,
  66523,
  76607,
  17956,
  6507,
  31279,
  90476,
  116611,
  167918,
  6560,
  1243,
  115324,
  80128,
  41867,
  55897,
  187323,
  37069,
  32596,
  189444,
  145931,
  13390,
  105530,
  65709,
  26805,
  6999,
  55714,
  41300,
  22915,
  68951,
  22138,
  21120,
  22264,
  10058,
  19945,
  33635,
  56123,
  99085,
  10032,
  5818,
  6016,
  46649,
  57476,
  35264,
  94413,
  112522,
  262288,
  93686,
  83038,
  14341,
  23204,
  28807,
  66084,
  77987,
  6101,
  126673,
  7133,
  38126,
  5923,
  122091,
  170240,
  97772,
  46874,
  215746,
  43948,
  41622,
  3272,
  55596,
  8332,
  146411,
  251315,
  13533,
  8561,
  81521,
  115449,
  48616,
  175175,
  2063,
  186556,
  3036,
  134537,
  75772,
  29728,
  82360,
  22973,
  186559,
  86348,
  89100,
  38388,
  82297,
  45610,
  2613,
  87082,
  9986,
  177812,
  57884,
  23591,
  47485,
  42543,
  33582,
  44713,
  74439,
  257444,
  252451,
  31825,
  35631,
  38540,
  33066,
  5147,
  13973,
  4343,
  51830,
  70378,
  22827,
  26448,
  95560,
  36896,
  241741,
  48067,
  203953,
  298860,
  61620,
  20450,
  3220,
  67272,
  6586,
  107662,
  100160,
  108684,
  6929,
  57226,
  4762,
  7457,
  1320,
  40404,
  77204,
  99309,
  62750,
  208653,
  59977,
  44e3,
  74315,
  34332,
  5819,
  172217,
  64904,
  114077,
  18147,
  84012,
  1791,
  98456,
  90930,
  21446,
  116669,
  103938,
  7422,
  85140,
  59713,
  5768,
  326211,
  16239,
  75411,
  13229,
  29398,
  10758,
  236107,
  1539,
  112472,
  95979,
  152154,
  151294,
  306,
  21196,
  38146,
  10700,
  6891,
  84282,
  109646,
  56492,
  40539,
  6589,
  119491,
  51354,
  30685,
  140209,
  136906,
  29622,
  73617,
  49553,
  70525,
  51671,
  166869,
  139616,
  74395,
  37439,
  49595,
  45678,
  11959,
  33211,
  86560,
  52434,
  9282,
  62690,
  112155,
  130810,
  5243,
  108261,
  99970,
  265613,
  72551,
  80049,
  6391,
  33365,
  90721,
  66737,
  69872,
  87011,
  1860,
  9032,
  112544,
  60905,
  37371,
  89015,
  140351,
  19076,
  850,
  373531,
  2802,
  36725,
  218795,
  72062,
  28990,
  16550,
  24614,
  7815,
  6187,
  26336,
  33373,
  32162,
  42791,
  73555,
  32062,
  23386,
  10244,
  56392,
  49442,
  27076,
  136262,
  12412,
  14883,
  1134,
  33675,
  97153,
  199281,
  15608,
  100152,
  74072,
  47942,
  254301,
  36451,
  16026,
  10687,
  65067,
  56708,
  254030,
  30290,
  50490,
  13864,
  57941,
  259331,
  35588,
  23485,
  43486,
  24869,
  21620,
  92971,
  22072,
  88645,
  1048,
  182050,
  13343,
  32452,
  14825,
  19509,
  3325,
  216938,
  45740,
  99716,
  189082,
  53740,
  78245,
  25609,
  24311,
  176777,
  47340,
  308354,
  40669,
  66085,
  14102,
  125339,
  9225,
  128709,
  97207,
  1271,
  200933,
  78439,
  113451,
  88975,
  18324,
  46521,
  11819,
  18570,
  141756,
  72512,
  170020,
  52754,
  63550,
  118515,
  103073,
  93330,
  32736,
  50499,
  14722,
  31600,
  68452,
  398867,
  29316,
  172786,
  18417,
  104924,
  2606,
  5670,
  84818,
  16288,
  67106,
  59580,
  82929,
  607401,
  291,
  85829,
  359,
  15897,
  35830,
  50696,
  65630,
  52672,
  22115,
  356968,
  29895,
  40837,
  231192,
  34024,
  38957,
  26722,
  406,
  23335,
  124952,
  72068,
  68804,
  13268,
  147101,
  164740,
  276569,
  162596,
  66943,
  11569,
  26654,
  66358,
  4777,
  23229,
  102127,
  5848,
  978,
  2921,
  59666,
  5371,
  28212,
  90108,
  42938,
  39320,
  2499,
  4271,
  108792,
  33510,
  125072,
  71653,
  65239,
  38250,
  66357,
  38577,
  13964,
  86251,
  35708,
  50755,
  36010,
  29448,
  12209,
  3844,
  38222,
  206337,
  100876,
  67827,
  137088,
  14167,
  252225,
  84163,
  195270,
  1306,
  5703,
  54198,
  779,
  46802,
  22028,
  51124,
  86759,
  70560,
  113164,
  35685,
  162145,
  45471,
  34561,
  422,
  2611,
  6464,
  47486,
  19223,
  38246,
  9191,
  18331,
  89942,
  243642,
  212364,
  15893,
  17518,
  22617,
  6409,
  30046,
  126182,
  59716,
  36560,
  104428,
  18846,
  26592,
  19458,
  50793,
  147333,
  30826,
  1388,
  27647,
  10922,
  14495,
  33545,
  19269,
  135828,
  39727,
  41601,
  46931,
  233379,
  49169,
  131130,
  182112,
  16276,
  82381,
  118209,
  142445,
  128310,
  19672,
  28740,
  82907,
  33436,
  3118,
  102206,
  28723,
  24819,
  41937,
  38854,
  5157,
  3881,
  111491,
  1142,
  9776,
  421673,
  152241,
  29309,
  14961,
  87854,
  6054,
  15424,
  3796,
  82656,
  54996,
  2108,
  55367,
  239450,
  154525,
  9643,
  118103,
  106041,
  64601,
  68549,
  48707,
  30266,
  25772,
  18740,
  9462,
  229669,
  91798,
  112152,
  191327,
  14493,
  72828,
  8175,
  66636,
  236474,
  25817,
  87351,
  129027,
  76653,
  20422,
  22983,
  71240,
  27846,
  44661,
  12399,
  46158,
  77704,
  53101,
  35032,
  11072,
  17300,
  109294,
  33638,
  24408,
  1895,
  11241,
  760,
  17584,
  82479,
  125877,
  63150,
  141075,
  34259,
  23274,
  81698,
  15732,
  43577,
  48340,
  91584,
  14688,
  16379,
  24481,
  150280,
  96420,
  262050,
  48635,
  43727,
  61819,
  56268,
  72003,
  88178,
  17281,
  79912,
  13218,
  122519,
  125295,
  166396,
  11811,
  2171,
  118930,
  67746,
  17636,
  178278,
  174656,
  95661,
  173039,
  83845,
  79689,
  17473,
  98555,
  127696,
  203415,
  54730,
  22925,
  232239,
  9309,
  12136,
  175026,
  20740,
  180188,
  10747,
  39816,
  314017,
  266131,
  10040,
  175732,
  112550,
  220651,
  31974,
  37393,
  888,
  23008,
  86799,
  4303,
  64905,
  148467,
  75337,
  251,
  3284,
  370102,
  50264,
  9835,
  5438,
  23655,
  4481,
  29851,
  329,
  12855,
  7162,
  64931,
  78141,
  12804,
  42372,
  296771,
  83547,
  18624,
  34874,
  86271,
  3360,
  48665,
  77735,
  88767,
  11463,
  63527,
  28889,
  22258,
  29140,
  194315,
  113924,
  25499,
  6406,
  31334,
  1845,
  4802,
  49184,
  43455,
  35469,
  127594,
  92970,
  61038,
  115005,
  38840,
  87761,
  106838,
  8811,
  20572,
  55637,
  11162,
  96721,
  132425,
  108925,
  2948,
  125457,
  36356,
  3502,
  75270,
  27622,
  127192,
  2561,
  123095,
  49394,
  61155,
  16897,
  110064,
  9699,
  89448,
  53356,
  19628,
  220310,
  21622,
  83036,
  9885,
  112214,
  6087,
  26713,
  17901,
  161912,
  91492,
  3440,
  68594,
  9266,
  92238,
  8087,
  6866,
  150194,
  72175,
  80701,
  13459,
  31836,
  43243,
  239700,
  95846,
  44749,
  50647,
  21945,
  230538,
  120612,
  132371,
  244604,
  5193,
  105637,
  34661,
  41341,
  68775,
  85393,
  1874,
  8771,
  33718,
  49672,
  77403,
  595452,
  99507,
  6490,
  58895,
  128742,
  7704,
  39239,
  73217,
  43816,
  62824,
  37804,
  199976,
  22361,
  80005,
  87514,
  94832,
  14089,
  4574,
  139975,
  59142,
  75523,
  100268,
  43906,
  53442,
  15152,
  2547,
  186002,
  17011,
  19513,
  204282,
  3343,
  60568,
  128318,
  119250,
  4298,
  51871,
  41336,
  71759,
  21921,
  45074,
  98169,
  145889,
  99427,
  11350,
  1237,
  5520,
  28799,
  7803,
  53702,
  21026,
  136352,
  38293,
  128690,
  12158,
  90132,
  44600,
  10184,
  26957,
  39459,
  126025,
  78904,
  82999,
  59373,
  39301,
  150198,
  120529,
  153042,
  20177,
  50089,
  14764,
  271571,
  30530,
  123161,
  38975,
  101562,
  22941,
  5648,
  124654,
  109243,
  69817,
  71675,
  49162,
  106884,
  21241,
  107795,
  30258,
  16572,
  188262,
  141456,
  7688,
  60718,
  8271,
  11044,
  32440,
  104608,
  103419,
  236109,
  93156,
  43293,
  128929,
  42107,
  67180,
  25201,
  115254,
  185488,
  130954,
  72813,
  167547,
  20537,
  39969,
  38432,
  22582,
  184022,
  1139,
  27199,
  5655,
  17767,
  97412,
  122606,
  209377,
  27070,
  35871,
  326617,
  188954,
  42680,
  73512,
  80911,
  22629,
  3011,
  95021,
  315242,
  157737,
  383,
  41821,
  41808,
  19335,
  27950,
  15674,
  25677,
  110950,
  35375,
  76835,
  59108,
  57370,
  35262,
  16569,
  160415,
  37706,
  78086,
  32041,
  49691,
  137143,
  9782,
  172080,
  50148,
  77917,
  6323,
  10110,
  69172,
  17711,
  21795,
  59511,
  76184,
  135114,
  31046,
  132319,
  59105,
  157578,
  20549,
  80778,
  57649,
  158421,
  65143,
  4575,
  72235,
  21899,
  10797,
  92745,
  34035,
  106079,
  80159,
  4508,
  78304,
  25350,
  75457,
  46458,
  32937,
  25623,
  47,
  8531,
  104751,
  84953,
  8138,
  36508,
  187199,
  66310,
  115274,
  13253,
  32461,
  38536,
  1916,
  42007,
  187160,
  35055,
  26325,
  84394,
  35963,
  94216,
  45590,
  97782
];
const MAX_COMMON_PREFIX_LENGTH = 15;
class RoutingTableRefresh {
  constructor(init2) {
    const { peerRouting, routingTable, refreshInterval, refreshQueryTimeout, lan } = init2;
    this.log = logger$1(`libp2p:kad-dht:${lan ? "lan" : "wan"}:routing-table:refresh`);
    this.peerRouting = peerRouting;
    this.routingTable = routingTable;
    this.refreshInterval = refreshInterval ?? TABLE_REFRESH_INTERVAL;
    this.refreshQueryTimeout = refreshQueryTimeout ?? TABLE_REFRESH_QUERY_TIMEOUT;
    this.commonPrefixLengthRefreshedAt = [];
    this.refreshTable = this.refreshTable.bind(this);
  }
  async start() {
    this.log(`refreshing routing table every ${this.refreshInterval}ms`);
    this.refreshTable(true);
  }
  async stop() {
    if (this.refreshTimeoutId != null) {
      clearTimeout(this.refreshTimeoutId);
    }
  }
  refreshTable(force = false) {
    this.log("refreshing routing table");
    const prefixLength = this._maxCommonPrefix();
    const refreshCpls = this._getTrackedCommonPrefixLengthsForRefresh(prefixLength);
    this.log(`max common prefix length ${prefixLength}`);
    this.log(`tracked CPLs [ ${refreshCpls.map((date) => date.toISOString()).join(", ")} ]`);
    Promise.all(refreshCpls.map(async (lastRefresh, index) => {
      try {
        await this._refreshCommonPrefixLength(index, lastRefresh, force);
        if (this._numPeersForCpl(prefixLength) === 0) {
          const lastCpl = Math.min(2 * (index + 1), refreshCpls.length - 1);
          for (let n = index + 1; n < lastCpl + 1; n++) {
            try {
              await this._refreshCommonPrefixLength(n, lastRefresh, force);
            } catch (err2) {
              this.log.error(err2);
            }
          }
        }
      } catch (err2) {
        this.log.error(err2);
      }
    })).catch((err2) => {
      this.log.error(err2);
    }).then(() => {
      this.refreshTimeoutId = setTimeout(this.refreshTable, this.refreshInterval);
      if (this.refreshTimeoutId.unref != null) {
        this.refreshTimeoutId.unref();
      }
    }).catch((err2) => {
      this.log.error(err2);
    });
  }
  async _refreshCommonPrefixLength(cpl, lastRefresh, force) {
    if (!force && lastRefresh.getTime() > Date.now() - this.refreshInterval) {
      this.log("not running refresh for cpl %s as time since last refresh not above interval", cpl);
      return;
    }
    const peerId = await this._generateRandomPeerId(cpl);
    this.log("starting refreshing cpl %s with key %p (routing table size was %s)", cpl, peerId, this.routingTable.size);
    const controller = new timeoutAbortController.TimeoutController(this.refreshQueryTimeout);
    try {
      const peers = await length$3(this.peerRouting.getClosestPeers(peerId.toBytes(), { signal: controller.signal }));
      this.log(`found ${peers} peers that were close to imaginary peer %p`, peerId);
      this.log("finished refreshing cpl %s with key %p (routing table size is now %s)", cpl, peerId, this.routingTable.size);
    } finally {
      controller.clear();
    }
  }
  _getTrackedCommonPrefixLengthsForRefresh(maxCommonPrefix) {
    if (maxCommonPrefix > MAX_COMMON_PREFIX_LENGTH) {
      maxCommonPrefix = MAX_COMMON_PREFIX_LENGTH;
    }
    const dates = [];
    for (let i2 = 0; i2 <= maxCommonPrefix; i2++) {
      dates[i2] = this.commonPrefixLengthRefreshedAt[i2] ?? new Date();
    }
    return dates;
  }
  async _generateRandomPeerId(targetCommonPrefixLength) {
    if (this.routingTable.kb == null) {
      throw new Error("Routing table not started");
    }
    const randomData = randomBytes$3(2);
    const randomUint16 = (randomData[1] << 8) + randomData[0];
    const key = await this._makePeerId(this.routingTable.kb.localNodeId, randomUint16, targetCommonPrefixLength);
    return peerIdFromBytes(key);
  }
  async _makePeerId(localKadId, randomPrefix, targetCommonPrefixLength) {
    if (targetCommonPrefixLength > MAX_COMMON_PREFIX_LENGTH) {
      throw new Error(`Cannot generate peer ID for common prefix length greater than ${MAX_COMMON_PREFIX_LENGTH}`);
    }
    const view = new DataView(localKadId.buffer, localKadId.byteOffset, localKadId.byteLength);
    const localPrefix = view.getUint16(0, false);
    const toggledLocalPrefix = localPrefix ^ 32768 >> targetCommonPrefixLength;
    const mask = 65535 << 16 - (targetCommonPrefixLength + 1);
    const targetPrefix = toggledLocalPrefix & mask | randomPrefix & ~mask;
    const keyPrefix2 = GENERATED_PREFIXES[targetPrefix];
    const keyBuffer = new ArrayBuffer(34);
    const keyView = new DataView(keyBuffer, 0, keyBuffer.byteLength);
    keyView.setUint8(0, sha256$3.code);
    keyView.setUint8(1, 32);
    keyView.setUint32(2, keyPrefix2, false);
    return new Uint8Array(keyView.buffer, keyView.byteOffset, keyView.byteLength);
  }
  _maxCommonPrefix() {
    let prefixLength = 0;
    for (const length3 of this._prefixLengths()) {
      if (length3 > prefixLength) {
        prefixLength = length3;
      }
    }
    return prefixLength;
  }
  _numPeersForCpl(prefixLength) {
    let count = 0;
    for (const length3 of this._prefixLengths()) {
      if (length3 === prefixLength) {
        count++;
      }
    }
    return count;
  }
  *_prefixLengths() {
    if (this.routingTable.kb == null) {
      return;
    }
    for (const { id } of this.routingTable.kb.toIterable()) {
      const distance = xor(this.routingTable.kb.localNodeId, id);
      let leadingZeros = 0;
      for (const byte of distance) {
        if (byte === 0) {
          leadingZeros++;
        } else {
          break;
        }
      }
      yield leadingZeros;
    }
  }
}
var Record;
(function(Record3) {
  let _codec;
  Record3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, writer2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          writer2.fork();
        }
        if (obj.key != null) {
          writer2.uint32(10);
          writer2.bytes(obj.key);
        }
        if (obj.value != null) {
          writer2.uint32(18);
          writer2.bytes(obj.value);
        }
        if (obj.author != null) {
          writer2.uint32(26);
          writer2.bytes(obj.author);
        }
        if (obj.signature != null) {
          writer2.uint32(34);
          writer2.bytes(obj.signature);
        }
        if (obj.timeReceived != null) {
          writer2.uint32(42);
          writer2.string(obj.timeReceived);
        }
        if (opts.lengthDelimited !== false) {
          writer2.ldelim();
        }
      }, (reader2, length3) => {
        const obj = {};
        const end2 = length3 == null ? reader2.len : reader2.pos + length3;
        while (reader2.pos < end2) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.key = reader2.bytes();
              break;
            case 2:
              obj.value = reader2.bytes();
              break;
            case 3:
              obj.author = reader2.bytes();
              break;
            case 4:
              obj.signature = reader2.bytes();
              break;
            case 5:
              obj.timeReceived = reader2.string();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Record3.encode = (obj) => {
    return encodeMessage(obj, Record3.codec());
  };
  Record3.decode = (buf2) => {
    return decodeMessage(buf2, Record3.codec());
  };
})(Record || (Record = {}));
var Message$2;
(function(Message2) {
  (function(MessageType2) {
    MessageType2["PUT_VALUE"] = "PUT_VALUE";
    MessageType2["GET_VALUE"] = "GET_VALUE";
    MessageType2["ADD_PROVIDER"] = "ADD_PROVIDER";
    MessageType2["GET_PROVIDERS"] = "GET_PROVIDERS";
    MessageType2["FIND_NODE"] = "FIND_NODE";
    MessageType2["PING"] = "PING";
  })(Message2.MessageType || (Message2.MessageType = {}));
  let __MessageTypeValues;
  (function(__MessageTypeValues2) {
    __MessageTypeValues2[__MessageTypeValues2["PUT_VALUE"] = 0] = "PUT_VALUE";
    __MessageTypeValues2[__MessageTypeValues2["GET_VALUE"] = 1] = "GET_VALUE";
    __MessageTypeValues2[__MessageTypeValues2["ADD_PROVIDER"] = 2] = "ADD_PROVIDER";
    __MessageTypeValues2[__MessageTypeValues2["GET_PROVIDERS"] = 3] = "GET_PROVIDERS";
    __MessageTypeValues2[__MessageTypeValues2["FIND_NODE"] = 4] = "FIND_NODE";
    __MessageTypeValues2[__MessageTypeValues2["PING"] = 5] = "PING";
  })(__MessageTypeValues || (__MessageTypeValues = {}));
  (function(MessageType2) {
    MessageType2.codec = () => {
      return enumeration(__MessageTypeValues);
    };
  })(Message2.MessageType || (Message2.MessageType = {}));
  (function(ConnectionType) {
    ConnectionType["NOT_CONNECTED"] = "NOT_CONNECTED";
    ConnectionType["CONNECTED"] = "CONNECTED";
    ConnectionType["CAN_CONNECT"] = "CAN_CONNECT";
    ConnectionType["CANNOT_CONNECT"] = "CANNOT_CONNECT";
  })(Message2.ConnectionType || (Message2.ConnectionType = {}));
  let __ConnectionTypeValues;
  (function(__ConnectionTypeValues2) {
    __ConnectionTypeValues2[__ConnectionTypeValues2["NOT_CONNECTED"] = 0] = "NOT_CONNECTED";
    __ConnectionTypeValues2[__ConnectionTypeValues2["CONNECTED"] = 1] = "CONNECTED";
    __ConnectionTypeValues2[__ConnectionTypeValues2["CAN_CONNECT"] = 2] = "CAN_CONNECT";
    __ConnectionTypeValues2[__ConnectionTypeValues2["CANNOT_CONNECT"] = 3] = "CANNOT_CONNECT";
  })(__ConnectionTypeValues || (__ConnectionTypeValues = {}));
  (function(ConnectionType) {
    ConnectionType.codec = () => {
      return enumeration(__ConnectionTypeValues);
    };
  })(Message2.ConnectionType || (Message2.ConnectionType = {}));
  (function(Peer2) {
    let _codec2;
    Peer2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, writer2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            writer2.fork();
          }
          if (obj.id != null) {
            writer2.uint32(10);
            writer2.bytes(obj.id);
          }
          if (obj.addrs != null) {
            for (const value2 of obj.addrs) {
              writer2.uint32(18);
              writer2.bytes(value2);
            }
          } else {
            throw new Error('Protocol error: required field "addrs" was not found in object');
          }
          if (obj.connection != null) {
            writer2.uint32(24);
            Message2.ConnectionType.codec().encode(obj.connection, writer2);
          }
          if (opts.lengthDelimited !== false) {
            writer2.ldelim();
          }
        }, (reader2, length3) => {
          const obj = {
            addrs: []
          };
          const end2 = length3 == null ? reader2.len : reader2.pos + length3;
          while (reader2.pos < end2) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.id = reader2.bytes();
                break;
              case 2:
                obj.addrs.push(reader2.bytes());
                break;
              case 3:
                obj.connection = Message2.ConnectionType.codec().decode(reader2);
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Peer2.encode = (obj) => {
      return encodeMessage(obj, Peer2.codec());
    };
    Peer2.decode = (buf2) => {
      return decodeMessage(buf2, Peer2.codec());
    };
  })(Message2.Peer || (Message2.Peer = {}));
  let _codec;
  Message2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, writer2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          writer2.fork();
        }
        if (obj.type != null) {
          writer2.uint32(8);
          Message2.MessageType.codec().encode(obj.type, writer2);
        }
        if (obj.clusterLevelRaw != null) {
          writer2.uint32(80);
          writer2.int32(obj.clusterLevelRaw);
        }
        if (obj.key != null) {
          writer2.uint32(18);
          writer2.bytes(obj.key);
        }
        if (obj.record != null) {
          writer2.uint32(26);
          writer2.bytes(obj.record);
        }
        if (obj.closerPeers != null) {
          for (const value2 of obj.closerPeers) {
            writer2.uint32(66);
            Message2.Peer.codec().encode(value2, writer2);
          }
        } else {
          throw new Error('Protocol error: required field "closerPeers" was not found in object');
        }
        if (obj.providerPeers != null) {
          for (const value2 of obj.providerPeers) {
            writer2.uint32(74);
            Message2.Peer.codec().encode(value2, writer2);
          }
        } else {
          throw new Error('Protocol error: required field "providerPeers" was not found in object');
        }
        if (opts.lengthDelimited !== false) {
          writer2.ldelim();
        }
      }, (reader2, length3) => {
        const obj = {
          closerPeers: [],
          providerPeers: []
        };
        const end2 = length3 == null ? reader2.len : reader2.pos + length3;
        while (reader2.pos < end2) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.type = Message2.MessageType.codec().decode(reader2);
              break;
            case 10:
              obj.clusterLevelRaw = reader2.int32();
              break;
            case 2:
              obj.key = reader2.bytes();
              break;
            case 3:
              obj.record = reader2.bytes();
              break;
            case 8:
              obj.closerPeers.push(Message2.Peer.codec().decode(reader2, reader2.uint32()));
              break;
            case 9:
              obj.providerPeers.push(Message2.Peer.codec().decode(reader2, reader2.uint32()));
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Message2.encode = (obj) => {
    return encodeMessage(obj, Message2.codec());
  };
  Message2.decode = (buf2) => {
    return decodeMessage(buf2, Message2.codec());
  };
})(Message$2 || (Message$2 = {}));
const MESSAGE_TYPE = Message$2.MessageType;
const CONNECTION_TYPE = Message$2.ConnectionType;
const MESSAGE_TYPE_LOOKUP = Object.keys(MESSAGE_TYPE);
class Message$1 {
  constructor(type, key, level) {
    if (!(key instanceof Uint8Array)) {
      throw new Error("Key must be a Uint8Array");
    }
    this.type = type;
    this.key = key;
    this.clusterLevelRaw = level;
    this.closerPeers = [];
    this.providerPeers = [];
    this.record = void 0;
  }
  get clusterLevel() {
    const level = this.clusterLevelRaw - 1;
    if (level < 0) {
      return 0;
    }
    return level;
  }
  set clusterLevel(level) {
    this.clusterLevelRaw = level;
  }
  serialize() {
    return Message$2.encode({
      key: this.key,
      type: this.type,
      clusterLevelRaw: this.clusterLevelRaw,
      closerPeers: this.closerPeers.map(toPbPeer),
      providerPeers: this.providerPeers.map(toPbPeer),
      record: this.record == null ? void 0 : this.record.serialize().subarray()
    });
  }
  static deserialize(raw2) {
    const dec = Message$2.decode(raw2);
    const msg = new Message$1(dec.type ?? Message$2.MessageType.PUT_VALUE, dec.key ?? Uint8Array.from([]), dec.clusterLevelRaw ?? 0);
    msg.closerPeers = dec.closerPeers.map(fromPbPeer);
    msg.providerPeers = dec.providerPeers.map(fromPbPeer);
    if (dec.record?.length != null) {
      msg.record = Libp2pRecord.deserialize(dec.record);
    }
    return msg;
  }
}
function toPbPeer(peer) {
  const output = {
    id: peer.id.toBytes(),
    addrs: (peer.multiaddrs ?? []).map((m) => m.bytes),
    connection: CONNECTION_TYPE.CONNECTED
  };
  return output;
}
function fromPbPeer(peer) {
  if (peer.id == null) {
    throw new Error("Invalid peer in message");
  }
  return {
    id: peerIdFromBytes(peer.id),
    multiaddrs: (peer.addrs ?? []).map((a) => multiaddr(a)),
    protocols: []
  };
}
function sendingQueryEvent(fields) {
  return {
    ...fields,
    name: "SENDING_QUERY",
    type: 0,
    messageName: fields.type,
    messageType: MESSAGE_TYPE_LOOKUP.indexOf(fields.type.toString())
  };
}
function peerResponseEvent(fields) {
  return {
    ...fields,
    name: "PEER_RESPONSE",
    type: 1,
    messageName: fields.messageType,
    closer: fields.closer != null ? fields.closer : [],
    providers: fields.providers != null ? fields.providers : []
  };
}
function finalPeerEvent(fields) {
  return {
    ...fields,
    name: "FINAL_PEER",
    type: 2
  };
}
function queryErrorEvent(fields) {
  return {
    ...fields,
    name: "QUERY_ERROR",
    type: 3
  };
}
function providerEvent(fields) {
  return {
    ...fields,
    name: "PROVIDER",
    type: 4
  };
}
function valueEvent(fields) {
  return {
    ...fields,
    name: "VALUE",
    type: 5
  };
}
function dialingPeerEvent(fields) {
  return {
    ...fields,
    name: "DIALING_PEER",
    type: 7
  };
}
class Network$2 extends EventEmitter$1 {
  constructor(components, init2) {
    super();
    const { protocol: protocol2, lan } = init2;
    this.components = components;
    this.log = logger$1(`libp2p:kad-dht:${lan ? "lan" : "wan"}:network`);
    this.running = false;
    this.protocol = protocol2;
  }
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
  }
  async stop() {
    this.running = false;
  }
  isStarted() {
    return this.running;
  }
  async *sendRequest(to, msg, options = {}) {
    if (!this.running) {
      return;
    }
    this.log("sending %s to %p", msg.type, to);
    yield dialingPeerEvent({ peer: to });
    yield sendingQueryEvent({ to, type: msg.type });
    try {
      const connection = await this.components.connectionManager.openConnection(to, options);
      const stream2 = await connection.newStream(this.protocol, options);
      const response = await this._writeReadMessage(stream2, msg.serialize(), options);
      yield peerResponseEvent({
        from: to,
        messageType: response.type,
        closer: response.closerPeers,
        providers: response.providerPeers,
        record: response.record
      });
    } catch (err2) {
      yield queryErrorEvent({ from: to, error: err2 });
    } finally {
    }
  }
  async *sendMessage(to, msg, options = {}) {
    if (!this.running) {
      return;
    }
    this.log("sending %s to %p", msg.type, to);
    yield dialingPeerEvent({ peer: to });
    yield sendingQueryEvent({ to, type: msg.type });
    try {
      const connection = await this.components.connectionManager.openConnection(to, options);
      const stream2 = await connection.newStream(this.protocol, options);
      await this._writeMessage(stream2, msg.serialize(), options);
      yield peerResponseEvent({ from: to, messageType: msg.type });
    } catch (err2) {
      yield queryErrorEvent({ from: to, error: err2 });
    } finally {
    }
  }
  async _writeMessage(stream2, msg, options) {
    if (options.signal != null) {
      stream2 = abortableDuplex(stream2, options.signal);
    }
    await pipe([msg], encode$5(), stream2, drain);
  }
  async _writeReadMessage(stream2, msg, options) {
    if (options.signal != null) {
      stream2 = abortableDuplex(stream2, options.signal);
    }
    const res = await pipe([msg], encode$5(), stream2, decode$3(), async (source2) => {
      const buf2 = await first$1(source2);
      if (buf2 != null) {
        return buf2;
      }
      throw errCode(new Error("No message received"), "ERR_NO_MESSAGE_RECEIVED");
    });
    const message2 = Message$1.deserialize(res);
    message2.closerPeers.forEach((peerData) => {
      this.dispatchEvent(new CustomEvent("peer", {
        detail: peerData
      }));
    });
    message2.providerPeers.forEach((peerData) => {
      this.dispatchEvent(new CustomEvent("peer", {
        detail: peerData
      }));
    });
    return message2;
  }
}
function verifyRecord(validators2, record) {
  const key = record.key;
  const keyString = toString$5(key);
  const parts2 = keyString.split("/");
  if (parts2.length < 3) {
    return;
  }
  const validator = validators2[parts2[1].toString()];
  if (validator == null) {
    const errMsg = "Invalid record keytype";
    throw errCode(new Error(errMsg), "ERR_INVALID_RECORD_KEY_TYPE");
  }
  return validator(key, record.value);
}
const validatePublicKeyRecord = async (key, publicKey) => {
  if (!(key instanceof Uint8Array)) {
    throw errCode(new Error('"key" must be a Uint8Array'), "ERR_INVALID_RECORD_KEY_NOT_BUFFER");
  }
  if (key.byteLength < 5) {
    throw errCode(new Error("invalid public key record"), "ERR_INVALID_RECORD_KEY_TOO_SHORT");
  }
  const prefix = toString$5(key.subarray(0, 4));
  if (prefix !== "/pk/") {
    throw errCode(new Error("key was not prefixed with /pk/"), "ERR_INVALID_RECORD_KEY_BAD_PREFIX");
  }
  const keyhash = key.slice(4);
  const publicKeyHash = await sha256$3.digest(publicKey);
  if (!equals$1(keyhash, publicKeyHash.bytes)) {
    throw errCode(new Error("public key does not match passed in key"), "ERR_INVALID_RECORD_HASH_MISMATCH");
  }
};
const validators = {
  pk: validatePublicKeyRecord
};
function bestRecord(selectors2, k, records) {
  if (records.length === 0) {
    const errMsg = "No records given";
    throw errCode(new Error(errMsg), "ERR_NO_RECORDS_RECEIVED");
  }
  const kStr = toString$5(k);
  const parts2 = kStr.split("/");
  if (parts2.length < 3) {
    const errMsg = "Record key does not have a selector function";
    throw errCode(new Error(errMsg), "ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY");
  }
  const selector = selectors2[parts2[1].toString()];
  if (selector == null) {
    const errMsg = `Unrecognized key prefix: ${parts2[1]}`;
    throw errCode(new Error(errMsg), "ERR_UNRECOGNIZED_KEY_PREFIX");
  }
  if (records.length === 1) {
    return 0;
  }
  return selector(k, records);
}
function publickKey(k, records) {
  return 0;
}
const selectors = {
  pk: publickKey
};
class ContentFetching {
  constructor(components, init2) {
    const { validators: validators2, selectors: selectors2, peerRouting, queryManager, routingTable, network, lan } = init2;
    this.components = components;
    this.log = logger$1(`libp2p:kad-dht:${lan ? "lan" : "wan"}:content-fetching`);
    this.validators = validators2;
    this.selectors = selectors2;
    this.peerRouting = peerRouting;
    this.queryManager = queryManager;
    this.routingTable = routingTable;
    this.network = network;
  }
  async putLocal(key, rec) {
    const dsKey = bufferToRecordKey(key);
    await this.components.datastore.put(dsKey, rec);
  }
  async getLocal(key) {
    this.log("getLocal %b", key);
    const dsKey = bufferToRecordKey(key);
    this.log("fetching record for key %k", dsKey);
    const raw2 = await this.components.datastore.get(dsKey);
    this.log("found %k in local datastore", dsKey);
    const rec = Libp2pRecord.deserialize(raw2);
    await verifyRecord(this.validators, rec);
    return rec;
  }
  async *sendCorrectionRecord(key, vals, best, options = {}) {
    this.log("sendCorrection for %b", key);
    const fixupRec = await createPutRecord(key, best);
    for (const { value: value2, from: from2 } of vals) {
      if (equals$1(value2, best)) {
        this.log("record was ok");
        continue;
      }
      if (this.components.peerId.equals(from2)) {
        try {
          const dsKey = bufferToRecordKey(key);
          this.log(`Storing corrected record for key ${dsKey.toString()}`);
          await this.components.datastore.put(dsKey, fixupRec.subarray());
        } catch (err2) {
          this.log.error("Failed error correcting self", err2);
        }
        continue;
      }
      let sentCorrection = false;
      const request2 = new Message$1(MESSAGE_TYPE.PUT_VALUE, key, 0);
      request2.record = Libp2pRecord.deserialize(fixupRec);
      for await (const event of this.network.sendRequest(from2, request2, options)) {
        if (event.name === "PEER_RESPONSE" && event.record != null && equals$1(event.record.value, Libp2pRecord.deserialize(fixupRec).value)) {
          sentCorrection = true;
        }
        yield event;
      }
      if (!sentCorrection) {
        yield queryErrorEvent({ from: from2, error: errCode(new Error("value not put correctly"), "ERR_PUT_VALUE_INVALID") });
      }
      this.log.error("Failed error correcting entry");
    }
  }
  async *put(key, value2, options = {}) {
    this.log("put key %b value %b", key, value2);
    const record = await createPutRecord(key, value2);
    const dsKey = bufferToRecordKey(key);
    this.log(`storing record for key ${dsKey.toString()}`);
    await this.components.datastore.put(dsKey, record.subarray());
    yield* pipe(this.peerRouting.getClosestPeers(key, { signal: options.signal }), (source2) => map$3(source2, (event) => {
      return async () => {
        if (event.name !== "FINAL_PEER") {
          return [event];
        }
        const events2 = [];
        const msg = new Message$1(MESSAGE_TYPE.PUT_VALUE, key, 0);
        msg.record = Libp2pRecord.deserialize(record);
        this.log("send put to %p", event.peer.id);
        for await (const putEvent of this.network.sendRequest(event.peer.id, msg, options)) {
          events2.push(putEvent);
          if (putEvent.name !== "PEER_RESPONSE") {
            continue;
          }
          if (!(putEvent.record != null && equals$1(putEvent.record.value, Libp2pRecord.deserialize(record).value))) {
            events2.push(queryErrorEvent({ from: event.peer.id, error: errCode(new Error("value not put correctly"), "ERR_PUT_VALUE_INVALID") }));
          }
        }
        return events2;
      };
    }), (source2) => parallel$1(source2, {
      ordered: false,
      concurrency: ALPHA
    }), async function* (source2) {
      for await (const events2 of source2) {
        yield* events2;
      }
    });
  }
  async *get(key, options = {}) {
    this.log("get %b", key);
    const vals = [];
    for await (const event of this.getMany(key, options)) {
      if (event.name === "VALUE") {
        vals.push(event);
      }
      yield event;
    }
    if (vals.length === 0) {
      return;
    }
    const records = vals.map((v) => v.value);
    let i2 = 0;
    try {
      i2 = bestRecord(this.selectors, key, records);
    } catch (err2) {
      if (err2.code !== "ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY") {
        throw err2;
      }
    }
    const best = records[i2];
    this.log("GetValue %b %b", key, best);
    if (best == null) {
      throw errCode(new Error("best value was not found"), "ERR_NOT_FOUND");
    }
    yield* this.sendCorrectionRecord(key, vals, best, options);
    yield vals[i2];
  }
  async *getMany(key, options = {}) {
    this.log("getMany values for %b", key);
    try {
      const localRec = await this.getLocal(key);
      yield valueEvent({
        value: localRec.value,
        from: this.components.peerId
      });
    } catch (err2) {
      this.log("error getting local value for %b", key, err2);
    }
    const id = await convertBuffer(key);
    const rtp = this.routingTable.closestPeers(id);
    this.log("found %d peers in routing table", rtp.length);
    const self2 = this;
    const getValueQuery = async function* ({ peer, signal }) {
      for await (const event of self2.peerRouting.getValueOrPeers(peer, key, { signal })) {
        yield event;
        if (event.name === "PEER_RESPONSE" && event.record != null) {
          yield valueEvent({ from: peer, value: event.record.value });
        }
      }
    };
    yield* this.queryManager.run(key, rtp, getValueQuery, options);
  }
}
class ContentRouting {
  constructor(components, init2) {
    const { network, peerRouting, queryManager, routingTable, providers, lan } = init2;
    this.components = components;
    this.log = logger$1(`libp2p:kad-dht:${lan ? "lan" : "wan"}:content-routing`);
    this.network = network;
    this.peerRouting = peerRouting;
    this.queryManager = queryManager;
    this.routingTable = routingTable;
    this.providers = providers;
  }
  async *provide(key, multiaddrs, options = {}) {
    this.log("provide %s", key);
    await this.providers.addProvider(key, this.components.peerId);
    const msg = new Message$1(MESSAGE_TYPE.ADD_PROVIDER, key.bytes, 0);
    msg.providerPeers = [{
      id: this.components.peerId,
      multiaddrs,
      protocols: []
    }];
    let sent = 0;
    const maybeNotifyPeer = (event) => {
      return async () => {
        if (event.name !== "FINAL_PEER") {
          return [event];
        }
        const events2 = [];
        this.log("putProvider %s to %p", key, event.peer.id);
        try {
          this.log("sending provider record for %s to %p", key, event.peer.id);
          for await (const sendEvent of this.network.sendMessage(event.peer.id, msg, options)) {
            if (sendEvent.name === "PEER_RESPONSE") {
              this.log("sent provider record for %s to %p", key, event.peer.id);
              sent++;
            }
            events2.push(sendEvent);
          }
        } catch (err2) {
          this.log.error("error sending provide record to peer %p", event.peer.id, err2);
          events2.push(queryErrorEvent({ from: event.peer.id, error: err2 }));
        }
        return events2;
      };
    };
    yield* pipe(this.peerRouting.getClosestPeers(key.multihash.bytes, options), (source2) => map$3(source2, (event) => maybeNotifyPeer(event)), (source2) => parallel$1(source2, {
      ordered: false,
      concurrency: ALPHA
    }), async function* (source2) {
      for await (const events2 of source2) {
        yield* events2;
      }
    });
    this.log("sent provider records to %d peers", sent);
  }
  async *findProviders(key, options) {
    const toFind = this.routingTable.kBucketSize;
    const target = key.multihash.bytes;
    const id = await convertBuffer(target);
    const self2 = this;
    this.log("findProviders %c", key);
    const provs = await this.providers.getProviders(key);
    if (provs.length > 0) {
      const providers2 = [];
      for (const peerId of provs.slice(0, toFind)) {
        providers2.push({
          id: peerId,
          multiaddrs: (await this.components.peerStore.addressBook.get(peerId) ?? []).map((address) => address.multiaddr),
          protocols: []
        });
      }
      yield peerResponseEvent({ from: this.components.peerId, messageType: MESSAGE_TYPE.GET_PROVIDERS, providers: providers2 });
      yield providerEvent({ from: this.components.peerId, providers: providers2 });
    }
    if (provs.length >= toFind) {
      return;
    }
    const findProvidersQuery = async function* ({ peer, signal }) {
      const request2 = new Message$1(MESSAGE_TYPE.GET_PROVIDERS, target, 0);
      yield* self2.network.sendRequest(peer, request2, { signal });
    };
    const providers = new Set(provs.map((p) => p.toString()));
    for await (const event of this.queryManager.run(target, this.routingTable.closestPeers(id), findProvidersQuery, options)) {
      yield event;
      if (event.name === "PEER_RESPONSE") {
        this.log("Found %d provider entries for %c and %d closer peers", event.providers.length, key, event.closer.length);
        const newProviders = [];
        for (const peer of event.providers) {
          if (providers.has(peer.id.toString())) {
            continue;
          }
          providers.add(peer.id.toString());
          newProviders.push(peer);
        }
        if (newProviders.length > 0) {
          yield providerEvent({ from: event.from, providers: newProviders });
        }
        if (providers.size === toFind) {
          return;
        }
      }
    }
  }
}
class PeerDistanceList {
  constructor(originDhtKey, capacity) {
    this.originDhtKey = originDhtKey;
    this.capacity = capacity;
    this.peerDistances = [];
  }
  get length() {
    return this.peerDistances.length;
  }
  get peers() {
    return this.peerDistances.map((pd) => pd.peerId);
  }
  async add(peerId) {
    if (this.peerDistances.find((pd) => pd.peerId.equals(peerId)) != null) {
      return;
    }
    const dhtKey = await convertPeerId(peerId);
    const el = {
      peerId,
      distance: xor(this.originDhtKey, dhtKey)
    };
    this.peerDistances.push(el);
    this.peerDistances.sort((a, b2) => compare$1(a.distance, b2.distance));
    this.peerDistances = this.peerDistances.slice(0, this.capacity);
  }
  async anyCloser(peerIds) {
    if (peerIds.length === 0) {
      return false;
    }
    if (this.length === 0) {
      return true;
    }
    const dhtKeys = await Promise.all(peerIds.map(convertPeerId));
    const furthestDistance = this.peerDistances[this.peerDistances.length - 1].distance;
    for (const dhtKey of dhtKeys) {
      const keyDistance = xor(this.originDhtKey, dhtKey);
      if (compare$1(keyDistance, furthestDistance) < 0) {
        return true;
      }
    }
    return false;
  }
}
class PeerRouting {
  constructor(components, init2) {
    const { routingTable, network, validators: validators2, queryManager, lan } = init2;
    this.components = components;
    this.routingTable = routingTable;
    this.network = network;
    this.validators = validators2;
    this.queryManager = queryManager;
    this.log = logger$1(`libp2p:kad-dht:${lan ? "lan" : "wan"}:peer-routing`);
  }
  async findPeerLocal(peer) {
    let peerData;
    const p = await this.routingTable.find(peer);
    if (p != null) {
      this.log("findPeerLocal found %p in routing table", peer);
      try {
        peerData = await this.components.peerStore.get(p);
      } catch (err2) {
        if (err2.code !== "ERR_NOT_FOUND") {
          throw err2;
        }
      }
    }
    if (peerData == null) {
      try {
        peerData = await this.components.peerStore.get(peer);
      } catch (err2) {
        if (err2.code !== "ERR_NOT_FOUND") {
          throw err2;
        }
      }
    }
    if (peerData != null) {
      this.log("findPeerLocal found %p in peer store", peer);
      return {
        id: peerData.id,
        multiaddrs: peerData.addresses.map((address) => address.multiaddr),
        protocols: []
      };
    }
    return void 0;
  }
  async *_getValueSingle(peer, key, options = {}) {
    const msg = new Message$1(MESSAGE_TYPE.GET_VALUE, key, 0);
    yield* this.network.sendRequest(peer, msg, options);
  }
  async *getPublicKeyFromNode(peer, options = {}) {
    const pkKey = keyForPublicKey(peer);
    for await (const event of this._getValueSingle(peer, pkKey, options)) {
      yield event;
      if (event.name === "PEER_RESPONSE" && event.record != null) {
        const recPeer = await peerIdFromKeys(marshalPublicKey({ bytes: event.record.value }));
        if (!recPeer.equals(peer)) {
          throw errCode(new Error("public key does not match id"), "ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID");
        }
        if (recPeer.publicKey == null) {
          throw errCode(new Error("public key missing"), "ERR_PUBLIC_KEY_MISSING");
        }
        yield valueEvent({ from: peer, value: recPeer.publicKey });
      }
    }
    throw errCode(new Error(`Node not responding with its public key: ${peer.toString()}`), "ERR_INVALID_RECORD");
  }
  async *findPeer(id, options = {}) {
    this.log("findPeer %p", id);
    const pi = await this.findPeerLocal(id);
    if (pi != null) {
      this.log("found local");
      yield finalPeerEvent({
        from: this.components.peerId,
        peer: pi
      });
      return;
    }
    const key = await convertPeerId(id);
    const peers = this.routingTable.closestPeers(key);
    const match = peers.find((p) => p.equals(id));
    if (match != null) {
      try {
        const peer = await this.components.peerStore.get(id);
        this.log("found in peerStore");
        yield finalPeerEvent({
          from: this.components.peerId,
          peer: {
            id: peer.id,
            multiaddrs: peer.addresses.map((address) => address.multiaddr),
            protocols: []
          }
        });
        return;
      } catch (err2) {
        if (err2.code !== "ERR_NOT_FOUND") {
          throw err2;
        }
      }
    }
    const self2 = this;
    const findPeerQuery = async function* ({ peer, signal }) {
      const request2 = new Message$1(MESSAGE_TYPE.FIND_NODE, id.toBytes(), 0);
      for await (const event of self2.network.sendRequest(peer, request2, { signal })) {
        yield event;
        if (event.name === "PEER_RESPONSE") {
          const match2 = event.closer.find((p) => p.id.equals(id));
          if (match2 != null) {
            yield finalPeerEvent({ from: event.from, peer: match2 });
          }
        }
      }
    };
    let foundPeer = false;
    for await (const event of this.queryManager.run(id.toBytes(), peers, findPeerQuery, options)) {
      if (event.name === "FINAL_PEER") {
        foundPeer = true;
      }
      yield event;
    }
    if (!foundPeer) {
      yield queryErrorEvent({ from: this.components.peerId, error: errCode(new Error("Not found"), "ERR_NOT_FOUND") });
    }
  }
  async *getClosestPeers(key, options = {}) {
    this.log("getClosestPeers to %b", key);
    const id = await convertBuffer(key);
    const tablePeers = this.routingTable.closestPeers(id);
    const self2 = this;
    const peers = new PeerDistanceList(id, this.routingTable.kBucketSize);
    await Promise.all(tablePeers.map(async (peer) => await peers.add(peer)));
    const getCloserPeersQuery = async function* ({ peer, signal }) {
      self2.log("closerPeersSingle %s from %p", toString$5(key, "base32"), peer);
      const request2 = new Message$1(MESSAGE_TYPE.FIND_NODE, key, 0);
      yield* self2.network.sendRequest(peer, request2, { signal });
    };
    for await (const event of this.queryManager.run(key, tablePeers, getCloserPeersQuery, options)) {
      yield event;
      if (event.name === "PEER_RESPONSE") {
        await Promise.all(event.closer.map(async (peerData) => await peers.add(peerData.id)));
      }
    }
    this.log("found %d peers close to %b", peers.length, key);
    for (const peer of peers.peers) {
      yield finalPeerEvent({
        from: this.components.peerId,
        peer: {
          id: peer,
          multiaddrs: (await this.components.peerStore.addressBook.get(peer) ?? []).map((addr) => addr.multiaddr),
          protocols: []
        }
      });
    }
  }
  async *getValueOrPeers(peer, key, options = {}) {
    for await (const event of this._getValueSingle(peer, key, options)) {
      if (event.name === "PEER_RESPONSE") {
        if (event.record != null) {
          try {
            await this._verifyRecordOnline(event.record);
          } catch (err2) {
            const errMsg = "invalid record received, discarded";
            this.log(errMsg);
            yield queryErrorEvent({ from: event.from, error: errCode(new Error(errMsg), "ERR_INVALID_RECORD") });
            continue;
          }
        }
      }
      yield event;
    }
  }
  async _verifyRecordOnline(record) {
    if (record.timeReceived == null) {
      throw errCode(new Error("invalid record received"), "ERR_INVALID_RECORD");
    }
    await verifyRecord(this.validators, new Libp2pRecord(record.key, record.value, record.timeReceived));
  }
  async getCloserPeersOffline(key, closerThan) {
    const id = await convertBuffer(key);
    const ids = this.routingTable.closestPeers(id);
    const output = [];
    for (const peerId of ids) {
      if (peerId.equals(closerThan)) {
        continue;
      }
      try {
        const addresses = await this.components.peerStore.addressBook.get(peerId);
        const protocols = await this.components.peerStore.protoBook.get(peerId);
        output.push({
          id: peerId,
          multiaddrs: addresses.map((address) => address.multiaddr),
          protocols
        });
      } catch (err2) {
        if (err2.code !== "ERR_NOT_FOUND") {
          throw err2;
        }
      }
    }
    if (output.length > 0) {
      this.log("getCloserPeersOffline found %d peer(s) closer to %b than %p", output.length, key, closerThan);
    } else {
      this.log("getCloserPeersOffline could not find peer closer to %b than %p", key, closerThan);
    }
    return output;
  }
}
const log$e = logger$1("libp2p:kad-dht:providers");
class Providers {
  constructor(components, init2 = {}) {
    const { cacheSize, cleanupInterval, provideValidity } = init2;
    this.components = components;
    this.cleanupInterval = cleanupInterval ?? PROVIDERS_CLEANUP_INTERVAL;
    this.provideValidity = provideValidity ?? PROVIDERS_VALIDITY;
    this.cache = hashlru(cacheSize ?? PROVIDERS_LRU_CACHE_SIZE);
    this.syncQueue = new PQueue({ concurrency: 1 });
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.started) {
      return;
    }
    this.started = true;
    this.cleaner = setInterval(() => {
      this._cleanup().catch((err2) => {
        log$e.error(err2);
      });
    }, this.cleanupInterval);
  }
  async stop() {
    this.started = false;
    if (this.cleaner != null) {
      clearInterval(this.cleaner);
      this.cleaner = void 0;
    }
  }
  async _cleanup() {
    return await this.syncQueue.add(async () => {
      const start = Date.now();
      let count = 0;
      let deleteCount = 0;
      const deleted = /* @__PURE__ */ new Map();
      const batch2 = this.components.datastore.batch();
      const query = this.components.datastore.query({ prefix: PROVIDER_KEY_PREFIX });
      for await (const entry of query) {
        try {
          const { cid, peerId } = parseProviderKey(entry.key);
          const time = readTime(entry.value).getTime();
          const now = Date.now();
          const delta = now - time;
          const expired = delta > this.provideValidity;
          log$e("comparing: %d - %d = %d > %d %s", now, time, delta, this.provideValidity, expired ? "(expired)" : "");
          if (expired) {
            deleteCount++;
            batch2.delete(entry.key);
            const peers = deleted.get(cid) ?? /* @__PURE__ */ new Set();
            peers.add(peerId);
            deleted.set(cid, peers);
          }
          count++;
        } catch (err2) {
          log$e.error(err2.message);
        }
      }
      if (deleted.size > 0) {
        log$e("deleting %d / %d entries", deleteCount, count);
        await batch2.commit();
      } else {
        log$e("nothing to delete");
      }
      for (const [cid, peers] of deleted) {
        const key = makeProviderKey(cid);
        const provs = this.cache.get(key);
        if (provs != null) {
          for (const peerId of peers) {
            provs.delete(peerId);
          }
          if (provs.size === 0) {
            this.cache.remove(key);
          } else {
            this.cache.set(key, provs);
          }
        }
      }
      log$e("Cleanup successful (%dms)", Date.now() - start);
    });
  }
  async _getProvidersMap(cid) {
    const cacheKey = makeProviderKey(cid);
    let provs = this.cache.get(cacheKey);
    if (provs == null) {
      provs = await loadProviders(this.components.datastore, cid);
      this.cache.set(cacheKey, provs);
    }
    return provs;
  }
  async addProvider(cid, provider) {
    return await this.syncQueue.add(async () => {
      log$e("%p provides %s", provider, cid);
      const provs = await this._getProvidersMap(cid);
      log$e("loaded %s provs", provs.size);
      const now = new Date();
      provs.set(provider.toString(), now);
      const dsKey = makeProviderKey(cid);
      this.cache.set(dsKey, provs);
      await writeProviderEntry(this.components.datastore, cid, provider, now);
    });
  }
  async getProviders(cid) {
    return await this.syncQueue.add(async () => {
      log$e("get providers for %s", cid);
      const provs = await this._getProvidersMap(cid);
      return [...provs.keys()].map((peerIdStr) => {
        return peerIdFromString(peerIdStr);
      });
    });
  }
}
function makeProviderKey(cid) {
  const cidStr = typeof cid === "string" ? cid : toString$5(cid.multihash.bytes, "base32");
  return `${PROVIDER_KEY_PREFIX}/${cidStr}`;
}
async function writeProviderEntry(store, cid, peer, time) {
  const dsKey = [
    makeProviderKey(cid),
    "/",
    peer.toString()
  ].join("");
  const key = new Key(dsKey);
  const buffer2 = Uint8Array.from(varint$3.encode(time.getTime()));
  return await store.put(key, buffer2);
}
function parseProviderKey(key) {
  const parts2 = key.toString().split("/");
  if (parts2.length !== 5) {
    throw new Error(`incorrectly formatted provider entry key in datastore: ${key.toString()}`);
  }
  return {
    cid: parts2[3],
    peerId: parts2[4]
  };
}
async function loadProviders(store, cid) {
  const providers = /* @__PURE__ */ new Map();
  const query = store.query({ prefix: makeProviderKey(cid) });
  for await (const entry of query) {
    const { peerId } = parseProviderKey(entry.key);
    providers.set(peerId, readTime(entry.value));
  }
  return providers;
}
function readTime(buf2) {
  return new Date(varint$3.decode(buf2));
}
const MAX_XOR = BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF");
async function* queryPath(options) {
  const { key, startingPeer, ourPeerId, signal, query, alpha, pathIndex, numPaths, cleanUp, queryFuncTimeout, log: log2, peersSeen } = options;
  const queue = new PQueue({
    concurrency: alpha
  });
  const kadId = await convertBuffer(key);
  function queryPeer(peer, peerKadId) {
    if (peer == null) {
      return;
    }
    peersSeen.add(peer);
    const peerXor = BigInt("0x" + toString$5(xor(peerKadId, kadId), "base16"));
    queue.add(async () => {
      let timeout2;
      const signals = [signal];
      if (queryFuncTimeout != null) {
        timeout2 = new timeoutAbortController.TimeoutController(queryFuncTimeout);
        signals.push(timeout2.signal);
      }
      const compoundSignal = anySignal_2(signals);
      try {
        for await (const event of query({
          key,
          peer,
          signal: compoundSignal,
          pathIndex,
          numPaths
        })) {
          if (compoundSignal.aborted) {
            return;
          }
          if (event.name === "PEER_RESPONSE") {
            for (const closerPeer of event.closer) {
              if (peersSeen.has(closerPeer.id)) {
                log2("already seen %p in query", closerPeer.id);
                continue;
              }
              if (ourPeerId.equals(closerPeer.id)) {
                log2("not querying ourselves");
                continue;
              }
              const closerPeerKadId = await convertPeerId(closerPeer.id);
              const closerPeerXor = BigInt("0x" + toString$5(xor(closerPeerKadId, kadId), "base16"));
              if (closerPeerXor > peerXor) {
                log2("skipping %p as they are not closer to %b than %p", closerPeer.id, key, peer);
                continue;
              }
              log2("querying closer peer %p", closerPeer.id);
              queryPeer(closerPeer.id, closerPeerKadId);
            }
          }
          queue.emit("completed", event);
        }
        timeout2?.clear();
      } catch (err2) {
        if (signal.aborted) {
          queue.emit("error", err2);
        } else {
          queue.emit("completed", queryErrorEvent({
            from: peer,
            error: err2
          }));
        }
      } finally {
        timeout2?.clear();
      }
    }, {
      priority: MAX_XOR - peerXor
    }).catch((err2) => {
      log2.error(err2);
    });
  }
  queryPeer(startingPeer, await convertPeerId(startingPeer));
  yield* toGenerator(queue, signal, cleanUp, log2);
}
async function* toGenerator(queue, signal, cleanUp, log2) {
  let deferred = pDefer$1();
  let running = true;
  const results = [];
  const cleanup = () => {
    if (!running) {
      return;
    }
    log2("clean up queue, results %d, queue size %d, pending tasks %d", results.length, queue.size, queue.pending);
    running = false;
    queue.clear();
    results.splice(0, results.length);
  };
  queue.on("completed", (result) => {
    results.push(result);
    deferred.resolve();
  });
  queue.on("error", (err2) => {
    log2("queue error", err2);
    cleanup();
    deferred.reject(err2);
  });
  queue.on("idle", () => {
    log2("queue idle");
    running = false;
    deferred.resolve();
  });
  signal.addEventListener("abort", () => {
    log2("abort queue");
    const wasRunning = running;
    cleanup();
    if (wasRunning) {
      deferred.reject(errCode(new Error("Query aborted"), "ERR_QUERY_ABORTED"));
    }
  });
  cleanUp.addEventListener("cleanup", () => {
    cleanup();
    deferred.resolve();
  });
  while (running) {
    await deferred.promise;
    deferred = pDefer$1();
    while (results.length > 0) {
      const result = results.shift();
      if (result != null) {
        yield result;
      }
    }
  }
  yield* results;
}
const METRIC_RUNNING_QUERIES = "running-queries";
class QueryManager {
  constructor(components, init2) {
    const { lan = false, disjointPaths = K, alpha = ALPHA } = init2;
    this.components = components;
    this.disjointPaths = disjointPaths ?? K;
    this.controllers = /* @__PURE__ */ new Set();
    this.running = false;
    this.alpha = alpha ?? ALPHA;
    this.lan = lan;
    this.queries = 0;
  }
  isStarted() {
    return this.running;
  }
  async start() {
    this.running = true;
  }
  async stop() {
    this.running = false;
    for (const controller of this.controllers) {
      controller.abort();
    }
    this.controllers.clear();
  }
  async *run(key, peers, queryFunc, options = {}) {
    if (!this.running) {
      throw new Error("QueryManager not started");
    }
    let timeoutController;
    if (options.signal == null) {
      timeoutController = new timeoutAbortController.TimeoutController(DEFAULT_QUERY_TIMEOUT);
      options.signal = timeoutController.signal;
      try {
        if (events.exports.setMaxListeners != null) {
          events.exports.setMaxListeners(Infinity, timeoutController.signal);
        }
      } catch {
      }
    }
    const abortController = new AbortController();
    this.controllers.add(abortController);
    const signals = [abortController.signal];
    if (options.signal != null) {
      signals.push(options.signal);
    }
    const signal = anySignal_2(signals);
    try {
      if (events.exports.setMaxListeners != null) {
        events.exports.setMaxListeners(Infinity, signal);
      }
    } catch {
    }
    const log2 = logger$1(`libp2p:kad-dht:${this.lan ? "lan" : "wan"}:query:` + toString$5(key, "base58btc"));
    const peersToQuery = peers.slice(0, Math.min(this.disjointPaths, peers.length));
    const startTime = Date.now();
    const cleanUp = new EventEmitter$1();
    try {
      log2("query:start");
      this.queries++;
      this.components.metrics?.updateComponentMetric({
        system: "libp2p",
        component: `kad-dht-${this.lan ? "lan" : "wan"}`,
        metric: METRIC_RUNNING_QUERIES,
        value: this.queries
      });
      if (peers.length === 0) {
        log2.error("Running query with no peers");
        return;
      }
      const peersSeen = new PeerSet();
      const paths = peersToQuery.map((peer, index) => {
        return queryPath({
          key,
          startingPeer: peer,
          ourPeerId: this.components.peerId,
          signal,
          query: queryFunc,
          pathIndex: index,
          numPaths: peersToQuery.length,
          alpha: this.alpha,
          cleanUp,
          queryFuncTimeout: options.queryFuncTimeout,
          log: log2,
          peersSeen
        });
      });
      for await (const event of merge$1(...paths)) {
        yield event;
        if (event.name === "QUERY_ERROR") {
          log2("error", event.error);
        }
      }
    } catch (err2) {
      if (!this.running && err2.code === "ERR_QUERY_ABORTED")
        ;
      else {
        throw err2;
      }
    } finally {
      this.controllers.delete(abortController);
      if (timeoutController != null) {
        timeoutController.clear();
      }
      this.queries--;
      this.components.metrics?.updateComponentMetric({
        system: "libp2p",
        component: `kad-dht-${this.lan ? "lan" : "wan"}`,
        metric: METRIC_RUNNING_QUERIES,
        value: this.queries
      });
      cleanUp.dispatchEvent(new CustomEvent("cleanup"));
      log2("query:done in %dms", Date.now() - startTime);
    }
  }
}
const log$d = logger$1("libp2p:kad-dht:rpc:handlers:add-provider");
class AddProviderHandler {
  constructor(init2) {
    const { providers } = init2;
    this.providers = providers;
  }
  async handle(peerId, msg) {
    log$d("start");
    if (msg.key == null || msg.key.length === 0) {
      throw errCode(new Error("Missing key"), "ERR_MISSING_KEY");
    }
    let cid;
    try {
      cid = CID.decode(msg.key);
    } catch (err2) {
      throw errCode(new Error("Invalid CID"), "ERR_INVALID_CID");
    }
    if (msg.providerPeers == null || msg.providerPeers.length === 0) {
      log$d.error("no providers found in message");
    }
    await Promise.all(msg.providerPeers.map(async (pi) => {
      if (!pi.id.equals(peerId)) {
        log$d("invalid provider peer %p from %p", pi.id, peerId);
        return;
      }
      if (pi.multiaddrs.length < 1) {
        log$d("no valid addresses for provider %p. Ignore", peerId);
        return;
      }
      log$d("received provider %p for %s (addrs %s)", peerId, cid, pi.multiaddrs.map((m) => m.toString()));
      await this.providers.addProvider(cid, pi.id);
    }));
    return void 0;
  }
}
const log$c = logger$1("libp2p:kad-dht:rpc:handlers:find-node");
class FindNodeHandler {
  constructor(components, init2) {
    const { peerRouting, lan } = init2;
    this.components = components;
    this.peerRouting = peerRouting;
    this.lan = Boolean(lan);
  }
  async handle(peerId, msg) {
    log$c("incoming request from %p for peers closer to %b", peerId, msg.key);
    let closer = [];
    if (equals$1(this.components.peerId.toBytes(), msg.key)) {
      closer = [{
        id: this.components.peerId,
        multiaddrs: this.components.addressManager.getAddresses().map((ma) => ma.decapsulateCode(getProtocol("p2p").code)),
        protocols: []
      }];
    } else {
      closer = await this.peerRouting.getCloserPeersOffline(msg.key, peerId);
    }
    closer = closer.map(this.lan ? removePublicAddresses : removePrivateAddresses).filter(({ multiaddrs }) => multiaddrs.length);
    const response = new Message$1(msg.type, new Uint8Array(0), msg.clusterLevel);
    if (closer.length > 0) {
      response.closerPeers = closer;
    } else {
      log$c("could not find any peers closer to %b than %p", msg.key, peerId);
    }
    return response;
  }
}
const log$b = logger$1("libp2p:kad-dht:rpc:handlers:get-providers");
class GetProvidersHandler {
  constructor(components, init2) {
    const { peerRouting, providers, lan } = init2;
    this.components = components;
    this.peerRouting = peerRouting;
    this.providers = providers;
    this.lan = Boolean(lan);
  }
  async handle(peerId, msg) {
    let cid;
    try {
      cid = CID.decode(msg.key);
    } catch (err2) {
      throw errCode(new Error("Invalid CID"), "ERR_INVALID_CID");
    }
    log$b("%p asking for providers for %s", peerId, cid);
    const [peers, closer] = await Promise.all([
      this.providers.getProviders(cid),
      this.peerRouting.getCloserPeersOffline(msg.key, peerId)
    ]);
    const providerPeers = await this._getPeers(peers);
    const closerPeers = await this._getPeers(closer.map(({ id }) => id));
    const response = new Message$1(msg.type, msg.key, msg.clusterLevel);
    if (providerPeers.length > 0) {
      response.providerPeers = providerPeers;
    }
    if (closerPeers.length > 0) {
      response.closerPeers = closerPeers;
    }
    log$b("got %s providers %s closerPeers", providerPeers.length, closerPeers.length);
    return response;
  }
  async _getAddresses(peerId) {
    const addrs = await this.components.peerStore.addressBook.get(peerId);
    return addrs.map((address) => address.multiaddr);
  }
  async _getPeers(peerIds) {
    const output = [];
    const addrFilter = this.lan ? removePublicAddresses : removePrivateAddresses;
    for (const peerId of peerIds) {
      const peer = addrFilter({
        id: peerId,
        multiaddrs: await this._getAddresses(peerId),
        protocols: []
      });
      if (peer.multiaddrs.length > 0) {
        output.push(peer);
      }
    }
    return output;
  }
}
const log$a = logger$1("libp2p:kad-dht:rpc:handlers:get-value");
class GetValueHandler {
  constructor(components, init2) {
    const { peerRouting } = init2;
    this.components = components;
    this.peerRouting = peerRouting;
  }
  async handle(peerId, msg) {
    const key = msg.key;
    log$a("%p asked for key %b", peerId, key);
    if (key == null || key.length === 0) {
      throw errCode(new Error("Invalid key"), "ERR_INVALID_KEY");
    }
    const response = new Message$1(MESSAGE_TYPE.GET_VALUE, key, msg.clusterLevel);
    if (isPublicKeyKey(key)) {
      log$a("is public key");
      const idFromKey = fromPublicKeyKey(key);
      let pubKey;
      try {
        const key2 = await this.components.peerStore.keyBook.get(idFromKey);
        if (key2 == null) {
          throw errCode(new Error("No public key found in key book"), "ERR_NOT_FOUND");
        }
        pubKey = key2;
      } catch (err2) {
        if (err2.code !== "ERR_NOT_FOUND") {
          throw err2;
        }
      }
      if (pubKey != null) {
        log$a("returning found public key");
        response.record = new Libp2pRecord(key, pubKey, new Date());
        return response;
      }
    }
    const [record, closer] = await Promise.all([
      this._checkLocalDatastore(key),
      this.peerRouting.getCloserPeersOffline(msg.key, peerId)
    ]);
    if (record != null) {
      log$a("had record for %b in local datastore", key);
      response.record = record;
    }
    if (closer.length > 0) {
      log$a("had %s closer peers in routing table", closer.length);
      response.closerPeers = closer;
    }
    return response;
  }
  async _checkLocalDatastore(key) {
    log$a("checkLocalDatastore looking for %b", key);
    const dsKey = bufferToRecordKey(key);
    let rawRecord;
    try {
      rawRecord = await this.components.datastore.get(dsKey);
    } catch (err2) {
      if (err2.code === "ERR_NOT_FOUND") {
        return void 0;
      }
      throw err2;
    }
    const record = Libp2pRecord.deserialize(rawRecord);
    if (record == null) {
      throw errCode(new Error("Invalid record"), "ERR_INVALID_RECORD");
    }
    if (record.timeReceived == null || Date.now() - record.timeReceived.getTime() > MAX_RECORD_AGE) {
      await this.components.datastore.delete(dsKey);
      return void 0;
    }
    return record;
  }
}
const log$9 = logger$1("libp2p:kad-dht:rpc:handlers:ping");
class PingHandler {
  async handle(peerId, msg) {
    log$9("ping from %p", peerId);
    return msg;
  }
}
class PutValueHandler {
  constructor(components, init2) {
    const { validators: validators2 } = init2;
    this.components = components;
    this.log = logger$1("libp2p:kad-dht:rpc:handlers:put-value");
    this.validators = validators2;
  }
  async handle(peerId, msg) {
    const key = msg.key;
    this.log("%p asked us to store value for key %b", peerId, key);
    const record = msg.record;
    if (record == null) {
      const errMsg = `Empty record from: ${peerId.toString()}`;
      this.log.error(errMsg);
      throw errCode(new Error(errMsg), "ERR_EMPTY_RECORD");
    }
    try {
      await verifyRecord(this.validators, record);
      record.timeReceived = new Date();
      const recordKey = bufferToRecordKey(record.key);
      await this.components.datastore.put(recordKey, record.serialize().subarray());
      this.log("put record for %b into datastore under key %k", key, recordKey);
    } catch (err2) {
      this.log("did not put record for key %b into datastore %o", key, err2);
    }
    return msg;
  }
}
class RPC {
  constructor(components, init2) {
    const { providers, peerRouting, validators: validators2, lan } = init2;
    this.log = logger$1("libp2p:kad-dht:rpc");
    this.routingTable = init2.routingTable;
    this.handlers = {
      [MESSAGE_TYPE.GET_VALUE]: new GetValueHandler(components, { peerRouting }),
      [MESSAGE_TYPE.PUT_VALUE]: new PutValueHandler(components, { validators: validators2 }),
      [MESSAGE_TYPE.FIND_NODE]: new FindNodeHandler(components, { peerRouting, lan }),
      [MESSAGE_TYPE.ADD_PROVIDER]: new AddProviderHandler({ providers }),
      [MESSAGE_TYPE.GET_PROVIDERS]: new GetProvidersHandler(components, { peerRouting, providers, lan }),
      [MESSAGE_TYPE.PING]: new PingHandler()
    };
  }
  async handleMessage(peerId, msg) {
    try {
      await this.routingTable.add(peerId);
    } catch (err2) {
      this.log.error("Failed to update the kbucket store", err2);
    }
    const handler = this.handlers[msg.type];
    if (handler == null) {
      this.log.error(`no handler found for message type: ${msg.type}`);
      return;
    }
    return await handler.handle(peerId, msg);
  }
  onIncomingStream(data) {
    Promise.resolve().then(async () => {
      const { stream: stream2, connection } = data;
      const peerId = connection.remotePeer;
      try {
        await this.routingTable.add(peerId);
      } catch (err2) {
        this.log.error(err2);
      }
      const self2 = this;
      await pipe(stream2, decode$3(), async function* (source2) {
        for await (const msg of source2) {
          const desMessage = Message$1.deserialize(msg);
          self2.log("incoming %s from %p", desMessage.type, peerId);
          const res = await self2.handleMessage(peerId, desMessage);
          if (res != null) {
            yield res.serialize();
          }
        }
      }, encode$5(), stream2);
    }).catch((err2) => {
      this.log.error(err2);
    });
  }
}
class TopologyListener extends EventEmitter$1 {
  constructor(components, init2) {
    super();
    const { protocol: protocol2, lan } = init2;
    this.components = components;
    this.log = logger$1(`libp2p:kad-dht:topology-listener:${lan ? "lan" : "wan"}`);
    this.running = false;
    this.protocol = protocol2;
  }
  isStarted() {
    return this.running;
  }
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
    const topology = createTopology({
      onConnect: (peerId) => {
        this.log("observed peer %p with protocol %s", peerId, this.protocol);
        this.dispatchEvent(new CustomEvent("peer", {
          detail: peerId
        }));
      }
    });
    this.registrarId = await this.components.registrar.register(this.protocol, topology);
  }
  stop() {
    this.running = false;
    if (this.registrarId != null) {
      this.components.registrar.unregister(this.registrarId);
      this.registrarId = void 0;
    }
  }
}
class QuerySelf {
  constructor(components, init2) {
    const { peerRouting, lan, count, interval, queryTimeout } = init2;
    this.components = components;
    this.log = logger$1(`libp2p:kad-dht:${lan ? "lan" : "wan"}:query-self`);
    this.running = false;
    this.peerRouting = peerRouting;
    this.count = count ?? K;
    this.interval = interval ?? QUERY_SELF_INTERVAL;
    this.queryTimeout = queryTimeout ?? QUERY_SELF_TIMEOUT;
  }
  isStarted() {
    return this.running;
  }
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
    this._querySelf();
  }
  async stop() {
    this.running = false;
    if (this.timeoutId != null) {
      clearTimeout(this.timeoutId);
    }
    if (this.controller != null) {
      this.controller.abort();
    }
  }
  _querySelf() {
    Promise.resolve().then(async () => {
      const timeoutController = new timeoutAbortController.TimeoutController(this.queryTimeout);
      try {
        this.controller = new AbortController();
        const signal = anySignal_2([this.controller.signal, timeoutController.signal]);
        try {
          if (events.exports.setMaxListeners != null) {
            events.exports.setMaxListeners(Infinity, signal);
          }
        } catch {
        }
        const found = await pipe(this.peerRouting.getClosestPeers(this.components.peerId.toBytes(), {
          signal
        }), (source2) => take(source2, this.count), async (source2) => await length$3(source2));
        this.log("query ran successfully - found %d peers", found);
      } catch (err2) {
        this.log("query error", err2);
      } finally {
        this.timeoutId = setTimeout(this._querySelf.bind(this), this.interval);
        timeoutController.clear();
      }
    }).catch((err2) => {
      this.log("query error", err2);
    });
  }
}
const DEFAULT_MAX_INBOUND_STREAMS$1 = 32;
const DEFAULT_MAX_OUTBOUND_STREAMS$1 = 64;
class KadDHT$1 extends EventEmitter$1 {
  constructor(components, init2) {
    super();
    const { kBucketSize, clientMode, validators: validators$1, selectors: selectors$1, querySelfInterval, lan, protocolPrefix, pingTimeout, pingConcurrency, maxInboundStreams, maxOutboundStreams } = init2;
    this.running = false;
    this.components = components;
    this.lan = Boolean(lan);
    this.log = logger$1(`libp2p:kad-dht:${lan === true ? "lan" : "wan"}`);
    this.protocol = `${protocolPrefix ?? PROTOCOL_PREFIX}${lan === true ? LAN_PREFIX : ""}${PROTOCOL_DHT}`;
    this.kBucketSize = kBucketSize ?? 20;
    this.clientMode = clientMode ?? true;
    this.maxInboundStreams = maxInboundStreams ?? DEFAULT_MAX_INBOUND_STREAMS$1;
    this.maxOutboundStreams = maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS$1;
    this.routingTable = new RoutingTable(components, {
      kBucketSize,
      lan: this.lan,
      pingTimeout,
      pingConcurrency,
      protocol: this.protocol
    });
    this.providers = new Providers(components);
    this.validators = {
      ...validators,
      ...validators$1
    };
    this.selectors = {
      ...selectors,
      ...selectors$1
    };
    this.network = new Network$2(components, {
      protocol: this.protocol,
      lan: this.lan
    });
    this.queryManager = new QueryManager(components, {
      disjointPaths: Math.ceil(this.kBucketSize / 2),
      lan
    });
    this.peerRouting = new PeerRouting(components, {
      routingTable: this.routingTable,
      network: this.network,
      validators: this.validators,
      queryManager: this.queryManager,
      lan: this.lan
    });
    this.contentFetching = new ContentFetching(components, {
      validators: this.validators,
      selectors: this.selectors,
      peerRouting: this.peerRouting,
      queryManager: this.queryManager,
      routingTable: this.routingTable,
      network: this.network,
      lan: this.lan
    });
    this.contentRouting = new ContentRouting(components, {
      network: this.network,
      peerRouting: this.peerRouting,
      queryManager: this.queryManager,
      routingTable: this.routingTable,
      providers: this.providers,
      lan: this.lan
    });
    this.routingTableRefresh = new RoutingTableRefresh({
      peerRouting: this.peerRouting,
      routingTable: this.routingTable,
      lan: this.lan
    });
    this.rpc = new RPC(components, {
      routingTable: this.routingTable,
      providers: this.providers,
      peerRouting: this.peerRouting,
      validators: this.validators,
      lan: this.lan
    });
    this.topologyListener = new TopologyListener(components, {
      protocol: this.protocol,
      lan: this.lan
    });
    this.querySelf = new QuerySelf(components, {
      peerRouting: this.peerRouting,
      interval: querySelfInterval,
      lan: this.lan
    });
    this.network.addEventListener("peer", (evt) => {
      const peerData = evt.detail;
      this.onPeerConnect(peerData).catch((err2) => {
        this.log.error("could not add %p to routing table", peerData.id, err2);
      });
      this.dispatchEvent(new CustomEvent("peer", {
        detail: peerData
      }));
    });
    this.topologyListener.addEventListener("peer", (evt) => {
      const peerId = evt.detail;
      Promise.resolve().then(async () => {
        const multiaddrs = await this.components.peerStore.addressBook.get(peerId);
        const peerData = {
          id: peerId,
          multiaddrs: multiaddrs.map((addr) => addr.multiaddr),
          protocols: []
        };
        await this.onPeerConnect(peerData);
      }).catch((err2) => {
        this.log.error("could not add %p to routing table", peerId, err2);
      });
    });
  }
  get [symbol$1]() {
    return true;
  }
  get [Symbol.toStringTag]() {
    return "@libp2p/kad-dht";
  }
  async onPeerConnect(peerData) {
    this.log("peer %p connected with protocols %s", peerData.id, peerData.protocols);
    if (this.lan) {
      peerData = removePublicAddresses(peerData);
    } else {
      peerData = removePrivateAddresses(peerData);
    }
    if (peerData.multiaddrs.length === 0) {
      this.log("ignoring %p as they do not have any %s addresses in %s", peerData.id, this.lan ? "private" : "public", peerData.multiaddrs.map((addr) => addr.toString()));
      return;
    }
    try {
      await this.routingTable.add(peerData.id);
    } catch (err2) {
      this.log.error("could not add %p to routing table", peerData.id, err2);
    }
  }
  isStarted() {
    return this.running;
  }
  async getMode() {
    return this.clientMode ? "client" : "server";
  }
  async setMode(mode) {
    await this.components.registrar.unhandle(this.protocol);
    if (mode === "client") {
      this.log("enabling client mode");
      this.clientMode = true;
    } else {
      this.log("enabling server mode");
      this.clientMode = false;
      await this.components.registrar.handle(this.protocol, this.rpc.onIncomingStream.bind(this.rpc), {
        maxInboundStreams: this.maxInboundStreams,
        maxOutboundStreams: this.maxOutboundStreams
      });
    }
  }
  async start() {
    this.running = true;
    await this.setMode(this.clientMode ? "client" : "server");
    await Promise.all([
      this.providers.start(),
      this.queryManager.start(),
      this.network.start(),
      this.routingTable.start(),
      this.topologyListener.start(),
      this.querySelf.start()
    ]);
    await this.routingTableRefresh.start();
  }
  async stop() {
    this.running = false;
    await Promise.all([
      this.providers.stop(),
      this.queryManager.stop(),
      this.network.stop(),
      this.routingTable.stop(),
      this.routingTableRefresh.stop(),
      this.topologyListener.stop(),
      this.querySelf.stop()
    ]);
  }
  async *put(key, value2, options = {}) {
    yield* this.contentFetching.put(key, value2, options);
  }
  async *get(key, options = {}) {
    yield* this.contentFetching.get(key, options);
  }
  async *provide(key, options = {}) {
    yield* this.contentRouting.provide(key, this.components.addressManager.getAddresses(), options);
  }
  async *findProviders(key, options = {}) {
    yield* this.contentRouting.findProviders(key, options);
  }
  async *findPeer(id, options = {}) {
    yield* this.peerRouting.findPeer(id, options);
  }
  async *getClosestPeers(key, options = {}) {
    yield* this.peerRouting.getClosestPeers(key, options);
  }
  async refreshRoutingTable() {
    await this.routingTableRefresh.refreshTable(true);
  }
}
const log$8 = logger$1("libp2p:kad-dht");
class DualKadDHT extends EventEmitter$1 {
  constructor(components, wan, lan) {
    super();
    this.components = components;
    this.wan = wan;
    this.lan = lan;
    this.wan.addEventListener("peer", (evt) => {
      this.dispatchEvent(new CustomEvent("peer", {
        detail: evt.detail
      }));
    });
    this.lan.addEventListener("peer", (evt) => {
      this.dispatchEvent(new CustomEvent("peer", {
        detail: evt.detail
      }));
    });
  }
  get [symbol$1]() {
    return true;
  }
  get [Symbol.toStringTag]() {
    return "@libp2p/dual-kad-dht";
  }
  isStarted() {
    return this.wan.isStarted() && this.lan.isStarted();
  }
  async getMode() {
    return await this.wan.getMode();
  }
  async setMode(mode) {
    await this.wan.setMode(mode);
  }
  async start() {
    await Promise.all([
      this.lan.start(),
      this.wan.start()
    ]);
  }
  async stop() {
    await Promise.all([
      this.lan.stop(),
      this.wan.stop()
    ]);
  }
  async *put(key, value2, options = {}) {
    for await (const event of merge$1(this.lan.put(key, value2, options), this.wan.put(key, value2, options))) {
      yield event;
    }
  }
  async *get(key, options = {}) {
    let queriedPeers = false;
    let foundValue = false;
    for await (const event of merge$1(this.lan.get(key, options), this.wan.get(key, options))) {
      yield event;
      if (event.name === "DIALING_PEER") {
        queriedPeers = true;
      }
      if (event.name === "VALUE") {
        queriedPeers = true;
        if (event.value != null) {
          foundValue = true;
        }
      }
      if (event.name === "SENDING_QUERY") {
        queriedPeers = true;
      }
    }
    if (!queriedPeers) {
      throw errCode(new Error("No peers found in routing table!"), "ERR_NO_PEERS_IN_ROUTING_TABLE");
    }
    if (!foundValue) {
      yield queryErrorEvent({
        from: this.components.peerId,
        error: errCode(new Error("Not found"), "ERR_NOT_FOUND")
      });
    }
  }
  async *provide(key, options = {}) {
    let sent = 0;
    let success = 0;
    const errors2 = [];
    const dhts = [this.lan];
    if (await this.wan.getMode() === "server") {
      dhts.push(this.wan);
    }
    for await (const event of merge$1(...dhts.map((dht) => dht.provide(key, options)))) {
      yield event;
      if (event.name === "SENDING_QUERY") {
        sent++;
      }
      if (event.name === "QUERY_ERROR") {
        errors2.push(event.error);
      }
      if (event.name === "PEER_RESPONSE" && event.messageName === "ADD_PROVIDER") {
        log$8("sent provider record for %s to %p", key, event.from);
        success++;
      }
    }
    if (success === 0) {
      if (errors2.length > 0) {
        throw errCode(new Error(`Failed to provide to ${errors2.length} of ${sent} peers`), "ERR_PROVIDES_FAILED", { errors: errors2 });
      }
      throw errCode(new Error("Failed to provide - no peers found"), "ERR_PROVIDES_FAILED");
    }
  }
  async *findProviders(key, options = {}) {
    yield* merge$1(this.lan.findProviders(key, options), this.wan.findProviders(key, options));
  }
  async *findPeer(id, options = {}) {
    let queriedPeers = false;
    for await (const event of merge$1(this.lan.findPeer(id, options), this.wan.findPeer(id, options))) {
      yield event;
      if (event.name === "SENDING_QUERY" || event.name === "FINAL_PEER") {
        queriedPeers = true;
      }
    }
    if (!queriedPeers) {
      throw errCode(new Error("Peer lookup failed"), "ERR_LOOKUP_FAILED");
    }
  }
  async *getClosestPeers(key, options = {}) {
    yield* merge$1(this.lan.getClosestPeers(key, options), this.wan.getClosestPeers(key, options));
  }
  async refreshRoutingTable() {
    await Promise.all([
      this.lan.refreshRoutingTable(),
      this.wan.refreshRoutingTable()
    ]);
  }
}
class KadDHT extends DualKadDHT {
  constructor(components, init2) {
    super(components, new KadDHT$1(components, {
      protocolPrefix: "/ipfs",
      ...init2,
      lan: false
    }), new KadDHT$1(components, {
      protocolPrefix: "/ipfs",
      ...init2,
      clientMode: false,
      lan: true
    }));
  }
}
function kadDHT(init2) {
  return (components) => new KadDHT(components, init2);
}
const log$7 = logger$1("libp2p:bootstrap");
const DEFAULT_BOOTSTRAP_TAG_NAME = "bootstrap";
const DEFAULT_BOOTSTRAP_TAG_VALUE = 50;
const DEFAULT_BOOTSTRAP_TAG_TTL = 12e4;
const DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT = 1e3;
class Bootstrap extends EventEmitter$1 {
  constructor(components, options = { list: [] }) {
    if (options.list == null || options.list.length === 0) {
      throw new Error("Bootstrap requires a list of peer addresses");
    }
    super();
    this.components = components;
    this.timeout = options.timeout ?? DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT;
    this.list = [];
    for (const candidate of options.list) {
      if (!P2P.matches(candidate)) {
        log$7.error("Invalid multiaddr");
        continue;
      }
      const ma = multiaddr(candidate);
      const peerIdStr = ma.getPeerId();
      if (peerIdStr == null) {
        log$7.error("Invalid bootstrap multiaddr without peer id");
        continue;
      }
      const peerData = {
        id: peerIdFromString(peerIdStr),
        multiaddrs: [ma],
        protocols: []
      };
      this.list.push(peerData);
    }
    this._init = options;
  }
  get [symbol$1]() {
    return true;
  }
  get [Symbol.toStringTag]() {
    return "@libp2p/bootstrap";
  }
  isStarted() {
    return Boolean(this.timer);
  }
  start() {
    if (this.isStarted()) {
      return;
    }
    log$7("Starting bootstrap node discovery, discovering peers after %s ms", this.timeout);
    this.timer = setTimeout(() => {
      void this._discoverBootstrapPeers().catch((err2) => {
        log$7.error(err2);
      });
    }, this.timeout);
  }
  async _discoverBootstrapPeers() {
    if (this.timer == null) {
      return;
    }
    for (const peerData of this.list) {
      await this.components.peerStore.tagPeer(peerData.id, this._init.tagName ?? DEFAULT_BOOTSTRAP_TAG_NAME, {
        value: this._init.tagValue ?? DEFAULT_BOOTSTRAP_TAG_VALUE,
        ttl: this._init.tagTTL ?? DEFAULT_BOOTSTRAP_TAG_TTL
      });
      if (this.timer == null) {
        return;
      }
      this.dispatchEvent(new CustomEvent("peer", { detail: peerData }));
    }
  }
  stop() {
    if (this.timer != null) {
      clearTimeout(this.timer);
    }
    this.timer = void 0;
  }
}
Bootstrap.tag = "bootstrap";
function bootstrap(init2) {
  return (components) => new Bootstrap(components, init2);
}
const WebSocket$1 = WebSocket;
var dom = {};
var eventIterator = {};
Object.defineProperty(eventIterator, "__esModule", { value: true });
class EventQueue {
  constructor() {
    this.pullQueue = [];
    this.pushQueue = [];
    this.eventHandlers = {};
    this.isPaused = false;
    this.isStopped = false;
  }
  push(value2) {
    if (this.isStopped)
      return;
    const resolution = { value: value2, done: false };
    if (this.pullQueue.length) {
      const placeholder = this.pullQueue.shift();
      if (placeholder)
        placeholder.resolve(resolution);
    } else {
      this.pushQueue.push(Promise.resolve(resolution));
      if (this.highWaterMark !== void 0 && this.pushQueue.length >= this.highWaterMark && !this.isPaused) {
        this.isPaused = true;
        if (this.eventHandlers.highWater) {
          this.eventHandlers.highWater();
        } else if (console) {
          console.warn(`EventIterator queue reached ${this.pushQueue.length} items`);
        }
      }
    }
  }
  stop() {
    if (this.isStopped)
      return;
    this.isStopped = true;
    this.remove();
    for (const placeholder of this.pullQueue) {
      placeholder.resolve({ value: void 0, done: true });
    }
    this.pullQueue.length = 0;
  }
  fail(error2) {
    if (this.isStopped)
      return;
    this.isStopped = true;
    this.remove();
    if (this.pullQueue.length) {
      for (const placeholder of this.pullQueue) {
        placeholder.reject(error2);
      }
      this.pullQueue.length = 0;
    } else {
      const rejection = Promise.reject(error2);
      rejection.catch(() => {
      });
      this.pushQueue.push(rejection);
    }
  }
  remove() {
    Promise.resolve().then(() => {
      if (this.removeCallback)
        this.removeCallback();
    });
  }
  [Symbol.asyncIterator]() {
    return {
      next: (value2) => {
        const result = this.pushQueue.shift();
        if (result) {
          if (this.lowWaterMark !== void 0 && this.pushQueue.length <= this.lowWaterMark && this.isPaused) {
            this.isPaused = false;
            if (this.eventHandlers.lowWater) {
              this.eventHandlers.lowWater();
            }
          }
          return result;
        } else if (this.isStopped) {
          return Promise.resolve({ value: void 0, done: true });
        } else {
          return new Promise((resolve2, reject) => {
            this.pullQueue.push({ resolve: resolve2, reject });
          });
        }
      },
      return: () => {
        this.isStopped = true;
        this.pushQueue.length = 0;
        this.remove();
        return Promise.resolve({ value: void 0, done: true });
      }
    };
  }
}
class EventIterator$1 {
  constructor(listen, { highWaterMark = 100, lowWaterMark = 1 } = {}) {
    const queue = new EventQueue();
    queue.highWaterMark = highWaterMark;
    queue.lowWaterMark = lowWaterMark;
    queue.removeCallback = listen({
      push: (value2) => queue.push(value2),
      stop: () => queue.stop(),
      fail: (error2) => queue.fail(error2),
      on: (event, fn) => {
        queue.eventHandlers[event] = fn;
      }
    }) || (() => {
    });
    this[Symbol.asyncIterator] = () => queue[Symbol.asyncIterator]();
    Object.freeze(this);
  }
}
eventIterator.EventIterator = EventIterator$1;
eventIterator.default = EventIterator$1;
Object.defineProperty(dom, "__esModule", { value: true });
const event_iterator_1 = eventIterator;
var EventIterator = dom.EventIterator = event_iterator_1.EventIterator;
function subscribe(event, options, evOptions) {
  return new event_iterator_1.EventIterator(({ push: push3 }) => {
    this.addEventListener(event, push3, options);
    return () => this.removeEventListener(event, push3, options);
  }, evOptions);
}
dom.subscribe = subscribe;
dom.default = event_iterator_1.EventIterator;
function isArrayBuffer(obj) {
  return obj instanceof ArrayBuffer || obj?.constructor?.name === "ArrayBuffer" && typeof obj?.byteLength === "number";
}
const source = (socket) => {
  socket.binaryType = "arraybuffer";
  const connected = async () => await new Promise((resolve2, reject) => {
    if (isConnected) {
      return resolve2();
    }
    if (connError != null) {
      return reject(connError);
    }
    const cleanUp = (cont) => {
      socket.removeEventListener("open", onOpen);
      socket.removeEventListener("error", onError);
      cont();
    };
    const onOpen = () => cleanUp(resolve2);
    const onError = (event) => {
      cleanUp(() => reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`)));
    };
    socket.addEventListener("open", onOpen);
    socket.addEventListener("error", onError);
  });
  const source2 = async function* () {
    const messages2 = new EventIterator(({ push: push3, stop: stop2, fail }) => {
      const onMessage = (event) => {
        let data = null;
        if (typeof event.data === "string") {
          data = fromString$3(event.data);
        }
        if (isArrayBuffer(event.data)) {
          data = new Uint8Array(event.data);
        }
        if (event.data instanceof Uint8Array) {
          data = event.data;
        }
        if (data == null) {
          return;
        }
        push3(data);
      };
      const onError = (event) => fail(event.error ?? new Error("Socket error"));
      socket.addEventListener("message", onMessage);
      socket.addEventListener("error", onError);
      socket.addEventListener("close", stop2);
      return () => {
        socket.removeEventListener("message", onMessage);
        socket.removeEventListener("error", onError);
        socket.removeEventListener("close", stop2);
      };
    }, { highWaterMark: Infinity });
    await connected();
    for await (const chunk of messages2) {
      yield isArrayBuffer(chunk) ? new Uint8Array(chunk) : chunk;
    }
  }();
  let isConnected = socket.readyState === 1;
  let connError;
  socket.addEventListener("open", () => {
    isConnected = true;
    connError = null;
  });
  socket.addEventListener("close", () => {
    isConnected = false;
    connError = null;
  });
  socket.addEventListener("error", (event) => {
    if (!isConnected) {
      connError = event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`);
    }
  });
  return Object.assign(source2, {
    connected
  });
};
const ready = (socket) => {
  if (socket.readyState >= 2) {
    throw new Error("socket closed");
  }
  if (socket.readyState === 1) {
    return;
  }
  return new Promise((resolve2, reject) => {
    function cleanup() {
      socket.removeEventListener("open", handleOpen);
      socket.removeEventListener("error", handleErr);
    }
    function handleOpen() {
      cleanup();
      resolve2();
    }
    function handleErr(event) {
      cleanup();
      reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`));
    }
    socket.addEventListener("open", handleOpen);
    socket.addEventListener("error", handleErr);
  });
};
const sink = (socket, options) => {
  options = options ?? {};
  options.closeOnEnd = options.closeOnEnd !== false;
  const sink2 = async (source2) => {
    for await (const data of source2) {
      try {
        await ready(socket);
      } catch (err2) {
        if (err2.message === "socket closed")
          break;
        throw err2;
      }
      socket.send(data);
    }
    if (options.closeOnEnd != null && socket.readyState <= 1) {
      return await new Promise((resolve2, reject) => {
        socket.addEventListener("close", (event) => {
          if (event.wasClean || event.code === 1006) {
            resolve2();
          } else {
            const err2 = Object.assign(new Error("ws error"), { event });
            reject(err2);
          }
        });
        setTimeout(() => socket.close());
      });
    }
  };
  return sink2;
};
const duplex = (socket, options) => {
  options = options ?? {};
  const connectedSource = source(socket);
  let remoteAddress = options.remoteAddress;
  let remotePort = options.remotePort;
  if (socket.url != null) {
    try {
      const url2 = new URL(socket.url);
      remoteAddress = url2.hostname;
      remotePort = parseInt(url2.port, 10);
    } catch {
    }
  }
  if (remoteAddress == null || remotePort == null) {
    throw new Error("Remote connection did not have address and/or port");
  }
  const duplex2 = {
    sink: sink(socket, options),
    source: connectedSource,
    connected: async () => await connectedSource.connected(),
    close: async () => {
      if (socket.readyState === socket.CONNECTING || socket.readyState === socket.OPEN) {
        await new Promise((resolve2) => {
          socket.addEventListener("close", () => {
            resolve2();
          });
          socket.close();
        });
      }
    },
    destroy: () => {
      if (socket.terminate != null) {
        socket.terminate();
      } else {
        socket.close();
      }
    },
    remoteAddress,
    remotePort,
    socket
  };
  return duplex2;
};
const map = { http: "ws", https: "wss" };
const def = "ws";
const wsurl = (url2, location2) => isoUrl.relative(url2, location2, map, def);
function connect(addr, opts) {
  const location2 = typeof window === "undefined" ? "" : window.location;
  opts = opts ?? {};
  const url2 = wsurl(addr, location2.toString());
  const socket = new WebSocket$1(url2, opts.websocket);
  return duplex(socket, opts);
}
function createListener() {
  throw new Error("WebSocket Servers can not be created in the browser!");
}
const CODE_P2P = 421;
const CODE_CIRCUIT = 290;
const CODE_TCP = 6;
const CODE_WSS = 478;
const CLOSE_TIMEOUT = 2e3;
const log$6 = logger$1("libp2p:websockets:socket");
function socketToMaConn(stream2, remoteAddr, options) {
  options = options ?? {};
  const maConn = {
    async sink(source2) {
      if (options?.signal != null) {
        source2 = abortableSource(source2, options.signal);
      }
      try {
        await stream2.sink(source2);
      } catch (err2) {
        if (err2.type !== "aborted") {
          log$6.error(err2);
        }
      }
    },
    source: options.signal != null ? abortableSource(stream2.source, options.signal) : stream2.source,
    remoteAddr,
    timeline: { open: Date.now() },
    async close() {
      const start = Date.now();
      try {
        await pTimeout(stream2.close(), {
          milliseconds: CLOSE_TIMEOUT
        });
      } catch (err2) {
        const { host, port } = maConn.remoteAddr.toOptions();
        log$6("timeout closing stream to %s:%s after %dms, destroying it manually", host, port, Date.now() - start);
        stream2.destroy();
      } finally {
        maConn.timeline.close = Date.now();
      }
    }
  };
  stream2.socket.addEventListener("close", () => {
    if (maConn.timeline.close == null) {
      maConn.timeline.close = Date.now();
    }
  }, { once: true });
  return maConn;
}
function all(multiaddrs) {
  return multiaddrs.filter((ma) => {
    if (ma.protoCodes().includes(CODE_CIRCUIT)) {
      return false;
    }
    const testMa = ma.decapsulateCode(CODE_P2P);
    return WebSockets$1.matches(testMa) || WebSocketsSecure.matches(testMa);
  });
}
function dnsWss(multiaddrs) {
  return multiaddrs.filter((ma) => {
    if (ma.protoCodes().includes(CODE_CIRCUIT)) {
      return false;
    }
    const testMa = ma.decapsulateCode(CODE_P2P);
    return WebSocketsSecure.matches(testMa) && DNS.matches(testMa.decapsulateCode(CODE_TCP).decapsulateCode(CODE_WSS));
  });
}
const log$5 = logger$1("libp2p:websockets");
class WebSockets {
  constructor(init2) {
    this.init = init2;
  }
  get [Symbol.toStringTag]() {
    return "@libp2p/websockets";
  }
  get [symbol$2]() {
    return true;
  }
  async dial(ma, options) {
    log$5("dialing %s", ma);
    options = options ?? {};
    const socket = await this._connect(ma, options);
    const maConn = socketToMaConn(socket, ma);
    log$5("new outbound connection %s", maConn.remoteAddr);
    const conn = await options.upgrader.upgradeOutbound(maConn);
    log$5("outbound connection %s upgraded", maConn.remoteAddr);
    return conn;
  }
  async _connect(ma, options) {
    if (options?.signal?.aborted === true) {
      throw new AbortError();
    }
    const cOpts = ma.toOptions();
    log$5("dialing %s:%s", cOpts.host, cOpts.port);
    const errorPromise = pDefer$1();
    const errfn = (err2) => {
      log$5.error("connection error:", err2);
      errorPromise.reject(err2);
    };
    const rawSocket = connect(multiaddrToUri(ma), this.init);
    if (rawSocket.socket.on != null) {
      rawSocket.socket.on("error", errfn);
    } else {
      rawSocket.socket.onerror = errfn;
    }
    if (options.signal == null) {
      await Promise.race([rawSocket.connected(), errorPromise.promise]);
      log$5("connected %s", ma);
      return rawSocket;
    }
    let onAbort;
    const abort = new Promise((resolve2, reject) => {
      onAbort = () => {
        reject(new AbortError());
        rawSocket.close().catch((err2) => {
          log$5.error("error closing raw socket", err2);
        });
      };
      if (options?.signal?.aborted === true) {
        return onAbort();
      }
      options?.signal?.addEventListener("abort", onAbort);
    });
    try {
      await Promise.race([abort, errorPromise.promise, rawSocket.connected()]);
    } finally {
      if (onAbort != null) {
        options?.signal?.removeEventListener("abort", onAbort);
      }
    }
    log$5("connected %s", ma);
    return rawSocket;
  }
  createListener(options) {
    return createListener({ ...this.init, ...options });
  }
  filter(multiaddrs) {
    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
    if (this.init?.filter != null) {
      return this.init?.filter(multiaddrs);
    }
    if (isBrowser || isWebWorker) {
      return dnsWss(multiaddrs);
    }
    return all(multiaddrs);
  }
}
function webSockets(init2 = {}) {
  return () => {
    return new WebSockets(init2);
  };
}
function allocUnsafe$1(size2) {
  return new Uint8Array(size2);
}
var MessageTypes;
(function(MessageTypes2) {
  MessageTypes2[MessageTypes2["NEW_STREAM"] = 0] = "NEW_STREAM";
  MessageTypes2[MessageTypes2["MESSAGE_RECEIVER"] = 1] = "MESSAGE_RECEIVER";
  MessageTypes2[MessageTypes2["MESSAGE_INITIATOR"] = 2] = "MESSAGE_INITIATOR";
  MessageTypes2[MessageTypes2["CLOSE_RECEIVER"] = 3] = "CLOSE_RECEIVER";
  MessageTypes2[MessageTypes2["CLOSE_INITIATOR"] = 4] = "CLOSE_INITIATOR";
  MessageTypes2[MessageTypes2["RESET_RECEIVER"] = 5] = "RESET_RECEIVER";
  MessageTypes2[MessageTypes2["RESET_INITIATOR"] = 6] = "RESET_INITIATOR";
})(MessageTypes || (MessageTypes = {}));
const MessageTypeNames = Object.freeze({
  0: "NEW_STREAM",
  1: "MESSAGE_RECEIVER",
  2: "MESSAGE_INITIATOR",
  3: "CLOSE_RECEIVER",
  4: "CLOSE_INITIATOR",
  5: "RESET_RECEIVER",
  6: "RESET_INITIATOR"
});
const InitiatorMessageTypes = Object.freeze({
  NEW_STREAM: MessageTypes.NEW_STREAM,
  MESSAGE: MessageTypes.MESSAGE_INITIATOR,
  CLOSE: MessageTypes.CLOSE_INITIATOR,
  RESET: MessageTypes.RESET_INITIATOR
});
const ReceiverMessageTypes = Object.freeze({
  MESSAGE: MessageTypes.MESSAGE_RECEIVER,
  CLOSE: MessageTypes.CLOSE_RECEIVER,
  RESET: MessageTypes.RESET_RECEIVER
});
const DEFAULT_BATCH_SIZE = 1024 * 1024;
const DEFAULT_SERIALIZE = (buf2, list) => list.append(buf2);
async function* batchedBytes(source2, options = {}) {
  let buffer2 = new Uint8ArrayList();
  let ended = false;
  let deferred = pDefer$1();
  let size2 = Number(options.size ?? DEFAULT_BATCH_SIZE);
  if (isNaN(size2) || size2 === 0 || size2 < 0) {
    size2 = DEFAULT_BATCH_SIZE;
  }
  const yieldAfter = options.yieldAfter ?? 0;
  const serialize = options.serialize ?? DEFAULT_SERIALIZE;
  void Promise.resolve().then(async () => {
    try {
      let timeout2;
      for await (const buf2 of source2) {
        serialize(buf2, buffer2);
        if (buffer2.byteLength >= size2) {
          clearTimeout(timeout2);
          deferred.resolve();
          continue;
        }
        timeout2 = setTimeout(() => {
          deferred.resolve();
        }, yieldAfter);
      }
      clearTimeout(timeout2);
      deferred.resolve();
    } catch (err2) {
      deferred.reject(err2);
    } finally {
      ended = true;
    }
  });
  while (!ended) {
    await deferred.promise;
    deferred = pDefer$1();
    if (buffer2.byteLength > 0) {
      const b2 = buffer2;
      buffer2 = new Uint8ArrayList();
      yield b2.subarray();
    }
  }
}
const POOL_SIZE = 10 * 1024;
class Encoder {
  constructor() {
    this._pool = allocUnsafe$1(POOL_SIZE);
    this._poolOffset = 0;
  }
  write(msg, list) {
    const pool2 = this._pool;
    let offset = this._poolOffset;
    varint$3.encode(msg.id << 3 | msg.type, pool2, offset);
    offset += varint$3.encode.bytes ?? 0;
    if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {
      varint$3.encode(msg.data.length, pool2, offset);
    } else {
      varint$3.encode(0, pool2, offset);
    }
    offset += varint$3.encode.bytes ?? 0;
    const header = pool2.subarray(this._poolOffset, offset);
    if (POOL_SIZE - offset < 100) {
      this._pool = allocUnsafe$1(POOL_SIZE);
      this._poolOffset = 0;
    } else {
      this._poolOffset = offset;
    }
    list.append(header);
    if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {
      list.append(msg.data);
    }
  }
}
const encoder = new Encoder();
async function* encode$1(source2, minSendBytes = 0) {
  if (minSendBytes == null || minSendBytes === 0) {
    for await (const messages2 of source2) {
      const list = new Uint8ArrayList();
      for (const msg of messages2) {
        encoder.write(msg, list);
      }
      yield list.subarray();
    }
    return;
  }
  yield* batchedBytes(source2, {
    size: minSendBytes,
    serialize: (obj, list) => {
      for (const m of obj) {
        encoder.write(m, list);
      }
    }
  });
}
const MAX_MSG_SIZE = 1 << 20;
const MAX_MSG_QUEUE_SIZE = 4 << 20;
class Decoder {
  constructor(maxMessageSize = MAX_MSG_SIZE, maxUnprocessedMessageQueueSize = MAX_MSG_QUEUE_SIZE) {
    this._buffer = new Uint8ArrayList();
    this._headerInfo = null;
    this._maxMessageSize = maxMessageSize;
    this._maxUnprocessedMessageQueueSize = maxUnprocessedMessageQueueSize;
  }
  write(chunk) {
    if (chunk == null || chunk.length === 0) {
      return [];
    }
    this._buffer.append(chunk);
    if (this._buffer.byteLength > this._maxUnprocessedMessageQueueSize) {
      throw Object.assign(new Error("unprocessed message queue size too large!"), { code: "ERR_MSG_QUEUE_TOO_BIG" });
    }
    const msgs = [];
    while (this._buffer.length !== 0) {
      if (this._headerInfo == null) {
        try {
          this._headerInfo = this._decodeHeader(this._buffer);
        } catch (err2) {
          if (err2.code === "ERR_MSG_TOO_BIG") {
            throw err2;
          }
          break;
        }
      }
      const { id, type, length: length3, offset } = this._headerInfo;
      const bufferedDataLength = this._buffer.length - offset;
      if (bufferedDataLength < length3) {
        break;
      }
      const msg = {
        id,
        type
      };
      if (type === MessageTypes.NEW_STREAM || type === MessageTypes.MESSAGE_INITIATOR || type === MessageTypes.MESSAGE_RECEIVER) {
        msg.data = this._buffer.sublist(offset, offset + length3);
      }
      msgs.push(msg);
      this._buffer.consume(offset + length3);
      this._headerInfo = null;
    }
    return msgs;
  }
  _decodeHeader(data) {
    const { value: h, offset } = readVarInt(data);
    const { value: length3, offset: end2 } = readVarInt(data, offset);
    const type = h & 7;
    if (MessageTypeNames[type] == null) {
      throw new Error(`Invalid type received: ${type}`);
    }
    if (length3 > this._maxMessageSize) {
      throw Object.assign(new Error("message size too large!"), { code: "ERR_MSG_TOO_BIG" });
    }
    return { id: h >> 3, type, offset: offset + end2, length: length3 };
  }
}
const MSB$2 = 128;
const REST$2 = 127;
function readVarInt(buf2, offset = 0) {
  let res = 0;
  let shift2 = 0;
  let counter2 = offset;
  let b2;
  const l = buf2.length;
  do {
    if (counter2 >= l || shift2 > 49) {
      offset = 0;
      throw new RangeError("Could not decode varint");
    }
    b2 = buf2.get(counter2++);
    res += shift2 < 28 ? (b2 & REST$2) << shift2 : (b2 & REST$2) * Math.pow(2, shift2);
    shift2 += 7;
  } while (b2 >= MSB$2);
  offset = counter2 - offset;
  return {
    value: res,
    offset
  };
}
const log$4 = logger$1("libp2p:mplex:stream");
const ERR_STREAM_RESET = "ERR_STREAM_RESET";
const ERR_STREAM_ABORT = "ERR_STREAM_ABORT";
const ERR_SINK_ENDED = "ERR_SINK_ENDED";
const ERR_DOUBLE_SINK = "ERR_DOUBLE_SINK";
function createStream(options) {
  const { id, name: name2, send, onEnd, type = "initiator", maxMsgSize = MAX_MSG_SIZE } = options;
  const abortController = new AbortController();
  const resetController = new AbortController();
  const closeController = new AbortController();
  const Types2 = type === "initiator" ? InitiatorMessageTypes : ReceiverMessageTypes;
  const externalId = type === "initiator" ? `i${id}` : `r${id}`;
  const streamName = `${name2 == null ? id : name2}`;
  let sourceEnded = false;
  let sinkEnded = false;
  let sinkSunk = false;
  let endErr;
  const timeline = {
    open: Date.now()
  };
  const onSourceEnd = (err2) => {
    if (sourceEnded) {
      return;
    }
    sourceEnded = true;
    log$4.trace("%s stream %s source end - err: %o", type, streamName, err2);
    if (err2 != null && endErr == null) {
      endErr = err2;
    }
    if (sinkEnded) {
      stream2.stat.timeline.close = Date.now();
      if (onEnd != null) {
        onEnd(endErr);
      }
    }
  };
  const onSinkEnd = (err2) => {
    if (sinkEnded) {
      return;
    }
    sinkEnded = true;
    log$4.trace("%s stream %s sink end - err: %o", type, streamName, err2);
    if (err2 != null && endErr == null) {
      endErr = err2;
    }
    if (sourceEnded) {
      timeline.close = Date.now();
      if (onEnd != null) {
        onEnd(endErr);
      }
    }
  };
  const streamSource = pushable({
    onEnd: onSourceEnd
  });
  const stream2 = {
    close: () => {
      log$4.trace("%s stream %s close", type, streamName);
      stream2.closeRead();
      stream2.closeWrite();
    },
    closeRead: () => {
      log$4.trace("%s stream %s closeRead", type, streamName);
      if (sourceEnded) {
        return;
      }
      streamSource.end();
    },
    closeWrite: () => {
      log$4.trace("%s stream %s closeWrite", type, streamName);
      if (sinkEnded) {
        return;
      }
      closeController.abort();
      try {
        send({ id, type: Types2.CLOSE });
      } catch (err2) {
        log$4.trace("%s stream %s error sending close", type, name2, err2);
      }
      onSinkEnd();
    },
    abort: (err2) => {
      log$4.trace("%s stream %s abort", type, streamName, err2);
      streamSource.end(err2);
      abortController.abort();
      onSinkEnd(err2);
    },
    reset: () => {
      const err2 = errCode(new Error("stream reset"), ERR_STREAM_RESET);
      resetController.abort();
      streamSource.end(err2);
      onSinkEnd(err2);
    },
    sink: async (source2) => {
      if (sinkSunk) {
        throw errCode(new Error("sink already called on stream"), ERR_DOUBLE_SINK);
      }
      sinkSunk = true;
      if (sinkEnded) {
        throw errCode(new Error("stream closed for writing"), ERR_SINK_ENDED);
      }
      source2 = abortableSource(source2, anySignal_2([
        abortController.signal,
        resetController.signal,
        closeController.signal
      ]));
      try {
        if (type === "initiator") {
          send({ id, type: InitiatorMessageTypes.NEW_STREAM, data: new Uint8ArrayList(fromString$3(streamName)) });
        }
        for await (let data of source2) {
          while (data.length > 0) {
            if (data.length <= maxMsgSize) {
              send({ id, type: Types2.MESSAGE, data: data instanceof Uint8Array ? new Uint8ArrayList(data) : data });
              break;
            }
            data = data instanceof Uint8Array ? new Uint8ArrayList(data) : data;
            send({ id, type: Types2.MESSAGE, data: data.sublist(0, maxMsgSize) });
            data.consume(maxMsgSize);
          }
        }
      } catch (err2) {
        if (err2.type === "aborted" && err2.message === "The operation was aborted") {
          if (closeController.signal.aborted) {
            return;
          }
          if (resetController.signal.aborted) {
            err2.message = "stream reset";
            err2.code = ERR_STREAM_RESET;
          }
          if (abortController.signal.aborted) {
            err2.message = "stream aborted";
            err2.code = ERR_STREAM_ABORT;
          }
        }
        if (err2.code === ERR_STREAM_RESET) {
          log$4.trace("%s stream %s reset", type, name2);
        } else {
          log$4.trace("%s stream %s error", type, name2, err2);
          try {
            send({ id, type: Types2.RESET });
          } catch (err3) {
            log$4.trace("%s stream %s error sending reset", type, name2, err3);
          }
        }
        streamSource.end(err2);
        onSinkEnd(err2);
        return;
      }
      try {
        send({ id, type: Types2.CLOSE });
      } catch (err2) {
        log$4.trace("%s stream %s error sending close", type, name2, err2);
      }
      onSinkEnd();
    },
    source: streamSource,
    sourcePush: (data) => {
      streamSource.push(data);
    },
    sourceReadableLength() {
      return streamSource.readableLength;
    },
    stat: {
      direction: type === "initiator" ? "outbound" : "inbound",
      timeline
    },
    metadata: {},
    id: externalId
  };
  return stream2;
}
const log$3 = logger$1("libp2p:mplex");
const MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION = 1024;
const MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION = 1024;
const MAX_STREAM_BUFFER_SIZE = 1024 * 1024 * 4;
const DISCONNECT_THRESHOLD = 5;
function printMessage(msg) {
  const output = {
    ...msg,
    type: `${MessageTypeNames[msg.type]} (${msg.type})`
  };
  if (msg.type === MessageTypes.NEW_STREAM) {
    output.data = toString$5(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray());
  }
  if (msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) {
    output.data = toString$5(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray(), "base16");
  }
  return output;
}
class MplexStreamMuxer {
  constructor(init2) {
    this.protocol = "/mplex/6.7.0";
    init2 = init2 ?? {};
    this._streamId = 0;
    this._streams = {
      initiators: /* @__PURE__ */ new Map(),
      receivers: /* @__PURE__ */ new Map()
    };
    this._init = init2;
    this.sink = this._createSink();
    const source2 = this._createSource();
    this._source = source2;
    this.source = source2;
    this.closeController = new AbortController();
    this.rateLimiter = new rateLimiterFlexible.RateLimiterMemory({
      points: init2.disconnectThreshold ?? DISCONNECT_THRESHOLD,
      duration: 1
    });
  }
  get streams() {
    const streams = [];
    for (const stream2 of this._streams.initiators.values()) {
      streams.push(stream2);
    }
    for (const stream2 of this._streams.receivers.values()) {
      streams.push(stream2);
    }
    return streams;
  }
  newStream(name2) {
    if (this.closeController.signal.aborted) {
      throw new Error("Muxer already closed");
    }
    const id = this._streamId++;
    name2 = name2 == null ? id.toString() : name2.toString();
    const registry = this._streams.initiators;
    return this._newStream({ id, name: name2, type: "initiator", registry });
  }
  close(err2) {
    if (this.closeController.signal.aborted)
      return;
    if (err2 != null) {
      this.streams.forEach((s2) => s2.abort(err2));
    } else {
      this.streams.forEach((s2) => s2.close());
    }
    this.closeController.abort();
  }
  _newReceiverStream(options) {
    const { id, name: name2 } = options;
    const registry = this._streams.receivers;
    return this._newStream({ id, name: name2, type: "receiver", registry });
  }
  _newStream(options) {
    const { id, name: name2, type, registry } = options;
    log$3("new %s stream %s", type, id);
    if (type === "initiator" && this._streams.initiators.size === (this._init.maxOutboundStreams ?? MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION)) {
      throw errCode(new Error("Too many outbound streams open"), "ERR_TOO_MANY_OUTBOUND_STREAMS");
    }
    if (registry.has(id)) {
      throw new Error(`${type} stream ${id} already exists!`);
    }
    const send = (msg) => {
      if (log$3.enabled) {
        log$3.trace("%s stream %s send", type, id, printMessage(msg));
      }
      this._source.push(msg);
    };
    const onEnd = () => {
      log$3("%s stream with id %s and protocol %s ended", type, id, stream2.stat.protocol);
      registry.delete(id);
      if (this._init.onStreamEnd != null) {
        this._init.onStreamEnd(stream2);
      }
    };
    const stream2 = createStream({ id, name: name2, send, type, onEnd, maxMsgSize: this._init.maxMsgSize });
    registry.set(id, stream2);
    return stream2;
  }
  _createSink() {
    const sink2 = async (source2) => {
      const abortSignals = [this.closeController.signal];
      if (this._init.signal != null) {
        abortSignals.push(this._init.signal);
      }
      source2 = abortableSource(source2, anySignal$2.exports(abortSignals));
      try {
        const decoder = new Decoder(this._init.maxMsgSize, this._init.maxUnprocessedMessageQueueSize);
        for await (const chunk of source2) {
          for (const msg of decoder.write(chunk)) {
            await this._handleIncoming(msg);
          }
        }
        this._source.end();
      } catch (err2) {
        log$3("error in sink", err2);
        this._source.end(err2);
      }
    };
    return sink2;
  }
  _createSource() {
    const onEnd = (err2) => {
      this.close(err2);
    };
    const source2 = pushableV({
      objectMode: true,
      onEnd
    });
    return Object.assign(encode$1(source2, this._init.minSendBytes), {
      push: source2.push,
      end: source2.end,
      return: source2.return
    });
  }
  async _handleIncoming(message2) {
    const { id, type } = message2;
    if (log$3.enabled) {
      log$3.trace("incoming message", printMessage(message2));
    }
    if (message2.type === MessageTypes.NEW_STREAM) {
      if (this._streams.receivers.size === (this._init.maxInboundStreams ?? MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION)) {
        log$3("too many inbound streams open");
        this._source.push({
          id,
          type: MessageTypes.RESET_RECEIVER
        });
        try {
          await this.rateLimiter.consume("new-stream", 1);
        } catch {
          log$3("rate limit hit when opening too many new streams over the inbound stream limit - closing remote connection");
          this._source.end(new Error("Too many open streams"));
          return;
        }
        return;
      }
      const stream3 = this._newReceiverStream({ id, name: toString$5(message2.data instanceof Uint8Array ? message2.data : message2.data.subarray()) });
      if (this._init.onIncomingStream != null) {
        this._init.onIncomingStream(stream3);
      }
      return;
    }
    const list = (type & 1) === 1 ? this._streams.initiators : this._streams.receivers;
    const stream2 = list.get(id);
    if (stream2 == null) {
      log$3("missing stream %s for message type %s", id, MessageTypeNames[type]);
      return;
    }
    const maxBufferSize = this._init.maxStreamBufferSize ?? MAX_STREAM_BUFFER_SIZE;
    switch (type) {
      case MessageTypes.MESSAGE_INITIATOR:
      case MessageTypes.MESSAGE_RECEIVER:
        if (stream2.sourceReadableLength() > maxBufferSize) {
          this._source.push({
            id: message2.id,
            type: type === MessageTypes.MESSAGE_INITIATOR ? MessageTypes.RESET_RECEIVER : MessageTypes.RESET_INITIATOR
          });
          const error2 = errCode(new Error("Input buffer full - increase Mplex maxBufferSize to accommodate slow consumers"), "ERR_STREAM_INPUT_BUFFER_FULL");
          stream2.abort(error2);
          return;
        }
        stream2.sourcePush(message2.data);
        break;
      case MessageTypes.CLOSE_INITIATOR:
      case MessageTypes.CLOSE_RECEIVER:
        stream2.closeRead();
        break;
      case MessageTypes.RESET_INITIATOR:
      case MessageTypes.RESET_RECEIVER:
        stream2.reset();
        break;
      default:
        log$3("unknown message type %s", type);
    }
  }
}
class Mplex {
  constructor(init2 = {}) {
    this.protocol = "/mplex/6.7.0";
    this._init = init2;
  }
  createStreamMuxer(init2 = {}) {
    return new MplexStreamMuxer({
      ...init2,
      ...this._init
    });
  }
}
function mplex(init2 = {}) {
  return () => new Mplex(init2);
}
function pbStream(duplex2, opts = {}) {
  const shake = handshake(duplex2);
  const lpReader = decode$3.fromReader(shake.reader, opts);
  const W = {
    read: async (bytes2) => {
      const { value: value2 } = await shake.reader.next(bytes2);
      if (value2 == null) {
        throw new Error("Value is null");
      }
      return value2;
    },
    readLP: async () => {
      const { value: value2 } = await lpReader.next();
      if (value2 == null) {
        throw new Error("Value is null");
      }
      return value2;
    },
    readPB: async (proto) => {
      const value2 = await W.readLP();
      if (value2 == null) {
        throw new Error("Value is null");
      }
      const buf2 = value2 instanceof Uint8Array ? value2 : value2.slice();
      return proto.decode(buf2);
    },
    write: (data) => {
      if (data instanceof Uint8Array) {
        shake.writer.push(data);
      } else {
        shake.writer.push(data.slice());
      }
    },
    writeLP: (data) => {
      W.write(encode$5.single(data, opts));
    },
    writePB: (data, proto) => {
      W.writeLP(proto.encode(data));
    },
    pb: (proto) => {
      return {
        read: async () => await W.readPB(proto),
        write: (d) => W.writePB(d, proto)
      };
    },
    unwrap: () => {
      shake.rest();
      return shake.stream;
    }
  };
  return W;
}
function pair() {
  const deferred = pDefer$1();
  let piped = false;
  return {
    sink: async (source2) => {
      if (piped) {
        throw new Error("already piped");
      }
      piped = true;
      deferred.resolve(source2);
    },
    source: async function* () {
      const source2 = await deferred.promise;
      yield* source2;
    }()
  };
}
function duplexPair() {
  const a = pair();
  const b2 = pair();
  return [
    {
      source: a.source,
      sink: b2.sink
    },
    {
      source: b2.source,
      sink: a.sink
    }
  ];
}
const NOISE_MSG_MAX_LENGTH_BYTES = 65535;
const NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = NOISE_MSG_MAX_LENGTH_BYTES - 16;
const DUMP_SESSION_KEYS = Boolean(globalThis.process?.env?.DUMP_SESSION_KEYS);
var hkdf = {};
var hmac$1 = {};
var hash = {};
Object.defineProperty(hash, "__esModule", { value: true });
function isSerializableHash(h) {
  return typeof h.saveState !== "undefined" && typeof h.restoreState !== "undefined" && typeof h.cleanSavedState !== "undefined";
}
hash.isSerializableHash = isSerializableHash;
var constantTime = {};
Object.defineProperty(constantTime, "__esModule", { value: true });
function select(subject, resultIfOne, resultIfZero) {
  return ~(subject - 1) & resultIfOne | subject - 1 & resultIfZero;
}
constantTime.select = select;
function lessOrEqual(a, b2) {
  return (a | 0) - (b2 | 0) - 1 >>> 31 & 1;
}
constantTime.lessOrEqual = lessOrEqual;
function compare(a, b2) {
  if (a.length !== b2.length) {
    return 0;
  }
  var result = 0;
  for (var i2 = 0; i2 < a.length; i2++) {
    result |= a[i2] ^ b2[i2];
  }
  return 1 & result - 1 >>> 8;
}
constantTime.compare = compare;
function equal(a, b2) {
  if (a.length === 0 || b2.length === 0) {
    return false;
  }
  return compare(a, b2) !== 0;
}
constantTime.equal = equal;
var wipe$1 = {};
Object.defineProperty(wipe$1, "__esModule", { value: true });
function wipe(array) {
  for (var i2 = 0; i2 < array.length; i2++) {
    array[i2] = 0;
  }
  return array;
}
wipe$1.wipe = wipe;
Object.defineProperty(hmac$1, "__esModule", { value: true });
var hash_1 = hash;
var constant_time_1 = constantTime;
var wipe_1$3 = wipe$1;
var HMAC = function() {
  function HMAC2(hash2, key) {
    this._finished = false;
    this._inner = new hash2();
    this._outer = new hash2();
    this.blockSize = this._outer.blockSize;
    this.digestLength = this._outer.digestLength;
    var pad = new Uint8Array(this.blockSize);
    if (key.length > this.blockSize) {
      this._inner.update(key).finish(pad).clean();
    } else {
      pad.set(key);
    }
    for (var i2 = 0; i2 < pad.length; i2++) {
      pad[i2] ^= 54;
    }
    this._inner.update(pad);
    for (var i2 = 0; i2 < pad.length; i2++) {
      pad[i2] ^= 54 ^ 92;
    }
    this._outer.update(pad);
    if (hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer)) {
      this._innerKeyedState = this._inner.saveState();
      this._outerKeyedState = this._outer.saveState();
    }
    wipe_1$3.wipe(pad);
  }
  HMAC2.prototype.reset = function() {
    if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
      throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
    }
    this._inner.restoreState(this._innerKeyedState);
    this._outer.restoreState(this._outerKeyedState);
    this._finished = false;
    return this;
  };
  HMAC2.prototype.clean = function() {
    if (hash_1.isSerializableHash(this._inner)) {
      this._inner.cleanSavedState(this._innerKeyedState);
    }
    if (hash_1.isSerializableHash(this._outer)) {
      this._outer.cleanSavedState(this._outerKeyedState);
    }
    this._inner.clean();
    this._outer.clean();
  };
  HMAC2.prototype.update = function(data) {
    this._inner.update(data);
    return this;
  };
  HMAC2.prototype.finish = function(out) {
    if (this._finished) {
      this._outer.finish(out);
      return this;
    }
    this._inner.finish(out);
    this._outer.update(out.subarray(0, this.digestLength)).finish(out);
    this._finished = true;
    return this;
  };
  HMAC2.prototype.digest = function() {
    var out = new Uint8Array(this.digestLength);
    this.finish(out);
    return out;
  };
  HMAC2.prototype.saveState = function() {
    if (!hash_1.isSerializableHash(this._inner)) {
      throw new Error("hmac: can't saveState() because hash doesn't implement it");
    }
    return this._inner.saveState();
  };
  HMAC2.prototype.restoreState = function(savedState) {
    if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
      throw new Error("hmac: can't restoreState() because hash doesn't implement it");
    }
    this._inner.restoreState(savedState);
    this._outer.restoreState(this._outerKeyedState);
    this._finished = false;
    return this;
  };
  HMAC2.prototype.cleanSavedState = function(savedState) {
    if (!hash_1.isSerializableHash(this._inner)) {
      throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
    }
    this._inner.cleanSavedState(savedState);
  };
  return HMAC2;
}();
hmac$1.HMAC = HMAC;
function hmac(hash2, key, data) {
  var h = new HMAC(hash2, key);
  h.update(data);
  var digest2 = h.digest();
  h.clean();
  return digest2;
}
hmac$1.hmac = hmac;
hmac$1.equal = constant_time_1.equal;
Object.defineProperty(hkdf, "__esModule", { value: true });
var hmac_1 = hmac$1;
var wipe_1$2 = wipe$1;
var HKDF = function() {
  function HKDF2(hash2, key, salt, info) {
    if (salt === void 0) {
      salt = new Uint8Array(0);
    }
    this._counter = new Uint8Array(1);
    this._hash = hash2;
    this._info = info;
    var okm = hmac_1.hmac(this._hash, salt, key);
    this._hmac = new hmac_1.HMAC(hash2, okm);
    this._buffer = new Uint8Array(this._hmac.digestLength);
    this._bufpos = this._buffer.length;
  }
  HKDF2.prototype._fillBuffer = function() {
    this._counter[0]++;
    var ctr = this._counter[0];
    if (ctr === 0) {
      throw new Error("hkdf: cannot expand more");
    }
    this._hmac.reset();
    if (ctr > 1) {
      this._hmac.update(this._buffer);
    }
    if (this._info) {
      this._hmac.update(this._info);
    }
    this._hmac.update(this._counter);
    this._hmac.finish(this._buffer);
    this._bufpos = 0;
  };
  HKDF2.prototype.expand = function(length3) {
    var out = new Uint8Array(length3);
    for (var i2 = 0; i2 < out.length; i2++) {
      if (this._bufpos === this._buffer.length) {
        this._fillBuffer();
      }
      out[i2] = this._buffer[this._bufpos++];
    }
    return out;
  };
  HKDF2.prototype.clean = function() {
    this._hmac.clean();
    wipe_1$2.wipe(this._buffer);
    wipe_1$2.wipe(this._counter);
    this._bufpos = 0;
  };
  return HKDF2;
}();
var HKDF_1 = hkdf.HKDF = HKDF;
var x25519 = {};
var random = {};
var system = {};
var browser = {};
Object.defineProperty(browser, "__esModule", { value: true });
browser.BrowserRandomSource = void 0;
const QUOTA = 65536;
class BrowserRandomSource {
  constructor() {
    this.isAvailable = false;
    this.isInstantiated = false;
    const browserCrypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
    if (browserCrypto && browserCrypto.getRandomValues !== void 0) {
      this._crypto = browserCrypto;
      this.isAvailable = true;
      this.isInstantiated = true;
    }
  }
  randomBytes(length3) {
    if (!this.isAvailable || !this._crypto) {
      throw new Error("Browser random byte generator is not available.");
    }
    const out = new Uint8Array(length3);
    for (let i2 = 0; i2 < out.length; i2 += QUOTA) {
      this._crypto.getRandomValues(out.subarray(i2, i2 + Math.min(out.length - i2, QUOTA)));
    }
    return out;
  }
}
browser.BrowserRandomSource = BrowserRandomSource;
var node = {};
Object.defineProperty(node, "__esModule", { value: true });
node.NodeRandomSource = void 0;
const wipe_1$1 = wipe$1;
class NodeRandomSource {
  constructor() {
    this.isAvailable = false;
    this.isInstantiated = false;
    if (typeof commonjsRequire !== "undefined") {
      const nodeCrypto2 = require$$1;
      if (nodeCrypto2 && nodeCrypto2.randomBytes) {
        this._crypto = nodeCrypto2;
        this.isAvailable = true;
        this.isInstantiated = true;
      }
    }
  }
  randomBytes(length3) {
    if (!this.isAvailable || !this._crypto) {
      throw new Error("Node.js random byte generator is not available.");
    }
    let buffer2 = this._crypto.randomBytes(length3);
    if (buffer2.length !== length3) {
      throw new Error("NodeRandomSource: got fewer bytes than requested");
    }
    const out = new Uint8Array(length3);
    for (let i2 = 0; i2 < out.length; i2++) {
      out[i2] = buffer2[i2];
    }
    (0, wipe_1$1.wipe)(buffer2);
    return out;
  }
}
node.NodeRandomSource = NodeRandomSource;
Object.defineProperty(system, "__esModule", { value: true });
system.SystemRandomSource = void 0;
const browser_1 = browser;
const node_1 = node;
class SystemRandomSource {
  constructor() {
    this.isAvailable = false;
    this.name = "";
    this._source = new browser_1.BrowserRandomSource();
    if (this._source.isAvailable) {
      this.isAvailable = true;
      this.name = "Browser";
      return;
    }
    this._source = new node_1.NodeRandomSource();
    if (this._source.isAvailable) {
      this.isAvailable = true;
      this.name = "Node";
      return;
    }
  }
  randomBytes(length3) {
    if (!this.isAvailable) {
      throw new Error("System random byte generator is not available.");
    }
    return this._source.randomBytes(length3);
  }
}
system.SystemRandomSource = SystemRandomSource;
var binary = {};
var int = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  function imulShim(a, b2) {
    var ah = a >>> 16 & 65535, al = a & 65535;
    var bh = b2 >>> 16 & 65535, bl = b2 & 65535;
    return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
  }
  exports.mul = Math.imul || imulShim;
  function add(a, b2) {
    return a + b2 | 0;
  }
  exports.add = add;
  function sub(a, b2) {
    return a - b2 | 0;
  }
  exports.sub = sub;
  function rotl(x, n) {
    return x << n | x >>> 32 - n;
  }
  exports.rotl = rotl;
  function rotr(x, n) {
    return x << 32 - n | x >>> n;
  }
  exports.rotr = rotr;
  function isIntegerShim(n) {
    return typeof n === "number" && isFinite(n) && Math.floor(n) === n;
  }
  exports.isInteger = Number.isInteger || isIntegerShim;
  exports.MAX_SAFE_INTEGER = 9007199254740991;
  exports.isSafeInteger = function(n) {
    return exports.isInteger(n) && (n >= -exports.MAX_SAFE_INTEGER && n <= exports.MAX_SAFE_INTEGER);
  };
})(int);
Object.defineProperty(binary, "__esModule", { value: true });
var int_1 = int;
function readInt16BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 0] << 8 | array[offset + 1]) << 16 >> 16;
}
binary.readInt16BE = readInt16BE;
function readUint16BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 0] << 8 | array[offset + 1]) >>> 0;
}
binary.readUint16BE = readUint16BE;
function readInt16LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 1] << 8 | array[offset]) << 16 >> 16;
}
binary.readInt16LE = readInt16LE;
function readUint16LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 1] << 8 | array[offset]) >>> 0;
}
binary.readUint16LE = readUint16LE;
function writeUint16BE(value2, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(2);
  }
  if (offset === void 0) {
    offset = 0;
  }
  out[offset + 0] = value2 >>> 8;
  out[offset + 1] = value2 >>> 0;
  return out;
}
binary.writeUint16BE = writeUint16BE;
binary.writeInt16BE = writeUint16BE;
function writeUint16LE(value2, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(2);
  }
  if (offset === void 0) {
    offset = 0;
  }
  out[offset + 0] = value2 >>> 0;
  out[offset + 1] = value2 >>> 8;
  return out;
}
binary.writeUint16LE = writeUint16LE;
binary.writeInt16LE = writeUint16LE;
function readInt32BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3];
}
binary.readInt32BE = readInt32BE;
function readUint32BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3]) >>> 0;
}
binary.readUint32BE = readUint32BE;
function readInt32LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset];
}
binary.readInt32LE = readInt32LE;
function readUint32LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset]) >>> 0;
}
binary.readUint32LE = readUint32LE;
function writeUint32BE(value2, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(4);
  }
  if (offset === void 0) {
    offset = 0;
  }
  out[offset + 0] = value2 >>> 24;
  out[offset + 1] = value2 >>> 16;
  out[offset + 2] = value2 >>> 8;
  out[offset + 3] = value2 >>> 0;
  return out;
}
binary.writeUint32BE = writeUint32BE;
binary.writeInt32BE = writeUint32BE;
function writeUint32LE(value2, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(4);
  }
  if (offset === void 0) {
    offset = 0;
  }
  out[offset + 0] = value2 >>> 0;
  out[offset + 1] = value2 >>> 8;
  out[offset + 2] = value2 >>> 16;
  out[offset + 3] = value2 >>> 24;
  return out;
}
binary.writeUint32LE = writeUint32LE;
binary.writeInt32LE = writeUint32LE;
function readInt64BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var hi = readInt32BE(array, offset);
  var lo = readInt32BE(array, offset + 4);
  return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
}
binary.readInt64BE = readInt64BE;
function readUint64BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var hi = readUint32BE(array, offset);
  var lo = readUint32BE(array, offset + 4);
  return hi * 4294967296 + lo;
}
binary.readUint64BE = readUint64BE;
function readInt64LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var lo = readInt32LE(array, offset);
  var hi = readInt32LE(array, offset + 4);
  return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
}
binary.readInt64LE = readInt64LE;
function readUint64LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var lo = readUint32LE(array, offset);
  var hi = readUint32LE(array, offset + 4);
  return hi * 4294967296 + lo;
}
binary.readUint64LE = readUint64LE;
function writeUint64BE(value2, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  writeUint32BE(value2 / 4294967296 >>> 0, out, offset);
  writeUint32BE(value2 >>> 0, out, offset + 4);
  return out;
}
binary.writeUint64BE = writeUint64BE;
binary.writeInt64BE = writeUint64BE;
function writeUint64LE(value2, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  writeUint32LE(value2 >>> 0, out, offset);
  writeUint32LE(value2 / 4294967296 >>> 0, out, offset + 4);
  return out;
}
binary.writeUint64LE = writeUint64LE;
binary.writeInt64LE = writeUint64LE;
function readUintBE(bitLength, array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  if (bitLength % 8 !== 0) {
    throw new Error("readUintBE supports only bitLengths divisible by 8");
  }
  if (bitLength / 8 > array.length - offset) {
    throw new Error("readUintBE: array is too short for the given bitLength");
  }
  var result = 0;
  var mul = 1;
  for (var i2 = bitLength / 8 + offset - 1; i2 >= offset; i2--) {
    result += array[i2] * mul;
    mul *= 256;
  }
  return result;
}
binary.readUintBE = readUintBE;
function readUintLE(bitLength, array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  if (bitLength % 8 !== 0) {
    throw new Error("readUintLE supports only bitLengths divisible by 8");
  }
  if (bitLength / 8 > array.length - offset) {
    throw new Error("readUintLE: array is too short for the given bitLength");
  }
  var result = 0;
  var mul = 1;
  for (var i2 = offset; i2 < offset + bitLength / 8; i2++) {
    result += array[i2] * mul;
    mul *= 256;
  }
  return result;
}
binary.readUintLE = readUintLE;
function writeUintBE(bitLength, value2, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(bitLength / 8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  if (bitLength % 8 !== 0) {
    throw new Error("writeUintBE supports only bitLengths divisible by 8");
  }
  if (!int_1.isSafeInteger(value2)) {
    throw new Error("writeUintBE value must be an integer");
  }
  var div = 1;
  for (var i2 = bitLength / 8 + offset - 1; i2 >= offset; i2--) {
    out[i2] = value2 / div & 255;
    div *= 256;
  }
  return out;
}
binary.writeUintBE = writeUintBE;
function writeUintLE(bitLength, value2, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(bitLength / 8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  if (bitLength % 8 !== 0) {
    throw new Error("writeUintLE supports only bitLengths divisible by 8");
  }
  if (!int_1.isSafeInteger(value2)) {
    throw new Error("writeUintLE value must be an integer");
  }
  var div = 1;
  for (var i2 = offset; i2 < offset + bitLength / 8; i2++) {
    out[i2] = value2 / div & 255;
    div *= 256;
  }
  return out;
}
binary.writeUintLE = writeUintLE;
function readFloat32BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat32(offset);
}
binary.readFloat32BE = readFloat32BE;
function readFloat32LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat32(offset, true);
}
binary.readFloat32LE = readFloat32LE;
function readFloat64BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat64(offset);
}
binary.readFloat64BE = readFloat64BE;
function readFloat64LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat64(offset, true);
}
binary.readFloat64LE = readFloat64LE;
function writeFloat32BE(value2, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(4);
  }
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  view.setFloat32(offset, value2);
  return out;
}
binary.writeFloat32BE = writeFloat32BE;
function writeFloat32LE(value2, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(4);
  }
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  view.setFloat32(offset, value2, true);
  return out;
}
binary.writeFloat32LE = writeFloat32LE;
function writeFloat64BE(value2, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  view.setFloat64(offset, value2);
  return out;
}
binary.writeFloat64BE = writeFloat64BE;
function writeFloat64LE(value2, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  view.setFloat64(offset, value2, true);
  return out;
}
binary.writeFloat64LE = writeFloat64LE;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.randomStringForEntropy = exports.randomString = exports.randomUint32 = exports.randomBytes = exports.defaultRandomSource = void 0;
  const system_1 = system;
  const binary_12 = binary;
  const wipe_12 = wipe$1;
  exports.defaultRandomSource = new system_1.SystemRandomSource();
  function randomBytes2(length3, prng2 = exports.defaultRandomSource) {
    return prng2.randomBytes(length3);
  }
  exports.randomBytes = randomBytes2;
  function randomUint32(prng2 = exports.defaultRandomSource) {
    const buf2 = randomBytes2(4, prng2);
    const result = (0, binary_12.readUint32LE)(buf2);
    (0, wipe_12.wipe)(buf2);
    return result;
  }
  exports.randomUint32 = randomUint32;
  const ALPHANUMERIC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  function randomString(length3, charset = ALPHANUMERIC, prng2 = exports.defaultRandomSource) {
    if (charset.length < 2) {
      throw new Error("randomString charset is too short");
    }
    if (charset.length > 256) {
      throw new Error("randomString charset is too long");
    }
    let out = "";
    const charsLen = charset.length;
    const maxByte = 256 - 256 % charsLen;
    while (length3 > 0) {
      const buf2 = randomBytes2(Math.ceil(length3 * 256 / maxByte), prng2);
      for (let i2 = 0; i2 < buf2.length && length3 > 0; i2++) {
        const randomByte = buf2[i2];
        if (randomByte < maxByte) {
          out += charset.charAt(randomByte % charsLen);
          length3--;
        }
      }
      (0, wipe_12.wipe)(buf2);
    }
    return out;
  }
  exports.randomString = randomString;
  function randomStringForEntropy(bits2, charset = ALPHANUMERIC, prng2 = exports.defaultRandomSource) {
    const length3 = Math.ceil(bits2 / (Math.log(charset.length) / Math.LN2));
    return randomString(length3, charset, prng2);
  }
  exports.randomStringForEntropy = randomStringForEntropy;
})(random);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sharedKey = exports.generateKeyPair = exports.generateKeyPairFromSeed = exports.scalarMultBase = exports.scalarMult = exports.SHARED_KEY_LENGTH = exports.SECRET_KEY_LENGTH = exports.PUBLIC_KEY_LENGTH = void 0;
  const random_1 = random;
  const wipe_12 = wipe$1;
  exports.PUBLIC_KEY_LENGTH = 32;
  exports.SECRET_KEY_LENGTH = 32;
  exports.SHARED_KEY_LENGTH = 32;
  function gf(init2) {
    const r = new Float64Array(16);
    if (init2) {
      for (let i2 = 0; i2 < init2.length; i2++) {
        r[i2] = init2[i2];
      }
    }
    return r;
  }
  const _9 = new Uint8Array(32);
  _9[0] = 9;
  const _121665 = gf([56129, 1]);
  function car25519(o) {
    let c = 1;
    for (let i2 = 0; i2 < 16; i2++) {
      let v = o[i2] + c + 65535;
      c = Math.floor(v / 65536);
      o[i2] = v - c * 65536;
    }
    o[0] += c - 1 + 37 * (c - 1);
  }
  function sel25519(p, q, b2) {
    const c = ~(b2 - 1);
    for (let i2 = 0; i2 < 16; i2++) {
      const t = c & (p[i2] ^ q[i2]);
      p[i2] ^= t;
      q[i2] ^= t;
    }
  }
  function pack25519(o, n) {
    const m = gf();
    const t = gf();
    for (let i2 = 0; i2 < 16; i2++) {
      t[i2] = n[i2];
    }
    car25519(t);
    car25519(t);
    car25519(t);
    for (let j = 0; j < 2; j++) {
      m[0] = t[0] - 65517;
      for (let i2 = 1; i2 < 15; i2++) {
        m[i2] = t[i2] - 65535 - (m[i2 - 1] >> 16 & 1);
        m[i2 - 1] &= 65535;
      }
      m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
      const b2 = m[15] >> 16 & 1;
      m[14] &= 65535;
      sel25519(t, m, 1 - b2);
    }
    for (let i2 = 0; i2 < 16; i2++) {
      o[2 * i2] = t[i2] & 255;
      o[2 * i2 + 1] = t[i2] >> 8;
    }
  }
  function unpack25519(o, n) {
    for (let i2 = 0; i2 < 16; i2++) {
      o[i2] = n[2 * i2] + (n[2 * i2 + 1] << 8);
    }
    o[15] &= 32767;
  }
  function add(o, a, b2) {
    for (let i2 = 0; i2 < 16; i2++) {
      o[i2] = a[i2] + b2[i2];
    }
  }
  function sub(o, a, b2) {
    for (let i2 = 0; i2 < 16; i2++) {
      o[i2] = a[i2] - b2[i2];
    }
  }
  function mul(o, a, b2) {
    let v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3], b4 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b12 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
    v = a[0];
    t0 += v * b0;
    t1 += v * b1;
    t2 += v * b22;
    t3 += v * b3;
    t4 += v * b4;
    t5 += v * b5;
    t6 += v * b6;
    t7 += v * b7;
    t8 += v * b8;
    t9 += v * b9;
    t10 += v * b10;
    t11 += v * b11;
    t12 += v * b12;
    t13 += v * b13;
    t14 += v * b14;
    t15 += v * b15;
    v = a[1];
    t1 += v * b0;
    t2 += v * b1;
    t3 += v * b22;
    t4 += v * b3;
    t5 += v * b4;
    t6 += v * b5;
    t7 += v * b6;
    t8 += v * b7;
    t9 += v * b8;
    t10 += v * b9;
    t11 += v * b10;
    t12 += v * b11;
    t13 += v * b12;
    t14 += v * b13;
    t15 += v * b14;
    t16 += v * b15;
    v = a[2];
    t2 += v * b0;
    t3 += v * b1;
    t4 += v * b22;
    t5 += v * b3;
    t6 += v * b4;
    t7 += v * b5;
    t8 += v * b6;
    t9 += v * b7;
    t10 += v * b8;
    t11 += v * b9;
    t12 += v * b10;
    t13 += v * b11;
    t14 += v * b12;
    t15 += v * b13;
    t16 += v * b14;
    t17 += v * b15;
    v = a[3];
    t3 += v * b0;
    t4 += v * b1;
    t5 += v * b22;
    t6 += v * b3;
    t7 += v * b4;
    t8 += v * b5;
    t9 += v * b6;
    t10 += v * b7;
    t11 += v * b8;
    t12 += v * b9;
    t13 += v * b10;
    t14 += v * b11;
    t15 += v * b12;
    t16 += v * b13;
    t17 += v * b14;
    t18 += v * b15;
    v = a[4];
    t4 += v * b0;
    t5 += v * b1;
    t6 += v * b22;
    t7 += v * b3;
    t8 += v * b4;
    t9 += v * b5;
    t10 += v * b6;
    t11 += v * b7;
    t12 += v * b8;
    t13 += v * b9;
    t14 += v * b10;
    t15 += v * b11;
    t16 += v * b12;
    t17 += v * b13;
    t18 += v * b14;
    t19 += v * b15;
    v = a[5];
    t5 += v * b0;
    t6 += v * b1;
    t7 += v * b22;
    t8 += v * b3;
    t9 += v * b4;
    t10 += v * b5;
    t11 += v * b6;
    t12 += v * b7;
    t13 += v * b8;
    t14 += v * b9;
    t15 += v * b10;
    t16 += v * b11;
    t17 += v * b12;
    t18 += v * b13;
    t19 += v * b14;
    t20 += v * b15;
    v = a[6];
    t6 += v * b0;
    t7 += v * b1;
    t8 += v * b22;
    t9 += v * b3;
    t10 += v * b4;
    t11 += v * b5;
    t12 += v * b6;
    t13 += v * b7;
    t14 += v * b8;
    t15 += v * b9;
    t16 += v * b10;
    t17 += v * b11;
    t18 += v * b12;
    t19 += v * b13;
    t20 += v * b14;
    t21 += v * b15;
    v = a[7];
    t7 += v * b0;
    t8 += v * b1;
    t9 += v * b22;
    t10 += v * b3;
    t11 += v * b4;
    t12 += v * b5;
    t13 += v * b6;
    t14 += v * b7;
    t15 += v * b8;
    t16 += v * b9;
    t17 += v * b10;
    t18 += v * b11;
    t19 += v * b12;
    t20 += v * b13;
    t21 += v * b14;
    t22 += v * b15;
    v = a[8];
    t8 += v * b0;
    t9 += v * b1;
    t10 += v * b22;
    t11 += v * b3;
    t12 += v * b4;
    t13 += v * b5;
    t14 += v * b6;
    t15 += v * b7;
    t16 += v * b8;
    t17 += v * b9;
    t18 += v * b10;
    t19 += v * b11;
    t20 += v * b12;
    t21 += v * b13;
    t22 += v * b14;
    t23 += v * b15;
    v = a[9];
    t9 += v * b0;
    t10 += v * b1;
    t11 += v * b22;
    t12 += v * b3;
    t13 += v * b4;
    t14 += v * b5;
    t15 += v * b6;
    t16 += v * b7;
    t17 += v * b8;
    t18 += v * b9;
    t19 += v * b10;
    t20 += v * b11;
    t21 += v * b12;
    t22 += v * b13;
    t23 += v * b14;
    t24 += v * b15;
    v = a[10];
    t10 += v * b0;
    t11 += v * b1;
    t12 += v * b22;
    t13 += v * b3;
    t14 += v * b4;
    t15 += v * b5;
    t16 += v * b6;
    t17 += v * b7;
    t18 += v * b8;
    t19 += v * b9;
    t20 += v * b10;
    t21 += v * b11;
    t22 += v * b12;
    t23 += v * b13;
    t24 += v * b14;
    t25 += v * b15;
    v = a[11];
    t11 += v * b0;
    t12 += v * b1;
    t13 += v * b22;
    t14 += v * b3;
    t15 += v * b4;
    t16 += v * b5;
    t17 += v * b6;
    t18 += v * b7;
    t19 += v * b8;
    t20 += v * b9;
    t21 += v * b10;
    t22 += v * b11;
    t23 += v * b12;
    t24 += v * b13;
    t25 += v * b14;
    t26 += v * b15;
    v = a[12];
    t12 += v * b0;
    t13 += v * b1;
    t14 += v * b22;
    t15 += v * b3;
    t16 += v * b4;
    t17 += v * b5;
    t18 += v * b6;
    t19 += v * b7;
    t20 += v * b8;
    t21 += v * b9;
    t22 += v * b10;
    t23 += v * b11;
    t24 += v * b12;
    t25 += v * b13;
    t26 += v * b14;
    t27 += v * b15;
    v = a[13];
    t13 += v * b0;
    t14 += v * b1;
    t15 += v * b22;
    t16 += v * b3;
    t17 += v * b4;
    t18 += v * b5;
    t19 += v * b6;
    t20 += v * b7;
    t21 += v * b8;
    t22 += v * b9;
    t23 += v * b10;
    t24 += v * b11;
    t25 += v * b12;
    t26 += v * b13;
    t27 += v * b14;
    t28 += v * b15;
    v = a[14];
    t14 += v * b0;
    t15 += v * b1;
    t16 += v * b22;
    t17 += v * b3;
    t18 += v * b4;
    t19 += v * b5;
    t20 += v * b6;
    t21 += v * b7;
    t22 += v * b8;
    t23 += v * b9;
    t24 += v * b10;
    t25 += v * b11;
    t26 += v * b12;
    t27 += v * b13;
    t28 += v * b14;
    t29 += v * b15;
    v = a[15];
    t15 += v * b0;
    t16 += v * b1;
    t17 += v * b22;
    t18 += v * b3;
    t19 += v * b4;
    t20 += v * b5;
    t21 += v * b6;
    t22 += v * b7;
    t23 += v * b8;
    t24 += v * b9;
    t25 += v * b10;
    t26 += v * b11;
    t27 += v * b12;
    t28 += v * b13;
    t29 += v * b14;
    t30 += v * b15;
    t0 += 38 * t16;
    t1 += 38 * t17;
    t2 += 38 * t18;
    t3 += 38 * t19;
    t4 += 38 * t20;
    t5 += 38 * t21;
    t6 += 38 * t22;
    t7 += 38 * t23;
    t8 += 38 * t24;
    t9 += 38 * t25;
    t10 += 38 * t26;
    t11 += 38 * t27;
    t12 += 38 * t28;
    t13 += 38 * t29;
    t14 += 38 * t30;
    c = 1;
    v = t0 + c + 65535;
    c = Math.floor(v / 65536);
    t0 = v - c * 65536;
    v = t1 + c + 65535;
    c = Math.floor(v / 65536);
    t1 = v - c * 65536;
    v = t2 + c + 65535;
    c = Math.floor(v / 65536);
    t2 = v - c * 65536;
    v = t3 + c + 65535;
    c = Math.floor(v / 65536);
    t3 = v - c * 65536;
    v = t4 + c + 65535;
    c = Math.floor(v / 65536);
    t4 = v - c * 65536;
    v = t5 + c + 65535;
    c = Math.floor(v / 65536);
    t5 = v - c * 65536;
    v = t6 + c + 65535;
    c = Math.floor(v / 65536);
    t6 = v - c * 65536;
    v = t7 + c + 65535;
    c = Math.floor(v / 65536);
    t7 = v - c * 65536;
    v = t8 + c + 65535;
    c = Math.floor(v / 65536);
    t8 = v - c * 65536;
    v = t9 + c + 65535;
    c = Math.floor(v / 65536);
    t9 = v - c * 65536;
    v = t10 + c + 65535;
    c = Math.floor(v / 65536);
    t10 = v - c * 65536;
    v = t11 + c + 65535;
    c = Math.floor(v / 65536);
    t11 = v - c * 65536;
    v = t12 + c + 65535;
    c = Math.floor(v / 65536);
    t12 = v - c * 65536;
    v = t13 + c + 65535;
    c = Math.floor(v / 65536);
    t13 = v - c * 65536;
    v = t14 + c + 65535;
    c = Math.floor(v / 65536);
    t14 = v - c * 65536;
    v = t15 + c + 65535;
    c = Math.floor(v / 65536);
    t15 = v - c * 65536;
    t0 += c - 1 + 37 * (c - 1);
    c = 1;
    v = t0 + c + 65535;
    c = Math.floor(v / 65536);
    t0 = v - c * 65536;
    v = t1 + c + 65535;
    c = Math.floor(v / 65536);
    t1 = v - c * 65536;
    v = t2 + c + 65535;
    c = Math.floor(v / 65536);
    t2 = v - c * 65536;
    v = t3 + c + 65535;
    c = Math.floor(v / 65536);
    t3 = v - c * 65536;
    v = t4 + c + 65535;
    c = Math.floor(v / 65536);
    t4 = v - c * 65536;
    v = t5 + c + 65535;
    c = Math.floor(v / 65536);
    t5 = v - c * 65536;
    v = t6 + c + 65535;
    c = Math.floor(v / 65536);
    t6 = v - c * 65536;
    v = t7 + c + 65535;
    c = Math.floor(v / 65536);
    t7 = v - c * 65536;
    v = t8 + c + 65535;
    c = Math.floor(v / 65536);
    t8 = v - c * 65536;
    v = t9 + c + 65535;
    c = Math.floor(v / 65536);
    t9 = v - c * 65536;
    v = t10 + c + 65535;
    c = Math.floor(v / 65536);
    t10 = v - c * 65536;
    v = t11 + c + 65535;
    c = Math.floor(v / 65536);
    t11 = v - c * 65536;
    v = t12 + c + 65535;
    c = Math.floor(v / 65536);
    t12 = v - c * 65536;
    v = t13 + c + 65535;
    c = Math.floor(v / 65536);
    t13 = v - c * 65536;
    v = t14 + c + 65535;
    c = Math.floor(v / 65536);
    t14 = v - c * 65536;
    v = t15 + c + 65535;
    c = Math.floor(v / 65536);
    t15 = v - c * 65536;
    t0 += c - 1 + 37 * (c - 1);
    o[0] = t0;
    o[1] = t1;
    o[2] = t2;
    o[3] = t3;
    o[4] = t4;
    o[5] = t5;
    o[6] = t6;
    o[7] = t7;
    o[8] = t8;
    o[9] = t9;
    o[10] = t10;
    o[11] = t11;
    o[12] = t12;
    o[13] = t13;
    o[14] = t14;
    o[15] = t15;
  }
  function square(o, a) {
    mul(o, a, a);
  }
  function inv25519(o, inp) {
    const c = gf();
    for (let i2 = 0; i2 < 16; i2++) {
      c[i2] = inp[i2];
    }
    for (let i2 = 253; i2 >= 0; i2--) {
      square(c, c);
      if (i2 !== 2 && i2 !== 4) {
        mul(c, c, inp);
      }
    }
    for (let i2 = 0; i2 < 16; i2++) {
      o[i2] = c[i2];
    }
  }
  function scalarMult(n, p) {
    const z = new Uint8Array(32);
    const x = new Float64Array(80);
    const a = gf(), b2 = gf(), c = gf(), d = gf(), e = gf(), f = gf();
    for (let i2 = 0; i2 < 31; i2++) {
      z[i2] = n[i2];
    }
    z[31] = n[31] & 127 | 64;
    z[0] &= 248;
    unpack25519(x, p);
    for (let i2 = 0; i2 < 16; i2++) {
      b2[i2] = x[i2];
    }
    a[0] = d[0] = 1;
    for (let i2 = 254; i2 >= 0; --i2) {
      const r = z[i2 >>> 3] >>> (i2 & 7) & 1;
      sel25519(a, b2, r);
      sel25519(c, d, r);
      add(e, a, c);
      sub(a, a, c);
      add(c, b2, d);
      sub(b2, b2, d);
      square(d, e);
      square(f, a);
      mul(a, c, a);
      mul(c, b2, e);
      add(e, a, c);
      sub(a, a, c);
      square(b2, a);
      sub(c, d, f);
      mul(a, c, _121665);
      add(a, a, d);
      mul(c, c, a);
      mul(a, d, f);
      mul(d, b2, x);
      square(b2, e);
      sel25519(a, b2, r);
      sel25519(c, d, r);
    }
    for (let i2 = 0; i2 < 16; i2++) {
      x[i2 + 16] = a[i2];
      x[i2 + 32] = c[i2];
      x[i2 + 48] = b2[i2];
      x[i2 + 64] = d[i2];
    }
    const x32 = x.subarray(32);
    const x16 = x.subarray(16);
    inv25519(x32, x32);
    mul(x16, x16, x32);
    const q = new Uint8Array(32);
    pack25519(q, x16);
    return q;
  }
  exports.scalarMult = scalarMult;
  function scalarMultBase(n) {
    return scalarMult(n, _9);
  }
  exports.scalarMultBase = scalarMultBase;
  function generateKeyPairFromSeed2(seed2) {
    if (seed2.length !== exports.SECRET_KEY_LENGTH) {
      throw new Error(`x25519: seed must be ${exports.SECRET_KEY_LENGTH} bytes`);
    }
    const secretKey = new Uint8Array(seed2);
    const publicKey = scalarMultBase(secretKey);
    return {
      publicKey,
      secretKey
    };
  }
  exports.generateKeyPairFromSeed = generateKeyPairFromSeed2;
  function generateKeyPair2(prng2) {
    const seed2 = (0, random_1.randomBytes)(32, prng2);
    const result = generateKeyPairFromSeed2(seed2);
    (0, wipe_12.wipe)(seed2);
    return result;
  }
  exports.generateKeyPair = generateKeyPair2;
  function sharedKey(mySecretKey, theirPublicKey, rejectZero = false) {
    if (mySecretKey.length !== exports.PUBLIC_KEY_LENGTH) {
      throw new Error("X25519: incorrect secret key length");
    }
    if (theirPublicKey.length !== exports.PUBLIC_KEY_LENGTH) {
      throw new Error("X25519: incorrect public key length");
    }
    const result = scalarMult(mySecretKey, theirPublicKey);
    if (rejectZero) {
      let zeros = 0;
      for (let i2 = 0; i2 < result.length; i2++) {
        zeros |= result[i2];
      }
      if (zeros === 0) {
        throw new Error("X25519: invalid shared key");
      }
    }
    return result;
  }
  exports.sharedKey = sharedKey;
})(x25519);
var sha256 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var binary_12 = binary;
  var wipe_12 = wipe$1;
  exports.DIGEST_LENGTH = 32;
  exports.BLOCK_SIZE = 64;
  var SHA256 = function() {
    function SHA2562() {
      this.digestLength = exports.DIGEST_LENGTH;
      this.blockSize = exports.BLOCK_SIZE;
      this._state = new Int32Array(8);
      this._temp = new Int32Array(64);
      this._buffer = new Uint8Array(128);
      this._bufferLength = 0;
      this._bytesHashed = 0;
      this._finished = false;
      this.reset();
    }
    SHA2562.prototype._initState = function() {
      this._state[0] = 1779033703;
      this._state[1] = 3144134277;
      this._state[2] = 1013904242;
      this._state[3] = 2773480762;
      this._state[4] = 1359893119;
      this._state[5] = 2600822924;
      this._state[6] = 528734635;
      this._state[7] = 1541459225;
    };
    SHA2562.prototype.reset = function() {
      this._initState();
      this._bufferLength = 0;
      this._bytesHashed = 0;
      this._finished = false;
      return this;
    };
    SHA2562.prototype.clean = function() {
      wipe_12.wipe(this._buffer);
      wipe_12.wipe(this._temp);
      this.reset();
    };
    SHA2562.prototype.update = function(data, dataLength) {
      if (dataLength === void 0) {
        dataLength = data.length;
      }
      if (this._finished) {
        throw new Error("SHA256: can't update because hash was finished.");
      }
      var dataPos = 0;
      this._bytesHashed += dataLength;
      if (this._bufferLength > 0) {
        while (this._bufferLength < this.blockSize && dataLength > 0) {
          this._buffer[this._bufferLength++] = data[dataPos++];
          dataLength--;
        }
        if (this._bufferLength === this.blockSize) {
          hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize);
          this._bufferLength = 0;
        }
      }
      if (dataLength >= this.blockSize) {
        dataPos = hashBlocks(this._temp, this._state, data, dataPos, dataLength);
        dataLength %= this.blockSize;
      }
      while (dataLength > 0) {
        this._buffer[this._bufferLength++] = data[dataPos++];
        dataLength--;
      }
      return this;
    };
    SHA2562.prototype.finish = function(out) {
      if (!this._finished) {
        var bytesHashed = this._bytesHashed;
        var left = this._bufferLength;
        var bitLenHi = bytesHashed / 536870912 | 0;
        var bitLenLo = bytesHashed << 3;
        var padLength = bytesHashed % 64 < 56 ? 64 : 128;
        this._buffer[left] = 128;
        for (var i2 = left + 1; i2 < padLength - 8; i2++) {
          this._buffer[i2] = 0;
        }
        binary_12.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
        binary_12.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
        hashBlocks(this._temp, this._state, this._buffer, 0, padLength);
        this._finished = true;
      }
      for (var i2 = 0; i2 < this.digestLength / 4; i2++) {
        binary_12.writeUint32BE(this._state[i2], out, i2 * 4);
      }
      return this;
    };
    SHA2562.prototype.digest = function() {
      var out = new Uint8Array(this.digestLength);
      this.finish(out);
      return out;
    };
    SHA2562.prototype.saveState = function() {
      if (this._finished) {
        throw new Error("SHA256: cannot save finished state");
      }
      return {
        state: new Int32Array(this._state),
        buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
        bufferLength: this._bufferLength,
        bytesHashed: this._bytesHashed
      };
    };
    SHA2562.prototype.restoreState = function(savedState) {
      this._state.set(savedState.state);
      this._bufferLength = savedState.bufferLength;
      if (savedState.buffer) {
        this._buffer.set(savedState.buffer);
      }
      this._bytesHashed = savedState.bytesHashed;
      this._finished = false;
      return this;
    };
    SHA2562.prototype.cleanSavedState = function(savedState) {
      wipe_12.wipe(savedState.state);
      if (savedState.buffer) {
        wipe_12.wipe(savedState.buffer);
      }
      savedState.bufferLength = 0;
      savedState.bytesHashed = 0;
    };
    return SHA2562;
  }();
  exports.SHA256 = SHA256;
  var K2 = new Int32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  function hashBlocks(w, v, p, pos, len2) {
    while (len2 >= 64) {
      var a = v[0];
      var b2 = v[1];
      var c = v[2];
      var d = v[3];
      var e = v[4];
      var f = v[5];
      var g = v[6];
      var h = v[7];
      for (var i2 = 0; i2 < 16; i2++) {
        var j = pos + i2 * 4;
        w[i2] = binary_12.readUint32BE(p, j);
      }
      for (var i2 = 16; i2 < 64; i2++) {
        var u = w[i2 - 2];
        var t1 = (u >>> 17 | u << 32 - 17) ^ (u >>> 19 | u << 32 - 19) ^ u >>> 10;
        u = w[i2 - 15];
        var t2 = (u >>> 7 | u << 32 - 7) ^ (u >>> 18 | u << 32 - 18) ^ u >>> 3;
        w[i2] = (t1 + w[i2 - 7] | 0) + (t2 + w[i2 - 16] | 0);
      }
      for (var i2 = 0; i2 < 64; i2++) {
        var t1 = (((e >>> 6 | e << 32 - 6) ^ (e >>> 11 | e << 32 - 11) ^ (e >>> 25 | e << 32 - 25)) + (e & f ^ ~e & g) | 0) + (h + (K2[i2] + w[i2] | 0) | 0) | 0;
        var t2 = ((a >>> 2 | a << 32 - 2) ^ (a >>> 13 | a << 32 - 13) ^ (a >>> 22 | a << 32 - 22)) + (a & b2 ^ a & c ^ b2 & c) | 0;
        h = g;
        g = f;
        f = e;
        e = d + t1 | 0;
        d = c;
        c = b2;
        b2 = a;
        a = t1 + t2 | 0;
      }
      v[0] += a;
      v[1] += b2;
      v[2] += c;
      v[3] += d;
      v[4] += e;
      v[5] += f;
      v[6] += g;
      v[7] += h;
      pos += 64;
      len2 -= 64;
    }
    return pos;
  }
  function hash2(data) {
    var h = new SHA256();
    h.update(data);
    var digest2 = h.digest();
    h.clean();
    return digest2;
  }
  exports.hash = hash2;
})(sha256);
var chacha20poly1305 = {};
var chacha = {};
Object.defineProperty(chacha, "__esModule", { value: true });
var binary_1 = binary;
var wipe_1 = wipe$1;
var ROUNDS = 20;
function core(out, input, key) {
  var j0 = 1634760805;
  var j1 = 857760878;
  var j2 = 2036477234;
  var j3 = 1797285236;
  var j4 = key[3] << 24 | key[2] << 16 | key[1] << 8 | key[0];
  var j5 = key[7] << 24 | key[6] << 16 | key[5] << 8 | key[4];
  var j6 = key[11] << 24 | key[10] << 16 | key[9] << 8 | key[8];
  var j7 = key[15] << 24 | key[14] << 16 | key[13] << 8 | key[12];
  var j8 = key[19] << 24 | key[18] << 16 | key[17] << 8 | key[16];
  var j9 = key[23] << 24 | key[22] << 16 | key[21] << 8 | key[20];
  var j10 = key[27] << 24 | key[26] << 16 | key[25] << 8 | key[24];
  var j11 = key[31] << 24 | key[30] << 16 | key[29] << 8 | key[28];
  var j12 = input[3] << 24 | input[2] << 16 | input[1] << 8 | input[0];
  var j13 = input[7] << 24 | input[6] << 16 | input[5] << 8 | input[4];
  var j14 = input[11] << 24 | input[10] << 16 | input[9] << 8 | input[8];
  var j15 = input[15] << 24 | input[14] << 16 | input[13] << 8 | input[12];
  var x0 = j0;
  var x1 = j1;
  var x2 = j2;
  var x3 = j3;
  var x4 = j4;
  var x5 = j5;
  var x6 = j6;
  var x7 = j7;
  var x8 = j8;
  var x9 = j9;
  var x10 = j10;
  var x11 = j11;
  var x12 = j12;
  var x13 = j13;
  var x14 = j14;
  var x15 = j15;
  for (var i2 = 0; i2 < ROUNDS; i2 += 2) {
    x0 = x0 + x4 | 0;
    x12 ^= x0;
    x12 = x12 >>> 32 - 16 | x12 << 16;
    x8 = x8 + x12 | 0;
    x4 ^= x8;
    x4 = x4 >>> 32 - 12 | x4 << 12;
    x1 = x1 + x5 | 0;
    x13 ^= x1;
    x13 = x13 >>> 32 - 16 | x13 << 16;
    x9 = x9 + x13 | 0;
    x5 ^= x9;
    x5 = x5 >>> 32 - 12 | x5 << 12;
    x2 = x2 + x6 | 0;
    x14 ^= x2;
    x14 = x14 >>> 32 - 16 | x14 << 16;
    x10 = x10 + x14 | 0;
    x6 ^= x10;
    x6 = x6 >>> 32 - 12 | x6 << 12;
    x3 = x3 + x7 | 0;
    x15 ^= x3;
    x15 = x15 >>> 32 - 16 | x15 << 16;
    x11 = x11 + x15 | 0;
    x7 ^= x11;
    x7 = x7 >>> 32 - 12 | x7 << 12;
    x2 = x2 + x6 | 0;
    x14 ^= x2;
    x14 = x14 >>> 32 - 8 | x14 << 8;
    x10 = x10 + x14 | 0;
    x6 ^= x10;
    x6 = x6 >>> 32 - 7 | x6 << 7;
    x3 = x3 + x7 | 0;
    x15 ^= x3;
    x15 = x15 >>> 32 - 8 | x15 << 8;
    x11 = x11 + x15 | 0;
    x7 ^= x11;
    x7 = x7 >>> 32 - 7 | x7 << 7;
    x1 = x1 + x5 | 0;
    x13 ^= x1;
    x13 = x13 >>> 32 - 8 | x13 << 8;
    x9 = x9 + x13 | 0;
    x5 ^= x9;
    x5 = x5 >>> 32 - 7 | x5 << 7;
    x0 = x0 + x4 | 0;
    x12 ^= x0;
    x12 = x12 >>> 32 - 8 | x12 << 8;
    x8 = x8 + x12 | 0;
    x4 ^= x8;
    x4 = x4 >>> 32 - 7 | x4 << 7;
    x0 = x0 + x5 | 0;
    x15 ^= x0;
    x15 = x15 >>> 32 - 16 | x15 << 16;
    x10 = x10 + x15 | 0;
    x5 ^= x10;
    x5 = x5 >>> 32 - 12 | x5 << 12;
    x1 = x1 + x6 | 0;
    x12 ^= x1;
    x12 = x12 >>> 32 - 16 | x12 << 16;
    x11 = x11 + x12 | 0;
    x6 ^= x11;
    x6 = x6 >>> 32 - 12 | x6 << 12;
    x2 = x2 + x7 | 0;
    x13 ^= x2;
    x13 = x13 >>> 32 - 16 | x13 << 16;
    x8 = x8 + x13 | 0;
    x7 ^= x8;
    x7 = x7 >>> 32 - 12 | x7 << 12;
    x3 = x3 + x4 | 0;
    x14 ^= x3;
    x14 = x14 >>> 32 - 16 | x14 << 16;
    x9 = x9 + x14 | 0;
    x4 ^= x9;
    x4 = x4 >>> 32 - 12 | x4 << 12;
    x2 = x2 + x7 | 0;
    x13 ^= x2;
    x13 = x13 >>> 32 - 8 | x13 << 8;
    x8 = x8 + x13 | 0;
    x7 ^= x8;
    x7 = x7 >>> 32 - 7 | x7 << 7;
    x3 = x3 + x4 | 0;
    x14 ^= x3;
    x14 = x14 >>> 32 - 8 | x14 << 8;
    x9 = x9 + x14 | 0;
    x4 ^= x9;
    x4 = x4 >>> 32 - 7 | x4 << 7;
    x1 = x1 + x6 | 0;
    x12 ^= x1;
    x12 = x12 >>> 32 - 8 | x12 << 8;
    x11 = x11 + x12 | 0;
    x6 ^= x11;
    x6 = x6 >>> 32 - 7 | x6 << 7;
    x0 = x0 + x5 | 0;
    x15 ^= x0;
    x15 = x15 >>> 32 - 8 | x15 << 8;
    x10 = x10 + x15 | 0;
    x5 ^= x10;
    x5 = x5 >>> 32 - 7 | x5 << 7;
  }
  binary_1.writeUint32LE(x0 + j0 | 0, out, 0);
  binary_1.writeUint32LE(x1 + j1 | 0, out, 4);
  binary_1.writeUint32LE(x2 + j2 | 0, out, 8);
  binary_1.writeUint32LE(x3 + j3 | 0, out, 12);
  binary_1.writeUint32LE(x4 + j4 | 0, out, 16);
  binary_1.writeUint32LE(x5 + j5 | 0, out, 20);
  binary_1.writeUint32LE(x6 + j6 | 0, out, 24);
  binary_1.writeUint32LE(x7 + j7 | 0, out, 28);
  binary_1.writeUint32LE(x8 + j8 | 0, out, 32);
  binary_1.writeUint32LE(x9 + j9 | 0, out, 36);
  binary_1.writeUint32LE(x10 + j10 | 0, out, 40);
  binary_1.writeUint32LE(x11 + j11 | 0, out, 44);
  binary_1.writeUint32LE(x12 + j12 | 0, out, 48);
  binary_1.writeUint32LE(x13 + j13 | 0, out, 52);
  binary_1.writeUint32LE(x14 + j14 | 0, out, 56);
  binary_1.writeUint32LE(x15 + j15 | 0, out, 60);
}
function streamXOR(key, nonce, src2, dst, nonceInplaceCounterLength) {
  if (nonceInplaceCounterLength === void 0) {
    nonceInplaceCounterLength = 0;
  }
  if (key.length !== 32) {
    throw new Error("ChaCha: key size must be 32 bytes");
  }
  if (dst.length < src2.length) {
    throw new Error("ChaCha: destination is shorter than source");
  }
  var nc;
  var counterLength;
  if (nonceInplaceCounterLength === 0) {
    if (nonce.length !== 8 && nonce.length !== 12) {
      throw new Error("ChaCha nonce must be 8 or 12 bytes");
    }
    nc = new Uint8Array(16);
    counterLength = nc.length - nonce.length;
    nc.set(nonce, counterLength);
  } else {
    if (nonce.length !== 16) {
      throw new Error("ChaCha nonce with counter must be 16 bytes");
    }
    nc = nonce;
    counterLength = nonceInplaceCounterLength;
  }
  var block = new Uint8Array(64);
  for (var i2 = 0; i2 < src2.length; i2 += 64) {
    core(block, nc, key);
    for (var j = i2; j < i2 + 64 && j < src2.length; j++) {
      dst[j] = src2[j] ^ block[j - i2];
    }
    incrementCounter(nc, 0, counterLength);
  }
  wipe_1.wipe(block);
  if (nonceInplaceCounterLength === 0) {
    wipe_1.wipe(nc);
  }
  return dst;
}
chacha.streamXOR = streamXOR;
function stream(key, nonce, dst, nonceInplaceCounterLength) {
  if (nonceInplaceCounterLength === void 0) {
    nonceInplaceCounterLength = 0;
  }
  wipe_1.wipe(dst);
  return streamXOR(key, nonce, dst, dst, nonceInplaceCounterLength);
}
chacha.stream = stream;
function incrementCounter(counter2, pos, len2) {
  var carry = 1;
  while (len2--) {
    carry = carry + (counter2[pos] & 255) | 0;
    counter2[pos] = carry & 255;
    carry >>>= 8;
    pos++;
  }
  if (carry > 0) {
    throw new Error("ChaCha: counter overflow");
  }
}
var poly1305 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var constant_time_12 = constantTime;
  var wipe_12 = wipe$1;
  exports.DIGEST_LENGTH = 16;
  var Poly1305 = function() {
    function Poly13052(key) {
      this.digestLength = exports.DIGEST_LENGTH;
      this._buffer = new Uint8Array(16);
      this._r = new Uint16Array(10);
      this._h = new Uint16Array(10);
      this._pad = new Uint16Array(8);
      this._leftover = 0;
      this._fin = 0;
      this._finished = false;
      var t0 = key[0] | key[1] << 8;
      this._r[0] = t0 & 8191;
      var t1 = key[2] | key[3] << 8;
      this._r[1] = (t0 >>> 13 | t1 << 3) & 8191;
      var t2 = key[4] | key[5] << 8;
      this._r[2] = (t1 >>> 10 | t2 << 6) & 7939;
      var t3 = key[6] | key[7] << 8;
      this._r[3] = (t2 >>> 7 | t3 << 9) & 8191;
      var t4 = key[8] | key[9] << 8;
      this._r[4] = (t3 >>> 4 | t4 << 12) & 255;
      this._r[5] = t4 >>> 1 & 8190;
      var t5 = key[10] | key[11] << 8;
      this._r[6] = (t4 >>> 14 | t5 << 2) & 8191;
      var t6 = key[12] | key[13] << 8;
      this._r[7] = (t5 >>> 11 | t6 << 5) & 8065;
      var t7 = key[14] | key[15] << 8;
      this._r[8] = (t6 >>> 8 | t7 << 8) & 8191;
      this._r[9] = t7 >>> 5 & 127;
      this._pad[0] = key[16] | key[17] << 8;
      this._pad[1] = key[18] | key[19] << 8;
      this._pad[2] = key[20] | key[21] << 8;
      this._pad[3] = key[22] | key[23] << 8;
      this._pad[4] = key[24] | key[25] << 8;
      this._pad[5] = key[26] | key[27] << 8;
      this._pad[6] = key[28] | key[29] << 8;
      this._pad[7] = key[30] | key[31] << 8;
    }
    Poly13052.prototype._blocks = function(m, mpos, bytes2) {
      var hibit = this._fin ? 0 : 1 << 11;
      var h0 = this._h[0], h1 = this._h[1], h2 = this._h[2], h3 = this._h[3], h4 = this._h[4], h5 = this._h[5], h6 = this._h[6], h7 = this._h[7], h8 = this._h[8], h9 = this._h[9];
      var r0 = this._r[0], r1 = this._r[1], r2 = this._r[2], r3 = this._r[3], r4 = this._r[4], r5 = this._r[5], r6 = this._r[6], r7 = this._r[7], r8 = this._r[8], r9 = this._r[9];
      while (bytes2 >= 16) {
        var t0 = m[mpos + 0] | m[mpos + 1] << 8;
        h0 += t0 & 8191;
        var t1 = m[mpos + 2] | m[mpos + 3] << 8;
        h1 += (t0 >>> 13 | t1 << 3) & 8191;
        var t2 = m[mpos + 4] | m[mpos + 5] << 8;
        h2 += (t1 >>> 10 | t2 << 6) & 8191;
        var t3 = m[mpos + 6] | m[mpos + 7] << 8;
        h3 += (t2 >>> 7 | t3 << 9) & 8191;
        var t4 = m[mpos + 8] | m[mpos + 9] << 8;
        h4 += (t3 >>> 4 | t4 << 12) & 8191;
        h5 += t4 >>> 1 & 8191;
        var t5 = m[mpos + 10] | m[mpos + 11] << 8;
        h6 += (t4 >>> 14 | t5 << 2) & 8191;
        var t6 = m[mpos + 12] | m[mpos + 13] << 8;
        h7 += (t5 >>> 11 | t6 << 5) & 8191;
        var t7 = m[mpos + 14] | m[mpos + 15] << 8;
        h8 += (t6 >>> 8 | t7 << 8) & 8191;
        h9 += t7 >>> 5 | hibit;
        var c = 0;
        var d0 = c;
        d0 += h0 * r0;
        d0 += h1 * (5 * r9);
        d0 += h2 * (5 * r8);
        d0 += h3 * (5 * r7);
        d0 += h4 * (5 * r6);
        c = d0 >>> 13;
        d0 &= 8191;
        d0 += h5 * (5 * r5);
        d0 += h6 * (5 * r4);
        d0 += h7 * (5 * r3);
        d0 += h8 * (5 * r2);
        d0 += h9 * (5 * r1);
        c += d0 >>> 13;
        d0 &= 8191;
        var d1 = c;
        d1 += h0 * r1;
        d1 += h1 * r0;
        d1 += h2 * (5 * r9);
        d1 += h3 * (5 * r8);
        d1 += h4 * (5 * r7);
        c = d1 >>> 13;
        d1 &= 8191;
        d1 += h5 * (5 * r6);
        d1 += h6 * (5 * r5);
        d1 += h7 * (5 * r4);
        d1 += h8 * (5 * r3);
        d1 += h9 * (5 * r2);
        c += d1 >>> 13;
        d1 &= 8191;
        var d2 = c;
        d2 += h0 * r2;
        d2 += h1 * r1;
        d2 += h2 * r0;
        d2 += h3 * (5 * r9);
        d2 += h4 * (5 * r8);
        c = d2 >>> 13;
        d2 &= 8191;
        d2 += h5 * (5 * r7);
        d2 += h6 * (5 * r6);
        d2 += h7 * (5 * r5);
        d2 += h8 * (5 * r4);
        d2 += h9 * (5 * r3);
        c += d2 >>> 13;
        d2 &= 8191;
        var d3 = c;
        d3 += h0 * r3;
        d3 += h1 * r2;
        d3 += h2 * r1;
        d3 += h3 * r0;
        d3 += h4 * (5 * r9);
        c = d3 >>> 13;
        d3 &= 8191;
        d3 += h5 * (5 * r8);
        d3 += h6 * (5 * r7);
        d3 += h7 * (5 * r6);
        d3 += h8 * (5 * r5);
        d3 += h9 * (5 * r4);
        c += d3 >>> 13;
        d3 &= 8191;
        var d4 = c;
        d4 += h0 * r4;
        d4 += h1 * r3;
        d4 += h2 * r2;
        d4 += h3 * r1;
        d4 += h4 * r0;
        c = d4 >>> 13;
        d4 &= 8191;
        d4 += h5 * (5 * r9);
        d4 += h6 * (5 * r8);
        d4 += h7 * (5 * r7);
        d4 += h8 * (5 * r6);
        d4 += h9 * (5 * r5);
        c += d4 >>> 13;
        d4 &= 8191;
        var d5 = c;
        d5 += h0 * r5;
        d5 += h1 * r4;
        d5 += h2 * r3;
        d5 += h3 * r2;
        d5 += h4 * r1;
        c = d5 >>> 13;
        d5 &= 8191;
        d5 += h5 * r0;
        d5 += h6 * (5 * r9);
        d5 += h7 * (5 * r8);
        d5 += h8 * (5 * r7);
        d5 += h9 * (5 * r6);
        c += d5 >>> 13;
        d5 &= 8191;
        var d6 = c;
        d6 += h0 * r6;
        d6 += h1 * r5;
        d6 += h2 * r4;
        d6 += h3 * r3;
        d6 += h4 * r2;
        c = d6 >>> 13;
        d6 &= 8191;
        d6 += h5 * r1;
        d6 += h6 * r0;
        d6 += h7 * (5 * r9);
        d6 += h8 * (5 * r8);
        d6 += h9 * (5 * r7);
        c += d6 >>> 13;
        d6 &= 8191;
        var d7 = c;
        d7 += h0 * r7;
        d7 += h1 * r6;
        d7 += h2 * r5;
        d7 += h3 * r4;
        d7 += h4 * r3;
        c = d7 >>> 13;
        d7 &= 8191;
        d7 += h5 * r2;
        d7 += h6 * r1;
        d7 += h7 * r0;
        d7 += h8 * (5 * r9);
        d7 += h9 * (5 * r8);
        c += d7 >>> 13;
        d7 &= 8191;
        var d8 = c;
        d8 += h0 * r8;
        d8 += h1 * r7;
        d8 += h2 * r6;
        d8 += h3 * r5;
        d8 += h4 * r4;
        c = d8 >>> 13;
        d8 &= 8191;
        d8 += h5 * r3;
        d8 += h6 * r2;
        d8 += h7 * r1;
        d8 += h8 * r0;
        d8 += h9 * (5 * r9);
        c += d8 >>> 13;
        d8 &= 8191;
        var d9 = c;
        d9 += h0 * r9;
        d9 += h1 * r8;
        d9 += h2 * r7;
        d9 += h3 * r6;
        d9 += h4 * r5;
        c = d9 >>> 13;
        d9 &= 8191;
        d9 += h5 * r4;
        d9 += h6 * r3;
        d9 += h7 * r2;
        d9 += h8 * r1;
        d9 += h9 * r0;
        c += d9 >>> 13;
        d9 &= 8191;
        c = (c << 2) + c | 0;
        c = c + d0 | 0;
        d0 = c & 8191;
        c = c >>> 13;
        d1 += c;
        h0 = d0;
        h1 = d1;
        h2 = d2;
        h3 = d3;
        h4 = d4;
        h5 = d5;
        h6 = d6;
        h7 = d7;
        h8 = d8;
        h9 = d9;
        mpos += 16;
        bytes2 -= 16;
      }
      this._h[0] = h0;
      this._h[1] = h1;
      this._h[2] = h2;
      this._h[3] = h3;
      this._h[4] = h4;
      this._h[5] = h5;
      this._h[6] = h6;
      this._h[7] = h7;
      this._h[8] = h8;
      this._h[9] = h9;
    };
    Poly13052.prototype.finish = function(mac, macpos) {
      if (macpos === void 0) {
        macpos = 0;
      }
      var g = new Uint16Array(10);
      var c;
      var mask;
      var f;
      var i2;
      if (this._leftover) {
        i2 = this._leftover;
        this._buffer[i2++] = 1;
        for (; i2 < 16; i2++) {
          this._buffer[i2] = 0;
        }
        this._fin = 1;
        this._blocks(this._buffer, 0, 16);
      }
      c = this._h[1] >>> 13;
      this._h[1] &= 8191;
      for (i2 = 2; i2 < 10; i2++) {
        this._h[i2] += c;
        c = this._h[i2] >>> 13;
        this._h[i2] &= 8191;
      }
      this._h[0] += c * 5;
      c = this._h[0] >>> 13;
      this._h[0] &= 8191;
      this._h[1] += c;
      c = this._h[1] >>> 13;
      this._h[1] &= 8191;
      this._h[2] += c;
      g[0] = this._h[0] + 5;
      c = g[0] >>> 13;
      g[0] &= 8191;
      for (i2 = 1; i2 < 10; i2++) {
        g[i2] = this._h[i2] + c;
        c = g[i2] >>> 13;
        g[i2] &= 8191;
      }
      g[9] -= 1 << 13;
      mask = (c ^ 1) - 1;
      for (i2 = 0; i2 < 10; i2++) {
        g[i2] &= mask;
      }
      mask = ~mask;
      for (i2 = 0; i2 < 10; i2++) {
        this._h[i2] = this._h[i2] & mask | g[i2];
      }
      this._h[0] = (this._h[0] | this._h[1] << 13) & 65535;
      this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535;
      this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535;
      this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535;
      this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535;
      this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535;
      this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535;
      this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535;
      f = this._h[0] + this._pad[0];
      this._h[0] = f & 65535;
      for (i2 = 1; i2 < 8; i2++) {
        f = (this._h[i2] + this._pad[i2] | 0) + (f >>> 16) | 0;
        this._h[i2] = f & 65535;
      }
      mac[macpos + 0] = this._h[0] >>> 0;
      mac[macpos + 1] = this._h[0] >>> 8;
      mac[macpos + 2] = this._h[1] >>> 0;
      mac[macpos + 3] = this._h[1] >>> 8;
      mac[macpos + 4] = this._h[2] >>> 0;
      mac[macpos + 5] = this._h[2] >>> 8;
      mac[macpos + 6] = this._h[3] >>> 0;
      mac[macpos + 7] = this._h[3] >>> 8;
      mac[macpos + 8] = this._h[4] >>> 0;
      mac[macpos + 9] = this._h[4] >>> 8;
      mac[macpos + 10] = this._h[5] >>> 0;
      mac[macpos + 11] = this._h[5] >>> 8;
      mac[macpos + 12] = this._h[6] >>> 0;
      mac[macpos + 13] = this._h[6] >>> 8;
      mac[macpos + 14] = this._h[7] >>> 0;
      mac[macpos + 15] = this._h[7] >>> 8;
      this._finished = true;
      return this;
    };
    Poly13052.prototype.update = function(m) {
      var mpos = 0;
      var bytes2 = m.length;
      var want;
      if (this._leftover) {
        want = 16 - this._leftover;
        if (want > bytes2) {
          want = bytes2;
        }
        for (var i2 = 0; i2 < want; i2++) {
          this._buffer[this._leftover + i2] = m[mpos + i2];
        }
        bytes2 -= want;
        mpos += want;
        this._leftover += want;
        if (this._leftover < 16) {
          return this;
        }
        this._blocks(this._buffer, 0, 16);
        this._leftover = 0;
      }
      if (bytes2 >= 16) {
        want = bytes2 - bytes2 % 16;
        this._blocks(m, mpos, want);
        mpos += want;
        bytes2 -= want;
      }
      if (bytes2) {
        for (var i2 = 0; i2 < bytes2; i2++) {
          this._buffer[this._leftover + i2] = m[mpos + i2];
        }
        this._leftover += bytes2;
      }
      return this;
    };
    Poly13052.prototype.digest = function() {
      if (this._finished) {
        throw new Error("Poly1305 was finished");
      }
      var mac = new Uint8Array(16);
      this.finish(mac);
      return mac;
    };
    Poly13052.prototype.clean = function() {
      wipe_12.wipe(this._buffer);
      wipe_12.wipe(this._r);
      wipe_12.wipe(this._h);
      wipe_12.wipe(this._pad);
      this._leftover = 0;
      this._fin = 0;
      this._finished = true;
      return this;
    };
    return Poly13052;
  }();
  exports.Poly1305 = Poly1305;
  function oneTimeAuth(key, data) {
    var h = new Poly1305(key);
    h.update(data);
    var digest2 = h.digest();
    h.clean();
    return digest2;
  }
  exports.oneTimeAuth = oneTimeAuth;
  function equal2(a, b2) {
    if (a.length !== exports.DIGEST_LENGTH || b2.length !== exports.DIGEST_LENGTH) {
      return false;
    }
    return constant_time_12.equal(a, b2);
  }
  exports.equal = equal2;
})(poly1305);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var chacha_1 = chacha;
  var poly1305_1 = poly1305;
  var wipe_12 = wipe$1;
  var binary_12 = binary;
  var constant_time_12 = constantTime;
  exports.KEY_LENGTH = 32;
  exports.NONCE_LENGTH = 12;
  exports.TAG_LENGTH = 16;
  var ZEROS2 = new Uint8Array(16);
  var ChaCha20Poly1305 = function() {
    function ChaCha20Poly13052(key) {
      this.nonceLength = exports.NONCE_LENGTH;
      this.tagLength = exports.TAG_LENGTH;
      if (key.length !== exports.KEY_LENGTH) {
        throw new Error("ChaCha20Poly1305 needs 32-byte key");
      }
      this._key = new Uint8Array(key);
    }
    ChaCha20Poly13052.prototype.seal = function(nonce, plaintext, associatedData, dst) {
      if (nonce.length > 16) {
        throw new Error("ChaCha20Poly1305: incorrect nonce length");
      }
      var counter2 = new Uint8Array(16);
      counter2.set(nonce, counter2.length - nonce.length);
      var authKey = new Uint8Array(32);
      chacha_1.stream(this._key, counter2, authKey, 4);
      var resultLength = plaintext.length + this.tagLength;
      var result;
      if (dst) {
        if (dst.length !== resultLength) {
          throw new Error("ChaCha20Poly1305: incorrect destination length");
        }
        result = dst;
      } else {
        result = new Uint8Array(resultLength);
      }
      chacha_1.streamXOR(this._key, counter2, plaintext, result, 4);
      this._authenticate(result.subarray(result.length - this.tagLength, result.length), authKey, result.subarray(0, result.length - this.tagLength), associatedData);
      wipe_12.wipe(counter2);
      return result;
    };
    ChaCha20Poly13052.prototype.open = function(nonce, sealed, associatedData, dst) {
      if (nonce.length > 16) {
        throw new Error("ChaCha20Poly1305: incorrect nonce length");
      }
      if (sealed.length < this.tagLength) {
        return null;
      }
      var counter2 = new Uint8Array(16);
      counter2.set(nonce, counter2.length - nonce.length);
      var authKey = new Uint8Array(32);
      chacha_1.stream(this._key, counter2, authKey, 4);
      var calculatedTag = new Uint8Array(this.tagLength);
      this._authenticate(calculatedTag, authKey, sealed.subarray(0, sealed.length - this.tagLength), associatedData);
      if (!constant_time_12.equal(calculatedTag, sealed.subarray(sealed.length - this.tagLength, sealed.length))) {
        return null;
      }
      var resultLength = sealed.length - this.tagLength;
      var result;
      if (dst) {
        if (dst.length !== resultLength) {
          throw new Error("ChaCha20Poly1305: incorrect destination length");
        }
        result = dst;
      } else {
        result = new Uint8Array(resultLength);
      }
      chacha_1.streamXOR(this._key, counter2, sealed.subarray(0, sealed.length - this.tagLength), result, 4);
      wipe_12.wipe(counter2);
      return result;
    };
    ChaCha20Poly13052.prototype.clean = function() {
      wipe_12.wipe(this._key);
      return this;
    };
    ChaCha20Poly13052.prototype._authenticate = function(tagOut, authKey, ciphertext, associatedData) {
      var h = new poly1305_1.Poly1305(authKey);
      if (associatedData) {
        h.update(associatedData);
        if (associatedData.length % 16 > 0) {
          h.update(ZEROS2.subarray(associatedData.length % 16));
        }
      }
      h.update(ciphertext);
      if (ciphertext.length % 16 > 0) {
        h.update(ZEROS2.subarray(ciphertext.length % 16));
      }
      var length3 = new Uint8Array(8);
      if (associatedData) {
        binary_12.writeUint64LE(associatedData.length, length3);
      }
      h.update(length3);
      binary_12.writeUint64LE(ciphertext.length, length3);
      h.update(length3);
      var tag = h.digest();
      for (var i2 = 0; i2 < tag.length; i2++) {
        tagOut[i2] = tag[i2];
      }
      h.clean();
      wipe_12.wipe(tag);
      wipe_12.wipe(length3);
    };
    return ChaCha20Poly13052;
  }();
  exports.ChaCha20Poly1305 = ChaCha20Poly1305;
})(chacha20poly1305);
const stablelib = {
  hashSHA256(data) {
    return sha256.hash(data);
  },
  getHKDF(ck, ikm) {
    const hkdf2 = new HKDF_1(sha256.SHA256, ikm, ck);
    const okmU8Array = hkdf2.expand(96);
    const okm = okmU8Array;
    const k1 = okm.subarray(0, 32);
    const k2 = okm.subarray(32, 64);
    const k3 = okm.subarray(64, 96);
    return [k1, k2, k3];
  },
  generateX25519KeyPair() {
    const keypair = x25519.generateKeyPair();
    return {
      publicKey: keypair.publicKey,
      privateKey: keypair.secretKey
    };
  },
  generateX25519KeyPairFromSeed(seed2) {
    const keypair = x25519.generateKeyPairFromSeed(seed2);
    return {
      publicKey: keypair.publicKey,
      privateKey: keypair.secretKey
    };
  },
  generateX25519SharedKey(privateKey, publicKey) {
    return x25519.sharedKey(privateKey, publicKey);
  },
  chaCha20Poly1305Encrypt(plaintext, nonce, ad, k) {
    const ctx = new chacha20poly1305.ChaCha20Poly1305(k);
    return ctx.seal(nonce, plaintext, ad);
  },
  chaCha20Poly1305Decrypt(ciphertext, nonce, ad, k, dst) {
    const ctx = new chacha20poly1305.ChaCha20Poly1305(k);
    return ctx.open(nonce, ciphertext, ad, dst);
  }
};
const allocUnsafe = (len2) => {
  if (globalThis.Buffer) {
    return globalThis.Buffer.allocUnsafe(len2);
  }
  return new Uint8Array(len2);
};
const uint16BEEncode = (value2) => {
  const target = allocUnsafe(2);
  new DataView(target.buffer, target.byteOffset, target.byteLength).setUint16(0, value2, false);
  return target;
};
uint16BEEncode.bytes = 2;
const uint16BEDecode = (data) => {
  if (data.length < 2)
    throw RangeError("Could not decode int16BE");
  if (data instanceof Uint8Array) {
    return new DataView(data.buffer, data.byteOffset, data.byteLength).getUint16(0, false);
  }
  return data.getUint16(0);
};
uint16BEDecode.bytes = 2;
function encode0(message2) {
  return concat$1([message2.ne, message2.ciphertext], message2.ne.length + message2.ciphertext.length);
}
function encode1(message2) {
  return concat$1([message2.ne, message2.ns, message2.ciphertext], message2.ne.length + message2.ns.length + message2.ciphertext.length);
}
function encode2(message2) {
  return concat$1([message2.ns, message2.ciphertext], message2.ns.length + message2.ciphertext.length);
}
function decode0(input) {
  if (input.length < 32) {
    throw new Error("Cannot decode stage 0 MessageBuffer: length less than 32 bytes.");
  }
  return {
    ne: input.subarray(0, 32),
    ciphertext: input.subarray(32, input.length),
    ns: new Uint8Array(0)
  };
}
function decode1(input) {
  if (input.length < 80) {
    throw new Error("Cannot decode stage 1 MessageBuffer: length less than 80 bytes.");
  }
  return {
    ne: input.subarray(0, 32),
    ns: input.subarray(32, 80),
    ciphertext: input.subarray(80, input.length)
  };
}
function decode2(input) {
  if (input.length < 48) {
    throw new Error("Cannot decode stage 2 MessageBuffer: length less than 48 bytes.");
  }
  return {
    ne: new Uint8Array(0),
    ns: input.subarray(0, 48),
    ciphertext: input.subarray(48, input.length)
  };
}
function encryptStream(handshake2, metrics) {
  return async function* (source2) {
    for await (const chunk of source2) {
      for (let i2 = 0; i2 < chunk.length; i2 += NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {
        let end2 = i2 + NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;
        if (end2 > chunk.length) {
          end2 = chunk.length;
        }
        const data = handshake2.encrypt(chunk.subarray(i2, end2), handshake2.session);
        metrics?.encryptedPackets.increment();
        yield uint16BEEncode(data.byteLength);
        yield data;
      }
    }
  };
}
function decryptStream(handshake2, metrics) {
  return async function* (source2) {
    for await (const chunk of source2) {
      for (let i2 = 0; i2 < chunk.length; i2 += NOISE_MSG_MAX_LENGTH_BYTES) {
        let end2 = i2 + NOISE_MSG_MAX_LENGTH_BYTES;
        if (end2 > chunk.length) {
          end2 = chunk.length;
        }
        if (end2 - chacha20poly1305.TAG_LENGTH < i2) {
          throw new Error("Invalid chunk");
        }
        const encrypted = chunk.subarray(i2, end2);
        const dst = chunk.subarray(i2, end2 - chacha20poly1305.TAG_LENGTH);
        const { plaintext: decrypted, valid } = handshake2.decrypt(encrypted, handshake2.session, dst);
        if (!valid) {
          metrics?.decryptErrors.increment();
          throw new Error("Failed to validate decrypted chunk");
        }
        metrics?.decryptedPackets.increment();
        yield decrypted;
      }
    }
  };
}
class UnexpectedPeerError extends Error {
  constructor(message2 = "Unexpected Peer") {
    super(message2);
    this.code = UnexpectedPeerError.code;
  }
  static get code() {
    return "ERR_UNEXPECTED_PEER";
  }
}
class InvalidCryptoExchangeError extends Error {
  constructor(message2 = "Invalid crypto exchange") {
    super(message2);
    this.code = InvalidCryptoExchangeError.code;
  }
  static get code() {
    return "ERR_INVALID_CRYPTO_EXCHANGE";
  }
}
var NoiseExtensions;
(function(NoiseExtensions2) {
  let _codec;
  NoiseExtensions2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.webtransportCerthashes != null) {
          for (const value2 of obj.webtransportCerthashes) {
            w.uint32(10);
            w.bytes(value2);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length3) => {
        const obj = {
          webtransportCerthashes: []
        };
        const end2 = length3 == null ? reader2.len : reader2.pos + length3;
        while (reader2.pos < end2) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.webtransportCerthashes.push(reader2.bytes());
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  NoiseExtensions2.encode = (obj) => {
    return encodeMessage(obj, NoiseExtensions2.codec());
  };
  NoiseExtensions2.decode = (buf2) => {
    return decodeMessage(buf2, NoiseExtensions2.codec());
  };
})(NoiseExtensions || (NoiseExtensions = {}));
var NoiseHandshakePayload;
(function(NoiseHandshakePayload2) {
  let _codec;
  NoiseHandshakePayload2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (opts.writeDefaults === true || obj.identityKey != null && obj.identityKey.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.identityKey);
        }
        if (opts.writeDefaults === true || obj.identitySig != null && obj.identitySig.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.identitySig);
        }
        if (obj.extensions != null) {
          w.uint32(34);
          NoiseExtensions.codec().encode(obj.extensions, w, {
            writeDefaults: false
          });
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length3) => {
        const obj = {
          identityKey: new Uint8Array(0),
          identitySig: new Uint8Array(0)
        };
        const end2 = length3 == null ? reader2.len : reader2.pos + length3;
        while (reader2.pos < end2) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.identityKey = reader2.bytes();
              break;
            case 2:
              obj.identitySig = reader2.bytes();
              break;
            case 4:
              obj.extensions = NoiseExtensions.codec().decode(reader2, reader2.uint32());
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  NoiseHandshakePayload2.encode = (obj) => {
    return encodeMessage(obj, NoiseHandshakePayload2.codec());
  };
  NoiseHandshakePayload2.decode = (buf2) => {
    return decodeMessage(buf2, NoiseHandshakePayload2.codec());
  };
})(NoiseHandshakePayload || (NoiseHandshakePayload = {}));
async function getPayload(localPeer, staticPublicKey, extensions) {
  const signedPayload = await signPayload(localPeer, getHandshakePayload(staticPublicKey));
  if (localPeer.publicKey == null) {
    throw new Error("PublicKey was missing from local PeerId");
  }
  return createHandshakePayload(localPeer.publicKey, signedPayload, extensions);
}
function createHandshakePayload(libp2pPublicKey, signedPayload, extensions) {
  return NoiseHandshakePayload.encode({
    identityKey: libp2pPublicKey,
    identitySig: signedPayload,
    extensions: extensions ?? { webtransportCerthashes: [] }
  }).subarray();
}
async function signPayload(peerId, payload) {
  if (peerId.privateKey == null) {
    throw new Error("PrivateKey was missing from PeerId");
  }
  const privateKey = await unmarshalPrivateKey(peerId.privateKey);
  return await privateKey.sign(payload);
}
async function getPeerIdFromPayload(payload) {
  return await peerIdFromKeys(payload.identityKey);
}
function decodePayload(payload) {
  return NoiseHandshakePayload.decode(payload);
}
function getHandshakePayload(publicKey) {
  const prefix = fromString$3("noise-libp2p-static-key:");
  return concat$1([prefix, publicKey], prefix.length + publicKey.length);
}
async function verifySignedPayload(noiseStaticKey, payload, remotePeer) {
  const payloadPeerId = await peerIdFromKeys(payload.identityKey);
  if (!payloadPeerId.equals(remotePeer)) {
    throw new Error("Peer ID doesn't match libp2p public key.");
  }
  const generatedPayload = getHandshakePayload(noiseStaticKey);
  if (payloadPeerId.publicKey == null) {
    throw new Error("PublicKey was missing from PeerId");
  }
  if (payload.identitySig == null) {
    throw new Error("Signature was missing from message");
  }
  const publicKey = unmarshalPublicKey(payloadPeerId.publicKey);
  const valid = await publicKey.verify(generatedPayload, payload.identitySig);
  if (!valid) {
    throw new Error("Static key doesn't match to peer that signed payload!");
  }
  return payloadPeerId;
}
function isValidPublicKey(pk) {
  if (!(pk instanceof Uint8Array)) {
    return false;
  }
  if (pk.length !== 32) {
    return false;
  }
  return true;
}
const log$2 = logger$1("libp2p:noise");
let keyLogger;
if (DUMP_SESSION_KEYS) {
  keyLogger = log$2;
} else {
  keyLogger = Object.assign(() => {
  }, {
    enabled: false,
    trace: () => {
    },
    error: () => {
    }
  });
}
function logLocalStaticKeys(s2) {
  keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${toString$5(s2.publicKey, "hex")}`);
  keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${toString$5(s2.privateKey, "hex")}`);
}
function logLocalEphemeralKeys(e) {
  if (e) {
    keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${toString$5(e.publicKey, "hex")}`);
    keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${toString$5(e.privateKey, "hex")}`);
  } else {
    keyLogger("Missing local ephemeral keys.");
  }
}
function logRemoteStaticKey(rs) {
  keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${toString$5(rs, "hex")}`);
}
function logRemoteEphemeralKey(re2) {
  keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${toString$5(re2, "hex")}`);
}
function logCipherState(session) {
  if (session.cs1 && session.cs2) {
    keyLogger(`CIPHER_STATE_1 ${session.cs1.n.getUint64()} ${toString$5(session.cs1.k, "hex")}`);
    keyLogger(`CIPHER_STATE_2 ${session.cs2.n.getUint64()} ${toString$5(session.cs2.k, "hex")}`);
  } else {
    keyLogger("Missing cipher state.");
  }
}
const MIN_NONCE = 0;
const MAX_NONCE = 4294967295;
const ERR_MAX_NONCE = "Cipherstate has reached maximum n, a new handshake must be performed";
class Nonce {
  constructor(n = MIN_NONCE) {
    this.n = n;
    this.bytes = new Uint8Array(12);
    this.view = new DataView(this.bytes.buffer, this.bytes.byteOffset, this.bytes.byteLength);
    this.view.setUint32(4, n, true);
  }
  increment() {
    this.n++;
    this.view.setUint32(4, this.n, true);
  }
  getBytes() {
    return this.bytes;
  }
  getUint64() {
    return this.n;
  }
  assertValue() {
    if (this.n > MAX_NONCE) {
      throw new Error(ERR_MAX_NONCE);
    }
  }
}
class AbstractHandshake {
  constructor(crypto2) {
    this.crypto = crypto2;
  }
  encryptWithAd(cs, ad, plaintext) {
    const e = this.encrypt(cs.k, cs.n, ad, plaintext);
    cs.n.increment();
    return e;
  }
  decryptWithAd(cs, ad, ciphertext, dst) {
    const { plaintext, valid } = this.decrypt(cs.k, cs.n, ad, ciphertext, dst);
    if (valid)
      cs.n.increment();
    return { plaintext, valid };
  }
  hasKey(cs) {
    return !this.isEmptyKey(cs.k);
  }
  createEmptyKey() {
    return new Uint8Array(32);
  }
  isEmptyKey(k) {
    const emptyKey = this.createEmptyKey();
    return equals$1(emptyKey, k);
  }
  encrypt(k, n, ad, plaintext) {
    n.assertValue();
    return this.crypto.chaCha20Poly1305Encrypt(plaintext, n.getBytes(), ad, k);
  }
  encryptAndHash(ss, plaintext) {
    let ciphertext;
    if (this.hasKey(ss.cs)) {
      ciphertext = this.encryptWithAd(ss.cs, ss.h, plaintext);
    } else {
      ciphertext = plaintext;
    }
    this.mixHash(ss, ciphertext);
    return ciphertext;
  }
  decrypt(k, n, ad, ciphertext, dst) {
    n.assertValue();
    const encryptedMessage = this.crypto.chaCha20Poly1305Decrypt(ciphertext, n.getBytes(), ad, k, dst);
    if (encryptedMessage) {
      return {
        plaintext: encryptedMessage,
        valid: true
      };
    } else {
      return {
        plaintext: new Uint8Array(0),
        valid: false
      };
    }
  }
  decryptAndHash(ss, ciphertext) {
    let plaintext;
    let valid = true;
    if (this.hasKey(ss.cs)) {
      ({ plaintext, valid } = this.decryptWithAd(ss.cs, ss.h, ciphertext));
    } else {
      plaintext = ciphertext;
    }
    this.mixHash(ss, ciphertext);
    return { plaintext, valid };
  }
  dh(privateKey, publicKey) {
    try {
      const derivedU8 = this.crypto.generateX25519SharedKey(privateKey, publicKey);
      if (derivedU8.length === 32) {
        return derivedU8;
      }
      return derivedU8.subarray(0, 32);
    } catch (e) {
      const err2 = e;
      log$2(err2.message);
      return new Uint8Array(32);
    }
  }
  mixHash(ss, data) {
    ss.h = this.getHash(ss.h, data);
  }
  getHash(a, b2) {
    const u = this.crypto.hashSHA256(concat$1([a, b2], a.length + b2.length));
    return u;
  }
  mixKey(ss, ikm) {
    const [ck, tempK] = this.crypto.getHKDF(ss.ck, ikm);
    ss.cs = this.initializeKey(tempK);
    ss.ck = ck;
  }
  initializeKey(k) {
    return { k, n: new Nonce() };
  }
  initializeSymmetric(protocolName) {
    const protocolNameBytes = fromString$3(protocolName, "utf-8");
    const h = this.hashProtocolName(protocolNameBytes);
    const ck = h;
    const key = this.createEmptyKey();
    const cs = this.initializeKey(key);
    return { cs, ck, h };
  }
  hashProtocolName(protocolName) {
    if (protocolName.length <= 32) {
      const h = new Uint8Array(32);
      h.set(protocolName);
      return h;
    } else {
      return this.getHash(protocolName, new Uint8Array(0));
    }
  }
  split(ss) {
    const [tempk1, tempk2] = this.crypto.getHKDF(ss.ck, new Uint8Array(0));
    const cs1 = this.initializeKey(tempk1);
    const cs2 = this.initializeKey(tempk2);
    return { cs1, cs2 };
  }
  writeMessageRegular(cs, payload) {
    const ciphertext = this.encryptWithAd(cs, new Uint8Array(0), payload);
    const ne = this.createEmptyKey();
    const ns = new Uint8Array(0);
    return { ne, ns, ciphertext };
  }
  readMessageRegular(cs, message2) {
    return this.decryptWithAd(cs, new Uint8Array(0), message2.ciphertext);
  }
}
class XX extends AbstractHandshake {
  initializeInitiator(prologue, s2, rs, psk) {
    const name2 = "Noise_XX_25519_ChaChaPoly_SHA256";
    const ss = this.initializeSymmetric(name2);
    this.mixHash(ss, prologue);
    const re2 = new Uint8Array(32);
    return { ss, s: s2, rs, psk, re: re2 };
  }
  initializeResponder(prologue, s2, rs, psk) {
    const name2 = "Noise_XX_25519_ChaChaPoly_SHA256";
    const ss = this.initializeSymmetric(name2);
    this.mixHash(ss, prologue);
    const re2 = new Uint8Array(32);
    return { ss, s: s2, rs, psk, re: re2 };
  }
  writeMessageA(hs, payload, e) {
    const ns = new Uint8Array(0);
    if (e !== void 0) {
      hs.e = e;
    } else {
      hs.e = this.crypto.generateX25519KeyPair();
    }
    const ne = hs.e.publicKey;
    this.mixHash(hs.ss, ne);
    const ciphertext = this.encryptAndHash(hs.ss, payload);
    return { ne, ns, ciphertext };
  }
  writeMessageB(hs, payload) {
    hs.e = this.crypto.generateX25519KeyPair();
    const ne = hs.e.publicKey;
    this.mixHash(hs.ss, ne);
    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));
    const spk = hs.s.publicKey;
    const ns = this.encryptAndHash(hs.ss, spk);
    this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));
    const ciphertext = this.encryptAndHash(hs.ss, payload);
    return { ne, ns, ciphertext };
  }
  writeMessageC(hs, payload) {
    const spk = hs.s.publicKey;
    const ns = this.encryptAndHash(hs.ss, spk);
    this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));
    const ciphertext = this.encryptAndHash(hs.ss, payload);
    const ne = this.createEmptyKey();
    const messageBuffer = { ne, ns, ciphertext };
    const { cs1, cs2 } = this.split(hs.ss);
    return { h: hs.ss.h, messageBuffer, cs1, cs2 };
  }
  readMessageA(hs, message2) {
    if (isValidPublicKey(message2.ne)) {
      hs.re = message2.ne;
    }
    this.mixHash(hs.ss, hs.re);
    return this.decryptAndHash(hs.ss, message2.ciphertext);
  }
  readMessageB(hs, message2) {
    if (isValidPublicKey(message2.ne)) {
      hs.re = message2.ne;
    }
    this.mixHash(hs.ss, hs.re);
    if (!hs.e) {
      throw new Error("Handshake state `e` param is missing.");
    }
    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));
    const { plaintext: ns, valid: valid1 } = this.decryptAndHash(hs.ss, message2.ns);
    if (valid1 && isValidPublicKey(ns)) {
      hs.rs = ns;
    }
    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));
    const { plaintext, valid: valid2 } = this.decryptAndHash(hs.ss, message2.ciphertext);
    return { plaintext, valid: valid1 && valid2 };
  }
  readMessageC(hs, message2) {
    const { plaintext: ns, valid: valid1 } = this.decryptAndHash(hs.ss, message2.ns);
    if (valid1 && isValidPublicKey(ns)) {
      hs.rs = ns;
    }
    if (!hs.e) {
      throw new Error("Handshake state `e` param is missing.");
    }
    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));
    const { plaintext, valid: valid2 } = this.decryptAndHash(hs.ss, message2.ciphertext);
    const { cs1, cs2 } = this.split(hs.ss);
    return { h: hs.ss.h, plaintext, valid: valid1 && valid2, cs1, cs2 };
  }
  initSession(initiator, prologue, s2) {
    const psk = this.createEmptyKey();
    const rs = new Uint8Array(32);
    let hs;
    if (initiator) {
      hs = this.initializeInitiator(prologue, s2, rs, psk);
    } else {
      hs = this.initializeResponder(prologue, s2, rs, psk);
    }
    return {
      hs,
      i: initiator,
      mc: 0
    };
  }
  sendMessage(session, message2, ephemeral) {
    let messageBuffer;
    if (session.mc === 0) {
      messageBuffer = this.writeMessageA(session.hs, message2, ephemeral);
    } else if (session.mc === 1) {
      messageBuffer = this.writeMessageB(session.hs, message2);
    } else if (session.mc === 2) {
      const { h, messageBuffer: resultingBuffer, cs1, cs2 } = this.writeMessageC(session.hs, message2);
      messageBuffer = resultingBuffer;
      session.h = h;
      session.cs1 = cs1;
      session.cs2 = cs2;
    } else if (session.mc > 2) {
      if (session.i) {
        if (!session.cs1) {
          throw new Error("CS1 (cipher state) is not defined");
        }
        messageBuffer = this.writeMessageRegular(session.cs1, message2);
      } else {
        if (!session.cs2) {
          throw new Error("CS2 (cipher state) is not defined");
        }
        messageBuffer = this.writeMessageRegular(session.cs2, message2);
      }
    } else {
      throw new Error("Session invalid.");
    }
    session.mc++;
    return messageBuffer;
  }
  recvMessage(session, message2) {
    let plaintext = new Uint8Array(0);
    let valid = false;
    if (session.mc === 0) {
      ({ plaintext, valid } = this.readMessageA(session.hs, message2));
    } else if (session.mc === 1) {
      ({ plaintext, valid } = this.readMessageB(session.hs, message2));
    } else if (session.mc === 2) {
      const { h, plaintext: resultingPlaintext, valid: resultingValid, cs1, cs2 } = this.readMessageC(session.hs, message2);
      plaintext = resultingPlaintext;
      valid = resultingValid;
      session.h = h;
      session.cs1 = cs1;
      session.cs2 = cs2;
    }
    session.mc++;
    return { plaintext, valid };
  }
}
class XXHandshake {
  constructor(isInitiator, payload, prologue, crypto2, staticKeypair, connection, remotePeer, handshake2) {
    this.remoteExtensions = { webtransportCerthashes: [] };
    this.isInitiator = isInitiator;
    this.payload = payload;
    this.prologue = prologue;
    this.staticKeypair = staticKeypair;
    this.connection = connection;
    if (remotePeer) {
      this.remotePeer = remotePeer;
    }
    this.xx = handshake2 ?? new XX(crypto2);
    this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair);
  }
  async propose() {
    logLocalStaticKeys(this.session.hs.s);
    if (this.isInitiator) {
      log$2("Stage 0 - Initiator starting to send first message.");
      const messageBuffer = this.xx.sendMessage(this.session, new Uint8Array(0));
      this.connection.writeLP(encode0(messageBuffer));
      log$2("Stage 0 - Initiator finished sending first message.");
      logLocalEphemeralKeys(this.session.hs.e);
    } else {
      log$2("Stage 0 - Responder waiting to receive first message...");
      const receivedMessageBuffer = decode0((await this.connection.readLP()).subarray());
      const { valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
      if (!valid) {
        throw new InvalidCryptoExchangeError("xx handshake stage 0 validation fail");
      }
      log$2("Stage 0 - Responder received first message.");
      logRemoteEphemeralKey(this.session.hs.re);
    }
  }
  async exchange() {
    if (this.isInitiator) {
      log$2("Stage 1 - Initiator waiting to receive first message from responder...");
      const receivedMessageBuffer = decode1((await this.connection.readLP()).subarray());
      const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
      if (!valid) {
        throw new InvalidCryptoExchangeError("xx handshake stage 1 validation fail");
      }
      log$2("Stage 1 - Initiator received the message.");
      logRemoteEphemeralKey(this.session.hs.re);
      logRemoteStaticKey(this.session.hs.rs);
      log$2("Initiator going to check remote's signature...");
      try {
        const decodedPayload = decodePayload(plaintext);
        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload);
        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);
        this.setRemoteNoiseExtension(decodedPayload.extensions);
      } catch (e) {
        const err2 = e;
        throw new UnexpectedPeerError(`Error occurred while verifying signed payload: ${err2.message}`);
      }
      log$2("All good with the signature!");
    } else {
      log$2("Stage 1 - Responder sending out first message with signed payload and static key.");
      const messageBuffer = this.xx.sendMessage(this.session, this.payload);
      this.connection.writeLP(encode1(messageBuffer));
      log$2("Stage 1 - Responder sent the second handshake message with signed payload.");
      logLocalEphemeralKeys(this.session.hs.e);
    }
  }
  async finish() {
    if (this.isInitiator) {
      log$2("Stage 2 - Initiator sending third handshake message.");
      const messageBuffer = this.xx.sendMessage(this.session, this.payload);
      this.connection.writeLP(encode2(messageBuffer));
      log$2("Stage 2 - Initiator sent message with signed payload.");
    } else {
      log$2("Stage 2 - Responder waiting for third handshake message...");
      const receivedMessageBuffer = decode2((await this.connection.readLP()).subarray());
      const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
      if (!valid) {
        throw new InvalidCryptoExchangeError("xx handshake stage 2 validation fail");
      }
      log$2("Stage 2 - Responder received the message, finished handshake.");
      try {
        const decodedPayload = decodePayload(plaintext);
        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload);
        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);
        this.setRemoteNoiseExtension(decodedPayload.extensions);
      } catch (e) {
        const err2 = e;
        throw new UnexpectedPeerError(`Error occurred while verifying signed payload: ${err2.message}`);
      }
    }
    logCipherState(this.session);
  }
  encrypt(plaintext, session) {
    const cs = this.getCS(session);
    return this.xx.encryptWithAd(cs, new Uint8Array(0), plaintext);
  }
  decrypt(ciphertext, session, dst) {
    const cs = this.getCS(session, false);
    return this.xx.decryptWithAd(cs, new Uint8Array(0), ciphertext, dst);
  }
  getRemoteStaticKey() {
    return this.session.hs.rs;
  }
  getCS(session, encryption = true) {
    if (!session.cs1 || !session.cs2) {
      throw new InvalidCryptoExchangeError("Handshake not completed properly, cipher state does not exist.");
    }
    if (this.isInitiator) {
      return encryption ? session.cs1 : session.cs2;
    } else {
      return encryption ? session.cs2 : session.cs1;
    }
  }
  setRemoteNoiseExtension(e) {
    if (e) {
      this.remoteExtensions = e;
    }
  }
}
function registerMetrics(metrics) {
  return {
    xxHandshakeSuccesses: metrics.registerCounter("libp2p_noise_xxhandshake_successes_total", {
      help: "Total count of noise xxHandshakes successes_"
    }),
    xxHandshakeErrors: metrics.registerCounter("libp2p_noise_xxhandshake_error_total", {
      help: "Total count of noise xxHandshakes errors"
    }),
    encryptedPackets: metrics.registerCounter("libp2p_noise_encrypted_packets_total", {
      help: "Total count of noise encrypted packets successfully"
    }),
    decryptedPackets: metrics.registerCounter("libp2p_noise_decrypted_packets_total", {
      help: "Total count of noise decrypted packets"
    }),
    decryptErrors: metrics.registerCounter("libp2p_noise_decrypt_errors_total", {
      help: "Total count of noise decrypt errors"
    })
  };
}
class Noise {
  constructor(init2 = {}) {
    this.protocol = "/noise";
    const { staticNoiseKey, extensions, crypto: crypto2, prologueBytes, metrics } = init2;
    this.crypto = crypto2 ?? stablelib;
    this.extensions = extensions;
    this.metrics = metrics ? registerMetrics(metrics) : void 0;
    if (staticNoiseKey) {
      this.staticKeys = this.crypto.generateX25519KeyPairFromSeed(staticNoiseKey);
    } else {
      this.staticKeys = this.crypto.generateX25519KeyPair();
    }
    this.prologue = prologueBytes ?? new Uint8Array(0);
  }
  async secureOutbound(localPeer, connection, remotePeer) {
    const wrappedConnection = pbStream(connection, {
      lengthEncoder: uint16BEEncode,
      lengthDecoder: uint16BEDecode,
      maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES
    });
    const handshake2 = await this.performHandshake({
      connection: wrappedConnection,
      isInitiator: true,
      localPeer,
      remotePeer
    });
    const conn = await this.createSecureConnection(wrappedConnection, handshake2);
    return {
      conn,
      remoteExtensions: handshake2.remoteExtensions,
      remotePeer: handshake2.remotePeer
    };
  }
  async secureInbound(localPeer, connection, remotePeer) {
    const wrappedConnection = pbStream(connection, {
      lengthEncoder: uint16BEEncode,
      lengthDecoder: uint16BEDecode,
      maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES
    });
    const handshake2 = await this.performHandshake({
      connection: wrappedConnection,
      isInitiator: false,
      localPeer,
      remotePeer
    });
    const conn = await this.createSecureConnection(wrappedConnection, handshake2);
    return {
      conn,
      remotePeer: handshake2.remotePeer,
      remoteExtensions: handshake2.remoteExtensions
    };
  }
  async performHandshake(params) {
    const payload = await getPayload(params.localPeer, this.staticKeys.publicKey, this.extensions);
    return await this.performXXHandshake(params, payload);
  }
  async performXXHandshake(params, payload) {
    const { isInitiator, remotePeer, connection } = params;
    const handshake2 = new XXHandshake(isInitiator, payload, this.prologue, this.crypto, this.staticKeys, connection, remotePeer);
    try {
      await handshake2.propose();
      await handshake2.exchange();
      await handshake2.finish();
      this.metrics?.xxHandshakeSuccesses.increment();
    } catch (e) {
      this.metrics?.xxHandshakeErrors.increment();
      if (e instanceof Error) {
        e.message = `Error occurred during XX handshake: ${e.message}`;
        throw e;
      }
    }
    return handshake2;
  }
  async createSecureConnection(connection, handshake2) {
    const [secure, user] = duplexPair();
    const network = connection.unwrap();
    await pipe(
      secure,
      encryptStream(handshake2, this.metrics),
      network,
      decode$3({ lengthDecoder: uint16BEDecode }),
      decryptStream(handshake2, this.metrics),
      secure
    );
    return user;
  }
}
function noise(init2 = {}) {
  return () => new Noise(init2);
}
const mergeOptions$2 = mergeOptions$g.bind({ ignoreUndefined: true, concatArrays: true });
function createLibp2p({
  options = {},
  peerId,
  multiaddrs = [],
  repo,
  keychainConfig = {},
  config: config2 = {}
}) {
  const { datastore } = repo;
  const libp2pOptions = getLibp2pOptions({
    options,
    config: config2,
    datastore,
    keychainConfig,
    peerId,
    multiaddrs
  });
  if (typeof options.libp2p === "function") {
    return options.libp2p({ libp2pOptions, options, config: config2, datastore, peerId });
  }
  return createLibp2p$1(libp2pOptions);
}
function getLibp2pOptions({ options, config: config2, datastore, keychainConfig, peerId, multiaddrs }) {
  const getPubsubRouter = () => {
    const router = get$2(config2, "Pubsub.Router") || "gossipsub";
    const availableRouters = routers();
    if (!availableRouters[router]) {
      throw errCode(new Error(`Router unavailable. Configure libp2p.modules.pubsub to use the ${router} router.`), "ERR_NOT_SUPPORTED");
    }
    return availableRouters[router];
  };
  const libp2pDefaults = {
    datastore,
    peerId
  };
  const libp2pOptions = {
    addresses: {
      listen: multiaddrs.map((ma) => ma.toString()),
      announce: get$2(options, "addresses.announce", get$2(config2, "Addresses.Announce", [])),
      noAnnounce: get$2(options, "addresses.noAnnounce", get$2(config2, "Addresses.NoAnnounce", []))
    },
    connectionManager: get$2(options, "connectionManager", {
      maxConnections: get$2(options, "config.Swarm.ConnMgr.HighWater", get$2(config2, "Swarm.ConnMgr.HighWater")),
      minConnections: get$2(options, "config.Swarm.ConnMgr.LowWater", get$2(config2, "Swarm.ConnMgr.LowWater"))
    }),
    keychain: keychainConfig,
    identify: {
      host: {
        agentVersion: `js-ipfs/${ipfsCore}`
      }
    },
    contentRouters: [],
    peerRouters: [],
    peerDiscovery: [],
    transports: [],
    streamMuxers: [
      mplex({
        maxInboundStreams: 256,
        maxOutboundStreams: 1024
      })
    ],
    connectionEncryption: [
      noise()
    ],
    relay: {
      enabled: get$2(options, "relay.enabled", get$2(config2, "relay.enabled", true)),
      hop: {
        enabled: get$2(options, "relay.hop.enabled", get$2(config2, "relay.hop.enabled", false)),
        active: get$2(options, "relay.hop.active", get$2(config2, "relay.hop.active", false))
      }
    },
    nat: {
      enabled: !get$2(config2, "Swarm.DisableNatPortMap", false)
    }
  };
  if (get$2(options, "config.Pubsub.Enabled", get$2(config2, "Pubsub.Enabled", true))) {
    libp2pOptions.pubsub = getPubsubRouter();
  }
  if (get$2(config2, "Routing.Type", "dhtclient") !== "none") {
    libp2pOptions.dht = kadDHT({
      clientMode: get$2(config2, "Routing.Type", "dht") !== "dhtserver",
      kBucketSize: get$2(options, "dht.kBucketSize", 20),
      validators: {
        ipns: ipnsValidator
      },
      selectors: {
        ipns: ipnsSelector
      }
    });
  }
  const boostrapNodes = get$2(options, "config.Bootstrap", get$2(config2, "Bootstrap", []));
  if (boostrapNodes.length > 0) {
    libp2pOptions.peerDiscovery?.push(
      bootstrap({
        list: boostrapNodes
      })
    );
  }
  let constructorOptions = get$2(options, "libp2p", void 0);
  if (typeof constructorOptions === "function") {
    constructorOptions = void 0;
  }
  const libp2pFinalConfig = mergeOptions$2(
    libp2pDefaults,
    libp2pConfig(),
    libp2pOptions,
    constructorOptions
  );
  const delegateHosts = get$2(
    options,
    "config.Addresses.Delegates",
    get$2(config2, "Addresses.Delegates", [])
  );
  if (delegateHosts.length > 0) {
    const delegateString = delegateHosts[Math.floor(Math.random() * delegateHosts.length)];
    const delegateAddr = multiaddr(delegateString).toOptions();
    const delegateApiOptions = {
      host: delegateAddr.host,
      protocol: parseInt(delegateAddr.port) === 443 ? "https" : "http",
      port: delegateAddr.port
    };
    const delegateHttpClient = create$2(delegateApiOptions);
    libp2pFinalConfig.contentRouters?.push(delegatedContentRouting(delegateHttpClient));
    libp2pFinalConfig.peerRouters?.push(delegatedPeerRouting(delegateHttpClient));
  }
  if (!get$2(options, "config.Discovery.MDNS.Enabled", get$2(config2, "Discovery.MDNS.Enabled", true))) {
    libp2pFinalConfig.peerDiscovery = libp2pFinalConfig.peerDiscovery?.filter((d) => {
      try {
        if (typeof d === "function") {
          return d({})[Symbol.toStringTag] !== "@libp2p/mdns";
        }
      } catch {
      }
      return true;
    });
  }
  if (libp2pFinalConfig.transports == null) {
    libp2pFinalConfig.transports = [];
  }
  if (libp2pFinalConfig.transports.find((t) => {
    try {
      if (typeof t === "function") {
        return t({})[Symbol.toStringTag] === "@libp2p/websockets";
      }
    } catch {
    }
    return false;
  }) == null) {
    libp2pFinalConfig.transports.push(webSockets());
  }
  return libp2pFinalConfig;
}
const mergeOptions$1 = mergeOptions$g.bind({ ignoreUndefined: true });
const log$1 = logger$1("ipfs:components:peer:storage");
class Storage {
  constructor(peerId, keychain, repo, print, isNew) {
    this.print = print;
    this.peerId = peerId;
    this.keychain = keychain;
    this.repo = repo;
    this.print = print;
    this.isNew = isNew;
  }
  static async start(print, codecs2, options) {
    const { repoAutoMigrate, repo: inputRepo, onMigrationProgress } = options;
    const repo = typeof inputRepo === "string" || inputRepo == null ? createRepo$1(print, codecs2, {
      path: inputRepo,
      autoMigrate: repoAutoMigrate,
      onMigrationProgress
    }) : inputRepo;
    const { peerId, keychain, isNew } = await loadRepo(print, repo, options);
    return new Storage(peerId, keychain, repo, print, isNew);
  }
}
const loadRepo = async (print, repo, options) => {
  if (!repo.closed) {
    return { ...await configureRepo(repo, options), isNew: false };
  }
  try {
    await repo.open();
    return { ...await configureRepo(repo, options), isNew: false };
  } catch (err2) {
    if (err2.code !== ERR_REPO_NOT_INITIALIZED) {
      throw err2;
    }
    if (options.init && options.init.allowNew === false) {
      throw new NotEnabledError("Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it");
    }
    return { ...await initRepo(print, repo, options), isNew: true };
  }
};
const initRepo = async (print, repo, options) => {
  const initOptions = options.init || {};
  const exists2 = await repo.exists();
  log$1("repo exists?", exists2);
  if (exists2 === true) {
    throw new Error("repo already exists");
  }
  const peerId = initOptions.privateKey ? await decodePeerId(initOptions.privateKey) : await initPeerId(print, initOptions);
  const identity2 = peerIdToIdentity(peerId);
  log$1("peer identity: %s", identity2.PeerID);
  const config2 = {
    ...mergeOptions$1(applyProfiles(getDefaultConfig(), initOptions.profiles), options.config),
    Identity: identity2
  };
  await repo.init(config2);
  await repo.open();
  log$1("repo opened");
  const keychainConfig = {
    pass: options.pass
  };
  try {
    keychainConfig.dek = await repo.config.get("Keychain.DEK");
  } catch (err2) {
    if (err2.code !== "ERR_NOT_FOUND") {
      throw err2;
    }
  }
  const libp2p = await createLibp2p({
    options: void 0,
    multiaddrs: void 0,
    peerId,
    repo,
    config: config2,
    keychainConfig
  });
  if (!await repo.datastore.has(new Key("/info/self"))) {
    await libp2p.keychain.importPeer("self", peerId);
  }
  await repo.config.set("Keychain", {
    DEK: libp2p.keychain.init.dek
  });
  return { peerId, keychain: libp2p.keychain };
};
const decodePeerId = async (peerId) => {
  log$1("using user-supplied private-key");
  if (isPeerId(peerId)) {
    return peerId;
  }
  const rawPrivateKey = fromString$3(peerId, "base64pad");
  const key = await unmarshalPrivateKey(rawPrivateKey);
  return await peerIdFromKeys(key.public.bytes, key.bytes);
};
const initPeerId = (print, { algorithm = "Ed25519", bits: bits2 = 2048 }) => {
  print("generating %s keypair...", algorithm);
  if (algorithm === "Ed25519") {
    return createEd25519PeerId();
  }
  if (algorithm === "RSA") {
    return createRSAPeerId({ bits: bits2 });
  }
  throw errCode(new Error("Unknown PeerId algorithm"), "ERR_UNKNOWN_PEER_ID_ALGORITHM");
};
const peerIdToIdentity = (peerId) => {
  if (peerId.privateKey == null) {
    throw errCode(new Error("Private key missing"), "ERR_MISSING_PRIVATE_KEY");
  }
  return {
    PeerID: peerId.toString(),
    PrivKey: toString$5(peerId.privateKey, "base64pad")
  };
};
const configureRepo = async (repo, options) => {
  const config2 = options.config;
  const profiles2 = options.init && options.init.profiles || [];
  const pass = options.pass;
  const original = await repo.config.getAll();
  const changed = mergeConfigs(applyProfiles(original, profiles2), config2);
  if (original !== changed) {
    await repo.config.replace(changed);
  }
  if (!changed.Identity || !changed.Identity.PrivKey) {
    throw new NotInitializedError("No private key was found in the config, please intialize the repo");
  }
  const buf2 = fromString$3(changed.Identity.PrivKey, "base64pad");
  const key = await unmarshalPrivateKey(buf2);
  const peerId = await peerIdFromKeys(key.public.bytes, key.bytes);
  const libp2p = await createLibp2p({
    options: void 0,
    multiaddrs: void 0,
    peerId,
    repo,
    config: changed,
    keychainConfig: {
      pass,
      ...changed.Keychain
    }
  });
  return { peerId, keychain: libp2p.keychain };
};
const mergeConfigs = (config2, changes) => changes ? mergeOptions$1(config2, changes) : config2;
const applyProfiles = (config2, profiles$1) => {
  return (profiles$1 || []).reduce((config3, name2) => {
    const profile = profiles[name2];
    if (!profile) {
      throw new Error(`Could not find profile with name '${name2}'`);
    }
    log$1("applying profile %s", name2);
    return profile.transform(config3);
  }, config2);
};
var encode_1 = encode;
var MSB$1 = 128, REST$1 = 127, MSBALL = ~REST$1, INT = Math.pow(2, 31);
function encode(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB$1;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB$1;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode.bytes = offset - oldOffset + 1;
  return out;
}
var decode = read;
var MSB = 128, REST = 127;
function read(buf2, offset) {
  var res = 0, offset = offset || 0, shift2 = 0, counter2 = offset, b2, l = buf2.length;
  do {
    if (counter2 >= l) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b2 = buf2[counter2++];
    res += shift2 < 28 ? (b2 & REST) << shift2 : (b2 & REST) * Math.pow(2, shift2);
    shift2 += 7;
  } while (b2 >= MSB);
  read.bytes = counter2 - offset;
  return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function(value2) {
  return value2 < N1 ? 1 : value2 < N2 ? 2 : value2 < N3 ? 3 : value2 < N4 ? 4 : value2 < N5 ? 5 : value2 < N6 ? 6 : value2 < N7 ? 7 : value2 < N8 ? 8 : value2 < N9 ? 9 : 10;
};
var varint$1 = {
  encode: encode_1,
  decode,
  encodingLength: length
};
const varint = varint$1;
var src = (buf2) => {
  if (!(buf2 instanceof Uint8Array)) {
    throw new Error("arg needs to be a Uint8Array");
  }
  const result = [];
  while (buf2.length > 0) {
    const num = varint.decode(buf2);
    result.push(num);
    buf2 = buf2.slice(varint.decode.bytes);
  }
  return result;
};
function varintEncoder(buf2) {
  let out = new Uint8Array(buf2.reduce((acc, curr) => {
    return acc + varint$3.encodingLength(curr);
  }, 0));
  let offset = 0;
  for (const num of buf2) {
    out = varint$3.encode(num, out, offset);
    offset += varint$3.encodingLength(num);
  }
  return out;
}
class WantListEntry {
  constructor(cid, priority, wantType) {
    this._refCounter = 1;
    this.cid = cid;
    this.priority = priority || 1;
    this.wantType = wantType;
  }
  inc() {
    this._refCounter += 1;
  }
  dec() {
    this._refCounter = Math.max(0, this._refCounter - 1);
  }
  hasRefs() {
    return this._refCounter > 0;
  }
  get [Symbol.toStringTag]() {
    const cidStr = this.cid.toString(base58btc$1);
    return `WantlistEntry <key: ${cidStr}, priority: ${this.priority}, refs: ${this._refCounter}>`;
  }
  equals(other) {
    return this._refCounter === other._refCounter && this.cid.equals(other.cid) && this.priority === other.priority && this.wantType === other.wantType;
  }
}
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
const $root = $protobuf.roots["ipfs-bitswap"] || ($protobuf.roots["ipfs-bitswap"] = {});
const Message = $root.Message = (() => {
  function Message2(p) {
    this.blocks = [];
    this.payload = [];
    this.blockPresences = [];
    if (p) {
      for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
        if (p[ks[i2]] != null)
          this[ks[i2]] = p[ks[i2]];
    }
  }
  Message2.prototype.wantlist = null;
  Message2.prototype.blocks = $util.emptyArray;
  Message2.prototype.payload = $util.emptyArray;
  Message2.prototype.blockPresences = $util.emptyArray;
  Message2.prototype.pendingBytes = 0;
  Message2.encode = function encode3(m, w) {
    if (!w)
      w = $Writer.create();
    if (m.wantlist != null && Object.hasOwnProperty.call(m, "wantlist"))
      $root.Message.Wantlist.encode(m.wantlist, w.uint32(10).fork()).ldelim();
    if (m.blocks != null && m.blocks.length) {
      for (var i2 = 0; i2 < m.blocks.length; ++i2)
        w.uint32(18).bytes(m.blocks[i2]);
    }
    if (m.payload != null && m.payload.length) {
      for (var i2 = 0; i2 < m.payload.length; ++i2)
        $root.Message.Block.encode(m.payload[i2], w.uint32(26).fork()).ldelim();
    }
    if (m.blockPresences != null && m.blockPresences.length) {
      for (var i2 = 0; i2 < m.blockPresences.length; ++i2)
        $root.Message.BlockPresence.encode(m.blockPresences[i2], w.uint32(34).fork()).ldelim();
    }
    if (m.pendingBytes != null && Object.hasOwnProperty.call(m, "pendingBytes"))
      w.uint32(40).int32(m.pendingBytes);
    return w;
  };
  Message2.decode = function decode3(r, l) {
    if (!(r instanceof $Reader))
      r = $Reader.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root.Message();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1: {
          m.wantlist = $root.Message.Wantlist.decode(r, r.uint32());
          break;
        }
        case 2: {
          if (!(m.blocks && m.blocks.length))
            m.blocks = [];
          m.blocks.push(r.bytes());
          break;
        }
        case 3: {
          if (!(m.payload && m.payload.length))
            m.payload = [];
          m.payload.push($root.Message.Block.decode(r, r.uint32()));
          break;
        }
        case 4: {
          if (!(m.blockPresences && m.blockPresences.length))
            m.blockPresences = [];
          m.blockPresences.push($root.Message.BlockPresence.decode(r, r.uint32()));
          break;
        }
        case 5: {
          m.pendingBytes = r.int32();
          break;
        }
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Message2.fromObject = function fromObject(d) {
    if (d instanceof $root.Message)
      return d;
    var m = new $root.Message();
    if (d.wantlist != null) {
      if (typeof d.wantlist !== "object")
        throw TypeError(".Message.wantlist: object expected");
      m.wantlist = $root.Message.Wantlist.fromObject(d.wantlist);
    }
    if (d.blocks) {
      if (!Array.isArray(d.blocks))
        throw TypeError(".Message.blocks: array expected");
      m.blocks = [];
      for (var i2 = 0; i2 < d.blocks.length; ++i2) {
        if (typeof d.blocks[i2] === "string")
          $util.base64.decode(d.blocks[i2], m.blocks[i2] = $util.newBuffer($util.base64.length(d.blocks[i2])), 0);
        else if (d.blocks[i2].length >= 0)
          m.blocks[i2] = d.blocks[i2];
      }
    }
    if (d.payload) {
      if (!Array.isArray(d.payload))
        throw TypeError(".Message.payload: array expected");
      m.payload = [];
      for (var i2 = 0; i2 < d.payload.length; ++i2) {
        if (typeof d.payload[i2] !== "object")
          throw TypeError(".Message.payload: object expected");
        m.payload[i2] = $root.Message.Block.fromObject(d.payload[i2]);
      }
    }
    if (d.blockPresences) {
      if (!Array.isArray(d.blockPresences))
        throw TypeError(".Message.blockPresences: array expected");
      m.blockPresences = [];
      for (var i2 = 0; i2 < d.blockPresences.length; ++i2) {
        if (typeof d.blockPresences[i2] !== "object")
          throw TypeError(".Message.blockPresences: object expected");
        m.blockPresences[i2] = $root.Message.BlockPresence.fromObject(d.blockPresences[i2]);
      }
    }
    if (d.pendingBytes != null) {
      m.pendingBytes = d.pendingBytes | 0;
    }
    return m;
  };
  Message2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.blocks = [];
      d.payload = [];
      d.blockPresences = [];
    }
    if (o.defaults) {
      d.wantlist = null;
      d.pendingBytes = 0;
    }
    if (m.wantlist != null && m.hasOwnProperty("wantlist")) {
      d.wantlist = $root.Message.Wantlist.toObject(m.wantlist, o);
    }
    if (m.blocks && m.blocks.length) {
      d.blocks = [];
      for (var j = 0; j < m.blocks.length; ++j) {
        d.blocks[j] = o.bytes === String ? $util.base64.encode(m.blocks[j], 0, m.blocks[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.blocks[j]) : m.blocks[j];
      }
    }
    if (m.payload && m.payload.length) {
      d.payload = [];
      for (var j = 0; j < m.payload.length; ++j) {
        d.payload[j] = $root.Message.Block.toObject(m.payload[j], o);
      }
    }
    if (m.blockPresences && m.blockPresences.length) {
      d.blockPresences = [];
      for (var j = 0; j < m.blockPresences.length; ++j) {
        d.blockPresences[j] = $root.Message.BlockPresence.toObject(m.blockPresences[j], o);
      }
    }
    if (m.pendingBytes != null && m.hasOwnProperty("pendingBytes")) {
      d.pendingBytes = m.pendingBytes;
    }
    return d;
  };
  Message2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };
  Message2.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
    if (typeUrlPrefix === void 0) {
      typeUrlPrefix = "type.googleapis.com";
    }
    return typeUrlPrefix + "/Message";
  };
  Message2.Wantlist = function() {
    function Wantlist2(p) {
      this.entries = [];
      if (p) {
        for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
          if (p[ks[i2]] != null)
            this[ks[i2]] = p[ks[i2]];
      }
    }
    Wantlist2.prototype.entries = $util.emptyArray;
    Wantlist2.prototype.full = false;
    Wantlist2.encode = function encode3(m, w) {
      if (!w)
        w = $Writer.create();
      if (m.entries != null && m.entries.length) {
        for (var i2 = 0; i2 < m.entries.length; ++i2)
          $root.Message.Wantlist.Entry.encode(m.entries[i2], w.uint32(10).fork()).ldelim();
      }
      if (m.full != null && Object.hasOwnProperty.call(m, "full"))
        w.uint32(16).bool(m.full);
      return w;
    };
    Wantlist2.decode = function decode3(r, l) {
      if (!(r instanceof $Reader))
        r = $Reader.create(r);
      var c = l === void 0 ? r.len : r.pos + l, m = new $root.Message.Wantlist();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1: {
            if (!(m.entries && m.entries.length))
              m.entries = [];
            m.entries.push($root.Message.Wantlist.Entry.decode(r, r.uint32()));
            break;
          }
          case 2: {
            m.full = r.bool();
            break;
          }
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    Wantlist2.fromObject = function fromObject(d) {
      if (d instanceof $root.Message.Wantlist)
        return d;
      var m = new $root.Message.Wantlist();
      if (d.entries) {
        if (!Array.isArray(d.entries))
          throw TypeError(".Message.Wantlist.entries: array expected");
        m.entries = [];
        for (var i2 = 0; i2 < d.entries.length; ++i2) {
          if (typeof d.entries[i2] !== "object")
            throw TypeError(".Message.Wantlist.entries: object expected");
          m.entries[i2] = $root.Message.Wantlist.Entry.fromObject(d.entries[i2]);
        }
      }
      if (d.full != null) {
        m.full = Boolean(d.full);
      }
      return m;
    };
    Wantlist2.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.arrays || o.defaults) {
        d.entries = [];
      }
      if (o.defaults) {
        d.full = false;
      }
      if (m.entries && m.entries.length) {
        d.entries = [];
        for (var j = 0; j < m.entries.length; ++j) {
          d.entries[j] = $root.Message.Wantlist.Entry.toObject(m.entries[j], o);
        }
      }
      if (m.full != null && m.hasOwnProperty("full")) {
        d.full = m.full;
      }
      return d;
    };
    Wantlist2.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    Wantlist2.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Message.Wantlist";
    };
    Wantlist2.WantType = function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = "Block"] = 0;
      values[valuesById[1] = "Have"] = 1;
      return values;
    }();
    Wantlist2.Entry = function() {
      function Entry(p) {
        if (p) {
          for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
            if (p[ks[i2]] != null)
              this[ks[i2]] = p[ks[i2]];
        }
      }
      Entry.prototype.block = $util.newBuffer([]);
      Entry.prototype.priority = 0;
      Entry.prototype.cancel = false;
      Entry.prototype.wantType = 0;
      Entry.prototype.sendDontHave = false;
      Entry.encode = function encode3(m, w) {
        if (!w)
          w = $Writer.create();
        if (m.block != null && Object.hasOwnProperty.call(m, "block"))
          w.uint32(10).bytes(m.block);
        if (m.priority != null && Object.hasOwnProperty.call(m, "priority"))
          w.uint32(16).int32(m.priority);
        if (m.cancel != null && Object.hasOwnProperty.call(m, "cancel"))
          w.uint32(24).bool(m.cancel);
        if (m.wantType != null && Object.hasOwnProperty.call(m, "wantType"))
          w.uint32(32).int32(m.wantType);
        if (m.sendDontHave != null && Object.hasOwnProperty.call(m, "sendDontHave"))
          w.uint32(40).bool(m.sendDontHave);
        return w;
      };
      Entry.decode = function decode3(r, l) {
        if (!(r instanceof $Reader))
          r = $Reader.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root.Message.Wantlist.Entry();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1: {
              m.block = r.bytes();
              break;
            }
            case 2: {
              m.priority = r.int32();
              break;
            }
            case 3: {
              m.cancel = r.bool();
              break;
            }
            case 4: {
              m.wantType = r.int32();
              break;
            }
            case 5: {
              m.sendDontHave = r.bool();
              break;
            }
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      Entry.fromObject = function fromObject(d) {
        if (d instanceof $root.Message.Wantlist.Entry)
          return d;
        var m = new $root.Message.Wantlist.Entry();
        if (d.block != null) {
          if (typeof d.block === "string")
            $util.base64.decode(d.block, m.block = $util.newBuffer($util.base64.length(d.block)), 0);
          else if (d.block.length >= 0)
            m.block = d.block;
        }
        if (d.priority != null) {
          m.priority = d.priority | 0;
        }
        if (d.cancel != null) {
          m.cancel = Boolean(d.cancel);
        }
        switch (d.wantType) {
          case "Block":
          case 0:
            m.wantType = 0;
            break;
          case "Have":
          case 1:
            m.wantType = 1;
            break;
        }
        if (d.sendDontHave != null) {
          m.sendDontHave = Boolean(d.sendDontHave);
        }
        return m;
      };
      Entry.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          if (o.bytes === String)
            d.block = "";
          else {
            d.block = [];
            if (o.bytes !== Array)
              d.block = $util.newBuffer(d.block);
          }
          d.priority = 0;
          d.cancel = false;
          d.wantType = o.enums === String ? "Block" : 0;
          d.sendDontHave = false;
        }
        if (m.block != null && m.hasOwnProperty("block")) {
          d.block = o.bytes === String ? $util.base64.encode(m.block, 0, m.block.length) : o.bytes === Array ? Array.prototype.slice.call(m.block) : m.block;
        }
        if (m.priority != null && m.hasOwnProperty("priority")) {
          d.priority = m.priority;
        }
        if (m.cancel != null && m.hasOwnProperty("cancel")) {
          d.cancel = m.cancel;
        }
        if (m.wantType != null && m.hasOwnProperty("wantType")) {
          d.wantType = o.enums === String ? $root.Message.Wantlist.WantType[m.wantType] : m.wantType;
        }
        if (m.sendDontHave != null && m.hasOwnProperty("sendDontHave")) {
          d.sendDontHave = m.sendDontHave;
        }
        return d;
      };
      Entry.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      Entry.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === void 0) {
          typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/Message.Wantlist.Entry";
      };
      return Entry;
    }();
    return Wantlist2;
  }();
  Message2.Block = function() {
    function Block2(p) {
      if (p) {
        for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
          if (p[ks[i2]] != null)
            this[ks[i2]] = p[ks[i2]];
      }
    }
    Block2.prototype.prefix = $util.newBuffer([]);
    Block2.prototype.data = $util.newBuffer([]);
    Block2.encode = function encode3(m, w) {
      if (!w)
        w = $Writer.create();
      if (m.prefix != null && Object.hasOwnProperty.call(m, "prefix"))
        w.uint32(10).bytes(m.prefix);
      if (m.data != null && Object.hasOwnProperty.call(m, "data"))
        w.uint32(18).bytes(m.data);
      return w;
    };
    Block2.decode = function decode3(r, l) {
      if (!(r instanceof $Reader))
        r = $Reader.create(r);
      var c = l === void 0 ? r.len : r.pos + l, m = new $root.Message.Block();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1: {
            m.prefix = r.bytes();
            break;
          }
          case 2: {
            m.data = r.bytes();
            break;
          }
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    Block2.fromObject = function fromObject(d) {
      if (d instanceof $root.Message.Block)
        return d;
      var m = new $root.Message.Block();
      if (d.prefix != null) {
        if (typeof d.prefix === "string")
          $util.base64.decode(d.prefix, m.prefix = $util.newBuffer($util.base64.length(d.prefix)), 0);
        else if (d.prefix.length >= 0)
          m.prefix = d.prefix;
      }
      if (d.data != null) {
        if (typeof d.data === "string")
          $util.base64.decode(d.data, m.data = $util.newBuffer($util.base64.length(d.data)), 0);
        else if (d.data.length >= 0)
          m.data = d.data;
      }
      return m;
    };
    Block2.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.defaults) {
        if (o.bytes === String)
          d.prefix = "";
        else {
          d.prefix = [];
          if (o.bytes !== Array)
            d.prefix = $util.newBuffer(d.prefix);
        }
        if (o.bytes === String)
          d.data = "";
        else {
          d.data = [];
          if (o.bytes !== Array)
            d.data = $util.newBuffer(d.data);
        }
      }
      if (m.prefix != null && m.hasOwnProperty("prefix")) {
        d.prefix = o.bytes === String ? $util.base64.encode(m.prefix, 0, m.prefix.length) : o.bytes === Array ? Array.prototype.slice.call(m.prefix) : m.prefix;
      }
      if (m.data != null && m.hasOwnProperty("data")) {
        d.data = o.bytes === String ? $util.base64.encode(m.data, 0, m.data.length) : o.bytes === Array ? Array.prototype.slice.call(m.data) : m.data;
      }
      return d;
    };
    Block2.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    Block2.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Message.Block";
    };
    return Block2;
  }();
  Message2.BlockPresenceType = function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "Have"] = 0;
    values[valuesById[1] = "DontHave"] = 1;
    return values;
  }();
  Message2.BlockPresence = function() {
    function BlockPresence(p) {
      if (p) {
        for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
          if (p[ks[i2]] != null)
            this[ks[i2]] = p[ks[i2]];
      }
    }
    BlockPresence.prototype.cid = $util.newBuffer([]);
    BlockPresence.prototype.type = 0;
    BlockPresence.encode = function encode3(m, w) {
      if (!w)
        w = $Writer.create();
      if (m.cid != null && Object.hasOwnProperty.call(m, "cid"))
        w.uint32(10).bytes(m.cid);
      if (m.type != null && Object.hasOwnProperty.call(m, "type"))
        w.uint32(16).int32(m.type);
      return w;
    };
    BlockPresence.decode = function decode3(r, l) {
      if (!(r instanceof $Reader))
        r = $Reader.create(r);
      var c = l === void 0 ? r.len : r.pos + l, m = new $root.Message.BlockPresence();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1: {
            m.cid = r.bytes();
            break;
          }
          case 2: {
            m.type = r.int32();
            break;
          }
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    BlockPresence.fromObject = function fromObject(d) {
      if (d instanceof $root.Message.BlockPresence)
        return d;
      var m = new $root.Message.BlockPresence();
      if (d.cid != null) {
        if (typeof d.cid === "string")
          $util.base64.decode(d.cid, m.cid = $util.newBuffer($util.base64.length(d.cid)), 0);
        else if (d.cid.length >= 0)
          m.cid = d.cid;
      }
      switch (d.type) {
        case "Have":
        case 0:
          m.type = 0;
          break;
        case "DontHave":
        case 1:
          m.type = 1;
          break;
      }
      return m;
    };
    BlockPresence.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.defaults) {
        if (o.bytes === String)
          d.cid = "";
        else {
          d.cid = [];
          if (o.bytes !== Array)
            d.cid = $util.newBuffer(d.cid);
        }
        d.type = o.enums === String ? "Have" : 0;
      }
      if (m.cid != null && m.hasOwnProperty("cid")) {
        d.cid = o.bytes === String ? $util.base64.encode(m.cid, 0, m.cid.length) : o.bytes === Array ? Array.prototype.slice.call(m.cid) : m.cid;
      }
      if (m.type != null && m.hasOwnProperty("type")) {
        d.type = o.enums === String ? $root.Message.BlockPresenceType[m.type] : m.type;
      }
      return d;
    };
    BlockPresence.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    BlockPresence.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Message.BlockPresence";
    };
    return BlockPresence;
  }();
  return Message2;
})();
const WantType$1 = {
  Block: Message.Wantlist.WantType.Block,
  Have: Message.Wantlist.WantType.Have
};
const sortBy = (fn, list) => {
  return Array.prototype.slice.call(list, 0).sort((a, b2) => {
    const aa = fn(a);
    const bb = fn(b2);
    return aa < bb ? -1 : aa > bb ? 1 : 0;
  });
};
class Wantlist {
  constructor(stats, libp2p) {
    this.set = libp2p ? trackedMap({
      system: "ipfs",
      component: "bitswap",
      metric: "wantlist",
      metrics: libp2p.metrics
    }) : /* @__PURE__ */ new Map();
    this._stats = stats;
  }
  get length() {
    return this.set.size;
  }
  add(cid, priority, wantType) {
    const cidStr = cid.toString(base58btc$1);
    const entry = this.set.get(cidStr);
    if (entry) {
      entry.inc();
      entry.priority = priority;
      if (entry.wantType === WantType$1.Have && wantType === WantType$1.Block) {
        entry.wantType = wantType;
      }
    } else {
      this.set.set(cidStr, new WantListEntry(cid, priority, wantType));
      if (this._stats) {
        this._stats.push(null, "wantListSize", 1);
      }
    }
  }
  remove(cid) {
    const cidStr = cid.toString(base58btc$1);
    const entry = this.set.get(cidStr);
    if (!entry) {
      return;
    }
    entry.dec();
    if (entry.hasRefs()) {
      return;
    }
    this.set.delete(cidStr);
    if (this._stats) {
      this._stats.push(null, "wantListSize", -1);
    }
  }
  removeForce(cidStr) {
    if (this.set.has(cidStr)) {
      this.set.delete(cidStr);
    }
  }
  forEach(fn) {
    return this.set.forEach(fn);
  }
  entries() {
    return this.set.entries();
  }
  sortedEntries() {
    return new Map(sortBy((o) => o[1].key, Array.from(this.set.entries())));
  }
  contains(cid) {
    const cidStr = cid.toString(base58btc$1);
    return this.set.has(cidStr);
  }
  get(cid) {
    const cidStr = cid.toString(base58btc$1);
    return this.set.get(cidStr);
  }
}
Wantlist.Entry = WantListEntry;
const WantlistEntry = Wantlist.Entry;
class BitswapMessageEntry {
  constructor(cid, priority, wantType, cancel, sendDontHave) {
    this.entry = new WantlistEntry(cid, priority, wantType);
    this.cancel = Boolean(cancel);
    this.sendDontHave = Boolean(sendDontHave);
  }
  get cid() {
    return this.entry.cid;
  }
  set cid(cid) {
    this.entry.cid = cid;
  }
  get priority() {
    return this.entry.priority;
  }
  set priority(val) {
    this.entry.priority = val;
  }
  get wantType() {
    return this.entry.wantType;
  }
  set wantType(val) {
    this.entry.wantType = val;
  }
  get [Symbol.toStringTag]() {
    const cidStr = this.cid.toString(base58btc$1);
    return `BitswapMessageEntry ${cidStr} <cancel: ${this.cancel}, priority: ${this.priority}>`;
  }
  equals(other) {
    return this.cancel === other.cancel && this.sendDontHave === other.sendDontHave && this.wantType === other.wantType && this.entry.equals(other.entry);
  }
}
const logger = (id, subsystem) => {
  const name2 = ["bitswap"];
  if (subsystem) {
    name2.push(subsystem);
  }
  if (id) {
    name2.push(`${id.toString().slice(0, 8)}`);
  }
  return Object.assign(debug(name2.join(":")), {
    error: debug(name2.concat(["error"]).join(":"))
  });
};
const isMapEqual = (a, b2) => {
  if (a.size !== b2.size) {
    return false;
  }
  for (const [key, valueA] of a) {
    const valueB = b2.get(key);
    if (valueB === void 0) {
      return false;
    }
    if (valueA instanceof Uint8Array && valueB instanceof Uint8Array && !equals$1(valueA, valueB)) {
      return false;
    }
    if (valueA instanceof BitswapMessageEntry && valueB instanceof BitswapMessageEntry && !valueA.equals(valueB)) {
      return false;
    }
  }
  return true;
};
class BitswapMessage {
  constructor(full) {
    this.full = full;
    this.wantlist = /* @__PURE__ */ new Map();
    this.blocks = /* @__PURE__ */ new Map();
    this.blockPresences = /* @__PURE__ */ new Map();
    this.pendingBytes = 0;
  }
  get empty() {
    return this.blocks.size === 0 && this.wantlist.size === 0 && this.blockPresences.size === 0;
  }
  addEntry(cid, priority, wantType, cancel, sendDontHave) {
    if (wantType == null) {
      wantType = BitswapMessage.WantType.Block;
    }
    const cidStr = cid.toString(base58btc$1);
    const entry = this.wantlist.get(cidStr);
    if (entry) {
      if (entry.wantType === wantType) {
        entry.priority = priority;
      }
      if (cancel) {
        entry.cancel = Boolean(cancel);
      }
      if (sendDontHave) {
        entry.sendDontHave = Boolean(sendDontHave);
      }
      if (wantType === BitswapMessage.WantType.Block && entry.wantType === BitswapMessage.WantType.Have) {
        entry.wantType = wantType;
      }
    } else {
      this.wantlist.set(cidStr, new BitswapMessageEntry(cid, priority, wantType, cancel, sendDontHave));
    }
  }
  addBlock(cid, block) {
    const cidStr = cid.toString(base58btc$1);
    this.blocks.set(cidStr, block);
  }
  addHave(cid) {
    const cidStr = cid.toString(base58btc$1);
    if (!this.blockPresences.has(cidStr)) {
      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.Have);
    }
  }
  addDontHave(cid) {
    const cidStr = cid.toString(base58btc$1);
    if (!this.blockPresences.has(cidStr)) {
      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.DontHave);
    }
  }
  cancel(cid) {
    const cidStr = cid.toString(base58btc$1);
    this.wantlist.delete(cidStr);
    this.addEntry(cid, 0, BitswapMessage.WantType.Block, true, false);
  }
  setPendingBytes(size2) {
    this.pendingBytes = size2;
  }
  serializeToBitswap100() {
    const msg = {
      wantlist: {
        entries: Array.from(this.wantlist.values()).map((entry) => {
          return {
            block: entry.cid.bytes,
            priority: Number(entry.priority),
            cancel: Boolean(entry.cancel)
          };
        }),
        full: this.full ? true : void 0
      },
      blocks: Array.from(this.blocks.values())
    };
    return Message.encode(msg).finish();
  }
  serializeToBitswap110() {
    const msg = {
      wantlist: {
        entries: Array.from(this.wantlist.values()).map((entry) => {
          return {
            block: entry.cid.bytes,
            priority: Number(entry.priority),
            wantType: entry.wantType,
            cancel: Boolean(entry.cancel),
            sendDontHave: Boolean(entry.sendDontHave)
          };
        }),
        full: this.full ? true : void 0
      },
      blockPresences: [],
      payload: [],
      pendingBytes: this.pendingBytes
    };
    for (const [cidStr, data] of this.blocks.entries()) {
      const cid = CID.parse(cidStr);
      const version2 = cid.version;
      const codec = cid.code;
      const multihash = cid.multihash.code;
      const digestLength = cid.multihash.digest.length;
      const prefix = varintEncoder([
        version2,
        codec,
        multihash,
        digestLength
      ]);
      msg.payload.push(
        new Message.Block({
          prefix,
          data
        })
      );
    }
    for (const [cidStr, bpType] of this.blockPresences) {
      msg.blockPresences.push(new Message.BlockPresence({
        cid: CID.parse(cidStr).bytes,
        type: bpType
      }));
    }
    if (this.pendingBytes > 0) {
      msg.pendingBytes = this.pendingBytes;
    }
    return Message.encode(msg).finish();
  }
  equals(other) {
    if (this.full !== other.full || this.pendingBytes !== other.pendingBytes || !isMapEqual(this.wantlist, other.wantlist) || !isMapEqual(this.blocks, other.blocks) || !isMapEqual(this.blockPresences, other.blockPresences)) {
      return false;
    }
    return true;
  }
  get [Symbol.toStringTag]() {
    const list = Array.from(this.wantlist.keys());
    const blocks = Array.from(this.blocks.keys());
    return `BitswapMessage <full: ${this.full}, list: ${list}, blocks: ${blocks}>`;
  }
}
BitswapMessage.deserialize = async (raw2, hashLoader) => {
  const decoded = Message.decode(raw2);
  const isFull = decoded.wantlist && decoded.wantlist.full || false;
  const msg = new BitswapMessage(isFull);
  if (decoded.wantlist && decoded.wantlist.entries) {
    decoded.wantlist.entries.forEach((entry) => {
      if (!entry.block) {
        return;
      }
      const cid = CID.decode(entry.block);
      msg.addEntry(cid, entry.priority || 0, entry.wantType, Boolean(entry.cancel), Boolean(entry.sendDontHave));
    });
  }
  if (decoded.blockPresences) {
    decoded.blockPresences.forEach((blockPresence) => {
      if (!blockPresence.cid) {
        return;
      }
      const cid = CID.decode(blockPresence.cid);
      if (blockPresence.type === BitswapMessage.BlockPresenceType.Have) {
        msg.addHave(cid);
      } else {
        msg.addDontHave(cid);
      }
    });
  }
  if (decoded.blocks.length > 0) {
    await Promise.all(decoded.blocks.map(async (b2) => {
      const hash2 = await sha256$3.digest(b2);
      const cid = CID.createV0(hash2);
      msg.addBlock(cid, b2);
    }));
    return msg;
  }
  if (decoded.payload.length > 0) {
    await Promise.all(decoded.payload.map(async (p) => {
      if (!p.prefix || !p.data) {
        return;
      }
      const values = src(p.prefix);
      const cidVersion = values[0];
      const multicodec = values[1];
      const hashAlg = values[2];
      const hasher = hashAlg === sha256$3.code ? sha256$3 : hashLoader && await hashLoader.getHasher(hashAlg);
      if (!hasher) {
        throw errCode(new Error("Unknown hash algorithm"), "ERR_UNKNOWN_HASH_ALG");
      }
      const hash2 = await hasher.digest(p.data);
      const cid = CID.create(cidVersion, multicodec, hash2);
      msg.addBlock(cid, p.data);
    }));
    msg.setPendingBytes(decoded.pendingBytes);
    return msg;
  }
  return msg;
};
BitswapMessage.blockPresenceSize = (cid) => {
  return cid.bytes.length + 1;
};
BitswapMessage.Entry = BitswapMessageEntry;
BitswapMessage.WantType = {
  Block: Message.Wantlist.WantType.Block,
  Have: Message.Wantlist.WantType.Have
};
BitswapMessage.BlockPresenceType = {
  Have: Message.BlockPresenceType.Have,
  DontHave: Message.BlockPresenceType.DontHave
};
const maxProvidersPerRequest = 3;
const kMaxPriority = Math.pow(2, 31) - 1;
const maxListeners = 1e3;
const wantlistSendDebounceMs = 1;
var functionDebounce = debounce;
function debounce(fn, wait, callFirst) {
  var timeout2 = null;
  var debouncedFn = null;
  var clear4 = function() {
    if (timeout2) {
      clearTimeout(timeout2);
      debouncedFn = null;
      timeout2 = null;
    }
  };
  var flush2 = function() {
    var call = debouncedFn;
    clear4();
    if (call) {
      call();
    }
  };
  var debounceWrapper = function() {
    if (!wait) {
      return fn.apply(this, arguments);
    }
    var context = this;
    var args = arguments;
    var callNow = callFirst && !timeout2;
    clear4();
    debouncedFn = function() {
      fn.apply(context, args);
    };
    timeout2 = setTimeout(function() {
      timeout2 = null;
      if (!callNow) {
        var call = debouncedFn;
        debouncedFn = null;
        return call();
      }
    }, wait);
    if (callNow) {
      return debouncedFn();
    }
  };
  debounceWrapper.cancel = clear4;
  debounceWrapper.flush = flush2;
  return debounceWrapper;
}
class MsgQueue {
  constructor(selfPeerId, otherPeerId, network) {
    this.peerId = otherPeerId;
    this.network = network;
    this.refcnt = 1;
    this._entries = [];
    this._log = logger(selfPeerId, "msgqueue");
    this.sendEntries = functionDebounce(this._sendEntries.bind(this), wantlistSendDebounceMs);
  }
  addMessage(msg) {
    if (msg.empty) {
      return;
    }
    this.send(msg);
  }
  addEntries(entries) {
    this._entries = this._entries.concat(entries);
    this.sendEntries();
  }
  _sendEntries() {
    if (!this._entries.length) {
      return;
    }
    const msg = new BitswapMessage(false);
    this._entries.forEach((entry) => {
      if (entry.cancel) {
        msg.cancel(entry.cid);
      } else {
        msg.addEntry(entry.cid, entry.priority);
      }
    });
    this._entries = [];
    this.addMessage(msg);
  }
  async send(msg) {
    try {
      await this.network.connectTo(this.peerId);
    } catch (err2) {
      this._log.error("cant connect to peer %s: %s", this.peerId.toString(), err2.message);
      return;
    }
    this._log("sending message to peer %s", this.peerId.toString());
    this.network.sendMessage(this.peerId, msg).catch((err2) => {
      this._log.error("send error: %s", err2.message);
    });
  }
}
class WantManager {
  constructor(peerId, network, stats, libp2p) {
    this.peers = trackedMap({
      system: "ipfs",
      component: "bitswap",
      metric: "want-manager-peers",
      metrics: libp2p.metrics
    });
    this.wantlist = new Wantlist(stats, libp2p);
    this.network = network;
    this._stats = stats;
    this._peerId = peerId;
    this._log = logger(peerId, "want");
  }
  _addEntries(cids, cancel, force) {
    const entries = cids.map((cid, i2) => {
      return new BitswapMessage.Entry(cid, kMaxPriority - i2, BitswapMessage.WantType.Block, cancel);
    });
    entries.forEach((e) => {
      if (e.cancel) {
        if (force) {
          this.wantlist.removeForce(e.cid.toString(base58btc$1));
        } else {
          this.wantlist.remove(e.cid);
        }
      } else {
        this._log("adding to wl");
        this.wantlist.add(e.cid, e.priority);
      }
    });
    for (const p of this.peers.values()) {
      p.addEntries(entries);
    }
  }
  _startPeerHandler(peerId) {
    let mq = this.peers.get(peerId.toString());
    if (mq) {
      mq.refcnt++;
      return;
    }
    mq = new MsgQueue(this._peerId, peerId, this.network);
    const fullwantlist = new BitswapMessage(true);
    for (const entry of this.wantlist.entries()) {
      fullwantlist.addEntry(entry[1].cid, entry[1].priority);
    }
    mq.addMessage(fullwantlist);
    this.peers.set(peerId.toString(), mq);
    return mq;
  }
  _stopPeerHandler(peerId) {
    const mq = this.peers.get(peerId.toString());
    if (!mq) {
      return;
    }
    mq.refcnt--;
    if (mq.refcnt > 0) {
      return;
    }
    this.peers.delete(peerId.toString());
  }
  wantBlocks(cids, options = {}) {
    this._addEntries(cids, false);
    if (options && options.signal) {
      options.signal.addEventListener("abort", () => {
        this.cancelWants(cids);
      });
    }
  }
  unwantBlocks(cids) {
    this._log("unwant blocks: %s", cids.length);
    this._addEntries(cids, true, true);
  }
  cancelWants(cids) {
    this._log("cancel wants: %s", cids.length);
    this._addEntries(cids, true);
  }
  connectedPeers() {
    return Array.from(this.peers.keys());
  }
  connected(peerId) {
    this._startPeerHandler(peerId);
  }
  disconnected(peerId) {
    this._stopPeerHandler(peerId);
  }
  start() {
  }
  stop() {
    this.peers.forEach((mq) => this.disconnected(mq.peerId));
  }
}
const BITSWAP100 = "/ipfs/bitswap/1.0.0";
const BITSWAP110 = "/ipfs/bitswap/1.1.0";
const BITSWAP120 = "/ipfs/bitswap/1.2.0";
const DEFAULT_MAX_INBOUND_STREAMS = 32;
const DEFAULT_MAX_OUTBOUND_STREAMS = 128;
const DEFAULT_INCOMING_STREAM_TIMEOUT = 3e4;
class Network$1 {
  constructor(libp2p, bitswap, stats, options = {}) {
    this._log = logger(libp2p.peerId, "network");
    this._libp2p = libp2p;
    this._bitswap = bitswap;
    this._protocols = [BITSWAP100];
    if (!options.b100Only) {
      this._protocols.unshift(BITSWAP110);
      this._protocols.unshift(BITSWAP120);
    }
    this._stats = stats;
    this._running = false;
    this._onPeerConnect = this._onPeerConnect.bind(this);
    this._onPeerDisconnect = this._onPeerDisconnect.bind(this);
    this._onConnection = this._onConnection.bind(this);
    this._hashLoader = options.hashLoader;
    this._maxInboundStreams = options.maxInboundStreams ?? DEFAULT_MAX_INBOUND_STREAMS;
    this._maxOutboundStreams = options.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS;
    this._incomingStreamTimeout = options.incomingStreamTimeout ?? DEFAULT_INCOMING_STREAM_TIMEOUT;
  }
  async start() {
    this._running = true;
    await this._libp2p.handle(this._protocols, this._onConnection, {
      maxInboundStreams: this._maxInboundStreams,
      maxOutboundStreams: this._maxOutboundStreams
    });
    const topology = createTopology({
      onConnect: this._onPeerConnect,
      onDisconnect: this._onPeerDisconnect
    });
    this._registrarIds = [];
    for (const protocol2 of this._protocols) {
      this._registrarIds.push(await this._libp2p.registrar.register(protocol2, topology));
    }
    this._libp2p.getConnections().forEach((conn) => {
      this._onPeerConnect(conn.remotePeer);
    });
  }
  async stop() {
    this._running = false;
    await this._libp2p.unhandle(this._protocols);
    if (this._registrarIds != null) {
      for (const id of this._registrarIds) {
        this._libp2p.registrar.unregister(id);
      }
      this._registrarIds = [];
    }
  }
  _onConnection({ stream: stream2, connection }) {
    if (!this._running) {
      return;
    }
    const controller = new timeoutAbortController.TimeoutController(this._incomingStreamTimeout);
    Promise.resolve().then(async () => {
      this._log("incoming new bitswap %s connection from %p", stream2.stat.protocol, connection.remotePeer);
      await pipe(
        abortableSource(stream2.source, controller.signal),
        decode$3(),
        async (source2) => {
          for await (const data of source2) {
            try {
              const message2 = await BitswapMessage.deserialize(data.subarray(), this._hashLoader);
              await this._bitswap._receiveMessage(connection.remotePeer, message2);
            } catch (err2) {
              this._bitswap._receiveError(err2);
              break;
            }
            controller.reset();
          }
        }
      );
    }).catch((err2) => {
      this._log(err2);
      stream2.abort(err2);
    }).finally(() => {
      controller.clear();
      stream2.close();
    });
  }
  _onPeerConnect(peerId) {
    this._bitswap._onPeerConnected(peerId);
  }
  _onPeerDisconnect(peerId) {
    this._bitswap._onPeerDisconnected(peerId);
  }
  findProviders(cid, options = {}) {
    return this._libp2p.contentRouting.findProviders(cid, options);
  }
  async findAndConnect(cid, options) {
    const connectAttempts = [];
    let found = 0;
    for await (const provider of this.findProviders(cid, options)) {
      this._log(`connecting to provider ${provider.id}`);
      connectAttempts.push(
        this.connectTo(provider.id, options).catch((err2) => {
          this._log.error(err2);
        })
      );
      found++;
      if (found === maxProvidersPerRequest) {
        break;
      }
    }
    await Promise.all(connectAttempts);
  }
  async provide(cid, options) {
    await this._libp2p.contentRouting.provide(cid, options);
  }
  async sendMessage(peer, msg) {
    if (!this._running)
      throw new Error("network isn't running");
    const stringId = peer.toString();
    this._log("sendMessage to %s", stringId, msg);
    const connection = await this._libp2p.dial(peer);
    const stream2 = await connection.newStream([BITSWAP120, BITSWAP110, BITSWAP100]);
    await writeMessage(stream2, msg, this._log);
    this._updateSentStats(peer, msg.blocks);
  }
  async connectTo(peer, options) {
    if (!this._running) {
      throw new Error("network isn't running");
    }
    return this._libp2p.dial(peer, options);
  }
  _updateSentStats(peer, blocks) {
    const peerId = peer.toString();
    if (this._stats) {
      for (const block of blocks.values()) {
        this._stats.push(peerId, "dataSent", block.length);
      }
      this._stats.push(peerId, "blocksSent", blocks.size);
    }
  }
}
async function writeMessage(stream2, msg, log2) {
  try {
    let serialized;
    switch (stream2.stat.protocol) {
      case BITSWAP100:
        serialized = msg.serializeToBitswap100();
        break;
      case BITSWAP110:
      case BITSWAP120:
        serialized = msg.serializeToBitswap110();
        break;
      default:
        throw new Error("Unknown protocol: " + stream2.stat.protocol);
    }
    await pipe(
      [serialized],
      encode$5(),
      stream2
    );
  } catch (err2) {
    log2(err2);
  } finally {
    stream2.close();
  }
}
class Ledger {
  constructor(peerId) {
    this.partner = peerId;
    this.wantlist = new Wantlist();
    this.exchangeCount = 0;
    this.sentToPeer = /* @__PURE__ */ new Map();
    this.accounting = {
      bytesSent: 0,
      bytesRecv: 0
    };
  }
  sentBytes(n) {
    this.exchangeCount++;
    this.lastExchange = new Date().getTime();
    this.accounting.bytesSent += n;
  }
  receivedBytes(n) {
    this.exchangeCount++;
    this.lastExchange = new Date().getTime();
    this.accounting.bytesRecv += n;
  }
  wants(cid, priority, wantType) {
    this.wantlist.add(cid, priority, wantType);
  }
  cancelWant(cid) {
    this.wantlist.remove(cid);
  }
  wantlistContains(cid) {
    return this.wantlist.get(cid);
  }
  debtRatio() {
    return this.accounting.bytesSent / (this.accounting.bytesRecv + 1);
  }
}
class SortedMap extends Map {
  constructor(entries, cmp) {
    super();
    this._cmp = cmp || this._defaultSort;
    this._keys = [];
    for (const [k, v] of entries || []) {
      this.set(k, v);
    }
  }
  update(i2) {
    if (i2 < 0 || i2 >= this._keys.length) {
      return;
    }
    const k = this._keys[i2];
    this._keys.splice(i2, 1);
    const newIdx = this._find(k);
    this._keys.splice(newIdx, 0, k);
  }
  set(k, v) {
    if (this.has(k)) {
      const i3 = this.indexOf(k);
      this._keys.splice(i3, 1);
    }
    super.set(k, v);
    const i2 = this._find(k);
    this._keys.splice(i2, 0, k);
    return this;
  }
  clear() {
    super.clear();
    this._keys = [];
  }
  delete(k) {
    if (!this.has(k)) {
      return false;
    }
    const i2 = this.indexOf(k);
    this._keys.splice(i2, 1);
    return super.delete(k);
  }
  indexOf(k) {
    if (!this.has(k)) {
      return -1;
    }
    const i2 = this._find(k);
    if (this._keys[i2] === k) {
      return i2;
    }
    for (let j = 1; j < this._keys.length; j++) {
      if (this._keys[i2 + j] === k)
        return i2 + j;
      if (this._keys[i2 - j] === k)
        return i2 - j;
    }
    return -1;
  }
  _find(k) {
    let lower = 0;
    let upper = this._keys.length;
    while (lower < upper) {
      const pivot = lower + upper >>> 1;
      const cmp = this._kCmp(this._keys[pivot], k);
      if (cmp < 0) {
        lower = pivot + 1;
      } else if (cmp > 0) {
        upper = pivot;
      } else {
        return pivot;
      }
    }
    return lower;
  }
  *keys() {
    for (const k of this._keys) {
      yield k;
    }
    return void 0;
  }
  *values() {
    for (const k of this._keys) {
      yield this.get(k);
    }
    return void 0;
  }
  *entries() {
    for (const k of this._keys) {
      yield [k, this.get(k)];
    }
    return void 0;
  }
  *[Symbol.iterator]() {
    yield* this.entries();
  }
  forEach(cb, thisArg) {
    if (!cb) {
      return;
    }
    for (const k of this._keys) {
      cb.apply(thisArg, [[k, this.get(k)]]);
    }
  }
  _defaultSort(a, b2) {
    if (a[0] < b2[0])
      return -1;
    if (b2[0] < a[0])
      return 1;
    return 0;
  }
  _kCmp(a, b2) {
    return this._cmp(
      [a, this.get(a)],
      [b2, this.get(b2)]
    );
  }
}
const DefaultTaskMerger = {
  hasNewInfo() {
    return false;
  },
  merge() {
  }
};
class RequestQueue {
  constructor(taskMerger = DefaultTaskMerger) {
    this._taskMerger = taskMerger;
    this._byPeer = new SortedMap([], PeerTasks.compare);
  }
  pushTasks(peerId, tasks) {
    let peerTasks = this._byPeer.get(peerId.toString());
    if (!peerTasks) {
      peerTasks = new PeerTasks(peerId, this._taskMerger);
    }
    peerTasks.pushTasks(tasks);
    this._byPeer.set(peerId.toString(), peerTasks);
  }
  popTasks(targetMinBytes) {
    const peerTasks = this._head();
    if (peerTasks === void 0) {
      return { tasks: [], pendingSize: 0 };
    }
    const { tasks, pendingSize } = peerTasks.popTasks(targetMinBytes);
    if (tasks.length === 0) {
      return { tasks, pendingSize };
    }
    const peerId = peerTasks.peerId;
    if (peerTasks.isIdle()) {
      this._byPeer.delete(peerId.toString());
    } else {
      this._byPeer.update(0);
    }
    return {
      peerId,
      tasks,
      pendingSize
    };
  }
  _head() {
    if (this._byPeer.size === 0) {
      return void 0;
    }
    for (const [, v] of this._byPeer) {
      return v;
    }
    return void 0;
  }
  remove(topic, peerId) {
    const peerTasks = this._byPeer.get(peerId.toString());
    peerTasks && peerTasks.remove(topic);
  }
  tasksDone(peerId, tasks) {
    const peerTasks = this._byPeer.get(peerId.toString());
    if (!peerTasks) {
      return;
    }
    const i2 = this._byPeer.indexOf(peerId.toString());
    for (const task of tasks) {
      peerTasks.taskDone(task);
    }
    this._byPeer.update(i2);
  }
}
class PeerTasks {
  constructor(peerId, taskMerger) {
    this.peerId = peerId;
    this._taskMerger = taskMerger;
    this._activeTotalSize = 0;
    this._pending = new PendingTasks();
    this._active = /* @__PURE__ */ new Set();
  }
  pushTasks(tasks) {
    for (const t of tasks) {
      this._pushTask(t);
    }
  }
  _pushTask(task) {
    if (!this._taskHasMoreInfoThanActiveTasks(task)) {
      return;
    }
    const existingTask = this._pending.get(task.topic);
    if (existingTask) {
      if (task.priority > existingTask.priority) {
        this._pending.updatePriority(task.topic, task.priority);
      }
      this._taskMerger.merge(task, existingTask);
      return;
    }
    this._pending.add(task);
  }
  _taskHasMoreInfoThanActiveTasks(task) {
    const tasksWithTopic = [];
    for (const activeTask of this._active) {
      if (activeTask.topic === task.topic) {
        tasksWithTopic.push(activeTask);
      }
    }
    if (tasksWithTopic.length === 0) {
      return true;
    }
    return this._taskMerger.hasNewInfo(task, tasksWithTopic);
  }
  popTasks(targetMinBytes) {
    let size2 = 0;
    const tasks = [];
    const pendingTasks = this._pending.tasks();
    for (let i2 = 0; i2 < pendingTasks.length && size2 < targetMinBytes; i2++) {
      const task = pendingTasks[i2];
      tasks.push(task);
      size2 += task.size;
      this._pending.delete(task.topic);
      this._activeTotalSize += task.size;
      this._active.add(task);
    }
    return {
      tasks,
      pendingSize: this._pending.totalSize
    };
  }
  taskDone(task) {
    if (this._active.has(task)) {
      this._activeTotalSize -= task.size;
      this._active.delete(task);
    }
  }
  remove(topic) {
    this._pending.delete(topic);
  }
  isIdle() {
    return this._pending.length === 0 && this._active.size === 0;
  }
  static compare(a, b2) {
    if (a[1]._pending.length === 0) {
      return 1;
    }
    if (b2[1]._pending.length === 0) {
      return -1;
    }
    if (a[1]._activeTotalSize === b2[1]._activeTotalSize) {
      return b2[1]._pending.length - a[1]._pending.length;
    }
    return a[1]._activeTotalSize - b2[1]._activeTotalSize;
  }
}
class PendingTasks {
  constructor() {
    this._tasks = new SortedMap([], this._compare);
  }
  get length() {
    return this._tasks.size;
  }
  get totalSize() {
    return [...this._tasks.values()].reduce((a, t) => a + t.task.size, 0);
  }
  get(topic) {
    return (this._tasks.get(topic) || {}).task;
  }
  add(task) {
    this._tasks.set(task.topic, {
      created: Date.now(),
      task
    });
  }
  delete(topic) {
    this._tasks.delete(topic);
  }
  tasks() {
    return [...this._tasks.values()].map((i2) => i2.task);
  }
  updatePriority(topic, priority) {
    const obj = this._tasks.get(topic);
    if (!obj) {
      return;
    }
    const i2 = this._tasks.indexOf(topic);
    obj.task.priority = priority;
    this._tasks.update(i2);
  }
  _compare(a, b2) {
    if (a[1].task.priority === b2[1].task.priority) {
      return a[1].created - b2[1].created;
    }
    return b2[1].task.priority - a[1].task.priority;
  }
}
const TaskMerger = {
  hasNewInfo(task, tasksWithTopic) {
    let haveBlock = false;
    let isWantBlock = false;
    for (const existing of tasksWithTopic) {
      if (existing.data.haveBlock) {
        haveBlock = true;
      }
      if (existing.data.isWantBlock) {
        isWantBlock = true;
      }
    }
    if (!isWantBlock && task.data.isWantBlock) {
      return true;
    }
    if (!haveBlock && task.data.haveBlock) {
      return true;
    }
    return false;
  },
  merge(newTask, existingTask) {
    const taskData = newTask.data;
    const existingData = existingTask.data;
    if (!existingData.haveBlock && taskData.haveBlock) {
      existingData.haveBlock = taskData.haveBlock;
      existingData.blockSize = taskData.blockSize;
    }
    if (!existingData.isWantBlock && taskData.isWantBlock) {
      existingData.isWantBlock = true;
      if (!existingData.haveBlock || taskData.haveBlock) {
        existingData.haveBlock = taskData.haveBlock;
        existingTask.size = newTask.size;
      }
    }
    if (existingData.isWantBlock && existingData.haveBlock) {
      existingTask.size = existingData.blockSize;
    }
  }
};
const WantType = BitswapMessage.WantType;
const TARGET_MESSAGE_SIZE = 16 * 1024;
const MAX_SIZE_REPLACE_HAS_WITH_BLOCK = 1024;
class DecisionEngine {
  constructor(peerId, blockstore, network, stats, libp2p, opts = {}) {
    this._log = logger(peerId, "engine");
    this.blockstore = blockstore;
    this.network = network;
    this._stats = stats;
    this._opts = this._processOpts(opts);
    this.ledgerMap = trackedMap({
      system: "ipfs",
      component: "bitswap",
      metric: "ledger-map",
      metrics: libp2p.metrics
    });
    this._running = false;
    this._requestQueue = new RequestQueue(TaskMerger);
  }
  _processOpts(opts) {
    return {
      maxSizeReplaceHasWithBlock: MAX_SIZE_REPLACE_HAS_WITH_BLOCK,
      targetMessageSize: TARGET_MESSAGE_SIZE,
      ...opts
    };
  }
  _scheduleProcessTasks() {
    setTimeout(() => {
      this._processTasks();
    });
  }
  async _processTasks() {
    if (!this._running) {
      return;
    }
    const { peerId, tasks, pendingSize } = this._requestQueue.popTasks(this._opts.targetMessageSize);
    if (tasks.length === 0) {
      return;
    }
    const msg = new BitswapMessage(false);
    msg.setPendingBytes(pendingSize);
    const blockCids = [];
    const blockTasks = /* @__PURE__ */ new Map();
    for (const task of tasks) {
      const cid = CID.parse(task.topic);
      if (task.data.haveBlock) {
        if (task.data.isWantBlock) {
          blockCids.push(cid);
          blockTasks.set(task.topic, task.data);
        } else {
          msg.addHave(cid);
        }
      } else {
        msg.addDontHave(cid);
      }
    }
    const blocks = await this._getBlocks(blockCids);
    for (const [topic, taskData] of blockTasks) {
      const cid = CID.parse(topic);
      const blk = blocks.get(topic);
      if (blk) {
        msg.addBlock(cid, blk);
      } else {
        if (taskData.sendDontHave) {
          msg.addDontHave(cid);
        }
      }
    }
    if (msg.empty) {
      peerId && this._requestQueue.tasksDone(peerId, tasks);
      this._scheduleProcessTasks();
      return;
    }
    try {
      peerId && await this.network.sendMessage(peerId, msg);
      for (const [cidStr, block] of blocks.entries()) {
        peerId && this.messageSent(peerId, CID.parse(cidStr), block);
      }
    } catch (err2) {
      this._log.error(err2);
    }
    peerId && this._requestQueue.tasksDone(peerId, tasks);
    this._scheduleProcessTasks();
  }
  wantlistForPeer(peerId) {
    const peerIdStr = peerId.toString();
    const ledger = this.ledgerMap.get(peerIdStr);
    return ledger ? ledger.wantlist.sortedEntries() : /* @__PURE__ */ new Map();
  }
  ledgerForPeer(peerId) {
    const peerIdStr = peerId.toString();
    const ledger = this.ledgerMap.get(peerIdStr);
    if (!ledger) {
      return null;
    }
    return {
      peer: ledger.partner,
      value: ledger.debtRatio(),
      sent: ledger.accounting.bytesSent,
      recv: ledger.accounting.bytesRecv,
      exchanged: ledger.exchangeCount
    };
  }
  peers() {
    return Array.from(this.ledgerMap.values()).map((l) => l.partner);
  }
  receivedBlocks(blocks) {
    if (!blocks.length) {
      return;
    }
    for (const ledger of this.ledgerMap.values()) {
      for (const block of blocks) {
        const want = ledger.wantlistContains(block.cid);
        if (!want) {
          continue;
        }
        const blockSize = block.data.length;
        const isWantBlock = this._sendAsBlock(want.wantType, blockSize);
        let entrySize = blockSize;
        if (!isWantBlock) {
          entrySize = BitswapMessage.blockPresenceSize(want.cid);
        }
        this._requestQueue.pushTasks(ledger.partner, [{
          topic: want.cid.toString(base58btc$1),
          priority: want.priority,
          size: entrySize,
          data: {
            blockSize,
            isWantBlock,
            haveBlock: true,
            sendDontHave: false
          }
        }]);
      }
    }
    this._scheduleProcessTasks();
  }
  async messageReceived(peerId, msg) {
    const ledger = this._findOrCreate(peerId);
    if (msg.empty) {
      return;
    }
    if (msg.full) {
      ledger.wantlist = new Wantlist();
    }
    this._updateBlockAccounting(msg.blocks, ledger);
    if (msg.wantlist.size === 0) {
      this._scheduleProcessTasks();
      return;
    }
    const cancels = [];
    const wants = [];
    msg.wantlist.forEach((entry) => {
      if (entry.cancel) {
        ledger.cancelWant(entry.cid);
        cancels.push(entry.cid);
      } else {
        ledger.wants(entry.cid, entry.priority, entry.wantType);
        wants.push(entry);
      }
    });
    this._cancelWants(peerId, cancels);
    await this._addWants(peerId, wants);
    this._scheduleProcessTasks();
  }
  _cancelWants(peerId, cids) {
    for (const c of cids) {
      this._requestQueue.remove(c.toString(base58btc$1), peerId);
    }
  }
  async _addWants(peerId, wants) {
    const blockSizes = await this._getBlockSizes(wants.map((w) => w.cid));
    const tasks = [];
    for (const want of wants) {
      const id = want.cid.toString(base58btc$1);
      const blockSize = blockSizes.get(id);
      if (blockSize == null) {
        if (want.sendDontHave) {
          tasks.push({
            topic: id,
            priority: want.priority,
            size: BitswapMessage.blockPresenceSize(want.cid),
            data: {
              isWantBlock: want.wantType === WantType.Block,
              blockSize: 0,
              haveBlock: false,
              sendDontHave: want.sendDontHave
            }
          });
        }
      } else {
        const isWantBlock = this._sendAsBlock(want.wantType, blockSize);
        let entrySize = blockSize;
        if (!isWantBlock) {
          entrySize = BitswapMessage.blockPresenceSize(want.cid);
        }
        tasks.push({
          topic: id,
          priority: want.priority,
          size: entrySize,
          data: {
            isWantBlock,
            blockSize,
            haveBlock: true,
            sendDontHave: want.sendDontHave
          }
        });
      }
      this._requestQueue.pushTasks(peerId, tasks);
    }
  }
  _sendAsBlock(wantType, blockSize) {
    return wantType === WantType.Block || blockSize <= this._opts.maxSizeReplaceHasWithBlock;
  }
  async _getBlockSizes(cids) {
    const blocks = await this._getBlocks(cids);
    return new Map([...blocks].map(([k, v]) => [k, v.length]));
  }
  async _getBlocks(cids) {
    const res = /* @__PURE__ */ new Map();
    await Promise.all(cids.map(async (cid) => {
      try {
        const block = await this.blockstore.get(cid);
        res.set(cid.toString(base58btc$1), block);
      } catch (e) {
        if (e.code !== "ERR_NOT_FOUND") {
          this._log.error("failed to query blockstore for %s: %s", cid, e);
        }
      }
    }));
    return res;
  }
  _updateBlockAccounting(blocksMap, ledger) {
    for (const block of blocksMap.values()) {
      this._log("got block (%s bytes)", block.length);
      ledger.receivedBytes(block.length);
    }
  }
  messageSent(peerId, cid, block) {
    const ledger = this._findOrCreate(peerId);
    ledger.sentBytes(block.length);
    ledger.wantlist.remove(cid);
  }
  numBytesSentTo(peerId) {
    return this._findOrCreate(peerId).accounting.bytesSent;
  }
  numBytesReceivedFrom(peerId) {
    return this._findOrCreate(peerId).accounting.bytesRecv;
  }
  peerDisconnected(peerId) {
    this.ledgerMap.delete(peerId.toString());
  }
  _findOrCreate(peerId) {
    const peerIdStr = peerId.toString();
    const ledger = this.ledgerMap.get(peerIdStr);
    if (ledger) {
      return ledger;
    }
    const l = new Ledger(peerId);
    this.ledgerMap.set(peerIdStr, l);
    if (this._stats) {
      this._stats.push(peerIdStr, "peerCount", 1);
    }
    return l;
  }
  start() {
    this._running = true;
  }
  stop() {
    this._running = false;
  }
}
const unwantEvent = (cid) => `unwant:${toString$5(cid.multihash.bytes, "base64")}`;
const blockEvent = (cid) => `block:${toString$5(cid.multihash.bytes, "base64")}`;
class Notifications extends events.exports.EventEmitter {
  constructor(peerId) {
    super();
    this.setMaxListeners(maxListeners);
    this._log = logger(peerId, "notif");
  }
  hasBlock(cid, block) {
    const event = blockEvent(cid);
    this._log(event);
    this.emit(event, block);
  }
  wantBlock(cid, options = {}) {
    if (!cid) {
      throw new Error("Not a valid cid");
    }
    const blockEvt = blockEvent(cid);
    const unwantEvt = unwantEvent(cid);
    this._log(`wantBlock:${cid}`);
    return new Promise((resolve2, reject) => {
      const onUnwant = () => {
        this.removeListener(blockEvt, onBlock);
        reject(new Error(`Block for ${cid} unwanted`));
      };
      const onBlock = (data) => {
        this.removeListener(unwantEvt, onUnwant);
        resolve2(data);
      };
      this.once(unwantEvt, onUnwant);
      this.once(blockEvt, onBlock);
      if (options && options.signal) {
        options.signal.addEventListener("abort", () => {
          this.removeListener(blockEvt, onBlock);
          this.removeListener(unwantEvt, onUnwant);
          reject(new Error(`Want for ${cid} aborted`));
        });
      }
    });
  }
  unwantBlock(cid) {
    const event = unwantEvent(cid);
    this._log(event);
    this.emit(event);
  }
}
var movingAverage = { exports: {} };
(function(module, exports) {
  const exp = Math.exp;
  module.exports = function MovingAverage2(timespan) {
    if (typeof timespan !== "number") {
      throw new Error("must provide a timespan to the moving average constructor");
    }
    if (timespan <= 0) {
      throw new Error("must provide a timespan > 0 to the moving average constructor");
    }
    let ma;
    let v = 0;
    let d = 0;
    let f = 0;
    let previousTime;
    let ret = {};
    function alpha(t, pt) {
      return 1 - exp(-(t - pt) / timespan);
    }
    ret.push = function push3(time, value2) {
      if (previousTime) {
        const a = alpha(time, previousTime);
        const diff = value2 - ma;
        const incr = a * diff;
        ma = a * value2 + (1 - a) * ma;
        v = (1 - a) * (v + diff * incr);
        d = Math.sqrt(v);
        f = ma + a * diff;
      } else {
        ma = value2;
      }
      previousTime = time;
    };
    ret.movingAverage = function movingAverage2() {
      return ma;
    };
    ret.variance = function variance() {
      return v;
    };
    ret.deviation = function deviation() {
      return d;
    };
    ret.forecast = function forecast() {
      return f;
    };
    return ret;
  };
})(movingAverage);
const MovingAverage = movingAverage.exports;
class Stat extends events.exports.EventEmitter {
  constructor(initialCounters2, options) {
    super();
    this._options = options;
    this._queue = [];
    this._stats = {};
    this._frequencyLastTime = Date.now();
    this._frequencyAccumulators = {};
    this._movingAverages = {};
    this._update = this._update.bind(this);
    initialCounters2.forEach((key) => {
      this._stats[key] = BigInt(0);
      this._movingAverages[key] = {};
      this._options.movingAverageIntervals.forEach((interval) => {
        const ma = this._movingAverages[key][interval] = MovingAverage(interval);
        ma.push(this._frequencyLastTime, 0);
      });
    });
    this._enabled = this._options.enabled;
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._disabled = true;
  }
  stop() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
  }
  get snapshot() {
    return Object.assign({}, this._stats);
  }
  get movingAverages() {
    return Object.assign({}, this._movingAverages);
  }
  push(counter2, inc) {
    if (this._enabled) {
      this._queue.push([counter2, inc, Date.now()]);
      this._resetComputeTimeout();
    }
  }
  _resetComputeTimeout() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
    this._timeout = setTimeout(this._update, this._nextTimeout());
  }
  _nextTimeout() {
    const urgency = this._queue.length / this._options.computeThrottleMaxQueueSize;
    return Math.max(this._options.computeThrottleTimeout * (1 - urgency), 0);
  }
  _update() {
    this._timeout = null;
    if (this._queue.length) {
      let last2;
      while (this._queue.length) {
        const op = last2 = this._queue.shift();
        op && this._applyOp(op);
      }
      last2 && this._updateFrequency(last2[2]);
      this.emit("update", this._stats);
    }
  }
  _updateFrequency(latestTime) {
    const timeDiff = latestTime - this._frequencyLastTime;
    if (timeDiff) {
      Object.keys(this._stats).forEach((key) => {
        this._updateFrequencyFor(key, timeDiff, latestTime);
      });
    }
    this._frequencyLastTime = latestTime;
  }
  _updateFrequencyFor(key, timeDiffMS, latestTime) {
    const count = this._frequencyAccumulators[key] || 0;
    this._frequencyAccumulators[key] = 0;
    const hz = count / timeDiffMS * 1e3;
    let movingAverages = this._movingAverages[key];
    if (!movingAverages) {
      movingAverages = this._movingAverages[key] = {};
    }
    this._options.movingAverageIntervals.forEach((movingAverageInterval) => {
      let movingAverage2 = movingAverages[movingAverageInterval];
      if (!movingAverage2) {
        movingAverage2 = movingAverages[movingAverageInterval] = MovingAverage(movingAverageInterval);
      }
      movingAverage2.push(latestTime, hz);
    });
  }
  _applyOp(op) {
    const key = op[0];
    const inc = op[1];
    if (typeof inc !== "number") {
      throw new Error(`invalid increment number: ${inc}`);
    }
    if (!Object.prototype.hasOwnProperty.call(this._stats, key)) {
      this._stats[key] = BigInt(0);
    }
    this._stats[key] = BigInt(this._stats[key]) + BigInt(inc);
    if (!this._frequencyAccumulators[key]) {
      this._frequencyAccumulators[key] = 0;
    }
    this._frequencyAccumulators[key] += inc;
  }
}
const defaultOptions$1 = {
  enabled: false,
  computeThrottleTimeout: 1e3,
  computeThrottleMaxQueueSize: 1e3,
  movingAverageIntervals: [
    60 * 1e3,
    5 * 60 * 1e3,
    15 * 60 * 1e3
  ]
};
class Stats extends events.exports.EventEmitter {
  constructor(libp2p, initialCounters2 = [], _options = defaultOptions$1) {
    super();
    const options = Object.assign({}, defaultOptions$1, _options);
    if (typeof options.computeThrottleTimeout !== "number") {
      throw new Error("need computeThrottleTimeout");
    }
    if (typeof options.computeThrottleMaxQueueSize !== "number") {
      throw new Error("need computeThrottleMaxQueueSize");
    }
    this._initialCounters = initialCounters2;
    this._options = options;
    this._enabled = this._options.enabled;
    this._global = new Stat(initialCounters2, options);
    this._global.on("update", (stats) => this.emit("update", stats));
    this._peers = trackedMap({
      system: "ipfs",
      component: "bitswap",
      metric: "stats-peers",
      metrics: libp2p.metrics
    });
  }
  enable() {
    this._enabled = true;
    this._options.enabled = true;
    this._global.enable();
  }
  disable() {
    this._enabled = false;
    this._options.enabled = false;
    this._global.disable();
  }
  stop() {
    this._enabled = false;
    this._global.stop();
    for (const peerStat of this._peers) {
      peerStat[1].stop();
    }
  }
  get snapshot() {
    return this._global.snapshot;
  }
  get movingAverages() {
    return this._global.movingAverages;
  }
  forPeer(peerId) {
    const peerIdStr = typeof peerId !== "string" && peerId.toString ? peerId.toString() : `${peerId}`;
    return this._peers.get(peerIdStr);
  }
  push(peer, counter2, inc) {
    if (this._enabled) {
      this._global.push(counter2, inc);
      if (peer) {
        let peerStats = this._peers.get(peer);
        if (!peerStats) {
          peerStats = new Stat(this._initialCounters, this._options);
          this._peers.set(peer, peerStats);
        }
        peerStats.push(counter2, inc);
      }
    }
  }
  disconnected(peer) {
    const peerId = peer.toString();
    const peerStats = this._peers.get(peerId);
    if (peerStats) {
      peerStats.stop();
      this._peers.delete(peerId);
    }
  }
}
const defaultOptions = {
  statsEnabled: false,
  statsComputeThrottleTimeout: 1e3,
  statsComputeThrottleMaxQueueSize: 1e3
};
const statsKeys = [
  "blocksReceived",
  "dataReceived",
  "dupBlksReceived",
  "dupDataReceived",
  "blocksSent",
  "dataSent",
  "providesBufferLength",
  "wantListLength",
  "peerCount"
];
class Bitswap extends BaseBlockstore {
  constructor(libp2p, blockstore, options = {}) {
    super();
    this._libp2p = libp2p;
    this._log = logger(this.peerId);
    this._options = Object.assign({}, defaultOptions, options);
    this._stats = new Stats(libp2p, statsKeys, {
      enabled: this._options.statsEnabled,
      computeThrottleTimeout: this._options.statsComputeThrottleTimeout,
      computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize
    });
    this.network = new Network$1(libp2p, this, this._stats, {
      hashLoader: options.hashLoader,
      maxInboundStreams: options.maxInboundStreams,
      maxOutboundStreams: options.maxOutboundStreams,
      incomingStreamTimeout: options.incomingStreamTimeout
    });
    this.blockstore = blockstore;
    this.engine = new DecisionEngine(this.peerId, blockstore, this.network, this._stats, libp2p);
    this.wm = new WantManager(this.peerId, this.network, this._stats, libp2p);
    this.notifications = new Notifications(this.peerId);
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  get peerId() {
    return this._libp2p.peerId;
  }
  async _receiveMessage(peerId, incoming) {
    try {
      await this.engine.messageReceived(peerId, incoming);
    } catch (err2) {
      this._log("failed to receive message", incoming);
    }
    if (incoming.blocks.size === 0) {
      return;
    }
    const received = [];
    for (const [cidStr, data] of incoming.blocks.entries()) {
      const cid = CID.parse(cidStr);
      received.push({
        wasWanted: this.wm.wantlist.contains(cid),
        cid,
        data
      });
    }
    this.wm.cancelWants(
      received.filter(({ wasWanted }) => wasWanted).map(({ cid }) => cid)
    );
    await Promise.all(
      received.map(
        ({ cid, wasWanted, data }) => this._handleReceivedBlock(peerId, cid, data, wasWanted)
      )
    );
  }
  async _handleReceivedBlock(peerId, cid, data, wasWanted) {
    this._log("received block");
    const has = await this.blockstore.has(cid);
    this._updateReceiveCounters(peerId.toString(), cid, data, has);
    if (!wasWanted) {
      return;
    }
    await this.put(cid, data);
  }
  _updateReceiveCounters(peerIdStr, cid, data, exists2) {
    this._stats.push(peerIdStr, "blocksReceived", 1);
    this._stats.push(peerIdStr, "dataReceived", data.length);
    if (exists2) {
      this._stats.push(peerIdStr, "dupBlksReceived", 1);
      this._stats.push(peerIdStr, "dupDataReceived", data.length);
    }
  }
  _receiveError(err2) {
    this._log.error("ReceiveError: %s", err2.message);
  }
  _onPeerConnected(peerId) {
    this.wm.connected(peerId);
  }
  _onPeerDisconnected(peerId) {
    this.wm.disconnected(peerId);
    this.engine.peerDisconnected(peerId);
    this._stats.disconnected(peerId);
  }
  enableStats() {
    this._stats.enable();
  }
  disableStats() {
    this._stats.disable();
  }
  wantlistForPeer(peerId, _options) {
    return this.engine.wantlistForPeer(peerId);
  }
  ledgerForPeer(peerId) {
    return this.engine.ledgerForPeer(peerId);
  }
  async get(cid, options = {}) {
    const fetchFromNetwork = (cid2, options2) => {
      this.wm.wantBlocks([cid2], options2);
      return this.notifications.wantBlock(cid2, options2);
    };
    let promptedNetwork = false;
    const loadOrFetchFromNetwork = async (cid2, options2) => {
      try {
        const block = await this.blockstore.get(cid2, options2);
        return block;
      } catch (err2) {
        if (err2.code !== "ERR_NOT_FOUND") {
          throw err2;
        }
        if (!promptedNetwork) {
          promptedNetwork = true;
          this.network.findAndConnect(cid2, options2).catch((err3) => this._log.error(err3));
        }
        return fetchFromNetwork(cid2, options2);
      }
    };
    const controller = new AbortController();
    const signal = options.signal ? anySignal_2([options.signal, controller.signal]) : controller.signal;
    try {
      const block = await Promise.race([
        this.notifications.wantBlock(cid, {
          signal
        }),
        loadOrFetchFromNetwork(cid, {
          signal
        })
      ]);
      return block;
    } finally {
      controller.abort();
    }
  }
  async *getMany(cids, options = {}) {
    for await (const cid of cids) {
      yield this.get(cid, options);
    }
  }
  unwant(cids) {
    const cidsArray = Array.isArray(cids) ? cids : [cids];
    this.wm.unwantBlocks(cidsArray);
    cidsArray.forEach((cid) => this.notifications.unwantBlock(cid));
  }
  cancelWants(cids) {
    this.wm.cancelWants(Array.isArray(cids) ? cids : [cids]);
  }
  async put(cid, block, _options) {
    await this.blockstore.put(cid, block);
    this._sendHaveBlockNotifications(cid, block);
  }
  async *putMany(source2, options) {
    for await (const { key, value: value2 } of this.blockstore.putMany(source2, options)) {
      this._sendHaveBlockNotifications(key, value2);
      yield { key, value: value2 };
    }
  }
  _sendHaveBlockNotifications(cid, data) {
    this.notifications.hasBlock(cid, data);
    this.engine.receivedBlocks([{ cid, data }]);
    this.network.provide(cid).catch((err2) => {
      this._log.error("Failed to provide: %s", err2.message);
    });
  }
  getWantlist() {
    return this.wm.wantlist.entries();
  }
  peers() {
    return this.engine.peers();
  }
  stat() {
    return this._stats;
  }
  async start() {
    this.wm.start();
    await this.network.start();
    this.engine.start();
    this.started = true;
  }
  async stop() {
    this._stats.stop();
    this.wm.stop();
    await this.network.stop();
    this.engine.stop();
    this.started = false;
  }
  unwrap() {
    return this.blockstore;
  }
}
const createBitswap = (libp2p, blockstore, options = {}) => {
  return new Bitswap(libp2p, blockstore, options);
};
function notFoundError(err2) {
  err2 = err2 || new Error("Not Found");
  return errCode(err2, "ERR_NOT_FOUND");
}
function abortedError(err2) {
  err2 = err2 || new Error("Aborted");
  return errCode(err2, "ERR_ABORTED");
}
const ErrorsImport = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  notFoundError,
  abortedError
}, Symbol.toStringTag, { value: "Module" }));
({
  ...ErrorsImport
});
class BlockStorage extends BaseBlockstore {
  constructor(blockstore, bitswap) {
    super();
    this.child = blockstore;
    this.bitswap = bitswap;
  }
  open() {
    return this.child.open();
  }
  close() {
    return this.child.close();
  }
  unwrap() {
    return this.child;
  }
  async put(cid, block, options = {}) {
    if (await this.has(cid)) {
      return;
    }
    if (this.bitswap.isStarted()) {
      await this.bitswap.put(cid, block, options);
    } else {
      await this.child.put(cid, block, options);
    }
  }
  async *putMany(blocks, options = {}) {
    const missingBlocks = filter$1(blocks, async ({ key }) => {
      return !await this.has(key);
    });
    if (this.bitswap.isStarted()) {
      yield* this.bitswap.putMany(missingBlocks, options);
    } else {
      yield* this.child.putMany(missingBlocks, options);
    }
  }
  async get(cid, options = {}) {
    if (!await this.has(cid) && this.bitswap.isStarted()) {
      return this.bitswap.get(cid, options);
    } else {
      return this.child.get(cid, options);
    }
  }
  async *getMany(cids, options = {}) {
    const getFromBitswap = pushable({ objectMode: true });
    const getFromChild = pushable({ objectMode: true });
    Promise.resolve().then(async () => {
      for await (const cid of cids) {
        if (!await this.has(cid) && this.bitswap.isStarted()) {
          getFromBitswap.push(cid);
        } else {
          getFromChild.push(cid);
        }
      }
      getFromBitswap.end();
      getFromChild.end();
    });
    yield* merge$1(
      this.bitswap.getMany(getFromBitswap, options),
      this.child.getMany(getFromChild, options)
    );
  }
  async delete(cid, options) {
    await this.child.delete(cid, options);
  }
  async *deleteMany(cids, options) {
    yield* this.child.deleteMany(cids, options);
  }
  async has(cid, options = {}) {
    return this.child.has(cid, options);
  }
  async *query(q, options = {}) {
    yield* this.child.query(q, options);
  }
  async *queryKeys(q, options = {}) {
    yield* this.child.queryKeys(q, options);
  }
}
class Network {
  constructor(peerId, libp2p, bitswap, repo, blockstore) {
    this.peerId = peerId;
    this.libp2p = libp2p;
    this.bitswap = bitswap;
    this.repo = repo;
    this.blockstore = blockstore;
  }
  static async start({ peerId, repo, print, hashers, options }) {
    if (repo.closed) {
      await repo.open();
    }
    const config2 = await repo.config.getAll();
    const libp2p = await createLibp2p({
      options,
      repo,
      peerId,
      multiaddrs: readAddrs(peerId, config2),
      config: config2,
      keychainConfig: void 0
    });
    await libp2p.start();
    for (const ma of libp2p.getMultiaddrs()) {
      print(`Swarm listening on ${ma.toString()}`);
    }
    const bitswap = createBitswap(libp2p, repo.blocks, {
      statsEnabled: true,
      hashLoader: hashers,
      maxInboundStreams: 1024,
      maxOutboundStreams: 1024
    });
    await bitswap.start();
    const blockstore = new BlockStorage(repo.blocks, bitswap);
    repo.blocks = blockstore;
    repo.pins.blockstore = blockstore;
    return new Network(peerId, libp2p, bitswap, repo, blockstore);
  }
  static async stop(network) {
    network.repo.blocks = network.blockstore.unwrap();
    network.repo.pins.blockstore = network.blockstore.unwrap();
    await network.bitswap.stop();
    await network.libp2p.stop();
  }
}
const readAddrs = (peerId, config2) => {
  const peerIdStr = peerId.toString();
  const addrs = [];
  const swarm = config2.Addresses && config2.Addresses.Swarm || [];
  for (const addr of swarm) {
    let ma = multiaddr(addr);
    if (ma.protoCodes().includes(WEBSOCKET_STAR_PROTO_CODE)) {
      throw errCode(new Error("websocket-star swarm addresses are not supported. See https://github.com/ipfs/js-ipfs/issues/2779"), "ERR_WEBSOCKET_STAR_SWARM_ADDR_NOT_SUPPORTED");
    }
    const maId = ma.getPeerId();
    if (maId && maId !== peerIdStr) {
      ma = ma.encapsulate(`/p2p/${peerIdStr}`);
    }
    addrs.push(ma);
  }
  return addrs;
};
const WEBSOCKET_STAR_PROTO_CODE = 479;
function createAddrs({ network }) {
  async function addrs(options = {}) {
    const peers = [];
    const { libp2p } = await network.use(options);
    await libp2p.peerStore.forEach((peer) => {
      peers.push({
        id: peer.id,
        addrs: peer.addresses.map((mi) => mi.multiaddr)
      });
    });
    return peers;
  }
  return withTimeoutOption(addrs);
}
function createConnect({ network }) {
  async function connect2(multiaddrOrPeerId, options = {}) {
    const { libp2p } = await network.use(options);
    await libp2p.dial(multiaddrOrPeerId, options);
  }
  return withTimeoutOption(connect2);
}
function createDisconnect({ network }) {
  async function disconnect(addr, options = {}) {
    const { libp2p } = await network.use(options);
    await libp2p.hangUp(addr);
  }
  return withTimeoutOption(disconnect);
}
function createLocalAddrs({ network }) {
  async function localAddrs(options = {}) {
    const { libp2p } = await network.use(options);
    return libp2p.getMultiaddrs();
  }
  return withTimeoutOption(localAddrs);
}
function createPeers({ network }) {
  async function peers(options = {}) {
    const { libp2p } = await network.use(options);
    if (options.verbose) {
      const peers3 = [];
      for (const connection of libp2p.getConnections()) {
        const peer = {
          addr: connection.remoteAddr,
          peer: connection.remotePeer
        };
        if (options.verbose || options.direction) {
          peer.direction = connection.stat.direction;
        }
        if (options.verbose) {
          peer.muxer = connection.stat.multiplexer;
          peer.latency = "n/a";
          peer.streams = [];
        }
        peers3.push(peer);
      }
      return peers3;
    }
    const peers2 = /* @__PURE__ */ new Map();
    for (const connection of libp2p.getConnections()) {
      const peer = {
        addr: connection.remoteAddr,
        peer: connection.remotePeer
      };
      peers2.set(connection.remotePeer.toString(), peer);
    }
    return Array.from(peers2.values());
  }
  return withTimeoutOption(peers);
}
class SwarmAPI {
  constructor({ network }) {
    this.addrs = createAddrs({ network });
    this.connect = createConnect({ network });
    this.disconnect = createDisconnect({ network });
    this.localAddrs = createLocalAddrs({ network });
    this.peers = createPeers({ network });
  }
}
const basePacket = { success: true, time: 0, text: "" };
function createPing({ network }) {
  async function* ping(peerId, options = {}) {
    const { libp2p } = await network.use();
    options.count = options.count || 10;
    const storedPeer = await libp2p.peerStore.get(peerId);
    let id = storedPeer && storedPeer.id;
    if (!id) {
      yield { ...basePacket, text: `Looking up peer ${peerId}` };
      const remotePeer = await libp2p.peerRouting.findPeer(peerId);
      id = remotePeer && remotePeer.id;
    }
    if (!id) {
      throw new Error("Peer was not found");
    }
    yield { ...basePacket, text: `PING ${id.toString()}` };
    let packetCount = 0;
    let totalTime = 0;
    for (let i2 = 0; i2 < options.count; i2++) {
      try {
        const time = await libp2p.ping(id);
        totalTime += time;
        packetCount++;
        yield { ...basePacket, time };
      } catch (err2) {
        yield { ...basePacket, success: false, text: err2.toString() };
      }
    }
    if (packetCount) {
      const average = totalTime / packetCount;
      yield { ...basePacket, text: `Average latency: ${average}ms` };
    }
  }
  return withTimeoutOption(ping);
}
const IPNS_PREFIX = "/ipns/";
function toDHTKey(str) {
  if (str.startsWith(IPNS_PREFIX)) {
    str = str.substring(IPNS_PREFIX.length);
  }
  let buf2;
  if (str[0] === "1" || str[0] === "Q") {
    str = `z${str}`;
  }
  if (str[0] === "z") {
    buf2 = base58btc$1.decode(str);
  }
  if (str[0] === "k") {
    buf2 = base36$2.decode(str);
  }
  if (!buf2) {
    throw new Error("Could not parse string");
  }
  if (buf2[0] !== 1 && buf2[1] !== 114) {
    buf2 = concat$1([
      [1, 114],
      buf2
    ]);
  }
  if (buf2.length !== 40) {
    throw new Error("Incorrect length " + buf2.length);
  }
  return concat$1([
    fromString$3(IPNS_PREFIX),
    buf2.subarray(2)
  ]);
}
function createDht({ network, repo, peerId }) {
  const { get: get3, put, findProvs, findPeer: findPeer2, provide, query } = {
    async *get(key, options = {}) {
      const { libp2p } = await use(network, peerId, options);
      const dhtKey = key instanceof Uint8Array ? key : toDHTKey(key);
      if (libp2p.dht == null) {
        throw errCode(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
      }
      yield* libp2p.dht.get(dhtKey, options);
    },
    async *put(key, value2, options) {
      const { libp2p } = await use(network, peerId, options);
      const dhtKey = key instanceof Uint8Array ? key : toDHTKey(key);
      if (libp2p.dht == null) {
        throw errCode(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
      }
      yield* libp2p.dht.put(dhtKey, value2, options);
    },
    async *findProvs(cid, options = {}) {
      const { libp2p } = await use(network, peerId, options);
      if (libp2p.dht == null) {
        throw errCode(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
      }
      yield* libp2p.dht.findProviders(cid, {
        signal: options.signal
      });
    },
    async *findPeer(peerIdToFind, options = {}) {
      const { libp2p } = await use(network, peerId, options);
      if (libp2p.dht == null) {
        throw errCode(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
      }
      yield* libp2p.dht.findPeer(peerIdToFind, {
        signal: options.signal
      });
    },
    async *provide(cid, options = { recursive: false }) {
      const { libp2p } = await use(network, peerId, options);
      const hasBlock = await repo.blocks.has(cid);
      if (!hasBlock) {
        throw errCode(new Error("block(s) not found locally, cannot provide"), "ERR_BLOCK_NOT_FOUND");
      }
      if (options.recursive) {
        throw errCode(new Error("not implemented yet"), "ERR_NOT_IMPLEMENTED_YET");
      }
      if (libp2p.dht == null) {
        throw errCode(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
      }
      yield* libp2p.dht.provide(cid);
    },
    async *query(peerIdToQuery, options = {}) {
      const { libp2p } = await use(network, peerId, options);
      let bytes2;
      const asCid = CID.asCID(peerIdToQuery);
      if (asCid != null) {
        bytes2 = asCid.multihash.bytes;
      } else {
        bytes2 = peerIdFromString(peerIdToQuery.toString()).toBytes();
      }
      if (libp2p.dht == null) {
        throw errCode(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
      }
      yield* libp2p.dht.getClosestPeers(bytes2, options);
    }
  };
  return {
    get: withTimeoutOption(get3),
    put: withTimeoutOption(put),
    findProvs: withTimeoutOption(findProvs),
    findPeer: withTimeoutOption(findPeer2),
    provide: withTimeoutOption(provide),
    query: withTimeoutOption(query)
  };
}
const use = async (network, peerId, options) => {
  const net = await network.use(options);
  if (net.libp2p.dht != null) {
    return net;
  } else {
    const fn = async function* () {
      yield {
        from: peerId,
        name: "QUERY_ERROR",
        type: 3,
        error: new NotEnabledError("dht not enabled")
      };
    };
    return {
      libp2p: {
        dht: {
          get: fn,
          put: fn,
          findProviders: fn,
          findPeer: fn,
          provide: fn,
          getClosestPeers: fn
        }
      }
    };
  }
};
function createPubsub({ network, config: config2 }) {
  const isEnabled = get$2(config2 || {}, "Pubsub.Enabled", true);
  const handlers = {};
  let onMessage;
  return {
    subscribe: isEnabled ? withTimeoutOption(subscribe2) : notEnabled,
    unsubscribe: isEnabled ? withTimeoutOption(unsubscribe) : notEnabled,
    publish: isEnabled ? withTimeoutOption(publish) : notEnabled,
    ls: isEnabled ? withTimeoutOption(ls) : notEnabled,
    peers: isEnabled ? withTimeoutOption(peers) : notEnabled
  };
  async function subscribe2(topic, handler, options = {}) {
    const { libp2p } = await network.use(options);
    libp2p.pubsub.subscribe(topic);
    if (onMessage == null) {
      onMessage = (evt) => {
        const msg = evt.detail;
        if (handlers[msg.topic]) {
          handlers[msg.topic].forEach((handler2) => {
            if (typeof handler2 === "function") {
              handler2(msg);
              return;
            }
            if (handler2 != null && handler2.handleEvent != null) {
              handler2.handleEvent(msg);
            }
          });
        }
      };
      libp2p.pubsub.addEventListener("message", onMessage);
    }
    if (handler != null) {
      if (handlers[topic] == null) {
        handlers[topic] = [];
      }
      handlers[topic].push(handler);
    }
  }
  async function unsubscribe(topic, handler, options = {}) {
    const { libp2p } = await network.use(options);
    if (handler != null && handlers[topic] != null) {
      handlers[topic] = handlers[topic].filter((h) => h !== handler);
      if (handlers[topic].length === 0) {
        delete handlers[topic];
      }
    }
    if (typeof handler !== "function") {
      delete handlers[topic];
    }
    if (handlers[topic] == null) {
      libp2p.pubsub.unsubscribe(topic);
    }
    if (Object.keys(handlers).length === 0) {
      libp2p.pubsub.removeEventListener("message", onMessage);
      onMessage = void 0;
    }
  }
  async function publish(topic, data, options = {}) {
    const { libp2p } = await network.use(options);
    if (!data) {
      throw errCode(new Error('argument "data" is required'), "ERR_ARG_REQUIRED");
    }
    await libp2p.pubsub.publish(topic, data);
  }
  async function ls(options = {}) {
    const { libp2p } = await network.use(options);
    return libp2p.pubsub.getTopics();
  }
  async function peers(topic, options = {}) {
    const { libp2p } = await network.use(options);
    return libp2p.pubsub.getSubscribers(topic);
  }
}
const notEnabled = async () => {
  throw new NotEnabledError("pubsub not enabled");
};
const mergeOptions = mergeOptions$g.bind({ ignoreUndefined: true });
const log = logger$1("ipfs");
const IPNS_INIT_KEYSPACE_TIMEOUT = 3e4;
class IPFS {
  constructor({ print, storage, codecs: codecs2, options }) {
    const { peerId, repo, keychain } = storage;
    const network = Service.create(Network);
    const preload2 = createPreloader(options.preload);
    const dns = createDns$1();
    const isOnline = createIsOnline$1({ network });
    const ipns = new IPNSAPI(options);
    const multihashHashers = Object.values(hashes);
    (options.ipld && options.ipld.hashers ? options.ipld.hashers : []).forEach((hasher) => multihashHashers.push(hasher));
    this.hashers = new Multihashes({
      hashers: multihashHashers,
      loadHasher: options.ipld && options.ipld.loadHasher
    });
    const multibaseCodecs = Object.values(bases$1);
    (options.ipld && options.ipld.bases ? options.ipld.bases : []).forEach((base3) => multibaseCodecs.push(base3));
    this.bases = new Multibases({
      bases: multibaseCodecs,
      loadBase: options.ipld && options.ipld.loadBase
    });
    const pin = new PinAPI({ repo, codecs: codecs2 });
    const block = new BlockAPI({ codecs: codecs2, hashers: this.hashers, preload: preload2, repo });
    const name2 = new NameAPI({
      dns,
      ipns,
      repo,
      codecs: codecs2,
      peerId,
      isOnline,
      keychain,
      options
    });
    const resolve2 = createResolve$5({ repo, codecs: codecs2, bases: this.bases, name: name2 });
    const dag = new DagAPI({ repo, codecs: codecs2, hashers: this.hashers, preload: preload2 });
    const refs = Object.assign(createRefs$1({ repo, codecs: codecs2, resolve: resolve2, preload: preload2 }), {
      local: createLocal$1({ repo: storage.repo })
    });
    const { add, addAll, cat, get: get3, ls } = new RootAPI({
      preload: preload2,
      repo,
      options: options.EXPERIMENTAL,
      hashers: this.hashers
    });
    const files = createFiles$1({
      repo,
      preload: preload2,
      hashers: this.hashers,
      options
    });
    const mfsPreload = createMfsPreloader({
      files,
      preload: preload2,
      options: options.preload
    });
    this.preload = preload2;
    this.name = name2;
    this.ipns = ipns;
    this.pin = pin;
    this.resolve = resolve2;
    this.block = block;
    this.refs = refs;
    this.start = createStart$1({
      network,
      peerId,
      repo,
      preload: preload2,
      ipns,
      mfsPreload,
      print,
      keychain,
      hashers: this.hashers,
      options
    });
    this.stop = createStop$1({
      network,
      preload: preload2,
      mfsPreload,
      ipns,
      repo
    });
    this.dht = createDht({ network, repo, peerId });
    this.pubsub = createPubsub({ network, config: options.config });
    this.dns = dns;
    this.isOnline = isOnline;
    this.id = createId$1({ network, peerId });
    this.version = createVersion$3({ repo });
    this.bitswap = new BitswapAPI({ network });
    this.bootstrap = new BootstrapAPI({ repo });
    this.config = createConfig$1({ repo });
    this.ping = createPing({ network });
    this.add = add;
    this.addAll = addAll;
    this.cat = cat;
    this.get = get3;
    this.ls = ls;
    this.dag = dag;
    this.files = files;
    this.key = new KeyAPI({ keychain });
    this.object = new ObjectAPI({ preload: preload2, codecs: codecs2, repo });
    this.repo = new RepoAPI({ repo, hashers: this.hashers });
    this.stats = new StatsAPI({ repo, network });
    this.swarm = new SwarmAPI({ network });
    Object.defineProperty(this, "libp2p", {
      get() {
        const net = network.try();
        return net ? net.libp2p : void 0;
      }
    });
    const notImplemented = () => Promise.reject(errCode(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED"));
    const notImplementedIter = async function* () {
      throw errCode(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
    };
    this.commands = notImplemented;
    this.diag = {
      cmds: notImplemented,
      net: notImplemented,
      sys: notImplemented
    };
    this.log = {
      level: notImplemented,
      ls: notImplemented,
      tail: notImplementedIter
    };
    this.mount = notImplemented;
    this.codecs = codecs2;
  }
  async init() {
    throw new AlreadyInitializedError();
  }
}
const addEmptyDir = async (ipfs2) => {
  const buf2 = encode$o({
    Data: new UnixFS({ type: "directory" }).marshal(),
    Links: []
  });
  const cid = await ipfs2.block.put(buf2, {
    mhtype: "sha2-256",
    format: "dag-pb"
  });
  await ipfs2.pin.add(cid);
  return cid;
};
const getDefaultOptions = () => ({
  start: true,
  EXPERIMENTAL: {},
  preload: {
    enabled: !env.isTest,
    addresses: [
      "/dns4/node0.preload.ipfs.io/https",
      "/dns4/node1.preload.ipfs.io/https",
      "/dns4/node2.preload.ipfs.io/https",
      "/dns4/node3.preload.ipfs.io/https"
    ]
  }
});
async function create$1(options = {}) {
  options = mergeOptions(getDefaultOptions(), options);
  const initOptions = options.init || {};
  const id = {
    name: identity$5.name,
    code: identity$5.code,
    encode: (id2) => id2,
    decode: (id2) => id2
  };
  const blockCodecs = Object.values(codecs);
  [dagPB, dagCBOR, dagJSON, dagJOSE, id].concat(options.ipld && options.ipld.codecs || []).forEach((codec) => blockCodecs.push(codec));
  const multicodecs = new Multicodecs({
    codecs: blockCodecs,
    loadCodec: options.ipld && options.ipld.loadCodec
  });
  const print = options.silent ? log : console.log;
  log("creating repo");
  const storage = await Storage.start(print, multicodecs, options);
  log("getting repo config");
  const config2 = await storage.repo.config.getAll();
  const ipfs2 = new IPFS({
    storage,
    print,
    codecs: multicodecs,
    options: { ...options, config: config2 }
  });
  log("starting preload");
  await ipfs2.preload.start();
  log("starting storage");
  ipfs2.ipns.startOffline(storage);
  if (storage.isNew && !initOptions.emptyRepo) {
    const cid = await addEmptyDir(ipfs2);
    log("adding default assets");
    await initAssets({ addAll: ipfs2.addAll, print });
    log("initializing IPNS keyspace");
    if (storage.peerId.publicKey == null) {
      throw errCode(new Error("Public key missing"), "ERR_MISSING_PUBLIC_KEY");
    }
    const timeoutController = new timeoutAbortController.TimeoutController(IPNS_INIT_KEYSPACE_TIMEOUT);
    try {
      await ipfs2.ipns.initializeKeyspace(storage.peerId, fromString$3(`/ipfs/${cid}`), {
        signal: timeoutController.signal
      });
    } finally {
      timeoutController.clear();
    }
  }
  if (options.start !== false) {
    log("starting node");
    await ipfs2.start();
  }
  return ipfs2;
}
const create = create$1;
let ipfs;
async function getIPFS() {
  if (!ipfs) {
    console.log("Creating IPFS node...");
    ipfs = await create({
      repo: String(Math.random() + Date.now()),
      init: { alogorithm: "ed25519" }
    });
    const id = await ipfs.id();
    console.log(`Connecting to ${id.id}...`, id.id);
  }
  return ipfs;
}
async function addToIPFS(name2, content) {
  const ipfs2 = await getIPFS();
  const fileToAdd = {
    path: `${name2}`,
    content
  };
  console.log(`Adding file ${fileToAdd.path}...`);
  const file = await ipfs2.add(fileToAdd);
  console.log(`Added to ${file.cid}`, file.cid);
  console.log("File object", file);
  console.log(`Preview: https://ipfs.io/ipfs/${file.cid}`);
  return file;
}
async function catCID(cid) {
  const ipfs2 = await getIPFS();
  const cat = async (cid2) => {
    const decoder = new TextDecoder();
    let content = "";
    for await (const chunk of ipfs2.cat(cid2)) {
      content += decoder.decode(chunk, {
        stream: true
      });
    }
    return content;
  };
  console.log("Reading file...");
  const text = await cat(cid);
  console.log(`${text.toString()}`);
  return text.toString();
}
export {
  addToIPFS as a,
  catCID as c
};
