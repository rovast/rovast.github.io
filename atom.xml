<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rovast</title>
  
  <subtitle>rovast&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://rovast.github.io/"/>
  <updated>2022-09-28T06:14:26.588Z</updated>
  <id>https://rovast.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>wasmcloud app interface 源码阅读</title>
    <link href="https://rovast.github.io/2022/09/28/wasmcloud-app-interface/"/>
    <id>https://rovast.github.io/2022/09/28/wasmcloud-app-interface/</id>
    <published>2022-09-28T05:57:16.000Z</published>
    <updated>2022-09-28T06:14:26.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="新建-interface"><a href="#新建-interface" class="headerlink" title="新建 interface"></a>新建 interface</h1><p>wasmcloud app 开发使用的是 CDD 模式，也就是基于契约开发的模式。其中契约的定义，使用 wash 指令即可完成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wash new interface</span><br></pre></td></tr></table></figure><p>执行完成后，会根据契约的相关属性信息（如 contractId）等，生成 smithy IDL 的定义文件。smithy 文件专注于契约的定义，而成功将契约和具体的语言实现解耦出来。</p><p>简单来说，同一套 smithy 定义文件，可以根据编程语言的不同，生成不同的代码，方便不同语言进行集成开发。</p><p>比如当前 wasmcloud 支持生成 rust 和 go 两种语言的代码。这样在基于 rust 语言开发 actor 时，可以直接在 cargo.toml 文件中引入 interface 的包，进而调用 interface 相关的 operation，也可以使用 interface 中的数据结构。</p><p>而这些 operation 的具体实现，则由 provider 来实现。</p><p>通过 smithy IDL 定义的契约，成功将 actor, provider 解耦出来。</p><p><img src="pic.png" width="700"></p><h2 id="actor-to-actor-VS-capability-provider"><a href="#actor-to-actor-VS-capability-provider" class="headerlink" title="actor-to-actor VS capability provider"></a>actor-to-actor VS capability provider</h2><p>在新建 interface 的时候，有两种模板可选，分别是 actor-to-actor 和 provider。其区别主要在 wasmbus 的相关处理上。本文主要讨论的是 capability provider。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// factorial.smithy</span></span><br><span class="line"><span class="comment">// A simple service that calculates the factorial of a whole number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the code generator how to reference symbols defined in this namespace</span></span><br><span class="line">metadata package = [ &#123; namespace: <span class="string">"org.example.interfaces.factorial"</span>, <span class="keyword">crate</span>: <span class="string">"factorial_interface"</span> &#125; ]</span><br><span class="line"></span><br><span class="line">namespace org.example.interfaces.factorial</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> org.wasmcloud.model#wasmbus</span><br><span class="line"><span class="keyword">use</span> org.wasmcloud.model#U32</span><br><span class="line"><span class="keyword">use</span> org.wasmcloud.model#U64</span><br><span class="line"></span><br><span class="line"><span class="comment">/// The Factorial service has a single method, calculate, which</span></span><br><span class="line"><span class="comment">/// calculates the factorial of its whole number parameter.</span></span><br><span class="line">**@wasmbus(</span><br><span class="line">    contractId: <span class="string">"example:interfaces:factorial"</span>,</span><br><span class="line">    actorReceive: <span class="literal">true</span>,</span><br><span class="line">    providerReceive: <span class="literal">true</span> )**</span><br><span class="line">service Factorial &#123;</span><br><span class="line">  version: <span class="string">"0.1"</span>,</span><br><span class="line">  operations: [ Calculate ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Calculates the factorial (n!) of the input parameter</span></span><br><span class="line">operation Calculate &#123;</span><br><span class="line">  input: U32,</span><br><span class="line">  output: U64</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// converter.smithy</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the code generator how to reference symbols defined in this namespace</span></span><br><span class="line">metadata package = [ &#123; namespace: <span class="string">"org.example.interfaces.converter"</span>, <span class="keyword">crate</span>: <span class="string">"converter_interface"</span> &#125; ]</span><br><span class="line"></span><br><span class="line">namespace org.example.interfaces.converter</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> org.wasmcloud.model#wasmbus</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Description of Converter service</span></span><br><span class="line">@wasmbus( actorReceive: <span class="literal">true</span> )</span><br><span class="line">service Converter &#123;</span><br><span class="line">  version: <span class="string">"0.1"</span>,</span><br><span class="line">  operations: [ Convert ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Converts the input string to a result</span></span><br><span class="line">operation Convert &#123;</span><br><span class="line">  input: <span class="built_in">String</span>,</span><br><span class="line">  output: <span class="built_in">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h1><p>这里以 keyvalue interface 为例进行分析，具体的定义可参阅下面的链接：</p><p><a href="https://github.com/wasmCloud/interfaces/tree/main/keyvalue" target="_blank" rel="noopener">https://github.com/wasmCloud/interfaces/tree/main/keyvalue</a></p><p>我们在 smithy IDL 中主要定义了下面三块内容：</p><ol><li>metadata，包括：contractId, version 等</li><li>operations，主要是该契约允许操作的方法，比如：increment, contains, del, get, set 等</li><li>structure，主要是用于各个 operation 的传参和入参，除了标量类型外的符合类型，包括：GetReponse, GetRequest 等</li></ol><p>部分归纳如下</p><table><thead><tr><th>metadata</th><th>contractId, version, namespace</th></tr></thead><tbody><tr><td>operations</td><td>get, set, del, increment, contains</td></tr><tr><td>structure</td><td>GetResponse, GetRequest, SetResponse, SetRequest</td></tr></tbody></table><p>我们重点看生成的 rust 文件 <code>keyvalue/rust/src/keyvalue.rs</code></p><p><img src="pic1.png" width="600"></p><p>文件脉络如下：</p><ol><li><p><strong>根据 smithy 定义的结构体信息</strong>，使用 rust 语言语法格式，定义各种 struct。除此之外，为了能够在 wasmcloud 运行时中传递该结构，需要对结构进行必要的序列化和反序列化（CBOR）。我们以 GetReponse 结构体为例。</p><ul><li><p><code>GetResponse</code> Smithy IDL，契约定义</p>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Response to get request</span></span><br><span class="line">structure GetResponse &#123;</span><br><span class="line">    <span class="comment">/// the value, if it existed</span></span><br><span class="line">    @required</span><br><span class="line">    @n(<span class="number">0</span>)</span><br><span class="line">    value: <span class="built_in">String</span>,</span><br><span class="line">    <span class="comment">/// whether or not the value existed</span></span><br><span class="line">    @required</span><br><span class="line">    @n(<span class="number">1</span>)</span><br><span class="line">    exists: Boolean,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><pre><code>- `GetResponse` rust struct，rust语言的结构体定义    <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Response to get request</span></span><br><span class="line"><span class="meta">#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">GetResponse</span></span> &#123;</span><br><span class="line">    <span class="comment">/// the value, if it existed</span></span><br><span class="line">    <span class="meta">#[serde(default)]</span></span><br><span class="line">    <span class="keyword">pub</span> value: <span class="built_in">String</span>,</span><br><span class="line">    <span class="comment">/// whether or not the value existed</span></span><br><span class="line">    <span class="meta">#[serde(default)]</span></span><br><span class="line">    <span class="keyword">pub</span> exists: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>- `GetResponse` rust encode，结构体序列化    <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Encode GetResponse as CBOR and append to output stream</span></span><br><span class="line"><span class="meta">#[doc(hidden)]</span></span><br><span class="line"><span class="meta">#[allow(unused_mut)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">encode_get_response</span></span>&lt;W: wasmbus_rpc::cbor::Write&gt;(</span><br><span class="line">    <span class="keyword">mut</span> e: &amp;<span class="keyword">mut</span> wasmbus_rpc::cbor::Encoder&lt;W&gt;,</span><br><span class="line">    val: &amp;GetResponse,</span><br><span class="line">) -&gt; RpcResult&lt;()&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    &lt;W <span class="keyword">as</span> wasmbus_rpc::cbor::Write&gt;::Error: std::fmt::Display,</span><br><span class="line">&#123;</span><br><span class="line">    e.array(<span class="number">2</span>)?; <span class="comment">// 结构体成员数量 2</span></span><br><span class="line">    e.<span class="built_in">str</span>(&amp;val.value)?; <span class="comment">// 第一个成员的类型 string</span></span><br><span class="line">    e.<span class="built_in">bool</span>(val.exists)?; <span class="comment">// 第二个成员的类型 bool</span></span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>- `GetResponse` rust decode，结构体反序列化    <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Decode GetResponse from cbor input stream</span></span><br><span class="line"><span class="meta">#[doc(hidden)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">decode_get_response</span></span>(</span><br><span class="line">    d: &amp;<span class="keyword">mut</span> wasmbus_rpc::cbor::Decoder&lt;<span class="symbol">'_</span>&gt;,</span><br><span class="line">) -&gt; <span class="built_in">Result</span>&lt;GetResponse, RpcError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> __result = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> value: <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> exists: <span class="built_in">Option</span>&lt;<span class="built_in">bool</span>&gt; = <span class="literal">None</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> is_array = <span class="keyword">match</span> d.datatype()? &#123;</span><br><span class="line">            wasmbus_rpc::cbor::Type::Array =&gt; <span class="literal">true</span>,</span><br><span class="line">            wasmbus_rpc::cbor::Type::Map =&gt; <span class="literal">false</span>,</span><br><span class="line">            _ =&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">Err</span>(RpcError::Deser(</span><br><span class="line">                    <span class="string">"decoding struct GetResponse, expected array or map"</span>.to_string(),</span><br><span class="line">                ))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> is_array &#123;</span><br><span class="line">            <span class="keyword">let</span> len = d.fixed_array()?;</span><br><span class="line">            <span class="keyword">for</span> __i <span class="keyword">in</span> <span class="number">0</span>..(len <span class="keyword">as</span> <span class="built_in">usize</span>) &#123;</span><br><span class="line">                <span class="keyword">match</span> __i &#123;</span><br><span class="line">                    <span class="number">0</span> =&gt; value = <span class="literal">Some</span>(d.<span class="built_in">str</span>()?.to_string()),</span><br><span class="line">                    <span class="number">1</span> =&gt; exists = <span class="literal">Some</span>(d.<span class="built_in">bool</span>()?),</span><br><span class="line">                    _ =&gt; d.skip()?,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> len = d.fixed_map()?;</span><br><span class="line">            <span class="keyword">for</span> __i <span class="keyword">in</span> <span class="number">0</span>..(len <span class="keyword">as</span> <span class="built_in">usize</span>) &#123;</span><br><span class="line">                <span class="keyword">match</span> d.<span class="built_in">str</span>()? &#123;</span><br><span class="line">                    <span class="string">"value"</span> =&gt; value = <span class="literal">Some</span>(d.<span class="built_in">str</span>()?.to_string()),</span><br><span class="line">                    <span class="string">"exists"</span> =&gt; exists = <span class="literal">Some</span>(d.<span class="built_in">bool</span>()?),</span><br><span class="line">                    _ =&gt; d.skip()?,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        GetResponse &#123;</span><br><span class="line">            value: <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(__x) = value &#123;</span><br><span class="line">                __x</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">Err</span>(RpcError::Deser(</span><br><span class="line">                    <span class="string">"missing field GetResponse.value (#0)"</span>.to_string(),</span><br><span class="line">                ));</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">            exists: <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(__x) = exists &#123;</span><br><span class="line">                __x</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">Err</span>(RpcError::Deser(</span><br><span class="line">                    <span class="string">"missing field GetResponse.exists (#1)"</span>.to_string(),</span><br><span class="line">                ));</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="literal">Ok</span>(__result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ol start="2"><li><p><strong>contract traIt 定义</strong>。这个定义比较简单，就是把 smithy IDL 的 operations 用 rust 语言翻译一遍。</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// wasmbus.contractId: wasmcloud:keyvalue</span></span><br><span class="line"><span class="comment">/// wasmbus.providerReceive</span></span><br><span class="line"><span class="meta">#[async_trait]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">KeyValue</span></span> &#123;</span><br><span class="line">    <span class="comment">/// returns the capability contract id for this interface</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">contract_id</span></span>() -&gt; &amp;<span class="symbol">'static</span> <span class="built_in">str</span> &#123;</span><br><span class="line">        <span class="string">"wasmcloud:keyvalue"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Increments a numeric value, returning the new value</span></span><br><span class="line">    async <span class="function"><span class="keyword">fn</span> <span class="title">increment</span></span>(&amp;<span class="keyword">self</span>, ctx: &amp;Context, arg: &amp;IncrementRequest) -&gt; RpcResult&lt;<span class="built_in">i32</span>&gt;;</span><br><span class="line">    <span class="comment">/// returns whether the store contains the key</span></span><br><span class="line">    async <span class="function"><span class="keyword">fn</span> <span class="title">contains</span></span>&lt;TS: <span class="built_in">ToString</span> + ?<span class="built_in">Sized</span> + std::marker::<span class="built_in">Sync</span>&gt;(</span><br><span class="line">        &amp;<span class="keyword">self</span>,</span><br><span class="line">        ctx: &amp;Context,</span><br><span class="line">        arg: &amp;TS,</span><br><span class="line">    ) -&gt; RpcResult&lt;<span class="built_in">bool</span>&gt;;</span><br><span class="line">    <span class="comment">/// Deletes a key, returning true if the key was deleted</span></span><br><span class="line">    async <span class="function"><span class="keyword">fn</span> <span class="title">del</span></span>&lt;TS: <span class="built_in">ToString</span> + ?<span class="built_in">Sized</span> + std::marker::<span class="built_in">Sync</span>&gt;(</span><br><span class="line">        &amp;<span class="keyword">self</span>,</span><br><span class="line">        ctx: &amp;Context,</span><br><span class="line">        arg: &amp;TS,</span><br><span class="line">    ) -&gt; RpcResult&lt;<span class="built_in">bool</span>&gt;;</span><br><span class="line">    <span class="comment">/// Gets a value for a specified key. If the key exists,</span></span><br><span class="line">    <span class="comment">/// the return structure contains exists: true and the value,</span></span><br><span class="line">    <span class="comment">/// otherwise the return structure contains exists == false.</span></span><br><span class="line">    async <span class="function"><span class="keyword">fn</span> <span class="title">get</span></span>&lt;TS: <span class="built_in">ToString</span> + ?<span class="built_in">Sized</span> + std::marker::<span class="built_in">Sync</span>&gt;(</span><br><span class="line">        &amp;<span class="keyword">self</span>,</span><br><span class="line">        ctx: &amp;Context,</span><br><span class="line">        arg: &amp;TS,</span><br><span class="line">    ) -&gt; RpcResult&lt;GetResponse&gt;;</span><br><span class="line">    <span class="comment">/// Append a value onto the end of a list. Returns the new list size</span></span><br><span class="line">    async <span class="function"><span class="keyword">fn</span> <span class="title">list_add</span></span>(&amp;<span class="keyword">self</span>, ctx: &amp;Context, arg: &amp;ListAddRequest) -&gt; RpcResult&lt;<span class="built_in">u32</span>&gt;;</span><br><span class="line">    <span class="comment">/// Deletes a list and its contents</span></span><br><span class="line">    <span class="comment">/// input: list name</span></span><br><span class="line">    <span class="comment">/// output: true if the list existed and was deleted</span></span><br><span class="line">    async <span class="function"><span class="keyword">fn</span> <span class="title">list_clear</span></span>&lt;TS: <span class="built_in">ToString</span> + ?<span class="built_in">Sized</span> + std::marker::<span class="built_in">Sync</span>&gt;(</span><br><span class="line">        &amp;<span class="keyword">self</span>,</span><br><span class="line">        ctx: &amp;Context,</span><br><span class="line">        arg: &amp;TS,</span><br><span class="line">    ) -&gt; RpcResult&lt;<span class="built_in">bool</span>&gt;;</span><br><span class="line">    <span class="comment">/// Deletes a value from a list. Returns true if the item was removed.</span></span><br><span class="line">    async <span class="function"><span class="keyword">fn</span> <span class="title">list_del</span></span>(&amp;<span class="keyword">self</span>, ctx: &amp;Context, arg: &amp;ListDelRequest) -&gt; RpcResult&lt;<span class="built_in">bool</span>&gt;;</span><br><span class="line">    <span class="comment">/// Retrieves a range of values from a list using 0-based indices.</span></span><br><span class="line">    <span class="comment">/// Start and end values are inclusive, for example, (0,10) returns</span></span><br><span class="line">    <span class="comment">/// 11 items if the list contains at least 11 items. If the stop value</span></span><br><span class="line">    <span class="comment">/// is beyond the end of the list, it is treated as the end of the list.</span></span><br><span class="line">    async <span class="function"><span class="keyword">fn</span> <span class="title">list_range</span></span>(&amp;<span class="keyword">self</span>, ctx: &amp;Context, arg: &amp;ListRangeRequest) -&gt; RpcResult&lt;StringList&gt;;</span><br><span class="line">    <span class="comment">/// Sets the value of a key.</span></span><br><span class="line">    <span class="comment">/// expires is an optional number of seconds before the value should be automatically deleted,</span></span><br><span class="line">    <span class="comment">/// or 0 for no expiration.</span></span><br><span class="line">    async <span class="function"><span class="keyword">fn</span> <span class="title">set</span></span>(&amp;<span class="keyword">self</span>, ctx: &amp;Context, arg: &amp;SetRequest) -&gt; RpcResult&lt;()&gt;;</span><br><span class="line">    <span class="comment">/// Add an item into a set. Returns number of items added (1 or 0)</span></span><br><span class="line">    async <span class="function"><span class="keyword">fn</span> <span class="title">set_add</span></span>(&amp;<span class="keyword">self</span>, ctx: &amp;Context, arg: &amp;SetAddRequest) -&gt; RpcResult&lt;<span class="built_in">u32</span>&gt;;</span><br><span class="line">    <span class="comment">/// Deletes an item from the set. Returns number of items removed from the set (1 or 0)</span></span><br><span class="line">    async <span class="function"><span class="keyword">fn</span> <span class="title">set_del</span></span>(&amp;<span class="keyword">self</span>, ctx: &amp;Context, arg: &amp;SetDelRequest) -&gt; RpcResult&lt;<span class="built_in">u32</span>&gt;;</span><br><span class="line">    <span class="comment">/// perform intersection of sets and returns values from the intersection.</span></span><br><span class="line">    <span class="comment">/// input: list of sets for performing intersection (at least two)</span></span><br><span class="line">    <span class="comment">/// output: values</span></span><br><span class="line">    async <span class="function"><span class="keyword">fn</span> <span class="title">set_intersection</span></span>(&amp;<span class="keyword">self</span>, ctx: &amp;Context, arg: &amp;StringList) -&gt; RpcResult&lt;StringList&gt;;</span><br><span class="line">    <span class="comment">/// Retrieves all items from a set</span></span><br><span class="line">    <span class="comment">/// input: String</span></span><br><span class="line">    <span class="comment">/// output: set members</span></span><br><span class="line">    async <span class="function"><span class="keyword">fn</span> <span class="title">set_query</span></span>&lt;TS: <span class="built_in">ToString</span> + ?<span class="built_in">Sized</span> + std::marker::<span class="built_in">Sync</span>&gt;(</span><br><span class="line">        &amp;<span class="keyword">self</span>,</span><br><span class="line">        ctx: &amp;Context,</span><br><span class="line">        arg: &amp;TS,</span><br><span class="line">    ) -&gt; RpcResult&lt;StringList&gt;;</span><br><span class="line">    <span class="comment">/// perform union of sets and returns values from the union</span></span><br><span class="line">    <span class="comment">/// input: list of sets for performing union (at least two)</span></span><br><span class="line">    <span class="comment">/// output: union of values</span></span><br><span class="line">    async <span class="function"><span class="keyword">fn</span> <span class="title">set_union</span></span>(&amp;<span class="keyword">self</span>, ctx: &amp;Context, arg: &amp;StringList) -&gt; RpcResult&lt;StringList&gt;;</span><br><span class="line">    <span class="comment">/// clears all values from the set and removes it</span></span><br><span class="line">    <span class="comment">/// input: set name</span></span><br><span class="line">    <span class="comment">/// output: true if the set existed and was deleted</span></span><br><span class="line">    async <span class="function"><span class="keyword">fn</span> <span class="title">set_clear</span></span>&lt;TS: <span class="built_in">ToString</span> + ?<span class="built_in">Sized</span> + std::marker::<span class="built_in">Sync</span>&gt;(</span><br><span class="line">        &amp;<span class="keyword">self</span>,</span><br><span class="line">        ctx: &amp;Context,</span><br><span class="line">        arg: &amp;TS,</span><br><span class="line">    ) -&gt; RpcResult&lt;<span class="built_in">bool</span>&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p><strong>Receiver trait 定义。</strong>receiver 的 trait 定义如下，默认实现了 dispatch 方法，根据 message.method 来进行不同的数据转换。Message 的结构体定义如下：</p><p> <code>wasmbus-rpc/src/common.rs</code>, 用于封装 wasmcloud message,主要是 trait 的 method 和 parameters</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A wasmcloud message</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Message</span></span>&lt;<span class="symbol">'m</span>&gt; &#123;</span><br><span class="line">    <span class="comment">/// Message name, usually in the form 'Trait.method'</span></span><br><span class="line">    <span class="keyword">pub</span> method: &amp;<span class="symbol">'m</span> <span class="built_in">str</span>,</span><br><span class="line">    <span class="comment">/// parameter serialized as a byte array. If the method takes no args, the array will be</span></span><br><span class="line">    <span class="comment">/// zero length.</span></span><br><span class="line">    <span class="keyword">pub</span> arg: Cow&lt;<span class="symbol">'m</span>, [<span class="built_in">u8</span>]&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><pre><code>`keyvalue/rust/src/keyvalue.rs`<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// KeyValueReceiver receives messages defined in the KeyValue service trait</span></span><br><span class="line"><span class="meta">#[doc(hidden)]</span></span><br><span class="line"><span class="meta">#[async_trait]</span></span><br><span class="line">**<span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">KeyValueReceiver</span></span>: MessageDispatch + KeyValue &#123;**</span><br><span class="line">    async <span class="function"><span class="keyword">fn</span> <span class="title">dispatch</span></span>(&amp;<span class="keyword">self</span>, ctx: &amp;Context, message: Message&lt;<span class="symbol">'_</span>&gt;) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt;, RpcError&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> message.method &#123; <span class="comment">// method 主要由 method 和 args 组成，用于传递消息</span></span><br><span class="line">            <span class="string">"**Increment**"</span> =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> value: IncrementRequest = wasmbus_rpc::common::deserialize(&amp;message.arg)</span><br><span class="line">                    .map_err(|e| RpcError::Deser(<span class="built_in">format!</span>(<span class="string">"'IncrementRequest': &#123;&#125;"</span>, e)))?;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> resp = **KeyValue::increment**(<span class="keyword">self</span>, ctx, &amp;value).await?; <span class="comment">// 根据不同的  method 调用 trait 的不同方法</span></span><br><span class="line">                <span class="keyword">let</span> buf = wasmbus_rpc::common::serialize(&amp;resp)?;  <span class="comment">// 根据该方法的返回值，进行不同的反序列化</span></span><br><span class="line"></span><br><span class="line">                <span class="literal">Ok</span>(buf)</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// ================= 其他更多 方法 ========== //</span></span><br><span class="line">            <span class="string">"Contains"</span> =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> value: <span class="built_in">String</span> = wasmbus_rpc::common::deserialize(&amp;message.arg)</span><br><span class="line">                    .map_err(|e| RpcError::Deser(<span class="built_in">format!</span>(<span class="string">"'String': &#123;&#125;"</span>, e)))?;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> resp = KeyValue::contains(<span class="keyword">self</span>, ctx, &amp;value).await?;</span><br><span class="line">                <span class="keyword">let</span> buf = wasmbus_rpc::common::serialize(&amp;resp)?;</span><br><span class="line"></span><br><span class="line">                <span class="literal">Ok</span>(buf)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="string">"Del"</span> =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> value: <span class="built_in">String</span> = wasmbus_rpc::common::deserialize(&amp;message.arg)</span><br><span class="line">                    .map_err(|e| RpcError::Deser(<span class="built_in">format!</span>(<span class="string">"'String': &#123;&#125;"</span>, e)))?;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> resp = KeyValue::del(<span class="keyword">self</span>, ctx, &amp;value).await?;</span><br><span class="line">                <span class="keyword">let</span> buf = wasmbus_rpc::common::serialize(&amp;resp)?;</span><br><span class="line"></span><br><span class="line">                <span class="literal">Ok</span>(buf)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="string">"Get"</span> =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> value: <span class="built_in">String</span> = wasmbus_rpc::common::deserialize(&amp;message.arg)</span><br><span class="line">                    .map_err(|e| RpcError::Deser(<span class="built_in">format!</span>(<span class="string">"'String': &#123;&#125;"</span>, e)))?;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> resp = KeyValue::get(<span class="keyword">self</span>, ctx, &amp;value).await?;</span><br><span class="line">                <span class="keyword">let</span> buf = wasmbus_rpc::common::serialize(&amp;resp)?;</span><br><span class="line"></span><br><span class="line">                <span class="literal">Ok</span>(buf)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="string">"Set"</span> =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> value: SetRequest = wasmbus_rpc::common::deserialize(&amp;message.arg)</span><br><span class="line">                    .map_err(|e| RpcError::Deser(<span class="built_in">format!</span>(<span class="string">"'SetRequest': &#123;&#125;"</span>, e)))?;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> _resp = KeyValue::set(<span class="keyword">self</span>, ctx, &amp;value).await?;</span><br><span class="line">                <span class="keyword">let</span> buf = <span class="built_in">Vec</span>::new();</span><br><span class="line">                <span class="literal">Ok</span>(buf)</span><br><span class="line">            &#125;</span><br><span class="line">            _ =&gt; <span class="literal">Err</span>(RpcError::MethodNotHandled(<span class="built_in">format!</span>(</span><br><span class="line">                <span class="string">"KeyValue::&#123;&#125;"</span>,</span><br><span class="line">                message.method</span><br><span class="line">            ))),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ol start="4"><li><p><strong>Sender trait 定义。</strong>Sender 用来传输调用的 method 和 args。</p><p> <img src="pic2.png" width="300"></p><p> <code>keyvalue/rust/src/keyvalue.rs</code>，根据调用的 operation 不同，组装不同的请求参数，进行不同的数据序列化</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> KeyValueSender&lt;wasmbus_rpc::actor::prelude::WasmHost&gt; &#123;</span><br><span class="line">    **<span class="comment">/// Constructs a client for sending to a KeyValue provider</span></span><br><span class="line">    <span class="comment">/// implementing the 'wasmcloud:keyvalue' capability contract, with the "default" link**</span></span><br><span class="line">    **<span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span>** &#123;</span><br><span class="line">        <span class="keyword">let</span> transport =</span><br><span class="line">            **wasmbus_rpc::actor::prelude::WasmHost::to_provider(<span class="string">"wasmcloud:keyvalue"</span>, <span class="string">"default"</span>)**</span><br><span class="line">                .unwrap();</span><br><span class="line">        <span class="keyword">Self</span> &#123; transport &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Constructs a client for sending to a KeyValue provider</span></span><br><span class="line">    <span class="comment">/// implementing the 'wasmcloud:keyvalue' capability contract, with the specified link name</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new_with_link</span></span>(link_name: &amp;<span class="built_in">str</span>) -&gt; wasmbus_rpc::error::RpcResult&lt;<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> transport =</span><br><span class="line">            wasmbus_rpc::actor::prelude::WasmHost::to_provider(<span class="string">"wasmcloud:keyvalue"</span>, link_name)?;</span><br><span class="line">        <span class="literal">Ok</span>(<span class="keyword">Self</span> &#123; transport &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[async_trait]</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Transport + std::marker::<span class="built_in">Sync</span> + std::marker::<span class="built_in">Send</span>&gt; KeyValue <span class="keyword">for</span> KeyValueSender&lt;T&gt; &#123;</span><br><span class="line">    <span class="meta">#[allow(unused)]</span></span><br><span class="line">    <span class="comment">/// Increments a numeric value, returning the new value</span></span><br><span class="line">    async <span class="function"><span class="keyword">fn</span> **<span class="title">increment</span>**</span>(&amp;<span class="keyword">self</span>, ctx: &amp;Context, arg: &amp;**IncrementRequest**) -&gt; RpcResult&lt;<span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> buf = wasmbus_rpc::common::serialize(arg)?;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> resp = <span class="keyword">self</span></span><br><span class="line">            .transport</span><br><span class="line">            .send(</span><br><span class="line">                ctx,</span><br><span class="line">                Message &#123;</span><br><span class="line">                    **method: <span class="string">"KeyValue.Increment"</span>,**</span><br><span class="line">                    arg: Cow::Borrowed(&amp;buf),</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="literal">None</span>,</span><br><span class="line">            )</span><br><span class="line">            .await?;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> value: <span class="built_in">i32</span> = wasmbus_rpc::common::deserialize(&amp;resp)</span><br><span class="line">            .map_err(|e| RpcError::Deser(<span class="built_in">format!</span>(<span class="string">"'&#123;&#125;': I32"</span>, e)))?;</span><br><span class="line">        <span class="literal">Ok</span>(value)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="actor-调用-interface"><a href="#actor-调用-interface" class="headerlink" title="actor 调用 interface"></a>actor 调用 interface</h1><p>我们以 kvcounter 为例，首先需要在 makefile 中声明（claims）自己需要使用的契约。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># examples/actor/kvcounter</span></span><br><span class="line"></span><br><span class="line">PROJECT  = kvcounter</span><br><span class="line">VERSION  = <span class="variable">$(<span class="built_in">shell</span> cargo metadata --no-deps --format-version 1 | jq -r '.packages[] .version' | head -1)</span></span><br><span class="line">REVISION = 0</span><br><span class="line"><span class="comment"># list of all contract claims for actor signing (space-separated)</span></span><br><span class="line">**CLAIMS   = wasmcloud:httpserver wasmcloud:keyvalue**</span><br><span class="line"><span class="comment"># registry url for our actor</span></span><br><span class="line">REG_URL  = localhost:5000/v2/<span class="variable">$(PROJECT)</span>:<span class="variable">$(VERSION)</span></span><br><span class="line"><span class="comment"># command to upload to registry (without last wasm parameter)</span></span><br><span class="line">PUSH_REG_CMD = wash reg push --insecure <span class="variable">$(REG_URL)</span></span><br><span class="line">ACTOR_NAME = <span class="string">"KVCounter"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> ../../build/makefiles/actor.mk</span><br></pre></td></tr></table></figure><p>其次在 cargo.toml 中引入需要的 interface。</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"kvcounter"</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">"0.3.4"</span></span><br><span class="line"><span class="attr">authors</span> = [ <span class="string">"wasmcloud Team"</span> ]</span><br><span class="line"><span class="attr">edition</span> = <span class="string">"2021"</span></span><br><span class="line"></span><br><span class="line"><span class="section">[lib]</span></span><br><span class="line"><span class="attr">crate-type</span> = [<span class="string">"cdylib"</span>, <span class="string">"rlib"</span>]</span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">async-trait</span> = <span class="string">"0.1"</span></span><br><span class="line"><span class="attr">form_urlencoded</span> = <span class="string">"1.0"</span></span><br><span class="line"><span class="attr">futures</span> = <span class="string">"0.3"</span></span><br><span class="line"><span class="attr">serde_bytes</span> = <span class="string">"0.11"</span></span><br><span class="line"><span class="attr">serde_json</span> =<span class="string">"1.0"</span></span><br><span class="line"><span class="attr">serde</span> = &#123;version = <span class="string">"1.0"</span>, features = [<span class="string">"derive"</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">wasmbus-rpc</span> = <span class="string">"0.9"</span></span><br><span class="line">**wasmcloud-interface-keyvalue = "0.7.0"</span><br><span class="line"><span class="attr">wasmcloud-interface-httpserver</span> = <span class="string">"0.6.0"</span>**</span><br><span class="line"></span><br><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="comment"># Optimize for small code size</span></span><br><span class="line"><span class="attr">lto</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="string">"s"</span></span><br></pre></td></tr></table></figure><p>最后在 actor 中使用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">increment_counter</span></span>(ctx: &amp;Context, key: <span class="built_in">String</span>, value: <span class="built_in">i32</span>) -&gt; RpcResult&lt;<span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> new_val = **KeyValueSender::new()**</span><br><span class="line">        **.increment(ctx, &amp;IncrementRequest &#123; key, value &#125;)**</span><br><span class="line">        .await?;</span><br><span class="line">    <span class="literal">Ok</span>(new_val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <strong>Sender::new().increment</strong> 就是我们之前在 Interface sender 中默认生成的方法，其核心就是把 actor 的调用包装成消息体发送出去：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">increment</span></span>(&amp;<span class="keyword">self</span>, ctx: &amp;Context, arg: &amp;IncrementRequest) -&gt; RpcResult&lt;<span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> buf = wasmbus_rpc::common::serialize(arg)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> resp = <span class="keyword">self</span></span><br><span class="line">        .transport</span><br><span class="line">        **.send(   <span class="comment">// wasmbus-rpc</span></span><br><span class="line">            ctx,</span><br><span class="line">            Message &#123;</span><br><span class="line">                method: <span class="string">"KeyValue.Increment"</span>,</span><br><span class="line">                arg: Cow::Borrowed(&amp;buf),</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="literal">None</span>,</span><br><span class="line">        )**</span><br><span class="line">        .await?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> value: <span class="built_in">i32</span> = wasmbus_rpc::common::deserialize(&amp;resp)</span><br><span class="line">        .map_err(|e| RpcError::Deser(<span class="built_in">format!</span>(<span class="string">"'&#123;&#125;': I32"</span>, e)))?;</span><br><span class="line">    <span class="literal">Ok</span>(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>根据上面的分析，我们初探了 interface 的具体代码生成规则：</p><ul><li>根据契约定义的不同，生成对应的结构体。包括序列化和反序列化</li><li>包装调用方法，抽象出 Sender 和 Receiver 两个 trait<ul><li>receiver 默认实现了 dispatch。里面根据具体调用的 method 进行数据的序列化和反序列化</li><li>sender 则根据不同的方法，生成了不同的 sender method，这样调用 Sender 的 method 时，就能直接发送对应的请求，请求体包含了 method 和 params</li></ul></li><li>actor 实际调用 interface 时，就是向 runtime 发送了具体的 rpc 请求。再由  runtime 去调度对应的 provider 实现，进而返回。</li></ul><p><img src="pic2.png" width="300"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;新建-interface&quot;&gt;&lt;a href=&quot;#新建-interface&quot; class=&quot;headerlink&quot; title=&quot;新建 interface&quot;&gt;&lt;/a&gt;新建 interface&lt;/h1&gt;&lt;p&gt;wasmcloud app 开发使用的是 CDD 模式，也就
      
    
    </summary>
    
      <category term="WASM" scheme="https://rovast.github.io/categories/WASM/"/>
    
    
  </entry>
  
  <entry>
    <title>wasmcloud app provider 源码阅读</title>
    <link href="https://rovast.github.io/2022/09/28/wasmcloud-app-provider-read/"/>
    <id>https://rovast.github.io/2022/09/28/wasmcloud-app-provider-read/</id>
    <published>2022-09-28T02:33:49.000Z</published>
    <updated>2022-09-28T06:14:26.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>provider 在 wasmcloud 体系中扮演者重要的作用。它负责实现 Interface，在 actor 和 provider 建立链接关系后，可为 actor 提供具体的能力。对于同一个 Interface，可以有不同的 Provider 实现，在 link def 阶段，再去指定具体由哪个 Provider 给 actor 提供能力。</p><p>而 actor 调用具体的 Interface 方法时，则由 wasmcloud host runtime 作为协调者，接收到 actor 调用的方法信息（包括函数名称，参数），进而寻找对应的 provider 进行执行，并将调用结果返回。</p><p><img src="pic.png" width="400"></p><h1 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h1><p>Provider 的运行机理主要分三块：</p><ol><li>启动 provider，建立和 wasmcloud runtime 的通信链接。这部分在我们 start provider 的时候就会执行。</li><li>实现 interface 中定义的 operations</li><li>处理控制 provider 的部分事件（可选）</li></ol><h2 id="启动-provider"><a href="#启动-provider" class="headerlink" title="启动 provider"></a>启动 provider</h2><p>我们可以在平台（或使用 wasmcloud shell）来启动 provider。启动后，会进行一系列的初始化，并向 wasmcloud runtime 中注册该 provider。</p><p><img src="pic1.png" width="500"></p><p>kvredis 和 http-server-rs 两个  provider 的 main 函数入口如下：</p><p><code>kvredis/src/main.rs</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; <span class="built_in">Result</span>&lt;(), <span class="built_in">Box</span>&lt;dyn std::error::Error&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// handle lattice control messages and forward rpc to the provider dispatch</span></span><br><span class="line">    <span class="comment">// returns when provider receives a shutdown control message</span></span><br><span class="line"><span class="comment">// 执行后，常驻 runtime，和 rpc 消息进行交互，直到接收到关闭指令后，才会退出。</span></span><br><span class="line">    provider_main(</span><br><span class="line">        KvRedisProvider::<span class="keyword">default</span>(),</span><br><span class="line">        <span class="literal">Some</span>(<span class="string">"KeyValue Redis Provider"</span>.to_string()),</span><br><span class="line">    )?;</span><br><span class="line"></span><br><span class="line">    eprintln!(<span class="string">"KVRedis provider exiting"</span>);</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>httpserver-rs/bin/main.rs</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; <span class="built_in">Result</span>&lt;(), <span class="built_in">Box</span>&lt;dyn std::error::Error&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// handle lattice control messages and forward rpc to the provider dispatch</span></span><br><span class="line">    <span class="comment">// returns when provider receives a shutdown control message</span></span><br><span class="line">    provider_main(</span><br><span class="line">        HttpServerProvider::<span class="keyword">default</span>(),</span><br><span class="line">        <span class="literal">Some</span>(<span class="string">"HttpServer Provider"</span>.to_string()),</span><br><span class="line">    )?;</span><br><span class="line"></span><br><span class="line">    eprintln!(<span class="string">"HttpServer provider exiting"</span>);</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到 provider 的 main 干的事情是一致的，即调用 provider_main 来启动 provider server。其中 provider_main 是由 wasmbus-rpc 库来提供，作为 provider 的开发者，直接调用即可。我们简单分析下 wasmbus-rpc 的 相关实现。</p><p><code>wasmbus-rpc-src/provider_main.rs</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Start provider services: tokio runtime, logger, nats, and rpc subscriptions</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> **<span class="title">provider_main</span>**</span>&lt;P&gt;(</span><br><span class="line">    provider_dispatch: P,</span><br><span class="line">    friendly_name: <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">) -&gt; <span class="built_in">Result</span>&lt;(), <span class="built_in">Box</span>&lt;dyn std::error::Error&gt;&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    P: ProviderDispatch + <span class="built_in">Send</span> + <span class="built_in">Sync</span> + <span class="built_in">Clone</span> + <span class="symbol">'static</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// get lattice configuration from host</span></span><br><span class="line"><span class="comment">// 通过 stdin 获取 host 配置信息</span></span><br><span class="line">    <span class="keyword">let</span> host_data = load_host_data().map_err(|e| &#123;</span><br><span class="line">        eprintln!(<span class="string">"error loading host data: &#123;&#125;"</span>, &amp;e.to_string());</span><br><span class="line">        <span class="built_in">Box</span>::new(e)</span><br><span class="line">    &#125;)?;</span><br><span class="line">    **provider_start**(provider_dispatch, host_data, friendly_name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Start provider services: tokio runtime, logger, nats, and rpc subscriptions,</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> **<span class="title">provider_start</span>**</span>&lt;P&gt;(</span><br><span class="line">    provider_dispatch: P,</span><br><span class="line">    host_data: HostData,</span><br><span class="line">    friendly_name: <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">) -&gt; <span class="built_in">Result</span>&lt;(), <span class="built_in">Box</span>&lt;dyn std::error::Error&gt;&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    P: ProviderDispatch + <span class="built_in">Send</span> + <span class="built_in">Sync</span> + <span class="built_in">Clone</span> + <span class="symbol">'static</span>,</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 这里的 runtime 是一个 tokio runtime 的库。</span></span><br><span class="line">    <span class="comment">// 简单来说，就是提供了诸如：并发、异步等编程所用的运行时，用用户态的调度方式来管理并发编程，类似 Go 的协程管理，Erlang 的进程管理等</span></span><br><span class="line">    <span class="keyword">let</span> runtime = tokio::runtime::Builder::new_multi_thread()</span><br><span class="line">        .enable_all()</span><br><span class="line">        <span class="comment">//.enable_io()</span></span><br><span class="line">        .build()?;</span><br><span class="line"></span><br><span class="line"><span class="comment">// block_on 就是执行一个异步操作，等待其结果</span></span><br><span class="line">    **runtime.block_on(async &#123; provider_run(provider_dispatch, host_data, friendly_name).await &#125;)?;**</span><br><span class="line">    <span class="comment">// in the unlikely case there are any stuck threads,</span></span><br><span class="line">    <span class="comment">// close them so the process has a clean exit</span></span><br><span class="line">    runtime.shutdown_timeout(core::time::Duration::from_secs(<span class="number">10</span>));</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/// Async provider initialization</span></span><br><span class="line"><span class="comment">// provider 初始化</span></span><br><span class="line"><span class="keyword">pub</span> async <span class="function"><span class="keyword">fn</span> **<span class="title">provider_run</span>**</span>&lt;P&gt;(</span><br><span class="line">    provider_dispatch: P,</span><br><span class="line">    host_data: HostData,</span><br><span class="line">    friendly_name: <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">) -&gt; <span class="built_in">Result</span>&lt;(), <span class="built_in">Box</span>&lt;dyn std::error::Error&gt;&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    P: ProviderDispatch + <span class="built_in">Send</span> + <span class="built_in">Sync</span> + <span class="built_in">Clone</span> + <span class="symbol">'static</span>,</span><br><span class="line">&#123;</span><br><span class="line">    configure_tracing(</span><br><span class="line">        friendly_name.unwrap_or_else(|| host_data.provider_key.clone()),</span><br><span class="line">        host_data.structured_logging,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (shutdown_tx, <span class="keyword">mut</span> shutdown_rx) = tokio::sync::broadcast::channel::&lt;<span class="built_in">bool</span>&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里输出了一条日志信息，在我们启动 provider 时候可以看到该日志</span></span><br><span class="line">    **eprintln!(</span><br><span class="line">        <span class="string">"Starting capability provider &#123;&#125; instance &#123;&#125; with nats url &#123;&#125;"</span>,</span><br><span class="line">        &amp;host_data.provider_key, &amp;host_data.instance_id, &amp;host_data.lattice_rpc_url,</span><br><span class="line">    );**</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 nats-server，建立链接</span></span><br><span class="line">    <span class="keyword">let</span> nats_addr = <span class="keyword">if</span> !host_data.lattice_rpc_url.is_empty() &#123;</span><br><span class="line">        host_data.lattice_rpc_url.as_str()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        crate::provider::DEFAULT_NATS_ADDR</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> nats_server = async_nats::ServerAddr::from_str(nats_addr).map_err(|e| &#123;</span><br><span class="line">        RpcError::InvalidParameter(<span class="built_in">format!</span>(<span class="string">"Invalid nats server url '&#123;&#125;': &#123;&#125;"</span>, nats_addr, e))</span><br><span class="line">    &#125;)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> nc = crate::rpc_client::with_connection_event_logging(</span><br><span class="line">        <span class="keyword">match</span> (</span><br><span class="line">            host_data.lattice_rpc_user_jwt.trim(),</span><br><span class="line">            host_data.lattice_rpc_user_seed.trim(),</span><br><span class="line">        ) &#123;</span><br><span class="line">            (<span class="string">""</span>, <span class="string">""</span>) =&gt; async_nats::ConnectOptions::<span class="keyword">default</span>(),</span><br><span class="line">            (rpc_jwt, rpc_seed) =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> key_pair = std::sync::Arc::new(nkeys::KeyPair::from_seed(rpc_seed).unwrap());</span><br><span class="line">                <span class="keyword">let</span> jwt = rpc_jwt.to_owned();</span><br><span class="line">                async_nats::ConnectOptions::with_jwt(jwt, <span class="keyword">move</span> |nonce| &#123;</span><br><span class="line">                    <span class="keyword">let</span> key_pair = key_pair.clone();</span><br><span class="line">                    async <span class="keyword">move</span> &#123; key_pair.sign(&amp;nonce).map_err(async_nats::AuthError::new) &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    )</span><br><span class="line">    .connect(nats_server)</span><br><span class="line">    .await?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize HostBridge</span></span><br><span class="line"><span class="comment">// HostBriage 管理 nats 和 host 之间的通信</span></span><br><span class="line">    <span class="keyword">let</span> bridge = HostBridge::new_client(nc, &amp;host_data)?;</span><br><span class="line">    set_host_bridge(bridge).ok();</span><br><span class="line">    <span class="keyword">let</span> bridge = get_host_bridge();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pre-populate provider and bridge with initial set of link definitions</span></span><br><span class="line">    <span class="comment">// initialization of any link is fatal for provider startup</span></span><br><span class="line"><span class="comment">// 如果已经有相关的 link 定义，那么在启动 provider 时候，需要恢复这些 link 信息</span></span><br><span class="line">    <span class="keyword">let</span> initial_links = host_data.link_definitions.clone();</span><br><span class="line">    <span class="keyword">for</span> ld <span class="keyword">in</span> initial_links.into_iter() &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Err</span>(e) = provider_dispatch.put_link(&amp;ld).await &#123;</span><br><span class="line">            eprintln!(</span><br><span class="line">                <span class="string">"Failed to initialize link during provider startup - (&#123;:?&#125;): &#123;:?&#125;"</span>,</span><br><span class="line">                &amp;ld, e</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            bridge.put_link(ld).await;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// subscribe to nats topics</span></span><br><span class="line"><span class="comment">// 订阅主题，用来和 wasmcloud host runtime 交互更自己相关的消息</span></span><br><span class="line">    <span class="keyword">let</span> _join = bridge</span><br><span class="line">        .connect(</span><br><span class="line">            provider_dispatch,</span><br><span class="line">            &amp;shutdown_tx,</span><br><span class="line">            &amp;host_data.lattice_rpc_prefix,</span><br><span class="line">        )</span><br><span class="line">        .await;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run until we receive a shutdown request from host</span></span><br><span class="line"><span class="comment">// 直到接收到 shutdown 请求，不然一直在这里监听</span></span><br><span class="line">    **<span class="keyword">let</span> _ = shutdown_rx.recv().await;**</span><br><span class="line"></span><br><span class="line">    <span class="comment">// close chunkifiers</span></span><br><span class="line">    <span class="keyword">let</span> _ = tokio::task::spawn_blocking(crate::chunkify::shutdown).await;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// flush async_nats client</span></span><br><span class="line">    bridge.flush().await;</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们添加完 provider 后，wasmcloud host 输出的日志如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[debug] StateMonitor handle info wasmbus.evt.<span class="keyword">default</span></span><br><span class="line">[debug] Handling host heartbeat</span><br><span class="line">**[debug] Received control interface request on wasmbus.ctl.<span class="keyword">default</span>.cmd.NBTXBYKGMTTLY6ZJHUMW4MBO2R6CJBPE5VC3VQ6XON3TMO4DASQ4AG2H.lp**</span><br><span class="line">[debug] StateMonitor handle info wasmbus.evt.<span class="keyword">default</span></span><br><span class="line">[debug] Handling host heartbeat</span><br><span class="line">[info] Starting executable capability provider from '/var/folders/wj/<span class="number">68</span>rwh9s94w17h9z0frb4h6w00000gn/T/wasmcloudcache/VAZVC4RX54J2NVCMCW7BPCAHGGG5XZXDBXFUMDUXGESTMQEJLC3YVZWB/<span class="number">1660779368</span>/wasmcloud_keyvalue_default'</span><br><span class="line">**[debug] Publishing OCI <span class="keyword">ref</span> map <span class="keyword">for</span> <span class="string">"wasmcloud.azurecr.io/kvredis:0.16.3"</span>**</span><br><span class="line">[debug] StateMonitor handle info wasmbus.evt.<span class="keyword">default</span></span><br><span class="line">span_id=e2b0fb00ba96b407 trace_id=<span class="number">8</span>bdcf587b24a5221c1ea0a9bf721d630 [**debug] Successfully started provider wasmcloud.azurecr.io/kvredis:<span class="number">0.16</span>.<span class="number">3</span> (<span class="keyword">default</span>)**</span><br><span class="line">[debug] StateMonitor handle info wasmbus.evt.<span class="keyword">default</span></span><br><span class="line">[debug] Cached claims <span class="keyword">for</span> VAZVC4RX54J2NVCMCW7BPCAHGGG5XZXDBXFUMDUXGESTMQEJLC3YVZWB</span><br><span class="line">[debug] Cached OCI map reference from wasmcloud.azurecr.io/kvredis:<span class="number">0.16</span>.<span class="number">3</span> to VAZVC4RX54J2NVCMCW7BPCAHGGG5XZXDBXFUMDUXGESTMQEJLC3YVZWB</span><br><span class="line">RUST_LOG was not set or the given directive was invalid: FromEnvError &#123; kind: Env(NotPresent) &#125;</span><br><span class="line">Defaulting logger to `info` level</span><br><span class="line">**Starting capability provider VAZVC4RX54J2NVCMCW7BPCAHGGG5XZXDBXFUMDUXGESTMQEJLC3YVZWB instance <span class="number">8</span>efc5842-<span class="number">5</span>b6e-<span class="number">4400</span>-afeb-<span class="number">95</span>c6207deb29 with nats url <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">4222</span>**</span><br><span class="line">[debug] StateMonitor handle info wasmbus.evt.<span class="keyword">default</span></span><br><span class="line">[debug] Handling successful health check <span class="keyword">for</span> VAZVC4RX54J2NVCMCW7BPCAHGGG5XZXDBXFUMDUXGESTMQEJLC3YVZWB</span><br></pre></td></tr></table></figure><p>其中倒数第三行加粗的部分，就是在 <strong><code>provider_run</code></strong> 函数中输出的日志。</p><h2 id="实现-interface"><a href="#实现-interface" class="headerlink" title="实现 interface"></a>实现 interface</h2><p>对于 keyvalue 这个 interface 而言，我们可以用 redis 来实现 kv 功能，也可以使用 vault。甚至可以使用其他你认为任意其他合适的存储驱动。实现完成后，actor 可根据自己的实际需求，来 link 对应的 provider 满足自己的需求。</p><p>那对于 provider 而言，就需要实现 interface trait 中定义的所有方法。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> wasmcloud_interface_keyvalue::&#123;</span><br><span class="line">    GetResponse, IncrementRequest, **KeyValue**, KeyValueReceiver, ListAddRequest, ListDelRequest,</span><br><span class="line">    ListRangeRequest, SetAddRequest, SetDelRequest, SetRequest, StringList,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Redis keyValue provider implementation.</span></span><br><span class="line"><span class="comment">// 这里通过一个 services 过程宏。给 KvRedisProvider extend 出 KeyValue 的 trait，进而约束其实现所有方法</span></span><br><span class="line"><span class="meta">#[derive(Default, Clone, Provider)]</span></span><br><span class="line">**<span class="meta">#[services(KeyValue)]</span>**</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KvRedisProvider</span></span> &#123;</span><br><span class="line">    <span class="comment">// store redis connections per actor</span></span><br><span class="line">    actors: Arc&lt;RwLock&lt;HashMap&lt;<span class="built_in">String</span>, RwLock&lt;Connection&gt;&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Handle KeyValue methods that interact with redis</span></span><br><span class="line"><span class="meta">#[async_trait]</span></span><br><span class="line">**<span class="keyword">impl</span> KeyValue <span class="keyword">for</span> KvRedisProvider &#123;**</span><br><span class="line">    <span class="comment">/// Increments a numeric value, returning the new value</span></span><br><span class="line">    <span class="meta">#[instrument(level = <span class="meta-string">"debug"</span>, skip(self, ctx, arg), fields(actor_id = ?ctx.actor, key = %arg.key))]</span></span><br><span class="line">    **async <span class="function"><span class="keyword">fn</span> <span class="title">increment</span></span>(&amp;<span class="keyword">self</span>, ctx: &amp;Context, arg: &amp;IncrementRequest) -&gt; RpcResult&lt;<span class="built_in">i32</span>&gt; &#123;**</span><br><span class="line">        **<span class="keyword">let</span> <span class="keyword">mut</span> cmd = redis::Cmd::incr(&amp;arg.key, &amp;arg.value); <span class="comment">// 实现 increment 方法**</span></span><br><span class="line">        <span class="keyword">let</span> val: <span class="built_in">i32</span> = <span class="keyword">self</span>.exec(ctx, &amp;<span class="keyword">mut</span> cmd).await?;</span><br><span class="line">        <span class="literal">Ok</span>(val)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件"></a>处理事件</h2><p>wasmcloud host runtime 会抛出部分事件，而 Provider 可以选择处理其中的部分事件。拿 rediskv 的 provider 而言，我们需要在用户 put link 的时候，建立和 redis 的链接，这样在后面的所有操作中，可以复用该链接。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Handle provider control commands</span></span><br><span class="line"><span class="comment">/// put_link (new actor link command), del_link (remove link command), and shutdown</span></span><br><span class="line"><span class="meta">#[async_trait]</span></span><br><span class="line"><span class="keyword">impl</span> ProviderHandler <span class="keyword">for</span> KvRedisProvider &#123;</span><br><span class="line">    <span class="comment">/// Provider should perform any operations needed for a new link,</span></span><br><span class="line">    <span class="comment">/// including setting up per-actor resources, and checking authorization.</span></span><br><span class="line">    <span class="comment">/// If the link is allowed, return true, otherwise return false to deny the link.</span></span><br><span class="line">**<span class="comment">// put_link 的时候建立链接**</span></span><br><span class="line">    <span class="meta">#[instrument(level = <span class="meta-string">"debug"</span>, skip(self, ld), fields(actor_id = %ld.actor_id))]</span></span><br><span class="line">    async <span class="function"><span class="keyword">fn</span> **<span class="title">put_link</span>**</span>(&amp;<span class="keyword">self</span>, ld: &amp;LinkDefinition) -&gt; RpcResult&lt;<span class="built_in">bool</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> redis_url = <span class="keyword">match</span> ld.values.get(REDIS_URL_KEY) &#123;</span><br><span class="line">            <span class="literal">Some</span>(v) =&gt; v.as_str(),</span><br><span class="line">            <span class="literal">None</span> =&gt; DEFAULT_CONNECT_URL,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> client = redis::Client::open(redis_url).map_err(|e| &#123;</span><br><span class="line">            RpcError::ProviderInit(<span class="built_in">format!</span>(<span class="string">"redis connection to &#123;&#125;: &#123;&#125;"</span>, redis_url, e))</span><br><span class="line">        &#125;)?;</span><br><span class="line">        <span class="keyword">let</span> connection = client.get_async_connection().await.map_err(|e| &#123;</span><br><span class="line">            RpcError::ProviderInit(<span class="built_in">format!</span>(<span class="string">"redis connection to &#123;&#125;: &#123;&#125;"</span>, redis_url, e))</span><br><span class="line">        &#125;)?;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> update_map = <span class="keyword">self</span>.actors.write().await;</span><br><span class="line">        update_map.insert(ld.actor_id.to_string(), RwLock::new(connection));</span><br><span class="line"></span><br><span class="line">        <span class="literal">Ok</span>(<span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Handle notification that a link is dropped - close the connection</span></span><br><span class="line">**<span class="comment">// delete_link 的时候，移除链接**</span></span><br><span class="line">    <span class="meta">#[instrument(level = <span class="meta-string">"info"</span>, skip(self))]</span></span><br><span class="line">    async <span class="function"><span class="keyword">fn</span> **<span class="title">delete_link</span>**</span>(&amp;<span class="keyword">self</span>, actor_id: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> aw = <span class="keyword">self</span>.actors.write().await;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(conn) = aw.remove(actor_id) &#123;</span><br><span class="line">            info!(<span class="string">"redis closing connection for actor &#123;&#125;"</span>, actor_id);</span><br><span class="line">            <span class="built_in">drop</span>(conn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Handle shutdown request by closing all connections</span></span><br><span class="line"><span class="comment">// shutdown 时关闭所有链接</span></span><br><span class="line">    async <span class="function"><span class="keyword">fn</span> **<span class="title">shutdown</span>**</span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;(), Infallible&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> aw = <span class="keyword">self</span>.actors.write().await;</span><br><span class="line">        <span class="comment">// empty the actor link data and stop all servers</span></span><br><span class="line">        <span class="keyword">for</span> (_, conn) <span class="keyword">in</span> aw.drain() &#123;</span><br><span class="line">            <span class="built_in">drop</span>(conn)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到在 http-server-rs（一个实现 http server 的 provider） 中，有类似处理</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[async_trait]</span></span><br><span class="line"><span class="keyword">impl</span> ProviderHandler <span class="keyword">for</span> HttpServerProvider &#123;</span><br><span class="line">    <span class="comment">/// Provider should perform any operations needed for a new link,</span></span><br><span class="line">    <span class="comment">/// including setting up per-actor resources, and checking authorization.</span></span><br><span class="line">    <span class="comment">/// If the link is allowed, return true, otherwise return false to deny the link.</span></span><br><span class="line">    async <span class="function"><span class="keyword">fn</span> **<span class="title">put_link</span>**</span>(&amp;<span class="keyword">self</span>, ld: &amp;LinkDefinition) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">bool</span>, RpcError&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> settings =</span><br><span class="line">            load_settings(&amp;ld.values).map_err(|e| RpcError::ProviderInit(e.to_string()))?;</span><br><span class="line"></span><br><span class="line">        **<span class="keyword">let</span> http_server = HttpServerCore::new(settings.clone(), get_host_bridge());**</span><br><span class="line">        http_server.start(ld.clone()).await.map_err(|e| &#123;</span><br><span class="line">            RpcError::ProviderInit(<span class="built_in">format!</span>(</span><br><span class="line">                <span class="string">"starting httpserver for &#123;&#125; &#123;:?&#125;: &#123;&#125;"</span>,</span><br><span class="line">                &amp;ld.actor_id, &amp;settings.address, e</span><br><span class="line">            ))</span><br><span class="line">        &#125;)?;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> update_map = <span class="keyword">self</span>.actors.write().await;</span><br><span class="line">        update_map.insert(ld.actor_id.to_string(), http_server);</span><br><span class="line"></span><br><span class="line">        <span class="literal">Ok</span>(<span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Handle notification that a link is dropped - stop the http listener</span></span><br><span class="line">    async <span class="function"><span class="keyword">fn</span> **<span class="title">delete_link</span>**</span>(&amp;<span class="keyword">self</span>, actor_id: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> aw = <span class="keyword">self</span>.actors.write().await;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(server) = aw.remove(actor_id) &#123;</span><br><span class="line">            tracing::info!(%actor_id, <span class="string">"httpserver stopping listener for actor"</span>);</span><br><span class="line">            **server.begin_shutdown().await;**</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Handle shutdown request by shutting down all the http server threads</span></span><br><span class="line">    async <span class="function"><span class="keyword">fn</span> **<span class="title">shutdown</span>**</span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;(), Infallible&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> aw = <span class="keyword">self</span>.actors.write().await;</span><br><span class="line">        <span class="comment">// empty the actor link data and stop all servers</span></span><br><span class="line">        **<span class="keyword">for</span> (_, server) <span class="keyword">in</span> aw.drain() &#123;</span><br><span class="line">            server.begin_shutdown().await;</span><br><span class="line">        &#125;**</span><br><span class="line">        <span class="literal">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>回顾一下 provider 的主要职能：</p><p><img src="pic2.png" width="700"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;provider 在 wasmcloud 体系中扮演者重要的作用。它负责实现 Interface，在 actor 和 provider 建立
      
    
    </summary>
    
      <category term="WASM" scheme="https://rovast.github.io/categories/WASM/"/>
    
    
  </entry>
  
  <entry>
    <title>wasmcloud app development</title>
    <link href="https://rovast.github.io/2022/09/23/wasmcloud-app-development/"/>
    <id>https://rovast.github.io/2022/09/23/wasmcloud-app-development/</id>
    <published>2022-09-23T05:57:31.000Z</published>
    <updated>2022-09-28T06:14:26.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>本文主要介绍基于 wasmcloud 的分布式开发概念和流程。通过以 wasm 为最小单元的开发，充分适用于当前的分布式开发环境。引用官方文档的原文来说：</p><blockquote><p><strong><em>Congratulations!</em></strong> You’ve successfully created and run your first actor. Welcome to the world of boilerplate-free, simple distributed application development in the cloud, browser, and everywhere in between.</p></blockquote><p>在了解和探索的过程中，主要参考官方文档进行了相关的示例程序编写和运行，用到的相关材料罗列如下：</p><table><thead><tr><th>说明</th><th>网址</th></tr></thead><tbody><tr><td>官网开发指引</td><td><a href="https://wasmcloud.dev/app-dev/" target="_blank" rel="noopener">https://wasmcloud.dev/app-dev/</a></td></tr><tr><td>官方examples代码</td><td><a href="https://github.com/wasmCloud/examples" target="_blank" rel="noopener">https://github.com/wasmCloud/examples</a></td></tr><tr><td>官方providers列表</td><td><a href="https://github.com/wasmCloud/capability-providers" target="_blank" rel="noopener">https://github.com/wasmCloud/capability-providers</a></td></tr><tr><td>官方interfaces列表</td><td><a href="https://github.com/wasmCloud/interfaces" target="_blank" rel="noopener">https://github.com/wasmCloud/interfaces</a></td></tr><tr><td>wasmcloud平台代码</td><td><a href="https://github.com/wasmCloud/wasmcloud-otp" target="_blank" rel="noopener">https://github.com/wasmCloud/wasmcloud-otp</a></td></tr><tr><td>rust权威指南</td><td><a href="https://zh.b-ok.cc/book/17931171/7b822e" target="_blank" rel="noopener">https://zh.b-ok.cc/book/17931171/7b822e</a></td></tr><tr><td>elixir教程</td><td><a href="https://pragprog.com/titles/passelixir/programmer-passport-elixir/" target="_blank" rel="noopener">https://pragprog.com/titles/passelixir/programmer-passport-elixir/</a></td></tr><tr><td>OTP教程</td><td><a href="https://pragprog.com/titles/passotp/programmer-passport-otp/" target="_blank" rel="noopener">https://pragprog.com/titles/passotp/programmer-passport-otp/</a></td></tr></tbody></table><h1 id="二、基本概念梳理"><a href="#二、基本概念梳理" class="headerlink" title="二、基本概念梳理"></a>二、基本概念梳理</h1><p>在展开介绍 wasmcloud 的应用开发之前，我们需要熟悉其抽象出的几个概念。</p><p>无论是采用传统的单体应用开发模式，还是微服务开发模式，亦或是 wasmcloud，其解决的问题基本类似，只不过不同的模式下称呼不同而已。</p><p>一般而言，应用的开发都可以划分为以下几个部分：</p><ol><li><strong>纯业务逻辑。*</strong>如：商品功能，会员功能等。面向<strong>业务开发</strong>人员。*</li><li><strong>中间件。*</strong>如：数据库中间件，缓存中间件，流量控制等。面向<strong>中间件开发</strong>人员，或<strong>平台开发</strong>人员。*</li><li><strong>运行环境。*</strong>根据不同的技术栈，有不同的运行环境，属于基础设施层。比如采用容器部署的，一般运行在k8s里，这部分面向<strong>平台开发</strong>人员。*</li></ol><p>在 wasmcloud 中具有相似的概念，这里列举如下</p><table><thead><tr><th>概念</th><th>面向人员</th><th>说明</th></tr></thead><tbody><tr><td>actor</td><td>业务开发</td><td>编写业务逻辑的地方，如果涉及到非业务逻辑的公共能力（或中间件能力），通过引用interface的方式来获取能力。业务人员可使用rust或tinyGo来开发actor。</td></tr><tr><td>interface</td><td>中间件或平台开发</td><td>采用CDD模式开发，定义一些业务无关的公共能力接口，比如：keyvalue能力，但是不提供具体的实现。可以在 interface 中定义允许的操作(operations)，以及各种结构体(structure)。使用 smithy IDL 进行 interface 的定义，使用 wash 工具来生成对应代码。</td></tr><tr><td>provider</td><td>中间件或平台开发</td><td>实现interface的能力，比如同样对于keyvalue功能，可以有redis实现，也可以有vault实现。并且可以用不同的技术栈来实现。可使用 rust 来进行 Provider 开发，官方未来会支持 Go。</td></tr><tr><td>link def</td><td>业务开发或部署人员</td><td>由于actor只是引用了具体的interface，并没有指定哪一个provider，所以在实际部署时，需要关联actor和provider。可以通过 wasmcloud shell(wash)命令行，或者平台进行操作。</td></tr><tr><td>wasm host</td><td>中间件或平台开发</td><td>作为整个wasmcloud生态的运行基石，用于协调actor,provider之间的分布式通信，同时也提供分布式调度能力。采用 Elixir/OTP 技术栈实现。</td></tr></tbody></table><p>整体的关系图梳理如下：</p><img src="/2022/09/23/wasmcloud-app-development/Untitled.png" title="pic1"><p>wasmcloud app 的开发采用 CDD（Contract Driven Develop） 方式进行，其中 interface 就是契约的定义。</p><h1 id="三、开发流程"><a href="#三、开发流程" class="headerlink" title="三、开发流程"></a>三、开发流程</h1><p>如果我们需要实现一个全新的业务场景，需要进行以下几个步骤:</p><img src="/2022/09/23/wasmcloud-app-development/pic1.png" title="图1"> )<br><br>接下来以 kvcounter 为例，进一步说明各个环节。<br><br>## 示例目标：<br><br>开发一个 kvcounter 示例程序，当用户访问 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 时，能够正常显示 counter，且每次访问 +1。<br><br>示例效果如下：<br><br><img src="/2022/09/23/wasmcloud-app-development/pic2.png" title="图1"> )<br><br>## 1、创建（或使用）interface<br><br>在本示例中，我们用到了 kv 功能，所以需要找到一个能够提供 keyvalue 功能的 interface。有两种方式，一是找到一个现成可用的interface，二是定义一个keyvalue 的 interface。<br><br>这里以定义一个新的 keyvalue 为例。<br><br>### 1.1 使用 wash 工具创建新的 interface<br><br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wash new interface keyvalue</span><br></pre></td></tr></table></figure><h3 id="1-2-编写-interface，即：smithy-文件"><a href="#1-2-编写-interface，即：smithy-文件" class="headerlink" title="1.2 编写 interface，即：smithy 文件"></a>1.2 编写 interface，即：smithy 文件</h3><p>首先确定该接口提供的操作，然后是<strong>每个操作（operations）涉及到的结构体(structure)</strong>：</p><p>这里摘除主要的operation定义，完整的定义可参考链接：</p><p><a href="https://github.com/wasmCloud/interfaces/blob/main/keyvalue/keyvalue.smithy" target="_blank" rel="noopener">interfaces/keyvalue.smithy at main · wasmCloud/interfaces</a></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">// key-value.smithy</span><br><span class="line">// Definition of a key-value store and the 'wasmcloud:keyvalue' capability contract</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">// Tell the code generator how to reference symbols defined in this namespace</span><br><span class="line">metadata package = [&#123;</span><br><span class="line">    namespace: <span class="string">"org.wasmcloud.interface.keyvalue"</span>,</span><br><span class="line">    crate: <span class="string">"wasmcloud_interface_keyvalue"</span>,</span><br><span class="line">    py_module: <span class="string">"wasmcloud_interface_keyvalue"</span>,</span><br><span class="line">    doc: <span class="string">"Keyvalue: wasmcloud capability contract for key-value store"</span>,</span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line">namespace org.wasmcloud.interface.keyvalue</span><br><span class="line"></span><br><span class="line">use org.wasmcloud.model<span class="comment">#wasmbus</span></span><br><span class="line">use org.wasmcloud.model<span class="comment">#rename</span></span><br><span class="line">use org.wasmcloud.model<span class="comment">#n</span></span><br><span class="line">use org.wasmcloud.model<span class="comment">#U32</span></span><br><span class="line">use org.wasmcloud.model<span class="comment">#I32</span></span><br><span class="line"></span><br><span class="line">@wasmbus(</span><br><span class="line">    contractId: <span class="string">"wasmcloud:keyvalue"</span>,</span><br><span class="line">    providerReceive: true )</span><br><span class="line">service KeyValue &#123;</span><br><span class="line">  version: <span class="string">"0.1.1"</span>,</span><br><span class="line">  operations: [</span><br><span class="line">    Increment, Contains, Del, Get,</span><br><span class="line">    ListAdd, ListClear, ListDel, ListRange,</span><br><span class="line">    Set, , SetAdd, SetDel, SetIntersection, SetQuery, SetUnion, SetClear,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// Gets a value for a specified key. If the key exists,</span><br><span class="line">/// the return structure contains exists: true and the value,</span><br><span class="line">/// otherwise the return structure contains exists == false.</span><br><span class="line">@readonly</span><br><span class="line">operation **Get** &#123;</span><br><span class="line">  input: String,</span><br><span class="line">  output: GetResponse,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// Sets the value of a key.</span><br><span class="line">/// expires is an optional number of seconds before the value should be automatically deleted,</span><br><span class="line">/// or 0 for no expiration.</span><br><span class="line">operation **Set** &#123;</span><br><span class="line">  input: SetRequest,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// Deletes a key, returning true if the key was deleted</span><br><span class="line"><span class="section">@rename([&#123;lang:"Python", name:"delete"&#125;])</span></span><br><span class="line">operation **Del** &#123;</span><br><span class="line">  input: String,</span><br><span class="line">  output: Boolean,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// Increments a numeric value, returning the new value</span><br><span class="line">operation **Increment** &#123;</span><br><span class="line">  input: IncrementRequest,</span><br><span class="line">  output: I32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到 smithy 文件只定义了相关的接口，并不涉及到具体的实现。这也是 wasmcloud app开发中比较重要的概念。</p><p><strong>actor只依赖于具体的interface，而一个interface可以由多个provider来实现。</strong></p><p>对于本示例，同样是 <code>wasmcloud:keyvalue</code> 的契约，我们可以用 redis 技术栈来实现一个 provider，也可以用 vault 来实现。实际上官方提供了两个版本 provider 的实现：</p><p><a href="https://github.com/wasmCloud/capability-providers" target="_blank" rel="noopener">https://github.com/wasmCloud/capability-providers</a></p><img src="/2022/09/23/wasmcloud-app-development/pic3.png" title="图1"> )<br><br>### 1.3 生成代码，发布到对应的仓，方便actor开发人员使用<br><br>我们可以直接执行 make 指令，生成对应的代码。之后可以把 interface 发布到 crate.io。<br><br>Go语言同理，这样在实际开发 actor 时，就可直接引入使用。<br><br>## 2、开发 provider<br><br>根据官方的说法，provider的作用如下：<br><br>启动后，通过 stdio 和 host 进行交互，其主要作用包括：健康检查、通过 RPC 和 actor 交互等。<br><br>&gt; Creating a capability provider involves creating a native executable. All capability provider executables have the same basic requirements:<br>&gt;<br>&gt; - Accept a <a href="https://wasmcloud.github.io/interfaces/html/org_wasmcloud_core.html#host_data" target="_blank" rel="noopener">Host Data</a> structure from <code>stdin</code> immediately upon starting the executable. The host data is a base64 encoded JSON object with a trailing newline making it easy to pull from the <code>stdin</code> pipe.<br>&gt; - Accept linkdef messages according to the <a href="https://wasmcloud.dev/reference/lattice-protocols/rpc" target="_blank" rel="noopener">RPC protocol</a><br>&gt; - Communicate with actors via rpc messages defined by a capability contract<br>&gt; - Respond to periodic health checks<br><br><img src="/2022/09/23/wasmcloud-app-development/pic4.png" title="图1"> )<br><br>### 2.1 使用 wash 新建 provider<br><br>通过 wash 指令，可以生成 provider 的模板代码<br><br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wash new provider kvredis</span><br></pre></td></tr></table></figure><h3 id="2-2-编写-provider"><a href="#2-2-编写-provider" class="headerlink" title="2.2 编写 provider"></a>2.2 编写 provider</h3><p>重点是基于 redis 实现 interface 中定义的各种 operations，完整代码见链接，核心代码框架摘录如下：</p><p><a href="https://github.com/wasmCloud/capability-providers/blob/main/kvredis/src/main.rs" target="_blank" rel="noopener">capability-providers/main.rs at main · wasmCloud/capability-providers</a></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/// Handle KeyValue methods that interact with redis</span></span><br><span class="line"><span class="meta">#[async_trait]</span></span><br><span class="line"><span class="keyword">impl</span> KeyValue <span class="keyword">for</span> KvRedisProvider &#123;</span><br><span class="line"><span class="comment">/// Increments a numeric value, returning the new value</span></span><br><span class="line">    <span class="meta">#[instrument(level = <span class="meta-string">"debug"</span>, skip(self, ctx, arg), fields(actor_id = ?ctx.actor, key = %arg.key))]</span></span><br><span class="line">    **async <span class="function"><span class="keyword">fn</span> <span class="title">increment</span>**</span>(&amp;<span class="keyword">self</span>, ctx: &amp;Context, arg: &amp;IncrementRequest) -&gt; RpcResult&lt;<span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> cmd = redis::Cmd::incr(&amp;arg.key, &amp;arg.value);</span><br><span class="line">        <span class="keyword">let</span> val: <span class="built_in">i32</span> = <span class="keyword">self</span>.exec(ctx, &amp;<span class="keyword">mut</span> cmd).await?;</span><br><span class="line">        <span class="literal">Ok</span>(val)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Deletes a key, returning true if the key was deleted</span></span><br><span class="line">    <span class="meta">#[instrument(level = <span class="meta-string">"debug"</span>, skip(self, ctx, arg), fields(actor_id = ?ctx.actor, key = %arg.to_string()))]</span></span><br><span class="line">    **async <span class="function"><span class="keyword">fn</span> <span class="title">del</span>**</span>&lt;TS: <span class="built_in">ToString</span> + ?<span class="built_in">Sized</span> + <span class="built_in">Sync</span>&gt;(&amp;<span class="keyword">self</span>, ctx: &amp;Context, arg: &amp;TS) -&gt; RpcResult&lt;<span class="built_in">bool</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> cmd = redis::Cmd::del(arg.to_string());</span><br><span class="line">        <span class="keyword">let</span> val: <span class="built_in">i32</span> = <span class="keyword">self</span>.exec(ctx, &amp;<span class="keyword">mut</span> cmd).await?;</span><br><span class="line">        <span class="literal">Ok</span>(val &gt; <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Gets a value for a specified key. If the key exists,</span></span><br><span class="line">    <span class="comment">/// the return structure contains exists: true and the value,</span></span><br><span class="line">    <span class="comment">/// otherwise the return structure contains exists == false.</span></span><br><span class="line">    <span class="meta">#[instrument(level = <span class="meta-string">"debug"</span>, skip(self, ctx, arg), fields(actor_id = ?ctx.actor, key = %arg.to_string()))]</span></span><br><span class="line">    **async <span class="function"><span class="keyword">fn</span> <span class="title">get</span>**</span>&lt;TS: <span class="built_in">ToString</span> + ?<span class="built_in">Sized</span> + <span class="built_in">Sync</span>&gt;(</span><br><span class="line">        &amp;<span class="keyword">self</span>,</span><br><span class="line">        ctx: &amp;Context,</span><br><span class="line">        arg: &amp;TS,</span><br><span class="line">    ) -&gt; RpcResult&lt;GetResponse&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> cmd = redis::Cmd::get(arg.to_string());</span><br><span class="line">        <span class="keyword">let</span> val: <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt; = <span class="keyword">self</span>.exec(ctx, &amp;<span class="keyword">mut</span> cmd).await?;</span><br><span class="line">        <span class="keyword">let</span> resp = <span class="keyword">match</span> val &#123;</span><br><span class="line">            <span class="literal">Some</span>(s) =&gt; GetResponse &#123;</span><br><span class="line">                exists: <span class="literal">true</span>,</span><br><span class="line">                value: s,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="literal">None</span> =&gt; GetResponse &#123;</span><br><span class="line">                exists: <span class="literal">false</span>,</span><br><span class="line">                ..<span class="built_in">Default</span>::<span class="keyword">default</span>()</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="literal">Ok</span>(resp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Sets the value of a key.</span></span><br><span class="line">    <span class="comment">/// expires is an optional number of seconds before the value should be automatically deleted,</span></span><br><span class="line">    <span class="comment">/// or 0 for no expiration.</span></span><br><span class="line">    <span class="meta">#[instrument(level = <span class="meta-string">"debug"</span>, skip(self, ctx, arg), fields(actor_id = ?ctx.actor, key = %arg.key))]</span></span><br><span class="line">    **async <span class="function"><span class="keyword">fn</span> <span class="title">set</span>**</span>(&amp;<span class="keyword">self</span>, ctx: &amp;Context, arg: &amp;SetRequest) -&gt; RpcResult&lt;()&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> cmd = <span class="keyword">match</span> arg.expires &#123;</span><br><span class="line">            <span class="number">0</span> =&gt; redis::Cmd::set(&amp;arg.key, &amp;arg.value),</span><br><span class="line">            _ =&gt; redis::Cmd::set_ex(&amp;arg.key, &amp;arg.value, arg.expires <span class="keyword">as</span> <span class="built_in">usize</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> _value: <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt; = <span class="keyword">self</span>.exec(ctx, &amp;<span class="keyword">mut</span> cmd).await?;</span><br><span class="line">        <span class="literal">Ok</span>(())</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>除了基于 redis 实现 provider 外，官方还提供了基于 valut 的 keyvalue 实现，可参阅</p><p><a href="https://github.com/wasmCloud/capability-providers/blob/main/kv-vault/src/main.rs" target="_blank" rel="noopener">capability-providers/main.rs at main · wasmCloud/capability-providers</a></p><p>其中也是有诸如 increment, del, set, get 的实现，而这些 operation 都是在名为 <code>wasmcloud:keyvalue</code> 的契约中定义的。</p><h3 id="2-3-生成-provider-产物"><a href="#2-3-生成-provider-产物" class="headerlink" title="2.3 生成 provider 产物"></a>2.3 生成 provider 产物</h3><p>简单的使用 <code>make</code> 指令即可完成部署产物，该产物可以推送至 OCI 仓库以方便使用。</p><h2 id="3、开发-actor"><a href="#3、开发-actor" class="headerlink" title="3、开发 actor"></a>3、开发 actor</h2><h3 id="3-1-新建-actor"><a href="#3-1-新建-actor" class="headerlink" title="3.1 新建 actor"></a>3.1 新建 actor</h3><p>使用 wash 指令可以很方便的生成便于快速开发的模板代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wash new actor kvcounter</span><br></pre></td></tr></table></figure><h3 id="3-2-开发-actor"><a href="#3-2-开发-actor" class="headerlink" title="3.2 开发 actor"></a>3.2 开发 actor</h3><p><strong>声明契约依赖</strong></p><p>kvcounter 依赖了两个 interface，用来提供两个能力：httpserver能力和 kv 存储能力。</p><p>我们需要声明该依赖，这样打包完成 kvcounter 后，可以 inspect 出对应的信息。</p><img src="/2022/09/23/wasmcloud-app-development/pic5.png" title="图1"> )<br><br>所以我们需要修改 makefile 的 CLAIMS 信息：<br><br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># examples/actor/kvcounter</span></span><br><span class="line"></span><br><span class="line">PROJECT  = kvcounter</span><br><span class="line">VERSION  = <span class="variable">$(<span class="built_in">shell</span> cargo metadata --no-deps --format-version 1 | jq -r '.packages[] .version' | head -1)</span></span><br><span class="line">REVISION = 0</span><br><span class="line"><span class="comment"># list of all contract claims for actor signing (space-separated)</span></span><br><span class="line">**CLAIMS   = wasmcloud:httpserver wasmcloud:keyvalue**</span><br></pre></td></tr></table></figure><p><strong>使用 interface</strong></p><p>根据不同语言，我们可以引入不同的 interface package。以 rust 为例，官方的 interface 可以在 <a href="http://crates.io" target="_blank" rel="noopener">crates.io</a> 中查阅</p><img src="/2022/09/23/wasmcloud-app-development/pic6.png" title="图1"> )<br><br>我们可在 cargo.toml 中加入 kvcounter 所依赖的两个包：<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"kvcounter"</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line">**wasmcloud-interface-keyvalue = "0.7.0"**</span><br><span class="line">**wasmcloud-interface-httpserver = "0.6.0"**</span><br></pre></td></tr></table></figure><p>在 actor 中调用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[async_trait]</span></span><br><span class="line"><span class="keyword">impl</span> HttpServer <span class="keyword">for</span> KvCounterActor &#123;</span><br><span class="line">    async <span class="function"><span class="keyword">fn</span> <span class="title">handle_request</span></span>(&amp;<span class="keyword">self</span>, ctx: &amp;Context, req: &amp;HttpRequest) -&gt; RpcResult&lt;HttpResponse&gt; &#123;</span><br><span class="line">        <span class="comment">// increment the value in kv and send response in json</span></span><br><span class="line">        <span class="keyword">let</span> (body, status_code) = <span class="keyword">match</span> **increment_counter**(ctx, key, amount).await &#123;</span><br><span class="line">            <span class="literal">Ok</span>(v) =&gt; (json!(&#123; <span class="string">"counter"</span>: v &#125;).to_string(), <span class="number">200</span>),</span><br><span class="line">            <span class="comment">// if we caught an error, return it to client</span></span><br><span class="line">            <span class="literal">Err</span>(e) =&gt; (json!(&#123; <span class="string">"error"</span>: e.to_string() &#125;).to_string(), <span class="number">500</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> resp = HttpResponse &#123;</span><br><span class="line">            body: body.as_bytes().to_vec(),</span><br><span class="line">            status_code,</span><br><span class="line">            ..<span class="built_in">Default</span>::<span class="keyword">default</span>()</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="literal">Ok</span>(resp)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// increment the counter by the amount, returning the new value</span></span><br><span class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">increment_counter</span></span>(ctx: &amp;Context, key: <span class="built_in">String</span>, value: <span class="built_in">i32</span>) -&gt; RpcResult&lt;<span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> new_val = KeyValueSender::new()</span><br><span class="line">        **.increment(ctx, &amp;IncrementRequest &#123; key, value &#125;)**</span><br><span class="line">        .await?;</span><br><span class="line">    <span class="literal">Ok</span>(new_val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-打包"><a href="#3-4-打包" class="headerlink" title="3.4 打包"></a>3.4 打包</h3><p>我们可以使用 make 指令，将代码打包为 .wasm 文件，进而推送到 OCI 仓库。</p><h2 id="4、部署"><a href="#4、部署" class="headerlink" title="4、部署"></a>4、部署</h2><p>我们可以使用 wasmcloud shell(即 wash) 或者 web dashboard 进行部署。主要进行如下操作：</p><ol><li>start actors。将 actor 的 wasm 文件上传到 wasmcloud 运行时，或者提供 registry 地址供其下载。</li><li>start providers。将 provider 的包上传到 wasmcloud 运行时，或提供 registry 地址供其下载。</li><li>建立 link 关系。</li></ol><p>在平台的操作截图效果如下：</p><img src="/2022/09/23/wasmcloud-app-development/pic7.png" title="图1"> )<br><br>这里需要注意的是，kvcounter 的 actor 需要分别与 httpserver 以及 kvredis 的 provider 进行 link，也就是有两条 link 记录。<br><br>## 5、访问<br><br>至此，已能正常通过 http 进行访问。<br><br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ curl localhost:<span class="number">8080</span></span><br><span class="line">&#123;<span class="string">"counter"</span>:<span class="number">17</span>&#125;%</span><br><span class="line">➜  ~ curl localhost:<span class="number">8080</span></span><br><span class="line">&#123;<span class="string">"counter"</span>:<span class="number">18</span>&#125;%</span><br></pre></td></tr></table></figure><h1 id="NEXT"><a href="#NEXT" class="headerlink" title="NEXT"></a>NEXT</h1><p>本文主要是梳理了 wasmcloud app 开发的概况，包括其主要涉及的概念、工具链的使用、主要的开发流程。</p><p>在当前的探索过程中，已基本熟悉 wasmcloud 的外围生态，能够根据实际的工作需求，进行部分平台数据获取（或UI）的修改，同时提交 PR，参与官方的平台建设。</p><p>下一步需要进一步探究 wasmcloud runtime 的具体实现，尤其是如何调度 actor, provider，以及 actor 和 provider 之间的协作通信细节。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、引言&quot;&gt;&lt;a href=&quot;#一、引言&quot; class=&quot;headerlink&quot; title=&quot;一、引言&quot;&gt;&lt;/a&gt;一、引言&lt;/h1&gt;&lt;p&gt;本文主要介绍基于 wasmcloud 的分布式开发概念和流程。通过以 wasm 为最小单元的开发，充分适用于当前的分布式开发
      
    
    </summary>
    
      <category term="WASM" scheme="https://rovast.github.io/categories/WASM/"/>
    
    
  </entry>
  
  <entry>
    <title>wasmcloud actor调度梳理</title>
    <link href="https://rovast.github.io/2022/09/19/wasmcloud-intro/"/>
    <id>https://rovast.github.io/2022/09/19/wasmcloud-intro/</id>
    <published>2022-09-19T05:22:55.000Z</published>
    <updated>2022-09-28T06:14:26.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h1><table><thead><tr><th>模块</th><th>作用</th></tr></thead><tbody><tr><td>wasmcloud_host_web</td><td>Web 平台，由 phoenixframework+liveview 技术栈组成，响应用户的操作。</td></tr><tr><td>wasmcloud_host</td><td>接收web的操作，包装数据，发送给 nat</td></tr><tr><td>host_core</td><td>主要负责 nat 消息的处理，actor 进程的直接管理（增删）</td></tr><tr><td>host_core/native</td><td>执行 actor wasm</td></tr></tbody></table><img src="/2022/09/19/wasmcloud-intro/uml.png" title="uml"><h1 id="Start-actor"><a href="#Start-actor" class="headerlink" title="Start actor"></a>Start actor</h1><h2 id="wasmcloud-host-web-UI"><a href="#wasmcloud-host-web-UI" class="headerlink" title="wasmcloud_host_web (UI)"></a>wasmcloud_host_web (UI)</h2><img src="/2022/09/19/wasmcloud-intro/form.png" title="form"><p>webui 部分使用的是 phoenixframework + liveview 的技术栈来构建。这里重点需要关注的文件是 <code>start_actor_component.ex</code>，在用户点击完 submit 后触发事件。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">render</span></span>(assigns) <span class="keyword">do</span></span><br><span class="line">    modal_id =</span><br><span class="line">      <span class="keyword">case</span> assigns.id <span class="keyword">do</span></span><br><span class="line">        <span class="symbol">:start_actor_file_modal</span> -&gt; <span class="string">"start_actor_file"</span></span><br><span class="line">        ***<span class="symbol">:start_actor_ociref_modal</span> -&gt; <span class="string">"start_actor_ociref"</span>***</span><br><span class="line">        <span class="symbol">:start_actor_file_hotreload_modal</span> -&gt; <span class="string">"start_actor_file_hotreload"</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    ~L<span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    &lt;form class="</span>form-horizontal<span class="string">" ***phx-submit="</span>&lt;%= modal_id %&gt;<span class="string">"*** phx-change="</span>validate<span class="string">" phx-target="</span>&lt;%= <span class="variable">@myself</span> %&gt;<span class="string">"&gt;</span></span><br></pre></td></tr></table></figure><p><em>重点代码部分已使用斜体加粗表示。</em></p><p>对于示例，会触发 <code>start_actor_ociref</code> 事件，进而被事件处理函数 <code>handle_event(”start_actor_ociref</code> 所匹配。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_event</span></span>(</span><br><span class="line">      ***<span class="string">"start_actor_ociref"</span>,***</span><br><span class="line">      %&#123;<span class="string">"count"</span> =&gt; count, <span class="string">"actor_ociref"</span> =&gt; actor_ociref, <span class="string">"host_id"</span> =&gt; host_id&#125;,</span><br><span class="line">      socket</span><br><span class="line">    ) <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">case</span> host_id <span class="keyword">do</span></span><br><span class="line">    <span class="string">""</span> -&gt; <span class="comment"># 其他处理，略</span></span><br><span class="line"></span><br><span class="line">    ***host_id -&gt;</span><br><span class="line">      start_actor(actor_ociref, count, host_id, socket)***</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">defp</span> <span class="title">start_actor</span></span>(actor_ociref, count, host_id, socket) <span class="keyword">do</span></span><br><span class="line"><span class="comment"># 获取 actor_id 略</span></span><br><span class="line">  <span class="keyword">case</span> ***WasmcloudHost.Lattice.ControlInterface.scale_actor***(</span><br><span class="line">         actor_id,</span><br><span class="line">         actor_ociref,</span><br><span class="line">         String.to_integer(count),</span><br><span class="line">         host_id</span><br><span class="line">       ) <span class="keyword">do</span></span><br><span class="line">   <span class="comment"># 返回结果处理，略</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="wasmcloud-host"><a href="#wasmcloud-host" class="headerlink" title="wasmcloud_host"></a>wasmcloud_host</h2><p>根据上面的梳理，我们知道在用户提交了相关信息后，最后调用如下（含值）：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WasmcloudHost.Lattice.ControlInterface.scale_actor(</span><br><span class="line">actor_id = <span class="string">"MBCFOPM6JW2APJLXJD3Z5O4CN7CPYJ2B4FTKLJUR5YR5MITIU7HD3WD5"</span></span><br><span class="line">actor_ociref = <span class="string">"wasmcloud.azurecr.io/echo:0.3.4"</span></span><br><span class="line">desired_count = <span class="number">1</span></span><br><span class="line">host_id = <span class="string">"NATIRMKFPZ3C6M3LYJBZUMAP72WCUKIDFVUYW77CC5IMRL5XRMYXXWXM"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中 actor_id 可以使用 wash 指令来获得，是 actor 的固有属性之一。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wash claims inspect wasmcloud.azurecr.io/<span class="built_in">echo</span>:0.3.4</span><br><span class="line"></span><br><span class="line">                               Echo - Module</span><br><span class="line">  Account       ACOJJN6WUP4ODD75XEBKKTCCUJJCY5ZKQ56XVKYK4BEJWGVAOOQHZMCW</span><br><span class="line">  Module        MBCFOPM6JW2APJLXJD3Z5O4CN7CPYJ2B4FTKLJUR5YR5MITIU7HD3WD5</span><br><span class="line">  Expires                                                          never</span><br><span class="line">  Can Be Used                                                immediately</span><br><span class="line">  Version                                                      0.3.4 (4)</span><br><span class="line">  Call Alias                                                   (Not <span class="built_in">set</span>)</span><br><span class="line">                               Capabilities</span><br><span class="line">  HTTP Server</span><br><span class="line">                                   Tags</span><br><span class="line">  None</span><br></pre></td></tr></table></figure><p>其函数的定义在文件 <code>control_interface.ex</code></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">WasmcloudHost.Lattice.ControlInterface</span></span> <span class="keyword">do</span></span><br><span class="line">  <span class="variable">@wasmbus_prefix</span> <span class="string">"wasmbus.ctl."</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> ***<span class="title">scale_actor</span></span>***(actor_id, actor_ref, desired_count, host_id) <span class="keyword">do</span></span><br><span class="line">    ***topic = <span class="string">"<span class="subst">#&#123;<span class="variable">@wasmbus_prefix</span>&#125;</span><span class="subst">#&#123;HostCore.Host.lattice_prefix()&#125;</span>.cmd.<span class="subst">#&#123;host_id&#125;</span>.scale"</span>***</span><br><span class="line"></span><br><span class="line">    ***payload =</span><br><span class="line">      Jason.encode!(%&#123;</span><br><span class="line">        <span class="string">"actor_id"</span> =&gt; actor_id,</span><br><span class="line">        <span class="string">"actor_ref"</span> =&gt; actor_ref,</span><br><span class="line">        <span class="string">"count"</span> =&gt; desired_count</span><br><span class="line">      &#125;)***</span><br><span class="line"></span><br><span class="line">    ***<span class="keyword">case</span> ctl_request(topic, payload, <span class="number">2_000</span>) <span class="keyword">do</span>***</span><br><span class="line"> <span class="comment"># 响应不同的返回，略</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">defp</span> <span class="title">ctl_request</span></span>(topic, payload, timeout) <span class="keyword">do</span></span><br><span class="line">    ***Gnat.request(<span class="symbol">:control_nats</span>, topic, payload, <span class="symbol">request_timeout:</span> timeout)***</span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>上述函数处理的重点在于包装需要的数据（payload），并通过 nat 进行通信。其中两个重要的参数和值分别如下：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ***topic = "#&#123;@wasmbus_prefix&#125;#&#123;HostCore.Host.lattice_prefix()&#125;.cmd.#&#123;host_id&#125;.scale"***</span></span><br><span class="line">topic = </span><br><span class="line"><span class="string">"wasmbus.ctl.default.cmd.NBNT7GUJSLQPIZ4LD4VALYXSRRPKWOLNKIC4LRGFOJNFQ43OJTMQ3AIM.scale"</span></span><br><span class="line"></span><br><span class="line">payload =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"actor_id"</span>: <span class="string">"MBCFOPM6JW2APJLXJD3Z5O4CN7CPYJ2B4FTKLJUR5YR5MITIU7HD3WD5"</span>,</span><br><span class="line">    <span class="string">"actor_ref"</span>: <span class="string">"wasmcloud.azurecr.io/echo:0.3.4"</span>,</span><br><span class="line">    <span class="string">"count"</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们已经梳理出用户在 UI 界面中 start actor 时，与 nat 进行交互的 topic 和 payload 内容</p><h2 id="host-core"><a href="#host-core" class="headerlink" title="host_core"></a>host_core</h2><p>经过上面的梳理，我们看到最后和 nat 交互的信息如下：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ***topic = "#&#123;@wasmbus_prefix&#125;#&#123;HostCore.Host.lattice_prefix()&#125;.cmd.#&#123;host_id&#125;.scale"***</span></span><br><span class="line">***Gnat.request(<span class="symbol">:control_nats</span>, </span><br><span class="line">topic =*** <span class="string">"wasmbus.ctl.default.cmd.NBNT7GUJSLQPIZ4LD4VALYXSRRPKWOLNKIC4LRGFOJNFQ43OJTMQ3AIM.scale"</span>***, </span><br><span class="line">payload =*** &#123;</span><br><span class="line">    <span class="string">"actor_id"</span>: <span class="string">"MBCFOPM6JW2APJLXJD3Z5O4CN7CPYJ2B4FTKLJUR5YR5MITIU7HD3WD5"</span>,</span><br><span class="line">    <span class="string">"actor_ref"</span>: <span class="string">"wasmcloud.azurecr.io/echo:0.3.4"</span>,</span><br><span class="line">    <span class="string">"count"</span>: <span class="number">1</span></span><br><span class="line">&#125;***, </span><br><span class="line"><span class="symbol">request_timeout:</span> timeout)***</span><br></pre></td></tr></table></figure><p>接下来我们需要找到 host_core 中消费该 topic 的进程处理模块。这部分可在 <code>host_core.ex</code> 查阅，其中 <code>Supervisor.start_link</code> 启动守护进程（或叫监督进程）时定义：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">defp</span> <span class="title">mount_supervisor_tree</span></span>(config) <span class="keyword">do</span></span><br><span class="line">[</span><br><span class="line"><span class="comment"># 其他处理，略 ...</span></span><br><span class="line">  Supervisor.child_spec(</span><br><span class="line">    &#123;Gnat.ConsumerSupervisor,</span><br><span class="line">     %&#123;</span><br><span class="line">       ***<span class="symbol">connection_name:</span> <span class="symbol">:control_nats</span>,</span><br><span class="line">       <span class="symbol">module:</span> HostCore.ControlInterface.Server,***</span><br><span class="line">       <span class="symbol">subscription_topics:</span> [</span><br><span class="line">         %&#123;<span class="symbol">topic:</span> <span class="string">"<span class="subst">#&#123;config.ctl_topic_prefix&#125;</span>.<span class="subst">#&#123;config.lattice_prefix&#125;</span>.registries.put"</span>&#125;,</span><br><span class="line">         ***%&#123;</span><br><span class="line">           <span class="symbol">topic:</span></span><br><span class="line">             <span class="string">"<span class="subst">#&#123;config.ctl_topic_prefix&#125;</span>.<span class="subst">#&#123;config.lattice_prefix&#125;</span>.cmd.<span class="subst">#&#123;config.host_key&#125;</span>.*"</span></span><br><span class="line">         &#125;,***</span><br><span class="line"><span class="comment"># 其他 topic 参数，略 ...</span></span><br><span class="line">       ]</span><br><span class="line">     &#125;&#125;,</span><br><span class="line">    <span class="symbol">id:</span> <span class="symbol">:latticectl_consumer_supervisor</span></span><br><span class="line">  ),</span><br></pre></td></tr></table></figure><p>我们可以看出，其 topic 对应的处理模块为 <strong><em><code>HostCore.ControlInterface.Server</code>，</em></strong>对应 <code>server.ex</code> 文件。其核心代码摘录如下：</p><blockquote><p>其中的 request 为 <code>use Gnat.Server</code> 时的 <code>callback</code>，可参阅文档：</p><p><a href="https://hexdocs.pm/gnat/Gnat.Server.html#c:request/1" target="_blank" rel="noopener">https://hexdocs.pm/gnat/Gnat.Server.html#c:request/1</a></p></blockquote><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">HostCore.ControlInterface.Server</span></span> <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">use</span> Gnat.Server</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 接收对应的 topic 的消息，这里主要对 topic 的格式进行了解析，并调用对应的匹配函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">request</span></span>(%&#123;<span class="symbol">topic:</span> topic, <span class="symbol">body:</span> body, <span class="symbol">reply_to:</span> reply_to&#125; = req) <span class="keyword">do</span></span><br><span class="line"><span class="comment"># 处理前的 topic</span></span><br><span class="line"><span class="comment"># wasmbus.ctl.default.cmd.NBNT7GUJSLQPIZ4LD4VALYXSRRPKWOLNKIC4LRGFOJNFQ43OJTMQ3AIM.scale</span></span><br><span class="line">    topic</span><br><span class="line">    |&gt; String.split(<span class="string">"."</span>)</span><br><span class="line">    <span class="comment"># wasmbus</span></span><br><span class="line">    |&gt; List.delete_at(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># ctl</span></span><br><span class="line">    |&gt; List.delete_at(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># prefix</span></span><br><span class="line">    |&gt; List.delete_at(<span class="number">0</span>)</span><br><span class="line">    |&gt; List.to_tuple()</span><br><span class="line">    |&gt; handle_request(body, reply_to)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理后的 topic</span></span><br><span class="line"><span class="comment"># cmd.NBNT7GUJSLQPIZ4LD4VALYXSRRPKWOLNKIC4LRGFOJNFQ43OJTMQ3AIM.scale</span></span><br><span class="line"><span class="comment"># &#123;"cmd", host_id, "scale"&#125;</span></span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>经过初步的格式解析，最后匹配的处理函数如下（重点已使用粗体标注）：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">defp</span> <span class="title">handle_request</span></span>(***&#123;<span class="string">"cmd"</span>, host_id, <span class="string">"scale"</span>&#125;***, body, _reply_to) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">with</span> &#123;<span class="symbol">:ok</span>, scale_request&#125; &lt;- Jason.decode(body),</span><br><span class="line"><span class="comment"># 一些格式确认的相关处理逻辑，略</span></span><br><span class="line">    <span class="keyword">case</span> ***HostCore.Actors.ActorSupervisor.scale_actor(actor_id, count, actor_ref)*** <span class="keyword">do</span></span><br><span class="line">      &#123;<span class="symbol">:error</span>, err&#125; -&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一些处理结果的数据返回包装，略</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">***payload =*** &#123;</span><br><span class="line">    <span class="string">"actor_id"</span>: <span class="string">"MBCFOPM6JW2APJLXJD3Z5O4CN7CPYJ2B4FTKLJUR5YR5MITIU7HD3WD5"</span>,</span><br><span class="line">    <span class="string">"actor_ref"</span>: <span class="string">"wasmcloud.azurecr.io/echo:0.3.4"</span>,</span><br><span class="line">    <span class="string">"count"</span>: <span class="number">1</span></span><br><span class="line">&#125;***,***</span><br></pre></td></tr></table></figure><p>我们看到，其重点在 <code>ActorSupervisor.scale_actor</code> <strong>**</strong>处理，我们再 <code>actor_supervisor.ex</code> 中找到相关处理函数：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scale_actor</span></span>(public_key, desired_count, oci \\ <span class="string">""</span>) <span class="keyword">do</span></span><br><span class="line">    current_instances = find_actor(public_key)</span><br><span class="line">    current_count = current_instances |&gt; Enum.count()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Attempt to retrieve OCI reference from running actor if not supplied</span></span><br><span class="line">    ociref =</span><br><span class="line">      <span class="keyword">cond</span> <span class="keyword">do</span></span><br><span class="line">        oci != <span class="string">""</span> -&gt;</span><br><span class="line">          oci</span><br><span class="line"></span><br><span class="line">        current_count &gt;= <span class="number">1</span> -&gt;</span><br><span class="line">          ActorModule.ociref(current_instances |&gt; List.first())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">true</span> -&gt;</span><br><span class="line">          <span class="string">""</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算出需要 scale 的数量</span></span><br><span class="line"><span class="comment"># 0表示不用管，大于0表示缩容，小于0表示扩容</span></span><br><span class="line">    ***diff = current_count - desired_count***</span><br><span class="line"></span><br><span class="line">    <span class="keyword">cond</span> <span class="keyword">do</span></span><br><span class="line">      <span class="comment"># Current count is desired actor count</span></span><br><span class="line">      ***diff == <span class="number">0</span> -&gt;***</span><br><span class="line">        <span class="symbol">:ok</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># Current count is greater than desired count, terminate instances</span></span><br><span class="line">      ***diff &gt; <span class="number">0</span> -&gt;***</span><br><span class="line">        <span class="comment"># wadm won't use the scale actor call, so we don't care about annotations here</span></span><br><span class="line">        ***terminate_actor(public_key, diff, %&#123;&#125;)***</span><br><span class="line"></span><br><span class="line">      <span class="comment"># Current count is less than desired count, start more instances</span></span><br><span class="line">      ***diff &lt; <span class="number">0</span> &amp;&amp; ociref != <span class="string">""</span> -&gt;***</span><br><span class="line">        if String.starts_with?(ociref, <span class="string">"bindle://"</span>) <span class="keyword">do</span></span><br><span class="line">          start_actor_from_bindle(ociref, abs(diff))</span><br><span class="line">        else</span><br><span class="line">          ***start_actor_from_oci(ociref, abs(diff))***</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">      diff &lt; <span class="number">0</span> -&gt;</span><br><span class="line">        Tracer.set_status(<span class="symbol">:error</span>, <span class="string">"Not allowed to scale actor w/out OCI reference"</span>)</span><br><span class="line">        &#123;<span class="symbol">:error</span>, <span class="string">"Scaling actor up without an OCI reference is not currently supported"</span>&#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>其中重点的处理函数如下：</p><ul><li><strong><em><code>terminate_actor(public_key, diff, %{})</code></em></strong> 缩</li><li><strong><em><code>start_actor_from_oci(ociref, abs(diff))</code></em></strong> 扩</li></ul><p>其对应的函数定义如下</p><p><strong><em>terminate_actor</em></strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Terminate `count` instances of an actor</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">terminate_actor</span></span>(public_key, count, annotations) <span class="keyword">when</span> count &gt; <span class="number">0</span> <span class="keyword">do</span></span><br><span class="line">  <span class="comment"># 根据 public_key 获取存在的 actors</span></span><br><span class="line">actors =</span><br><span class="line">    Registry.lookup(Registry.ActorRegistry, public_key)</span><br><span class="line">    |&gt; Enum.filter(<span class="keyword">fn</span> &#123;pid, _v&#125; -&gt;</span><br><span class="line">      existing = HostCore.Actors.ActorModule.annotations(pid)</span><br><span class="line">      <span class="comment"># Property of maps - map a is contained within b if b.merge(a) == b</span></span><br><span class="line">      Map.merge(existing, annotations) == existing</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">  remaining = length(actors) - count</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止多余的 actor 进程</span></span><br><span class="line">  actors</span><br><span class="line">  |&gt; Enum.take(count)</span><br><span class="line">  |&gt; Enum.map(<span class="keyword">fn</span> &#123;pid, _v&#125; -&gt; pid <span class="keyword">end</span>)</span><br><span class="line">  ***|&gt; Enum.each(<span class="keyword">fn</span> pid -&gt; ActorModule.halt(pid) <span class="keyword">end</span>)***</span><br><span class="line"></span><br><span class="line">  if remaining &lt;= <span class="number">0</span> <span class="keyword">do</span></span><br><span class="line">    HostCore.Actors.ActorRpcSupervisor.stop_rpc_subscriber(public_key)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="symbol">:ok</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># actor_module.ex</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">halt</span></span>(pid) <span class="keyword">do</span></span><br><span class="line">  if Process.alive?(pid), <span class="symbol">do:</span> ***GenServer.call(pid, <span class="symbol">:halt_and_cleanup</span>)***</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong><em>start_actor_from_oci</em></strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_actor_from_oci</span></span>(oci, count \\ <span class="number">1</span>, annotations \\ %&#123;&#125;) <span class="keyword">do</span></span><br><span class="line">  Tracer.with_span <span class="string">"Starting Actor from OCI"</span>, <span class="symbol">kind:</span> <span class="symbol">:server</span> <span class="keyword">do</span></span><br><span class="line">    creds = HostCore.Host.get_creds(oci)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> HostCore.WasmCloud.Native.get_oci_bytes(</span><br><span class="line">           creds,</span><br><span class="line">           oci,</span><br><span class="line">           HostCore.Oci.allow_latest(),</span><br><span class="line">           HostCore.Oci.allowed_insecure()</span><br><span class="line">         ) <span class="keyword">do</span></span><br><span class="line">      &#123;<span class="symbol">:error</span>, err&#125; -&gt;</span><br><span class="line">        Tracer.add_event(<span class="string">"OCI image fetch failed"</span>, <span class="symbol">reason:</span> <span class="string">"<span class="subst">#&#123;inspect(err)&#125;</span>"</span>)</span><br><span class="line">        Tracer.set_status(<span class="symbol">:error</span>, <span class="string">"<span class="subst">#&#123;inspect(err)&#125;</span>"</span>)</span><br><span class="line">        Logger.error(<span class="string">"Failed to download OCI bytes for <span class="subst">#&#123;oci&#125;</span>: <span class="subst">#&#123;inspect(err)&#125;</span>"</span>, <span class="symbol">oci_ref:</span> oci)</span><br><span class="line">        &#123;<span class="symbol">:error</span>, err&#125;</span><br><span class="line"></span><br><span class="line">      &#123;<span class="symbol">:ok</span>, bytes&#125; -&gt;</span><br><span class="line">        Tracer.add_event(<span class="string">"OCI image fetched"</span>, <span class="symbol">byte_size:</span> length(bytes))</span><br><span class="line">        ***start_actor(bytes |&gt; IO.iodata_to_binary(), oci, count, annotations)***</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_actor</span></span>(bytes, oci \\ <span class="string">""</span>, count \\ <span class="number">1</span>, annotations \\ %&#123;&#125;) <span class="keyword">when</span> is_binary(bytes) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> HostCore.WasmCloud.Native.extract_claims(bytes) <span class="keyword">do</span></span><br><span class="line">      &#123;<span class="symbol">:ok</span>, claims&#125; -&gt;</span><br><span class="line">        <span class="comment"># with ... do 的用法就是 with 后面的几个条件都满足，会执行 do</span></span><br><span class="line">        <span class="comment">#    如果有一个不满足，则进入 else，并且携带第一个不满足的 statement 的返回值</span></span><br><span class="line">        <span class="keyword">with</span> %&#123;<span class="symbol">permitted:</span> <span class="keyword">true</span>&#125; &lt;-</span><br><span class="line">               HostCore.Policy.Manager.evaluate_action(</span><br><span class="line">                 %&#123;</span><br><span class="line">                   <span class="symbol">publicKey:</span> <span class="string">""</span>,</span><br><span class="line">                   <span class="symbol">contractId:</span> <span class="string">""</span>,</span><br><span class="line">                   <span class="symbol">linkName:</span> <span class="string">""</span>,</span><br><span class="line">                   <span class="symbol">capabilities:</span> [],</span><br><span class="line">                   <span class="symbol">issuer:</span> <span class="string">""</span>,</span><br><span class="line">                   <span class="symbol">issuedOn:</span> <span class="string">""</span>,</span><br><span class="line">                   <span class="symbol">expiresAt:</span> DateTime.utc_now() |&gt; DateTime.add(<span class="number">60</span>) |&gt; DateTime.to_unix(),</span><br><span class="line">                   <span class="symbol">expired:</span> <span class="keyword">false</span></span><br><span class="line">                 &#125;,</span><br><span class="line">                 %&#123;</span><br><span class="line">                   <span class="symbol">publicKey:</span> claims.public_key,</span><br><span class="line">                   <span class="symbol">issuer:</span> claims.issuer,</span><br><span class="line">                   <span class="symbol">contractId:</span> <span class="keyword">nil</span>,</span><br><span class="line">                   <span class="symbol">linkName:</span> <span class="keyword">nil</span></span><br><span class="line">                 &#125;,</span><br><span class="line">                 <span class="variable">@start_actor</span></span><br><span class="line">               ),</span><br><span class="line">             <span class="keyword">false</span> &lt;- other_oci_already_running?(oci, claims.public_key) <span class="keyword">do</span></span><br><span class="line">          <span class="comment"># Start `count` instances of this actor</span></span><br><span class="line">          <span class="keyword">case</span> <span class="number">1</span>..count</span><br><span class="line">               |&gt; Enum.reduce_while([], <span class="keyword">fn</span> _count, pids -&gt;</span><br><span class="line">                 <span class="keyword">case</span> ***DynamicSupervisor.start_child***(</span><br><span class="line">                        __MODULE_<span class="number">_</span>,</span><br><span class="line">                        ***&#123;HostCore.Actors.ActorModule, &#123;claims, bytes, oci, annotations&#125;***&#125;</span><br><span class="line">                      ) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>其重点在于 <strong><em>DynamicSupervisor.start_child，</em></strong>即根据实际的需求数量，启动对应的 actor process（注意：本文提到的 process 为 elixir process区别于 system process）。</p><h1 id="wasm执行"><a href="#wasm执行" class="headerlink" title="wasm执行"></a>wasm执行</h1><p>根据上面的 start_actor 梳理，涉及到的核心代码如下：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_actor_from_oci</span></span>(oci, count \\ <span class="number">1</span>, annotations \\ %&#123;&#125;) <span class="keyword">do</span></span><br><span class="line"><span class="keyword">case</span> ***HostCore.WasmCloud.Native.get_oci_bytes***(</span><br><span class="line">           creds,</span><br><span class="line">           oci,</span><br><span class="line">           HostCore.Oci.allow_latest(),</span><br><span class="line">           HostCore.Oci.allowed_insecure()</span><br><span class="line">         ) <span class="keyword">do</span></span><br><span class="line">***&#123;<span class="symbol">:ok</span>, bytes&#125; -&gt; start_actor(bytes |&gt; IO.iodata_to_binary(), oci, count, annotations)***</span><br></pre></td></tr></table></figure><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_actor</span></span>(bytes, oci \\ <span class="string">""</span>, count \\ <span class="number">1</span>, annotations \\ %&#123;&#125;) <span class="keyword">when</span> is_binary(bytes) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> ***HostCore.WasmCloud.Native.extract_claims(bytes)*** <span class="keyword">do</span></span><br><span class="line">      &#123;<span class="symbol">:ok</span>, claims&#125; -&gt;</span><br><span class="line">***DynamicSupervisor.start_child***(</span><br><span class="line">                        __MODULE_<span class="number">_</span>,</span><br><span class="line">                        ***&#123;HostCore.Actors.ActorModule, &#123;claims, bytes, oci, annotations&#125;***&#125;</span><br><span class="line">                      )</span><br></pre></td></tr></table></figure><p><strong><em>HostCore.WasmCloud.Native</em></strong> 的文件如下：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">HostCore.WasmCloud.Native</span></span> <span class="keyword">do</span></span><br><span class="line">  <span class="variable">@moduledoc</span> <span class="keyword">false</span></span><br><span class="line">  ***<span class="keyword">use</span> Rustler, <span class="symbol">otp_app:</span> <span class="symbol">:host_core</span>, <span class="symbol">crate:</span> <span class="symbol">:hostcore_wasmcloud_native***</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">extract_claims</span></span>(_bytes), <span class="symbol">do:</span> error()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">defp</span> <span class="title">error</span></span>, <span class="symbol">do:</span> <span class="symbol">:erlang</span>.nif_error(<span class="symbol">:nif_not_loaded</span>)</span><br></pre></td></tr></table></figure><p>其中用到了 Rustler 库，这个库的作用：<strong><em>Safe Rust bridge for creating Erlang NIF functions</em></strong></p><p>在 <code>native.ex</code> 声明，在 rust 项目中实现，比如 <code>extract_claims(_bytes)</code>，在 <a href="http://lib.rs" target="_blank" rel="noopener">lib.rs</a> 文件中</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[rustler::nif(schedule = <span class="meta-string">"DirtyIo"</span>)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_oci_bytes</span></span>(</span><br><span class="line">    creds_override: <span class="built_in">Option</span>&lt;HashMap&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;&gt;,</span><br><span class="line">    oci_ref: <span class="built_in">String</span>,</span><br><span class="line">    allow_latest: <span class="built_in">bool</span>,</span><br><span class="line">    allowed_insecure: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">) -&gt; <span class="built_in">Result</span>&lt;(Atom, <span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt;), Error&gt; &#123;</span><br><span class="line">    task::TOKIO.block_on(async &#123;</span><br><span class="line">        <span class="keyword">let</span> path =</span><br><span class="line">            <span class="keyword">match</span> oci::fetch_oci_path(&amp;oci_ref, allow_latest, allowed_insecure, creds_override)</span><br><span class="line">                .await</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="literal">Ok</span>(p) =&gt; p,</span><br><span class="line">                <span class="literal">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="literal">Err</span>(rustler::Error::Term(<span class="built_in">Box</span>::new(<span class="built_in">format!</span>(<span class="string">"&#123;&#125;"</span>, e)))),</span><br><span class="line">            &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> output = <span class="built_in">Vec</span>::new();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> file = tokio::fs::File::open(path).await.map_err(to_rustler_err)?;</span><br><span class="line">        file.read_to_end(&amp;<span class="keyword">mut</span> output)</span><br><span class="line">            .await</span><br><span class="line">            .map_err(to_rustler_err)?;</span><br><span class="line">        <span class="literal">Ok</span>((atoms::ok(), output))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;组成&quot;&gt;&lt;a href=&quot;#组成&quot; class=&quot;headerlink&quot; title=&quot;组成&quot;&gt;&lt;/a&gt;组成&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;模块&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;

      
    
    </summary>
    
      <category term="WASM" scheme="https://rovast.github.io/categories/WASM/"/>
    
    
  </entry>
  
  <entry>
    <title>meshery 初步试用 &amp; Service Mesh Performance(SMP) 了解</title>
    <link href="https://rovast.github.io/2022/01/06/try-meshery/"/>
    <id>https://rovast.github.io/2022/01/06/try-meshery/</id>
    <published>2022-01-06T08:18:33.000Z</published>
    <updated>2022-09-28T06:14:26.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="First-Try-Meshery"><a href="#First-Try-Meshery" class="headerlink" title="First Try Meshery"></a>First Try Meshery</h1><p>Created: January 6, 2022 11:02 AM</p><h1 id="零、总结"><a href="#零、总结" class="headerlink" title="零、总结"></a>零、总结</h1><p><strong>SMP 是用来进行 Service Mesh 的性能测试而生的，并非实际的应用或集群的遥测。它定义了一致的性能测试标准，便于多 Service Mesh 进行统一横向性能比较(apples to apples performance comparisons)。</strong></p><p><strong>在 Mesh 和 Application 的遥测方面，Meshery 是通过接入 Grafana 或 Promethues 的方式来满足需求。</strong></p><h2 id="0-1-SMP（Service-Mesh-Performance）——-Service-Mesh-性能测试（详情见-2-5-章节）"><a href="#0-1-SMP（Service-Mesh-Performance）——-Service-Mesh-性能测试（详情见-2-5-章节）" class="headerlink" title="0.1 SMP（Service Mesh Performance）—— Service Mesh 性能测试（详情见 2.5 章节）"></a>0.1 SMP（Service Mesh Performance）—— Service Mesh 性能测试（详情见 2.5 章节）</h2><p>SMP 是用来测试 Service Mesh 的性能表现的统一协议（数据格式）。通过一致的 protobuf 数据格式（在 Meshery 的源码中，就是 import 了 service-mesh-performance 的 go sdk），来完成不同 Service Mesh 的性能横向比较。</p><p><em>协议</em></p><img src="/2022/01/06/try-meshery/Untitled.png" class="img"><p><em>按照定义的 metadata 数据接入新 Service Mesh</em></p><img src="/2022/01/06/try-meshery/Untitled-1.png" class="img"><p><em>运行性能测试（图中的 11 是倒计时，点击 run test 后，就会产生一个大大的倒计时数字）</em></p><img src="/2022/01/06/try-meshery/Untitled-2.png" class="img"><p><em>不同 Service Mesh 性能横向比较</em></p><img src="/2022/01/06/try-meshery/Untitled-3.png" class="img"><h2 id="0-2-SMI（Service-Mesh-Interface）"><a href="#0-2-SMI（Service-Mesh-Interface）" class="headerlink" title="0.2 SMI（Service Mesh Interface）"></a>0.2 SMI（Service Mesh Interface）</h2><p>这一块在平台上的体现是 SMI 协议合规度检测，从协议定义的 Traffic Spec、Traffic Split、Traffic Access 三个方向进行检测（由于暂未找到应用相关的数据，尚不知晓关于流量方便的具体平台展现形式）。</p><img src="/2022/01/06/try-meshery/Untitled-4.png" class="img"><h2 id="0-3-文档导读"><a href="#0-3-文档导读" class="headerlink" title="0.3 文档导读"></a>0.3 文档导读</h2><p>由于 Meshery 是 Layer5 的官方标准实现，此次调研以 Meshery 的平台为主要切入点，看其标准在平台上的具体落实情况来进一步了解，其调研的数据主要来源以下三个地方</p><ol><li>官方文档（含 Github）</li><li>官方 YouTube 频道</li><li>官方提供的在线实验</li></ol><h1 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h1><p>使用 layer5 官方提供的在线 lab 来运行。</p><p><a href="https://layer5.io/learn/service-mesh-labs" target="_blank" rel="noopener">Interactive Service Mesh Labs</a></p><img src="/2022/01/06/try-meshery/Untitled-5.png" class="img"><p>有以下两点需要注意：</p><ol><li><em>按照步骤进行运行即可，需要注意的是，当我们正常安装 Meshery 后，添加 Provider 一般是不生效的，我们需要点击 terminal 的  + 号，选择 “Select port to view on Host1”，并且输入端口后 9081 才能访问系统。</em></li><li><p><em>另外，当我们正常安装完成后，可查看 meshery 状态都是 ready 后，方可打开 web</em></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ mesheryctl system status</span><br><span class="line">NAME                    READY   STATUS  RESTARTS        AGE   </span><br><span class="line">meshery                 1/1     Running 0               2m30s</span><br><span class="line">meshery-broker          1/1     Running 0               1m7s </span><br><span class="line">meshery-linkerd         1/1     Running 0               2m30s</span><br><span class="line">meshery-operator        2/2     Running 0               2m30s</span><br><span class="line"></span><br><span class="line">Meshery endpoint is http://localhost:9081</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>通过体验 Meshery 的安装流程，我们发现其安装及其简单，通过一条指令即可完成，这是我们需要思考的，如何让用户以最小的心智来试用。</p></blockquote><p>除了安装友好，在进入系统后，我们安装对应的 service mesh，或者安装示例程序，都是直接在平台上点击操作，无疑大大简化了用户的上手负担。</p><blockquote></blockquote><h1 id="二、平台模块速览"><a href="#二、平台模块速览" class="headerlink" title="二、平台模块速览"></a>二、平台模块速览</h1><p><em>说明：由于实验环境很多数据缺失，所以部分页面从 YouTube 或其他地方截图所得，来源见附录。</em></p><h2 id="2-1-平台初始化配置"><a href="#2-1-平台初始化配置" class="headerlink" title="2.1 平台初始化配置"></a>2.1 平台初始化配置</h2><p>平台初始化配置主要完成以下工作：1、添加 Provider；2、登录</p><p><em>Choose a provider ↓</em></p><img src="/2022/01/06/try-meshery/Untitled-6.png" class="img"><img src="/2022/01/06/try-meshery/Untitled-7.png" class="img"><p><em>Login ↓</em></p><img src="/2022/01/06/try-meshery/Untitled-8.png" class="img"><h2 id="2-2-平台菜单一览"><a href="#2-2-平台菜单一览" class="headerlink" title="2.2 平台菜单一览"></a>2.2 平台菜单一览</h2><p>菜单分为以下几个部分</p><ol><li><strong><em>Performance(SMP). 用来对 Service Mesh 进行性能测试。</em></strong></li><li><strong><em>Conformance(SMI). 用来测试 Service Mesh 的协议合规度检测。</em></strong></li><li><strong><em>Lifecycle. 用来管理不同的 Service Mesh。</em></strong></li></ol><p><em>SMP&amp;SMI ↓</em></p><img src="/2022/01/06/try-meshery/Untitled-9.png" class="img"><p><em>Configuration ↓</em></p><img src="/2022/01/06/try-meshery/Untitled-10.png" class="img"><p><em>Lifecycle&amp;Service Meshes ↓</em></p><img src="/2022/01/06/try-meshery/Untitled-11.png" class="img"><h2 id="2-3-Dashboard"><a href="#2-3-Dashboard" class="headerlink" title="2.3 Dashboard"></a>2.3 Dashboard</h2><p><em>Dashboard without data</em></p><img src="/2022/01/06/try-meshery/Untitled-12.png" class="img"><p><em>Dashboard with data</em></p><ol><li><em>Service Mesh 看板显示了当前接入的 mesh 和组件</em></li><li><em>Metrics 直接嵌入的 Grafana 或 Promethues 面板</em></li></ol><img src="/2022/01/06/try-meshery/Untitled-13.png" class="img"><h2 id="2-4-Install-Service-Mesh"><a href="#2-4-Install-Service-Mesh" class="headerlink" title="2.4 Install Service Mesh"></a>2.4 Install Service Mesh</h2><p>通过 Meshery 可以管理多种 Service Mesh，我们可以在 meshery 中直接添加 service mesh 和示例程序。</p><p><em>Linkerd Adapter</em></p><img src="/2022/01/06/try-meshery/Untitled-14.png" class="img"><p><em>点击加号，添加 Linkerd Service Mesh</em></p><img src="/2022/01/06/try-meshery/Untitled-15.png" class="img"><p><em>点击加号，添加示例程序</em></p><img src="/2022/01/06/try-meshery/Untitled-16.png" class="img"><h2 id="2-5-Performance"><a href="#2-5-Performance" class="headerlink" title="2.5 Performance"></a>2.5 Performance</h2><h3 id="2-5-1-Performance-Dashboard"><a href="#2-5-1-Performance-Dashboard" class="headerlink" title="2.5.1 Performance Dashboard"></a>2.5.1 Performance Dashboard</h3><p><em>Performance Dashboard without data</em></p><img src="/2022/01/06/try-meshery/Untitled-17.png" class="img"><p><em>Performance Dashboard with data</em></p><img src="/2022/01/06/try-meshery/Untitled-18.png" class="img"><h3 id="2-5-2-Profiles"><a href="#2-5-2-Profiles" class="headerlink" title="2.5.2 Profiles"></a>2.5.2 Profiles</h3><p><em>SMP Profiles without data</em></p><img src="/2022/01/06/try-meshery/Untitled-19.png" class="img"><p><em>SMP Profiles 列表</em></p><img src="/2022/01/06/try-meshery/Untitled-20.png" class="img"><p><em>查看 SMP Profile 详情以及具体测试数据结果</em></p><p>![Meshery - The Service Mesh Manager 35-47 screenshot.png]<img src="/2022/01/06/try-meshery/Meshery_-_The_Service_Mesh_Manager_35-47_screenshot.png" class="img"></p><h3 id="2-5-1-Add-Profile"><a href="#2-5-1-Add-Profile" class="headerlink" title="2.5.1 Add Profile"></a>2.5.1 Add Profile</h3><p><em>Profile 表单</em></p><img src="/2022/01/06/try-meshery/Untitled-1.png" class="img"><p><em>SMP Profile Service Mesh Options，选择具体的 Service Mesh</em></p><img src="/2022/01/06/try-meshery/Untitled-21.png" class="img"><p><em>SMP  Profile Service Mesh Load Generator，选择负载产生器</em></p><img src="/2022/01/06/try-meshery/Untitled-22.png" class="img"><img src="/2022/01/06/try-meshery/Untitled-23.png" class="img"><p><em>SMP Profile Advanced Options，进一步定制压测的请求信息</em></p><img src="/2022/01/06/try-meshery/Untitled-24.png" class="img"><h3 id="2-5-4-Run-Test"><a href="#2-5-4-Run-Test" class="headerlink" title="2.5.4 Run Test"></a>2.5.4 Run Test</h3><p><em>Run test 运行测试，倒计时</em></p><img src="/2022/01/06/try-meshery/Untitled-2.png" class="img"><p><em>View Performance Result 查看测试结果</em></p><img src="/2022/01/06/try-meshery/Untitled-25.png" class="img"><p><strong><em>Comparison 比较同一个 Profile 不同测试结果</em></strong></p><ol><li><em>这一点和 SMP 文档中 apple to apple performance comparison 相对应</em></li></ol><img src="/2022/01/06/try-meshery/Untitled-3.png" class="img"><h2 id="2-6-Add-Service-Mesh-Metrics"><a href="#2-6-Add-Service-Mesh-Metrics" class="headerlink" title="2.6 Add Service Mesh Metrics"></a>2.6 Add Service Mesh Metrics</h2><p><em>Configure Service Mesh Metrics</em></p><img src="/2022/01/06/try-meshery/Untitled-26.png" class="img"><p><em>Add Grafana</em></p><img src="/2022/01/06/try-meshery/Untitled-27.png" class="img"><p><em>Add Promethues</em></p><img src="/2022/01/06/try-meshery/Untitled-28.png" class="img"><p><em>Environment &amp; In Cluster Deployment</em></p><img src="/2022/01/06/try-meshery/Untitled-29.png" class="img"><p><em>Service Meshes</em></p><img src="/2022/01/06/try-meshery/Untitled-30.png" class="img"><h2 id="2-7-Conformance-SMI"><a href="#2-7-Conformance-SMI" class="headerlink" title="2.7 Conformance(SMI)"></a>2.7 Conformance(SMI)</h2><p><em>在 Manage Service Mesh 地方执行 SMI 协议检测</em></p><img src="/2022/01/06/try-meshery/Untitled-31.png" class="img"><p><em>Service Mesh Interface Conformance Results, SMI 协议标准合规情况检测</em></p><img src="/2022/01/06/try-meshery/Untitled-4.png" class="img"><p><em>摘自文档的更多检查结果</em></p><img src="/2022/01/06/try-meshery/Untitled-32.png" class="img"><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><ul><li><p>YouTube, <em>Meshery - The Service Mesh Manager</em></p><p>  <a href="https://www.youtube.com/watch?v=mU8qHUGYsk8&amp;t=2146s" target="_blank" rel="noopener">Meshery - The Service Mesh Manager</a></p></li><li><p><em>Performance Management 文档</em></p><p>  <a href="https://docs.meshery.io/functionality/performance-management" target="_blank" rel="noopener">Performance Management</a></p></li><li><p><em>Run SMI Conformance 文档</em></p><p>  <a href="https://docs.meshery.io/guides/smi-conformance" target="_blank" rel="noopener">Running SMI Conformance Tests</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;First-Try-Meshery&quot;&gt;&lt;a href=&quot;#First-Try-Meshery&quot; class=&quot;headerlink&quot; title=&quot;First Try Meshery&quot;&gt;&lt;/a&gt;First Try Meshery&lt;/h1&gt;&lt;p&gt;Created: J
      
    
    </summary>
    
      <category term="云原生" scheme="https://rovast.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>优雅统一处理 JS 错误(Sentry 上报场景)</title>
    <link href="https://rovast.github.io/2021/09/18/elegant-handler-error-with-sentry/"/>
    <id>https://rovast.github.io/2021/09/18/elegant-handler-error-with-sentry/</id>
    <published>2021-09-18T13:28:30.000Z</published>
    <updated>2022-09-28T06:14:26.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>Sentry 可以有效帮助我们发现项目中存在的问题。经过一段时间的使用和了解，我们对其中的错误进行了汇总。</p><p><img src="/assets/hook-sentry.png" alt="Untitled"></p><p><img src="/assets/hook-sentry1.png" alt="Untitled"></p><p><img src="/assets/hook-sentry2.png" alt="Untitled"></p><p>我们发现有大量的错误是由于 HTTP 请求 400 或者 401 导致。</p><h1 id="二、错误分析"><a href="#二、错误分析" class="headerlink" title="二、错误分析"></a>二、错误分析</h1><p>现有的 MSP 请求封装了统一的 request 请求，对 <code>request.repsonse</code> 进行了 <code>interceptor</code> 操作。即：进行了 <code>response</code> 的统一处理，由自己处理完后再返回给业务层。</p><p>之前我们在 <code>interceptors.response</code> 中对部分业务码进行了统一处理，如：401 未授权跳转到登录页。</p><p>之前为了忽略部分状态码，直接进行了 <code>return</code> 操作，此操作后，业务层会进入 <code>Promise.then</code> 环节。由于在 http status 400 或 401 情况下，API 返回的数据格式异常，所以导致了 <code>Cannot read property of null</code> 的错误。</p><p><code>request-helper.js</code> 的 return 操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (statusCode === <span class="number">401</span>) &#123; <span class="comment">// 未授权的登录，这种情况需要重定向到登录页面</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.location.pathname === <span class="string">'/login'</span>) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  Modal.confirm(&#123;</span><br><span class="line">    title: <span class="string">'提示'</span>,</span><br><span class="line">    content: <span class="string">'您当前处于未登录状态，部分功能无法使用'</span>,</span><br><span class="line">    okText: <span class="string">'去登录'</span>,</span><br><span class="line">    cancelText: <span class="string">'停留在此页'</span>,</span><br><span class="line">    onOk: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      store.dispatch(<span class="string">'user/resetToken'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">window</span>.location.reload()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    onCancel: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>user.js</code> 读取</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">refreshToken(&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      refreshToken().then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; data &#125; = response <span class="comment">// 拿不到有效的数据，所以 data 为 null</span></span><br><span class="line">        commit(<span class="string">'SET_TOKEN'</span>, data)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="三、处理分析"><a href="#三、处理分析" class="headerlink" title="三、处理分析"></a>三、处理分析</h1><p>关于部分请求的错误，如 401、403我们需要进行放行。理由如下</p><ul><li>401，用户没有授权，属于正常业务逻辑，不需要上报</li><li>400，参数认证失败，属于正常的业务逻辑，不需要上报</li><li>500，待定，此类问题一般由于内部错误导致（还有发版时会遇到），可以先正常上报。</li></ul><p>所以我们看到，需要对 reponse 进行统一的兜底处理。但是我们发起方是在业务代码里(<code>vue</code>文件），所以是否存在 业务层的统一处理？</p><p>答案是：存在的。借助 <code>window.onunhandledrejection</code></p><p>统一处理异常 <code>main.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onunhandledrejection = <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Promise failed: <span class="subst">$&#123;error.reason&#125;</span>`</span>)</span><br><span class="line">  error.preventDefault() <span class="comment">// 抑制终端报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务 <code>user.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      getInfo().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        commit(<span class="string">'SET_USERNAME'</span>, username)</span><br><span class="line">        resolve(username)</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'业务自行处理异常'</span>)</span><br><span class="line">        reject(<span class="string">'我抛给了统一处理'</span>)</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure><p>终端输出</p><p><img src="/assets/hook-sentry3.png" alt="Untitled"></p><p>猜想：sentry 或者 vue，会不会使用这种方式统一捕捉错误。如果大家都用了，这个错误就不能有效传导了。所以我们需要保留其他已注册函数的处理句柄。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _oldHandler = <span class="built_in">window</span>.onunhandledrejection</span><br><span class="line"><span class="built_in">window</span>.onunhandledrejection = <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  _oldHandler.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Promise failed1: <span class="subst">$&#123;error.reason&#125;</span>`</span>)</span><br><span class="line">  error.preventDefault()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> _oldHandler2 = <span class="built_in">window</span>.onunhandledrejection</span><br><span class="line"><span class="built_in">window</span>.onunhandledrejection = <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  _oldHandler2.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Promise failed2: <span class="subst">$&#123;error.reason&#125;</span>`</span>)</span><br><span class="line">  error.preventDefault()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过保留上次处理函数句柄的方式，可以有效传导</p><p><img src="/assets/hook-sentry4.png" alt="Untitled"></p><h1 id="四、实现"><a href="#四、实现" class="headerlink" title="四、实现"></a>四、实现</h1><p>综上，我们设定一个全局的错误处理函数来进行错误捕捉，而不用逐个去修改源码。处理方式如下</p><ul><li>1）request 层正常 reject 所有错误（即：正常向上 throw error）</li><li>2）在 main.js 中注册全局的错误处理函数</li></ul><h2 id="4-1-正常-reject-error"><a href="#4-1-正常-reject-error" class="headerlink" title="4.1 正常 reject error"></a>4.1 正常 reject error</h2><p>之前由于其他地方零零散散的会上报错误，部分被注释了，现在统一打开，正常在 Promoise.reject</p><h2 id="4-2-注册全局处理函数"><a href="#4-2-注册全局处理函数" class="headerlink" title="4.2 注册全局处理函数"></a>4.2 注册全局处理函数</h2><p><code>main.js</code> 注册全局处理函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; globalErrorHandler &#125; <span class="keyword">from</span> <span class="string">'./error-handler'</span></span><br><span class="line">initSentry(Vue, router)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自己的全局处理函数一定要在 sentry 后面，这样可以拦截到他的错误上报函数，进而进行 hook</span></span><br><span class="line">globalErrorHandler()</span><br></pre></td></tr></table></figure><p><code>error-handler.js</code> 处理错误</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义需要忽略上报的 http status code</span></span><br><span class="line"><span class="keyword">const</span> SkipHttpStatus = [<span class="number">400</span>, <span class="number">401</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理全局错误</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">globalErrorHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> originalErrorHandler = <span class="built_in">window</span>.onunhandledrejection</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.onunhandledrejection = <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> request = error.reason.request</span><br><span class="line">    <span class="keyword">if</span> (request) &#123; <span class="comment">// 捕捉请求类错误，统一处理状态码</span></span><br><span class="line">      <span class="comment">// http status code</span></span><br><span class="line">      <span class="keyword">const</span> status = error.reason.request.status</span><br><span class="line">      <span class="keyword">if</span> (SkipHttpStatus.includes(status)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Ignore request error, cause the http status is [%s]'</span>, status)</span><br><span class="line">        error.preventDefault() <span class="comment">// 取消控制台的报错</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他情况，正常上报错误即可，这里主要就是 sentry 注册的处理函数</span></span><br><span class="line">    originalErrorHandler.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>) <span class="comment">// 执行之前注册的错误处理函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里需要注意的是，需要先拦截到 sentry 的钩子，然后进行对应的情况处理。</p></blockquote><p>当满足我们忽略条件时，不再进行上报。其他情况，正常上报</p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><ol><li>不要干扰正常的异常抛出流程，该抛出异常时，大胆抛出</li><li><p>使用统一处理函数 <code>window.onunhandledrejection</code> 进行统一错误捕获。基本上目前主流的语言(或框架)都会提供统一的错误处理机制，所以首先想到<br>的一定是“统一”处理，而不是每个业务代码都去改动。</p><ul><li>PHP 错误全局捕获 <code>set_exception_handler</code> <code>set_error_handler</code></li><li><a href="https://www.php.net/manual/en/function.set-error-handler.php" target="_blank" rel="noopener">https://www.php.net/manual/en/function.set-error-handler.php</a></li><li><a href="https://www.php.net/manual/en/function.set-exception-handler.php" target="_blank" rel="noopener">https://www.php.net/manual/en/function.set-exception-handler.php</a></li></ul></li><li><p>注意使用 <code>window.onunhandledrejection</code> 时，不要干扰已经注册的处理函数，所以可以先“暂存”，之后再“恢复”。这个和 PHP 内核拓展开发时，hook<br>内置的函数有异曲同工之妙。</p><ul><li>PHP 内核示例<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过在 Module Init 环节拦截函数入口，进而 Hook，进行一系列自定义处理</span></span><br><span class="line">PHP_MINIT_FUNCTION(skywalking)</span><br><span class="line">&#123;</span><br><span class="line">    ZEND_INIT_MODULE_GLOBALS(skywalking, php_skywalking_init_globals, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//data_register_hashtable();</span></span><br><span class="line">    REGISTER_INI_ENTRIES();</span><br><span class="line">    <span class="comment">/* If you have INI entries, uncomment these lines</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (SKYWALKING_G(enable))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (strcasecmp(<span class="string">"cli"</span>, sapi_module.name) == <span class="number">0</span> &amp;&amp; cli_debug == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用户自定义函数执行器(php脚本定义的类、函数)</span></span><br><span class="line">        ori_execute_ex = zend_execute_ex;</span><br><span class="line">        zend_execute_ex = sky_execute_ex;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内部函数执行器(c语言定义的类、函数)</span></span><br><span class="line">        ori_execute_internal = zend_execute_internal;</span><br><span class="line">        zend_execute_internal = sky_execute_internal;</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h1&gt;&lt;p&gt;Sentry 可以有效帮助我们发现项目中存在的问题。经过一段时间的使用和了解，我们对其中的错误进行了汇总。&lt;/p&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
      <category term="云原生" scheme="https://rovast.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
      <category term="APM" scheme="https://rovast.github.io/categories/APM/"/>
    
    
      <category term="APM" scheme="https://rovast.github.io/tags/APM/"/>
    
  </entry>
  
  <entry>
    <title>初探 http-streaming</title>
    <link href="https://rovast.github.io/2021/04/07/http-straming-in-js/"/>
    <id>https://rovast.github.io/2021/04/07/http-straming-in-js/</id>
    <published>2021-04-07T02:22:37.000Z</published>
    <updated>2022-09-28T06:14:26.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>HTTP 流简单的理解为：服务端维持一个 HTTP 连接，通过这个 HTTP 连接源源不断、持续的输出内容至客户端。相较于我们常见的 HTTP 请求(一次返回)，流处理的特点在于持续返回。</p><p>我们举个简单的应用场景：股票网站的股价更新。你可以使用轮询的方式，前端设置定时器周期性的请求股价接口来刷新股价。除此之外，可以使用 HTTP Streaming 的方式，只需要维持一个 HTTP 链接，就可以由后端自行将最新的股价信息 Push 到客户端来完成实时刷新。</p><p>同时需要注意，为了实现这种持续返回的效果，服务端需要在客户端返回的 Header 中设置 <code>Transfer Encoding: chunked</code> [2]。</p><blockquote><p>To achieve an indefinite response, the server must respond to client requests by specifying Transfer Encoding: chunked in the header. This sets up a persistent connection from server to client and allows the server to send response data in chunks of newline-delimited strings. These chunks of data can then be received and processed on-the-fly by the client.</p></blockquote><h2 id="服务端初体验"><a href="#服务端初体验" class="headerlink" title="服务端初体验"></a>服务端初体验</h2><p>我们使用 php fpm + nginx，来完成服务端的 http 流输出。PHP 代码如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ob_get_level() == <span class="number">0</span>) ob_start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ($i = <span class="number">0</span>; $i&lt;<span class="number">10</span>; $i++)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;br&gt; Line to show. At"</span>.date(<span class="string">'Y-m-d H:i:s'</span>);</span><br><span class="line">    <span class="keyword">echo</span> str_pad(<span class="string">''</span>,<span class="number">4096</span>).<span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    ob_flush();</span><br><span class="line">    flush();</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Done."</span>;</span><br><span class="line"></span><br><span class="line">ob_end_flush();</span><br></pre></td></tr></table></figure><p>我们看到其中有 <code>str_pad(&#39;&#39;,4096)</code>，为填充输出缓冲区，进而保障每次 flush 都有数据能输出到客户端。因为我们的服务经过 Nginx，而 Nginx 的 proxy_buffer_size [3] 默认是 4k，所以我们需要填充完缓冲区后，才能保证每次的 Server 端输出可以直接打到客户端。（当然了，你也可以关闭 Nginx 的缓冲区设置）</p><p>其输出为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Line to show. At2021-04-11 01:54:52</span><br><span class="line">Line to show. At2021-04-11 01:54:54</span><br><span class="line">Line to show. At2021-04-11 01:54:56</span><br><span class="line">Line to show. At2021-04-11 01:54:58</span><br><span class="line">Line to show. At2021-04-11 01:55:00</span><br><span class="line">Line to show. At2021-04-11 01:55:02</span><br><span class="line">Line to show. At2021-04-11 01:55:04</span><br><span class="line">Line to show. At2021-04-11 01:55:06</span><br><span class="line">Line to show. At2021-04-11 01:55:08</span><br><span class="line">Line to show. At2021-04-11 01:55:10 Done.</span><br></pre></td></tr></table></figure></p><p>对于客户端，我们也有简单的代码验证，关注浏览器开发者工具即可<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watchResource</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">  xhr.open(<span class="string">"GET"</span>, url, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  xhr.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState &gt;= <span class="number">3</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">      callback(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  xhr.send();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> xhr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">watchResource(<span class="string">"/streaming.php"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>在这种情况下，每次后端有新的数据推送过来时，都会触发 <code>xhr.onreadystatechange</code> 事件，进而进入回调函数。</p><p>关于 xhr.onreadystatechange 的 readState 状态值含义如下[1]：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0The request is not initialized.</span><br><span class="line">1The request has been set up.</span><br><span class="line">2The request has been sent.</span><br><span class="line">3The request is in process.</span><br><span class="line">4The request is completed.</span><br></pre></td></tr></table></figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="HTTP-Streaming-VS-WebSocket"><a href="#HTTP-Streaming-VS-WebSocket" class="headerlink" title="HTTP Streaming VS WebSocket"></a>HTTP Streaming VS WebSocket</h3><p>两者的模式和使用场景不同，最明显的区别</p><ul><li>HTTP Streaming 是 Server Push，数据流向是单向的，由服务器推送给客户端。</li><li>WebSocket 是双向通信，客户端可以和服务端进行交互通信。</li></ul><h3 id="以容器云为例的应用场景"><a href="#以容器云为例的应用场景" class="headerlink" title="以容器云为例的应用场景"></a>以容器云为例的应用场景</h3><p>以容器云平台为例，我们需要在平台上对容器进行简单的管理，其管理包括：</p><ul><li>场景1：持续获取容器的运行日志，即容器终端持续输出的日志(view container logs)</li><li>场景2：远程登录至容器终端(exec container terminal)</li></ul><h4 id="场景1情况下，我们需要持续获取终端的日志输出，并且数据的流向是单向的：即服务端有新的日志输出就推送至客户端"><a href="#场景1情况下，我们需要持续获取终端的日志输出，并且数据的流向是单向的：即服务端有新的日志输出就推送至客户端" class="headerlink" title="场景1情况下，我们需要持续获取终端的日志输出，并且数据的流向是单向的：即服务端有新的日志输出就推送至客户端"></a>场景1情况下，我们需要持续获取终端的日志输出，并且数据的流向是单向的：即服务端有新的日志输出就推送至客户端</h4><p>在这种情况下，我们可以采用 HTTP Streaming 的方式来完成需求，其前端的代码简化如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听 url 的输出，每次触发后进入 callback 回调</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watchResource</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">  xhr.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">  xhr.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState &gt;= <span class="number">3</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">      callback(xhr.responseText)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  xhr.send()</span><br><span class="line">  <span class="keyword">return</span> xhr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 持续获取日志用于显示</span></span><br><span class="line"><span class="keyword">this</span>.logText = <span class="string">''</span></span><br><span class="line">watchResource(<span class="string">'/logs'</span>, res =&gt; &#123;</span><br><span class="line">  <span class="keyword">this</span>.logText += res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="场景2情况下，数据是双向交互的，我们选择使用-Websocket"><a href="#场景2情况下，数据是双向交互的，我们选择使用-Websocket" class="headerlink" title="场景2情况下，数据是双向交互的，我们选择使用 Websocket"></a>场景2情况下，数据是双向交互的，我们选择使用 Websocket</h4><p>此场景下，用户输入 command 后，服务端响应后返回至前端，是典型的双向通信场景，使用 websocket 来完成需求。</p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>在实际操作过程中，还是有些注意点需要提及。</p><ol><li>服务端的数据如果经过 Nginx 转发，需要注意 <code>proxy_buffer</code> 配置。不然会出现服务端服务有持续输出，经过 Nginx 后不一定有输出的情况。</li><li>客户端在处理完流数据后，记得在合适的析构时期断开连接。如在 <code>unmount</code> 组件时进行 <code>xhr.abort()</code></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] XMLHttpRequest WIKI <a href="https://www.wikiwand.com/en/XMLHttpRequest" target="_blank" rel="noopener">https://www.wikiwand.com/en/XMLHttpRequest</a></li><li>[2] What is HTTP Streaming? <a href="https://www.pubnub.com/learn/glossary/what-is-http-streaming/" target="_blank" rel="noopener">https://www.pubnub.com/learn/glossary/what-is-http-streaming/</a></li><li>[3] proxy_buffer_size <a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_buffer_size" target="_blank" rel="noopener">http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_buffer_size</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a&gt;基础概念&lt;/h2&gt;&lt;p&gt;HTTP 流简单的理解为：服务端维持一个 HTTP 连接，通过这个 HTTP 连接源源不断、持续的输出内容至客户端。相较于我
      
    
    </summary>
    
      <category term="编程" scheme="https://rovast.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="基础" scheme="https://rovast.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>使用 github action 自动发布 hexo blog</title>
    <link href="https://rovast.github.io/2021/03/20/hexo-github-action/"/>
    <id>https://rovast.github.io/2021/03/20/hexo-github-action/</id>
    <published>2021-03-20T14:16:03.000Z</published>
    <updated>2022-09-28T06:14:26.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>用 Hexo 来生成 Github Pages 有一段时间了，之前一直是在本地写完 Blog 然后执行下述指令来发博客<br><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf public</span><br><span class="line">npx hexo deploy</span><br></pre></td></tr></table></figure></p><p>今天想想，不是有 github acion 嘛，能不能使用自动化 CI 流程来发布，当我的 Hexo Repo 发布时，自动进行 deply 动作，进而部署到 rovast.github.io。<br>当然是可以的！本文就其中的步骤进行记录，也算是 github action 的初体验了。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>首先我们要确认一个前提，就是 github pages 和 hexo 源码是两个东西，那我的来说，我有两个仓</p><ul><li>仓库1，hexo source 仓库，存放 hexo 博客源码。<a href="https://github.com/rovast/hexo-config" target="_blank" rel="noopener">https://github.com/rovast/hexo-config</a></li><li>仓库2，和自己用户名同样的仓库，你只要放了静态文件 index.html，github 自动帮你生成 github pages。<a href="https://github.com/rovast/rovast.github.io" target="_blank" rel="noopener">https://github.com/rovast/rovast.github.io</a></li></ul><p>整体的步骤如下</p><ol><li>正确配置 hexo-config 的配置文件 <code>_config.yaml</code></li><li>正确 <a href="https://github.com/rovast/hexo-config" target="_blank" rel="noopener">https://github.com/rovast/hexo-config</a> 仓库配置，尤其是 git 的 ssh 私钥和 github action</li><li>正确配置 <a href="https://github.com/rovast/rovast.github.io" target="_blank" rel="noopener">https://github.com/rovast/rovast.github.io</a> 的 deploy key</li></ol><p>接下来依次配置</p><h3 id="1、配置-hexo-config-项目的-config-yaml"><a href="#1、配置-hexo-config-项目的-config-yaml" class="headerlink" title="1、配置 hexo-config 项目的 _config.yaml"></a>1、配置 hexo-config 项目的 <code>_config.yaml</code></h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="string">git@github.com:rovast/rovast.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>注意其中的 repo 一定要是用 ssh 的协议，一因为后面我们要借助 ssh-key。</p><h3 id="2、配置-https-github-com-rovast-hexo-config-的-github-配置"><a href="#2、配置-https-github-com-rovast-hexo-config-的-github-配置" class="headerlink" title="2、配置 https://github.com/rovast/hexo-config 的 github 配置"></a>2、配置 <a href="https://github.com/rovast/hexo-config" target="_blank" rel="noopener">https://github.com/rovast/hexo-config</a> 的 github 配置</h3><p><strong>1. 配置 github action 的 yaml</strong></p><p>参考的 <a href="https://github.com/sma11black/hexo-action，我们新建文件" target="_blank" rel="noopener">https://github.com/sma11black/hexo-action，我们新建文件</a> <code>.github/workflows/deploy.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span> <span class="string">[push]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line"><span class="attr">  build:</span></span><br><span class="line"><span class="attr">    runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">A</span> <span class="string">job</span> <span class="string">to</span> <span class="string">deploy</span> <span class="string">blog.</span></span><br><span class="line"><span class="attr">    steps:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Checkout</span></span><br><span class="line"><span class="attr">      uses:</span> <span class="string">actions/checkout@v1</span></span><br><span class="line"><span class="attr">      with:</span></span><br><span class="line"><span class="attr">        submodules:</span> <span class="literal">true</span> <span class="comment"># Checkout private submodules(themes or something else).</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Caching dependencies to speed up workflows. (GitHub will remove any cache entries that have not been accessed in over 7 days.)</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Cache</span> <span class="string">node</span> <span class="string">modules</span></span><br><span class="line"><span class="attr">      uses:</span> <span class="string">actions/cache@v1</span></span><br><span class="line"><span class="attr">      id:</span> <span class="string">cache</span></span><br><span class="line"><span class="attr">      with:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">node_modules</span></span><br><span class="line"><span class="attr">        key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.os</span> <span class="string">&#125;&#125;-node-$&#123;&#123;</span> <span class="string">hashFiles('**/package-lock.json')</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">        restore-keys:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          $<span class="template-variable">&#123;&#123; runner.os &#125;&#125;</span>-node-</span></span><br><span class="line"><span class="string"></span><span class="attr">    - name:</span> <span class="string">Install</span> <span class="string">Dependencies</span></span><br><span class="line"><span class="attr">      if:</span> <span class="string">steps.cache.outputs.cache-hit</span> <span class="string">!=</span> <span class="string">'true'</span></span><br><span class="line"><span class="attr">      run:</span> <span class="string">npm</span> <span class="string">ci</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Deploy hexo blog website.</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Deploy</span></span><br><span class="line"><span class="attr">      id:</span> <span class="string">deploy</span></span><br><span class="line"><span class="attr">      uses:</span> <span class="string">sma11black/hexo-action@v1.0.3</span></span><br><span class="line"><span class="attr">      with:</span></span><br><span class="line"><span class="attr">        deploy_key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEPLOY_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">        commit_msg:</span> <span class="string">$&#123;&#123;</span> <span class="string">github.event.head_commit.message</span> <span class="string">&#125;&#125;</span>  <span class="comment"># (or delete this input setting to use hexo default settings)</span></span><br><span class="line">    <span class="comment"># Use the output from the `deploy` step(use for test action)</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Get</span> <span class="string">the</span> <span class="string">output</span></span><br><span class="line"><span class="attr">      run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        echo "$<span class="template-variable">&#123;&#123; steps.deploy.outputs.notify &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure><p><strong>2. 配置 secrect.DEPLOY_KEY</strong></p><p>我们看到 github action 里读取了 <code>$</code>，这个需要在 github 里正确配置。</p><p>注意这里应该填写的是私钥(<code>cat ~/.ssh/id_rsa</code>)，而不是 pub 公钥</p><p><img src="/assets/image-20210320222831807.png" alt="image-20210320222831807"></p><h3 id="3、在-https-github-com-rovast-rovast-github-io-配置-deploy-key"><a href="#3、在-https-github-com-rovast-rovast-github-io-配置-deploy-key" class="headerlink" title="3、在 https://github.com/rovast/rovast.github.io 配置 deploy key"></a>3、在 <a href="https://github.com/rovast/rovast.github.io" target="_blank" rel="noopener">https://github.com/rovast/rovast.github.io</a> 配置 deploy key</h3><p><code>cat ~/.ssh/id_rsa.pub</code>，配置到仓库的 deploy key 里面</p><p><img src="/assets/image-20210320223441248.png" alt="image-20210320223441248"></p><h3 id="4、结束"><a href="#4、结束" class="headerlink" title="4、结束"></a>4、结束</h3><p>正常保存 <a href="https://github.com/rovast/hexo-config" target="_blank" rel="noopener">https://github.com/rovast/hexo-config</a> 仓库，push 后自动触发 github action 进行发布。</p><p><img src="/assets/image-20210320223657343.png" alt="image-20210320223657343"></p><p><img src="/assets/image-20210320223734616.png" alt="image-20210320223734616"></p><h2 id="使用感受"><a href="#使用感受" class="headerlink" title="使用感受"></a>使用感受</h2><p>有以下几点在使用过程中不得不提</p><ol><li><p>丰富的 github action 模板，你甚至可以在编写的工程中在线搜索他的 Market Place！对新手而言可以快速入门，对于老手而言可以快速找到适合你的速成方案。</p><p><img src="/assets/image-20210320224530765.png" alt="image-20210320224530765"></p></li><li><p>自定义的 secrect.VAR，并且这个 secrect 编写后，居然是不可以查看的，只能更改，简直太赞！对于一些敏感内容而言，简直完美！</p><p><img src="/assets/image-20210320224658673.png" alt="image-20210320224658673"></p></li><li><p>执行 action 过程中的 UI 提示，很丝滑，执行到哪步，就显示哪个步骤。</p><p><img src="/assets/image-20210320224737049.png" alt="image-20210320224737049"></p></li><li><p>另外，通过查看 <a href="https://github.com/sma11black/hexo-action" target="_blank" rel="noopener">https://github.com/sma11black/hexo-action</a> 源码，我们知道，是可以对 Dockerfile 进行操作的，这个想象的空间就无限大了。</p></li></ol><p>让你感觉这个流程本该如此的操作，一定是好操作！</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li>《GitHub Actions 入门教程》<a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html</a></li><li><a href="https://github.com/sma11black/hexo-action" target="_blank" rel="noopener">https://github.com/sma11black/hexo-action</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;用 Hexo 来生成 Github Pages 有一段时间了，之前一直是在本地写完 Blog 然后执行下述指令来发博客&lt;br&gt;&lt;figure
      
    
    </summary>
    
      <category term="杂项" scheme="https://rovast.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
      <category term="工具" scheme="https://rovast.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>【转】npx 使用教程</title>
    <link href="https://rovast.github.io/2021/03/18/use-npx/"/>
    <id>https://rovast.github.io/2021/03/18/use-npx/</id>
    <published>2021-03-18T02:32:46.000Z</published>
    <updated>2022-09-28T06:14:26.588Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文 <a href="https://www.ruanyifeng.com/blog/2019/02/npx.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2019/02/npx.html</a></p></blockquote><p>npm 从5.2版开始，增加了 npx 命令。它有很多用处，本文介绍该命令的主要使用场景。</p><p><img src="/assets/bg2019020901.jpg" alt="img"></p><p>Node 自带 npm 模块，所以可以直接使用 npx 命令。万一不能用，就要手动安装一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g npx</span><br></pre></td></tr></table></figure><h2 id="调用项目安装的模块"><a href="#调用项目安装的模块" class="headerlink" title="调用项目安装的模块"></a>调用项目安装的模块</h2><p>npx 想要解决的主要问题，就是调用项目内部安装的模块。比如，项目内部安装了测试工具 <a href="http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html" target="_blank" rel="noopener">Mocha</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -D mocha</span><br></pre></td></tr></table></figure><p>一般来说，调用 Mocha ，只能在项目脚本和 package.json 的<a href="http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html" target="_blank" rel="noopener"><code>scripts</code></a>字段里面， 如果想在命令行下调用，必须像下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 项目的根目录下执行</span></span><br><span class="line">$ node-modules/.bin/mocha --version</span><br></pre></td></tr></table></figure><p>npx 就是想解决这个问题，让项目内部安装的模块用起来更方便，只要像下面这样调用就行了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx mocha --version</span><br></pre></td></tr></table></figure><p>npx 的原理很简单，就是运行的时候，会到<code>node_modules/.bin</code>路径和环境变量<code>$PATH</code>里面，检查命令是否存在。</p><p>由于 npx 会检查环境变量<code>$PATH</code>，所以系统命令也可以调用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 等同于 ls</span></span><br><span class="line">$ npx ls</span><br></pre></td></tr></table></figure><p>注意，Bash 内置的命令不在<code>$PATH</code>里面，所以不能用。比如，<code>cd</code>是 Bash 命令，因此就不能用<code>npx cd</code>。</p><h2 id="避免全局安装模块"><a href="#避免全局安装模块" class="headerlink" title="避免全局安装模块"></a>避免全局安装模块</h2><p>除了调用项目内部模块，npx 还能避免全局安装的模块。比如，<code>create-react-app</code>这个模块是全局安装，npx 可以运行它，而且不进行全局安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx create-react-app my-react-app</span><br></pre></td></tr></table></figure><p>上面代码运行时，npx 将<code>create-react-app</code>下载到一个临时目录，使用以后再删除。所以，以后再次执行上面的命令，会重新下载<code>create-react-app</code>。</p><p>下载全局模块时，npx 允许指定版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx uglify-js@3.1.0 main.js -o ./dist/main.js</span><br></pre></td></tr></table></figure><p>上面代码指定使用 3.1.0 版本的<code>uglify-js</code>压缩脚本。</p><p>注意，只要 npx 后面的模块无法在本地发现，就会下载同名模块。比如，本地没有安装<code>http-server</code>模块，下面的命令会自动下载该模块，在当前目录启动一个 Web 服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx http-server</span><br></pre></td></tr></table></figure><h2 id="no-install-参数和-ignore-existing-参数"><a href="#no-install-参数和-ignore-existing-参数" class="headerlink" title="--no-install 参数和--ignore-existing 参数"></a><code>--no-install</code> 参数和<code>--ignore-existing</code> 参数</h2><p>如果想让 npx 强制使用本地模块，不下载远程模块，可以使用<code>--no-install</code>参数。如果本地不存在该模块，就会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx --no-install http-server</span><br></pre></td></tr></table></figure><p>反过来，如果忽略本地的同名模块，强制安装使用远程模块，可以使用<code>--ignore-existing</code>参数。比如，本地已经全局安装了<code>create-react-app</code>，但还是想使用远程模块，就用这个参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx --ignore-existing create-react-app my-react-app</span><br></pre></td></tr></table></figure><h2 id="使用不同版本的-node"><a href="#使用不同版本的-node" class="headerlink" title="使用不同版本的 node"></a>使用不同版本的 node</h2><p>利用 npx 可以下载模块这个特点，可以指定某个版本的 Node 运行脚本。它的窍门就是使用 npm 的 <a href="https://www.npmjs.com/package/node" target="_blank" rel="noopener">node 模块</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npx node@0.12.8 -v</span><br><span class="line">v0.12.8</span><br></pre></td></tr></table></figure><p>上面命令会使用 0.12.8 版本的 Node 执行脚本。原理是从 npm 下载这个版本的 node，使用后再删掉。</p><p>某些场景下，这个方法用来切换 Node 版本，要比 nvm 那样的版本管理器方便一些。</p><h2 id="p-参数"><a href="#p-参数" class="headerlink" title="-p 参数"></a><code>-p</code> 参数</h2><p><code>-p</code>参数用于指定 npx 所要安装的模块，所以上一节的命令可以写成下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npx -p node@0.12.8 node -v </span><br><span class="line">v0.12.8</span><br></pre></td></tr></table></figure><p>上面命令先指定安装<a href="mailto:`node@0.12.8" target="_blank" rel="noopener">`node@0.12.8</a><code>，然后再执行</code>node -v`命令。</p><p><code>-p</code>参数对于需要安装多个模块的场景很有用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx -p lolcatjs -p cowsay [<span class="built_in">command</span>]</span><br></pre></td></tr></table></figure><h2 id="c-参数"><a href="#c-参数" class="headerlink" title="-c 参数"></a>-c 参数</h2><p>如果 npx 安装多个模块，默认情况下，所执行的命令之中，只有第一个可执行项会使用 npx 安装的模块，后面的可执行项还是会交给 Shell 解释。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npx -p lolcatjs -p cowsay <span class="string">'cowsay hello | lolcatjs'</span></span><br><span class="line"><span class="comment"># 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>cowsay hello | lolcatjs</code>执行时会报错，原因是第一项<code>cowsay</code>由 npx 解释，而第二项命令<code>localcatjs</code>由 Shell 解释，但是<code>lolcatjs</code>并没有全局安装，所以报错。</p><p><code>-c</code>参数可以将所有命令都用 npx 解释。有了它，下面代码就可以正常执行了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx -p lolcatjs -p cowsay -c <span class="string">'cowsay hello | lolcatjs'</span></span><br></pre></td></tr></table></figure><p><code>-c</code>参数的另一个作用，是将环境变量带入所要执行的命令。举例来说，npm 提供当前项目的一些环境变量，可以用下面的命令查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run env | grep npm_</span><br></pre></td></tr></table></figure><p><code>-c</code>参数可以把这些 npm 的环境变量带入 npx 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx -c <span class="string">'echo "$npm_package_name"'</span></span><br></pre></td></tr></table></figure><p>上面代码会输出当前项目的项目名。</p><h2 id="执行-GitHub-源码"><a href="#执行-GitHub-源码" class="headerlink" title="执行 GitHub 源码"></a>执行 GitHub 源码</h2><p>npx 还可以执行 GitHub 上面的模块源码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行 Gist 代码</span></span><br><span class="line">$ npx https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行仓库代码</span></span><br><span class="line">$ npx github:piuccio/cowsay hello</span><br></pre></td></tr></table></figure><p>注意，远程代码必须是一个模块，即必须包含<code>package.json</code>和入口脚本。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.npmjs.com/package/npx" target="_blank" rel="noopener">npx</a></li><li><a href="https://alligator.io/workflow/npx/" target="_blank" rel="noopener">Speed Up Your npm Workflow With npx</a></li><li><a href="https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b" target="_blank" rel="noopener">Introducing npx: an npm package runner</a></li></ul><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文 &lt;a href=&quot;https://www.ruanyifeng.com/blog/2019/02/npx.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.ruanyifeng.com/blog
      
    
    </summary>
    
      <category term="杂项" scheme="https://rovast.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
      <category term="工具" scheme="https://rovast.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux客户端设置 socks5+kcptun</title>
    <link href="https://rovast.github.io/2021/03/13/server-set-proxy-use-socks5/"/>
    <id>https://rovast.github.io/2021/03/13/server-set-proxy-use-socks5/</id>
    <published>2021-03-13T15:08:40.000Z</published>
    <updated>2022-09-28T06:14:26.568Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/ss-kcp.jpg" alt="ss-kcp"></p><p><img src="/assets/kcptun.jpg" alt="kcptun"></p><p>之前更多使用 Linux 服务器作为服务器来提供代理服务，这里使用 Linux 机器作为客户端，链接远端代理服务器，使用纯终端来设置代理，加速访问。</p><p>同时，参考 《pm2 简明使用教程》来配合进行守护进程使用</p><h2 id="安软件"><a href="#安软件" class="headerlink" title="安软件"></a>安软件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> shadowsocks</span></span><br><span class="line">pip3 install shadowsocks</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> kcptun</span></span><br><span class="line">wget https://github.com/xtaci/kcptun/releases/download/v20210103/kcptun-linux-amd64-20210103.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> cow，用于转换 socks5 协议至 http 和 https</span></span><br><span class="line">wget https://github.com/cyfdecyf/cow/releases/download/0.9.8/cow-linux64-0.9.8.gz</span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ol><li><p>kcptun.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"localaddr"</span>: <span class="string">":1080"</span>,</span><br><span class="line">    <span class="attr">"remoteaddr"</span>: <span class="string">"REMOTE_SERVER:29900"</span>,</span><br><span class="line">    <span class="attr">"key"</span>: <span class="string">"111111"</span>,</span><br><span class="line">    <span class="attr">"crypt"</span>: <span class="string">"aes"</span>,</span><br><span class="line">    <span class="attr">"mode"</span>: <span class="string">"fast"</span>,</span><br><span class="line">    <span class="attr">"conn"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"autoexpire"</span>: <span class="number">60</span>,</span><br><span class="line">    <span class="attr">"mtu"</span>: <span class="number">1350</span>,</span><br><span class="line">    <span class="attr">"sndwnd"</span>: <span class="number">512</span>,</span><br><span class="line">    <span class="attr">"rcvwnd"</span>: <span class="number">512</span>,</span><br><span class="line">    <span class="attr">"datashard"</span>: <span class="number">70</span>,</span><br><span class="line">    <span class="attr">"parityshard"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"dscp"</span>: <span class="number">46</span>,</span><br><span class="line">    <span class="attr">"nocomp"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"acknodelay"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"nodelay"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"interval"</span>: <span class="number">40</span>,</span><br><span class="line">    <span class="attr">"resend"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"nc"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"sockbuf"</span>: <span class="number">4194304</span>,</span><br><span class="line">    <span class="attr">"keepalive"</span>: <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ss.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"server"</span>:<span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="attr">"server_port"</span>:<span class="number">1080</span>,</span><br><span class="line">    <span class="attr">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="attr">"local_port"</span>:<span class="number">1087</span>,</span><br><span class="line">    <span class="attr">"password"</span>:<span class="string">"9SehN7C3GQ9h9Cyt"</span>,</span><br><span class="line">    <span class="attr">"timeout"</span>:<span class="number">300</span>,</span><br><span class="line">    <span class="attr">"method"</span>:<span class="string">"chacha20"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>~/.cow/rc</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">listen = http://127.0.0.1:4411</span><br><span class="line">proxy = socks5://127.0.0.1:1087</span><br></pre></td></tr></table></figure></li></ol><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> socks5 协议转为 http 和 https</span></span><br><span class="line">/home/rovast/applications/cow-linux64-0.9.8</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启 kcptun</span></span><br><span class="line">/home/rovast/applications/kcptun/client_linux_amd64 -c /home/rovast/applications/kcptun/kcptun.json</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启 ss</span></span><br><span class="line">/usr/bin/ss-local -c /home/rovast/applications/shadowsocks/ss.json</span><br></pre></td></tr></table></figure><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ul><li><a href="https://github.com/xtaci/kcptun" target="_blank" rel="noopener">https://github.com/xtaci/kcptun</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/assets/ss-kcp.jpg&quot; alt=&quot;ss-kcp&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/kcptun.jpg&quot; alt=&quot;kcptun&quot;&gt;&lt;/p&gt;
&lt;p&gt;之前更多使用 Linux 服务器作为服务器来提供代理服务，这里使用 L
      
    
    </summary>
    
      <category term="杂项" scheme="https://rovast.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>pm2 简明使用教程</title>
    <link href="https://rovast.github.io/2021/03/13/pm2-usage/"/>
    <id>https://rovast.github.io/2021/03/13/pm2-usage/</id>
    <published>2021-03-13T15:04:30.000Z</published>
    <updated>2022-09-28T06:14:26.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>npm install pm2@latest -g</p><h2 id="书写配置文件"><a href="#书写配置文件" class="headerlink" title="书写配置文件"></a>书写配置文件</h2><p>使用配置文件来启动，便于统一管理</p><p><code>~/.config/pm2/ecosystem.config.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apps:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">script</span>     <span class="string">:</span> <span class="string">/home/luohao/applications/code-server-3.9.1-linux-amd64/bin/code-server</span></span><br><span class="line"><span class="attr">    interpreter:</span> <span class="string">none</span></span><br><span class="line"><span class="attr">    max_memory_restart:</span> <span class="number">500</span><span class="string">M</span></span><br><span class="line">    <span class="string">name</span>       <span class="string">:</span> <span class="string">'code-server'</span></span><br><span class="line">    <span class="string">instances</span>  <span class="string">:</span> <span class="number">1</span></span><br><span class="line">    <span class="string">exec_mode</span>  <span class="string">:</span> <span class="string">fork</span></span><br><span class="line"><span class="attr">    env:</span></span><br><span class="line">      <span class="string">http_proxy</span> <span class="string">:</span> <span class="attr">http://127.0.0.1:4411</span></span><br><span class="line"><span class="attr">      https_proxy:</span> <span class="attr">http://127.0.0.1:4411</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">script</span>     <span class="string">:</span> <span class="string">/home/luohao/applications/cow-linux64-0.9.8</span></span><br><span class="line"><span class="attr">    interpreter:</span> <span class="string">none</span></span><br><span class="line">    <span class="string">name</span>       <span class="string">:</span> <span class="string">'cow'</span></span><br><span class="line">    <span class="string">instances</span>  <span class="string">:</span> <span class="number">1</span></span><br><span class="line">    <span class="string">exec_mode</span>  <span class="string">:</span> <span class="string">fork</span></span><br><span class="line"><span class="attr">    env:</span></span><br><span class="line"><span class="attr">      version:</span> <span class="number">0.9</span><span class="number">.8</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">script</span>     <span class="string">:</span> <span class="string">/home/luohao/applications/kcptun/client_linux_amd64</span> <span class="bullet">-c</span> <span class="string">/home/luohao/applications/kcptun/kcptun.json</span></span><br><span class="line"><span class="attr">    interpreter:</span> <span class="string">none</span></span><br><span class="line">    <span class="string">name</span>       <span class="string">:</span> <span class="string">'kcptun-client'</span></span><br><span class="line">    <span class="string">instances</span>  <span class="string">:</span> <span class="number">1</span></span><br><span class="line">    <span class="string">exec_mode</span>  <span class="string">:</span> <span class="string">fork</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">script</span>     <span class="string">:</span> <span class="string">/usr/bin/ss-local</span> <span class="bullet">-c</span> <span class="string">/home/luohao/applications/shadowsocks/ss.json</span></span><br><span class="line"><span class="attr">    interpreter:</span> <span class="string">none</span></span><br><span class="line">    <span class="string">name</span>       <span class="string">:</span> <span class="string">'shadowsocks-client'</span></span><br><span class="line">    <span class="string">instances</span>  <span class="string">:</span> <span class="number">1</span></span><br><span class="line">    <span class="string">exec_mode</span>  <span class="string">:</span> <span class="string">fork</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">script</span>     <span class="string">:</span> <span class="string">/home/luohao/.local/bin/projector</span> <span class="string">run</span> <span class="string">Goland</span></span><br><span class="line"><span class="attr">    interpreter:</span> <span class="string">none</span></span><br><span class="line">    <span class="string">name</span>       <span class="string">:</span> <span class="string">'Goland-server'</span></span><br><span class="line">    <span class="string">instances</span>  <span class="string">:</span> <span class="number">1</span></span><br><span class="line">    <span class="string">exec_mode</span>  <span class="string">:</span> <span class="string">fork</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">script</span>     <span class="string">:</span> <span class="string">/home/luohao/.local/bin/projector</span> <span class="string">run</span> <span class="string">Webstorm</span></span><br><span class="line"><span class="attr">    interpreter:</span> <span class="string">none</span></span><br><span class="line">    <span class="string">name</span>       <span class="string">:</span> <span class="string">'Webstorm-server'</span></span><br><span class="line">    <span class="string">instances</span>  <span class="string">:</span> <span class="number">1</span></span><br><span class="line">    <span class="string">exec_mode</span>  <span class="string">:</span> <span class="string">fork</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">script</span>     <span class="string">:</span> <span class="string">/home/luohao/.local/bin/projector</span> <span class="string">run</span> <span class="string">Clion</span></span><br><span class="line"><span class="attr">    interpreter:</span> <span class="string">none</span></span><br><span class="line">    <span class="string">name</span>       <span class="string">:</span> <span class="string">'Clion-server'</span></span><br><span class="line">    <span class="string">instances</span>  <span class="string">:</span> <span class="number">1</span></span><br><span class="line">    <span class="string">exec_mode</span>  <span class="string">:</span> <span class="string">fork</span></span><br></pre></td></tr></table></figure><blockquote><p>interpreter 设置为 none，用默认行为启动二进制文件。以上是服务器设置客户端代理的脚本，供参考</p></blockquote><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start ~/.config/pm2/ecosystem.config.yaml</span><br></pre></td></tr></table></figure><p>常用的操作还有下面的系列操作，可以在后面加上 jobId(通过 <code>pm2 list</code>查看)，或者加上 echosystem 文件<br><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pm2 delete JOBID_OR_FILE</span><br><span class="line">pm2 stop JOBID_OR_FILE</span><br><span class="line">pm2 reload JOBID_OR_FILE</span><br><span class="line">pm2 restart JOBID_OR_FILE</span><br><span class="line">pm2 descibe JOBID_OR_FILE</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 监控类</span></span><br><span class="line">pm2 monit</span><br><span class="line">pm2 list</span><br></pre></td></tr></table></figure></p><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p><a href="https://app.pm2.io/" target="_blank" rel="noopener">https://app.pm2.io/</a></p><h2 id="设置为开机自启动"><a href="#设置为开机自启动" class="headerlink" title="设置为开机自启动"></a>设置为开机自启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pm2 startup</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入完 之后有如下提示</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo env PATH=<span class="variable">$PATH</span>:/home/luohao/.nvm/versions/node/v15.11.0/bin /home/luohao/.nvm/versions/node/v15.11.0/lib/node_modules/pm2/bin/pm2 startup systemd -u luohao --hp /home/luohao</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更改完配置后更新最新配置</span></span><br><span class="line">pm2 save</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;npm install pm2@latest -g&lt;/p&gt;
&lt;h2 id=&quot;书写配置文件&quot;&gt;&lt;a href=&quot;#书写配置文件&quot; class=
      
    
    </summary>
    
      <category term="工具" scheme="https://rovast.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>【转】人人都有认知障</title>
    <link href="https://rovast.github.io/2021/02/20/renrendouyourenzhizhangai/"/>
    <id>https://rovast.github.io/2021/02/20/renrendouyourenzhizhangai/</id>
    <published>2021-02-20T05:16:50.000Z</published>
    <updated>2022-09-28T06:14:26.568Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://mp.weixin.qq.com/s/eO7mVliAl8CwYnGV1FwtJg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/eO7mVliAl8CwYnGV1FwtJg</a></p></blockquote><blockquote><p>原文标题：《人人都有认知障》</p></blockquote><blockquote><p>原文公众号：caoz的梦呓</p></blockquote><p>以前记得看过这么一个段子，当然我是没办法求证真伪的，说大清后期有个皇上，有一天跟大臣聊天，问大臣，你早上上朝之前吃的什么啊，大臣如实回复，早上吃了俩鸡子（也就是鸡蛋），皇上就很惊讶，这么奢侈啊，你的俸禄够花么，为什么皇上很惊讶呢，因为内务府的太监跟皇上报账一个鸡蛋要好几两银子，而实际上一个鸡蛋也就几文钱。大臣心知肚明但也不便点破，就说我们吃的是寻常鸡蛋，比不上皇家特供的高级，所以没那么贵。</p><p>故事真假不知，但我觉得这比各种清宫戏反而真实一些，其实这种情况并不罕见，正如晋惠帝那句流传千古的话，何不食肉糜。生在深宫大院，帝王人家，不知柴米油盐，是很寻常的，一个太监就能蒙蔽圣听。其实当今社会，对于富裕的年轻一代或者富裕国家的国民，去理解挣扎在温饱线的时代或者贫困国家的人民生活，何不食肉糜这种认知还真不是段子，一直一直一直都有，只是换个说法而已。包括现在很多年轻人开始怀念几十年前所谓没有内卷的年代，真是都没挨饿过。</p><p>类似的故事还有，说辛亥革命后，旗人贵族没落了，需要出来自己讨生计，有个贵族遗少也出来自己想办法赚钱养活自己，走在街上饿了，花几个钱买了街边现烤的烧饼，一吃之下大惊，原来新出炉的烧饼这么脆这么好吃，以前都是让仆人出去买，每次吃到的都是冷冰冰硬梆梆的。深宫大院说起来要啥有啥，吃穿不愁，但恰恰远离了烟火气。一些寻常百姓唾手可得的东西，他们反而是难以理解。</p><p>贵族不懂百姓，当然百姓也不懂贵族，这才有相声里提到的吕剧唱词，”东宫的娘娘烙大饼，西宫的娘娘卷大葱。” 旧社会普通百姓对富贵人家的想象，也就局限于此了。</p><p>说的这些，其实不同阶层，不同社会地位，不同地域，乃至不同行业的人，对彼此的认知都会有很大的误区，不同地域也是，一个地区约定俗成的东西，在另一个地区可能就是闻所未闻。</p><p>经常有一种观点，认为高认知碾压低认知，说你如果达到某个阶层，掌握某个认知，就可以碾压那些阶层之下的人，可以任意收割或者利用他们。</p><p>但我发现，其实并不是，高学历，高智商人群被低学历，低背景人群诈骗收割的案例也很多。最近爆出来的阿里女员工被诈骗的新闻，其实真的不是孤例。很多人认为这些人认知不够，但扪心自问，我们自己又高明到哪里去，在投资领域我犯过的错误也数不胜数，认知不足交过的学费算下来也是挺大的数字了。</p><p>现在业内都知道，所谓下沉市场价值巨大，我在星球里说过，对如何挖掘下沉市场，我是没任何感知的。因为我从小就没在农村住过一天，虽然小时候家里也很穷，但属于城市平民，所以对所谓乡村生活，乡村人际，乡村的过年气氛，就完全无感，我看到有读者说，现在年味越来越淡，只有小时候乡下过年那才叫过年，这话我就不爱听，我城里长大的就不配过年是怎么的。</p><p>另外，我还说过一点，我没有故乡的概念，我虽然是天津出生的，但是随着父亲工作单位调动，6岁之前在山东德州，是出扒鸡的德州，不是出牛仔的德州。那么6岁之前是没任何印象的，6岁后父母迁回天津，事业单位，属于水利部下的勘测设计院，当时还叫水电部，那么住的小区是单位家属区，整个设计院的人分别来自山东德州和河南三门峡，换句话说，家属院里就没有本土的天津人。当然，我们家祖籍也不是天津，是河北，解放前我爷爷迁居到天津的，可是河北老家我也一次都没去过。所以不好意思，我小时候在天津的时候，就没觉得自己是天津人，天津人也没拿我当本地人，但我也没觉得自己是河北人，是山东人。所以所谓叶落归根，荣归故里，很惭愧，我也是完全没感觉的。</p><p>没有故土概念，也没有乡村生活经历，城里亲戚关系也没那么深厚，对很多这方面的感知基本没有，所以我知道很多人会用这样的认知感来做营销，做市场运营，做低成本获客，但这种我就不会碰，因为我的认知跟不上。</p><p>以前草根创业者，很多是本色的认知感，比如李兴平，做的非常成功；后来精英们做下沉，靠数据反馈迭代，我是很佩服张一鸣和黄峥这种，我是做不来。但确实，跨越阶层，跨越群体的认知，是产生很多商业机会，以及个人价值增长的所在。 这句话我加粗一下，希望读者仔细想想。</p><p>比如说，为什么我常说，技术人员懂一点商业，会非常有价值，看看中国和美国的福布斯榜单，多少大佬是程序员出身。懂草根的精英，和懂精英的草根，也都是非常容易创建商业奇迹的人。</p><p>比如说，出海企业，能够理解海外市场，并掌握中国研发资源的人，就会非常有优势。</p><p>跨越不同族群，不同阶层的时候，你会发现，A群体中非常渴望的诉求，认为非常难以实现的事情，在B群体里其实是非常简单，容易获取的资源，但B群体并不知道A群体存在这样的诉求，如果有一个人，比如他是A群体的人，突然有机会接触了B群体，掌握了B群体的认知，发现存在非常简单，容易获取这样的资源，他拿到资源转过头来，回到A群体贩售，这就是很多商业成功案例的本质逻辑。</p><p>我看到包括生财有术，包括我自己星球里很多读者分享的赚钱案例，相当高的比例都可以用这个逻辑来套用，几乎都能符合。</p><p>很多草根创业者小有成就后，都愿意花钱读个emba，试图让自己融入另一个阶层，也是存在这样的一种理念。</p><p>但这里存在一个问题，最近我发现很多创业者，或者一些还不错的草根创业者，存在这样一个问题，他们脱胎于A群体，开始接触B群体，靠B群体的认知，转过头来，在A群体解决了一些关键诉求，实现了很好的商业转化，这不挺成功的么，然后他们就开始觉得，A群体太low了，什么都不懂，自己要怎样，脱胎换骨，成为B群体中的一员，但是这里问题来了，彻底脱离了A群体后，他们其实就失去了自己的价值了。</p><p>这就是今天要说的主题，能够纵横跨越阶层，跨越族群的认知，充分利用起来，可以具有极大的商业价值，但如果你彻底放弃了某个群体和阶层的认知，你以为你脱胎换骨，其实你是自废武功。你说增进认知，学习更多难道有错么？当然没错。但究竟什么才是你的价值，既懂A，又懂B才是你的价值。放弃A，追求B，你什么都不是。</p><p>底层逆袭的人，往往会忽视底层认知的价值，当你脱离了所谓低级趣味的时候，你可能已经失去了很重要的价值资源。而这样的人，还真挺多的。</p><p>类似的案例还有很多，中国改革开放，第一批睁眼看世界的人，既懂中国，又懂西方，就很容易抓住时代的机遇，抓住很多稀缺的机会，成就一番事业，这些人慢慢成为中年人，觉得自己孩子早点接受西方教育，不是比自己更有优势么？结果问题来了，下一代人确实很懂西方，但不懂中国，反而失去了独特的价值。</p><p>认知障无处不在，所谓高阶人士，其实也存在很多认知障，就好比说，一路开挂的学霸是教不了学渣的，因为他们无法理解学渣的困境和苦恼，反而是从学渣逆袭诚学霸的，拥有跨越阶层的思维，才能更有针对性的辅导学渣。就好比说，纯粹大公司成长起来的技术高手很难去早期创业公司带团队，因为他们很难理解资源极为苛刻，人力极为平庸的情况下，如何做好产品，但反而是那些从巨头草创早期就加入，一路成长的高手，更能理解从创业到成长为巨头的挑战，这些都可以认为是跨越阶层的认知，具有独特的价值。</p><p>但切记，同时拥有多个阶层的认知才是你的价值所在，不要顾此失彼，为了追求所谓阶层上升，阶层融入，轻易放弃曾经的认知能力。最近发现有不少创业者，在做这样自废武功的事情，遂有感慨成此文。</p><p>一定要找到自己的独特价值，无论面对什么阶层，什么样的人，你总会在某个细分领域的认知具有优势，你找到这个点，然后再通过学习和领悟对方阶层的认知，从中挖掘匹配的需求点，就是你的独特价值。</p><p>我的知识星球，年终免费福利课，复盘人生关键决策，有效期只剩不到10天，最后提醒，3月1日凌晨准时下架。</p><p>懒得发链接了，星球用户去看置顶帖，其他读者忽略即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/eO7mVliAl8CwYnGV1FwtJg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/e
      
    
    </summary>
    
      <category term="随想" scheme="https://rovast.github.io/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="转载" scheme="https://rovast.github.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>理解 shell 脚本中的常见用法2&gt;&amp;1</title>
    <link href="https://rovast.github.io/2021/02/08/understanding-shell-script-idiom-redirect/"/>
    <id>https://rovast.github.io/2021/02/08/understanding-shell-script-idiom-redirect/</id>
    <published>2021-02-08T09:39:02.000Z</published>
    <updated>2022-09-28T06:14:26.584Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://www.brianstorti.com/understanding-shell-script-idiom-redirect/" target="_blank" rel="noopener">https://www.brianstorti.com/understanding-shell-script-idiom-redirect/</a></p><p>在我们接触的 shell 脚本中，对 <code>2&gt;&amp;1</code> 一定不陌生，比如 <code>ls foo &gt; /dev/null 2&gt;&amp;1</code>。</p><p>本文就来解释下 <code>2&gt;&amp;1</code> 究竟做了什么，并且是如何起作用的。</p><h2 id="一、I-O-重定向简介"><a href="#一、I-O-重定向简介" class="headerlink" title="一、I/O 重定向简介"></a>一、I/O 重定向简介</h2><p>「重定向」是计算机用来把命令的输出从一个地方，输出到另一个地方。举个例子，默认情况下，我们使用 <code>cat</code> 指令可以把一个文件的内容打印到终端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat foo.txt</span><br><span class="line">foo</span><br><span class="line">bar</span><br><span class="line">baz</span><br></pre></td></tr></table></figure><p>但是，我们可以把输出重定向到另外地方。此例中，我们可以把输出重定向到 <code>output.txt</code> 中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat foo.txt &gt; output.txt</span><br><span class="line"></span><br><span class="line">$ cat output.txt</span><br><span class="line">foo</span><br><span class="line">bar</span><br><span class="line">baz</span><br></pre></td></tr></table></figure><p>注意，在执行第一行命令 <code>cat foo.txt &gt; output.txt</code> 时，我们在屏幕上看不到任何输出。我们把原来应该打印到屏幕的内容，重定向到 <code>output.txt</code> 了，所以屏幕上不会有任何输出了。</p><p>这里，「本来应该打印到屏幕的内容」，就是<strong>标准输出</strong>，即 <strong>stdout(standard output)</strong>。</p><p>除了<strong>标准输出</strong>可以接收程序的输出之外，还有一个地方可以，叫 <strong>标准错误输出</strong>，即 <strong>stderr(standard error)</strong>。stderr 用来接收程序的错误消息。例如，我们 <code>cat</code> 了一个不存在的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat nop.txt &gt; output.txt</span><br><span class="line">cat: nop.txt: No such file or directory</span><br></pre></td></tr></table></figure><p>我们看到，虽然我们要求程序把输出重定向到 <code>output.txt</code>，但是我们还是在屏幕上看到了错误消息输出。这是因为我们只是重定向了 standard output，而不是 standard error。</p><h2 id="二、文件描述符-fd-简介"><a href="#二、文件描述符-fd-简介" class="headerlink" title="二、文件描述符(fd)简介"></a>二、文件描述符(fd)简介</h2><p>文件描述符（file descriptor）简单来说，就是一个正整数，用来代表一个打开的文件。比如当前我们有 100 各打开的文件，那么就有 100 个文件描述符。</p><p>唯一需要补充的是，在 Unix 系统中，「一切皆文件」。</p><p>同时我们还应该知道，对于标准输出(stdout)和标准错误输出(stderr)，也有对应的文件描述符。我们使用 1 和 2 来分别表示 stdout 和 stderr 所在的位置。</p><h2 id="三、融合上述知识"><a href="#三、融合上述知识" class="headerlink" title="三、融合上述知识"></a>三、融合上述知识</h2><p>回到我们的第一个示例，我们还可以有另外一种写法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写法一</span></span><br><span class="line">$ cat foo.txt &gt; output.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价写法二</span></span><br><span class="line">$ cat foo.txt 1&gt; output.txt</span><br></pre></td></tr></table></figure><p>这里的 1 就是用来代表 stdout 的文件描述符。语法是 <code>[FILE_DESCRIPTOR]&gt;</code>。我们看到把 1 省略的写法 <code>&gt;</code>只是 <code>1&gt;</code> 的快捷写法而已。</p><p>对于重定向到 stderr 的场景，我们只需要在右边的文件前面加上文件描述符即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat nop.txt 2&gt; error.txt</span><br><span class="line"></span><br><span class="line">$ cat error.txt</span><br><span class="line">cat: nop.txt: No such file or directory</span><br></pre></td></tr></table></figure><p>你看，这样就生效了。这会儿，你大概知道 <code>2&gt;&amp;1</code> 是怎样工作的，让我们来总结总结。</p><p>我们使用 <code>&amp;1</code> 来表示文件描述符1(stdout)的地址。当你使用 <code>2&gt;&amp;1</code> 时，其实就是在说：把 stderr 的输出重定向到 stdout 的地方。这样，我们就可以把程序的标准输出和错误输出都输出到同一个地方了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cat foo.txt &gt; output.txt 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">$ cat output.txt</span><br><span class="line">foo</span><br><span class="line">bar</span><br><span class="line">baz</span><br><span class="line"></span><br><span class="line">$ cat nop.txt &gt; output.txt 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">$ cat output.txt</span><br><span class="line">cat: nop.txt: No such file or directory</span><br></pre></td></tr></table></figure><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><ul><li>程序可以把输出发送到两个地方：标准输出(stdout，standard output)和标准错误输出(stderr，standard error)。</li><li>你可以把输出重定向到另一个地方（比如文件）</li><li>文件描述符1和2 可以分别用来表示 stdout 和 stderr</li><li><code>command &gt; output</code> 是 <code>command 1&gt; output</code> 的缩写</li><li>可以使用 <code>&amp;[FILE_DESCRIPTOR]</code> 来引用文件描述符的值（或者叫指向文件描述符的地址）</li><li>使用 <code>2&gt;&amp;1</code> 来重定向 stderr 的输出至 stdout 的地方（你可以用 <code>1&gt;&amp;2</code> 来进行反向操作）</li></ul><p>另，在 Linux 系统中 0、1、2 分别表示不同的设备类型，其中</p><p>0 标准输入设备，指键盘<br>1 标准正确输出设备<br>2 标准错误输出设备</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://www.brianstorti.com/understanding-shell-script-idiom-redirect/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.brianstort
      
    
    </summary>
    
      <category term="Linux" scheme="https://rovast.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>MacOS非安全模式打开Chrome</title>
    <link href="https://rovast.github.io/2021/02/01/cors-on-mac/"/>
    <id>https://rovast.github.io/2021/02/01/cors-on-mac/</id>
    <published>2021-02-01T08:02:18.000Z</published>
    <updated>2022-09-28T06:14:26.544Z</updated>
    
    <content type="html"><![CDATA[<p>使用允许跨域（不安全）模式打开，便于调试，设定一个 Alias 即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> openChromeNoCORS=<span class="string">"open -na Google\ Chrome --args --user-data-dir=/tmp/temporary-chrome-profile-dir --disable-web-security --disable-site-isolation-trials"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用允许跨域（不安全）模式打开，便于调试，设定一个 Alias 即可&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;
      
    
    </summary>
    
      <category term="杂项" scheme="https://rovast.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="mac" scheme="https://rovast.github.io/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>Antv G2 修改 Brush 默认行为为返回时间戳范围</title>
    <link href="https://rovast.github.io/2021/01/29/ant-g2-brush-timerange/"/>
    <id>https://rovast.github.io/2021/01/29/ant-g2-brush-timerange/</id>
    <published>2021-01-29T09:12:46.000Z</published>
    <updated>2022-09-28T06:14:26.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="G2-brush-时间轴，而不是筛选数据点"><a href="#G2-brush-时间轴，而不是筛选数据点" class="headerlink" title="G2 brush 时间轴，而不是筛选数据点"></a>G2 brush 时间轴，而不是筛选数据点</h1><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>目前 G2 使用 brush-x 筛选后的是对应的点，而不是 X 轴的时间范围。在实际使用过程中，我们需要场景如下</p><ol><li>鼠标筛选一个区域</li><li>获取这个区域的开始时间和结束时间</li><li>以第2步获取到的时间范围作为结果来重新获取数据</li></ol><h2 id="二、核心代码一览"><a href="#二、核心代码一览" class="headerlink" title="二、核心代码一览"></a>二、核心代码一览</h2><h3 id="2-1-注册-Action"><a href="#2-1-注册-Action" class="headerlink" title="2.1 注册 Action"></a>2.1 注册 Action</h3><ul><li><code>src/index.ts</code>，中枚举出了可以使用的 Action</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">registerAction(<span class="string">'brush'</span>, DataRangeFilter);</span><br><span class="line">registerAction(<span class="string">'brush-x'</span>, DataRangeFilter, &#123; dims: [<span class="string">'x'</span>] &#125;);</span><br><span class="line">registerAction(<span class="string">'brush-y'</span>, DataRangeFilter, &#123; dims: [<span class="string">'y'</span>] &#125;);</span><br></pre></td></tr></table></figure><h3 id="2-2-filter-处理逻辑"><a href="#2-2-filter-处理逻辑" class="headerlink" title="2.2 filter 处理逻辑"></a>2.2 filter 处理逻辑</h3><ul><li>看下 filter 流程<code>src/interaction/action/data/range-filter.ts</code><ul><li>获取到用户当前选择的视觉点</li><li>转换视觉点，获取到实际选择的 min value 和 max value，并且生成 filter</li><li>根据 filter 进行数据筛选</li></ul></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> filter() &#123;</span><br><span class="line">  <span class="keyword">let</span> startPoint;</span><br><span class="line">  <span class="keyword">let</span> currentPoint;</span><br><span class="line">  <span class="comment">// ... codes</span></span><br><span class="line">  <span class="comment">// 进行一些列处理，得到 startPoint 和 currentPoint 的值</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> view = <span class="keyword">this</span>.context.view;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取到归一化坐标</span></span><br><span class="line">  <span class="keyword">const</span> coord = view.getCoordinate();</span><br><span class="line">  <span class="keyword">const</span> normalCurrent = coord.invert(currentPoint);</span><br><span class="line">  <span class="keyword">const</span> normalStart = coord.invert(startPoint);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 设置 x 方向的 filter</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.hasDim(<span class="string">'x'</span>)) &#123;</span><br><span class="line">    <span class="keyword">const</span> xScale = view.getXScale();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// filter 其实就是一个函数  (value: any, datum: Datum, idx?: number) =&gt; boolean;</span></span><br><span class="line">    <span class="keyword">const</span> filter = getFilter(xScale, <span class="string">'x'</span>, normalCurrent, normalStart);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 核心！根据 filter 进行筛选</span></span><br><span class="line">    <span class="keyword">this</span>.filterView(view, xScale.field, filter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置 y 方向的 filter</span></span><br><span class="line">  <span class="comment">// ... codes</span></span><br><span class="line">  <span class="keyword">this</span>.reRender(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>看下如何获取到 min value 和 max value <code>src/interaction/action/data/range-filter.ts</code><ul><li>获取到的 minValue 和 maxValue 取整后就是时间戳了</li></ul></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFilter</span>(<span class="params">scale: Scale, dim: <span class="built_in">string</span>, point1: Point, point2: Point</span>): <span class="title">FilterCondition</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> min = <span class="built_in">Math</span>.min(point1[dim], point2[dim]);</span><br><span class="line">  <span class="keyword">let</span> max = <span class="built_in">Math</span>.max(point1[dim], point2[dim]);</span><br><span class="line">  <span class="keyword">const</span> [rangeMin, rangeMax] = scale.range;</span><br><span class="line">  <span class="comment">// 约束值在 scale 的 range 之间</span></span><br><span class="line">  <span class="keyword">if</span> (min &lt; rangeMin) &#123;</span><br><span class="line">    min = rangeMin;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (max &gt; rangeMax) &#123;</span><br><span class="line">    max = rangeMax;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 范围大于整个 view 的范围，则返回 null</span></span><br><span class="line">  <span class="keyword">if</span> (min === rangeMax &amp;&amp; max === rangeMax) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> minValue = scale.invert(min);</span><br><span class="line">  <span class="keyword">const</span> maxValue = scale.invert(max);</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 这里获取到的 minValue 和 maxValue，就是对应的 x 轴选择的时间范围</span></span><br><span class="line"><span class="comment">   * 类似 minValue 1611724258188.5186 Wed Jan 27 2021 13:10:58 GMT+0800</span></span><br><span class="line"><span class="comment">   *  maxValue 1611724586405.7407 Wed Jan 27 2021 13:16:26 GMT+0800</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (scale.isCategory) &#123;</span><br><span class="line">    <span class="keyword">const</span> minIndex = scale.values.indexOf(minValue);</span><br><span class="line">    <span class="keyword">const</span> maxIndex = scale.values.indexOf(maxValue);</span><br><span class="line">    <span class="keyword">const</span> arr = scale.values.slice(minIndex, maxIndex + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> arr.includes(value);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> value &gt;= minValue &amp;&amp; value &lt;= maxValue;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在用户定义的 action 上下文里拿到对应的 rangefilter 实例</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.actions.find(<span class="function"><span class="params">v</span> =&gt;</span> v.name === <span class="string">'brush-x'</span>)</span><br></pre></td></tr></table></figure><p>但同时我们也看到，我们需要的 minValue 和 maxValue 都是作为临时计算的产物，并没有挂在对象实例上，所以我们有以下三条路</p><ol><li>获取到 ctx 后，自己重新计算</li><li>修改源码，把这个临时状态挂在对象上。不过需要重新发包，或者把代码纳入版本库？侵入性强，不便于后期升级，还是算了吧</li><li>再去看看其他方案吧</li></ol><p>不需要在选择上浪费太多时间，干就完了。我们先选择方案一，要是后面有更好的，再更换嘛。</p><h3 id="2-3-根据获取到的-ctx-来计算-Min-和-Max"><a href="#2-3-根据获取到的-ctx-来计算-Min-和-Max" class="headerlink" title="2.3 根据获取到的 ctx 来计算 Min 和 Max"></a>2.3 根据获取到的 ctx 来计算 Min 和 Max</h3><p><img src="/assets/image-20210127174119210.png" alt="image-20210127174119210"></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、获取到可视区域 view 的宽度</span></span><br><span class="line"><span class="comment"> * 2、获取到可视区域的时间戳分布</span></span><br><span class="line"><span class="comment"> * 3、算出 brush 的起始点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param ctx</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getBrushedTimeRange</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// action 本身实例</span></span><br><span class="line">  <span class="keyword">const</span> self = ctx.actions.find(<span class="function"><span class="params">v</span> =&gt;</span> v.name === <span class="string">'brush-x'</span>)</span><br><span class="line">  <span class="keyword">const</span> view = self.context.view</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取到两个选择的点</span></span><br><span class="line">  <span class="keyword">const</span> startPoint = self.startPoint</span><br><span class="line">  <span class="keyword">const</span> currentPoint = ctx.getCurrentPoint()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 画布两侧的 padding</span></span><br><span class="line">  <span class="keyword">const</span> paddingLeft = view.padding[<span class="number">3</span>]</span><br><span class="line">  <span class="comment">// 获取主体的实际宽度</span></span><br><span class="line">  <span class="keyword">const</span> totalWith = view.width - view.padding[<span class="number">1</span>] - view.padding[<span class="number">3</span>]</span><br><span class="line">  <span class="comment">// 获取选择点的开始结束坐标</span></span><br><span class="line">  <span class="keyword">const</span> startX = startPoint.x - paddingLeft</span><br><span class="line">  <span class="keyword">const</span> endX = currentPoint.x - paddingLeft</span><br><span class="line"></span><br><span class="line">  <span class="comment">// range 范围的才会落点</span></span><br><span class="line">  <span class="keyword">const</span> timestampsCount = (view.getXScale().max - view.getXScale().min) / (view.getXScale().range[<span class="number">1</span>] - view.getXScale().range[<span class="number">0</span>])</span><br><span class="line">  <span class="comment">// 获取到每一个时间占用的宽度</span></span><br><span class="line">  <span class="keyword">const</span> perTimestampWidth = timestampsCount / totalWith</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始需要补偿的时间范围</span></span><br><span class="line">  <span class="keyword">const</span> startXTimestamp = view.getXScale().min - view.getXScale().range[<span class="number">0</span>] * totalWith * perTimestampWidth</span><br><span class="line">  <span class="keyword">const</span> startTime = startXTimestamp + startX * perTimestampWidth</span><br><span class="line">  <span class="keyword">const</span> endTime = startXTimestamp + endX * perTimestampWidth</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> startTime &lt; endTime ? [startTime, endTime] : [endTime, startTime]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在brush回调的地方，执行下面的动作即可，着重关注 <code>callback</code> 地方</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">registerInteraction(<span class="string">'brushX'</span>, &#123;</span><br><span class="line">  showEnable: [</span><br><span class="line">    &#123; trigger: <span class="string">'plot:mouseenter'</span>, action: <span class="string">'cursor:crosshair'</span> &#125;,</span><br><span class="line">    &#123; trigger: <span class="string">'plot:mouseleave'</span>, action: <span class="string">'cursor:default'</span> &#125;</span><br><span class="line">  ],</span><br><span class="line">  start: [</span><br><span class="line">    &#123;</span><br><span class="line">      trigger: <span class="string">'mousedown'</span>,</span><br><span class="line">      action: [<span class="string">'brush-x:start'</span>, <span class="string">'x-rect-mask:start'</span>, <span class="string">'x-rect-mask:show'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  processing: [</span><br><span class="line">    &#123;</span><br><span class="line">      trigger: <span class="string">'mousemove'</span>,</span><br><span class="line">      action: [<span class="string">'x-rect-mask:resize'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  end: [</span><br><span class="line">    &#123;</span><br><span class="line">      trigger: <span class="string">'mouseup'</span>,</span><br><span class="line">      action: [<span class="string">'brush-x:end'</span>, <span class="string">'x-rect-mask:end'</span>, <span class="string">'x-rect-mask:hide'</span>],</span><br><span class="line">      callback: <span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 重点再这里</span></span><br><span class="line">        <span class="keyword">const</span> [startTime, endTime] = getBrushedTimeRange(ctx)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.$emit(<span class="string">'on-brushed'</span>, [startTime, endTime])</span><br><span class="line">        <span class="keyword">this</span>.resetBrushAction = ctx.actions.find(<span class="function"><span class="params">v</span> =&gt;</span> v.name === <span class="string">'brush-x'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  rollback: [</span><br><span class="line">    &#123; trigger: <span class="string">'dblclick'</span>, action: [<span class="string">'brush-x:reset'</span>, <span class="string">'reset-button:hide'</span>] &#125;,</span><br><span class="line">    &#123; trigger: <span class="string">'reset-button:click'</span>, action: [<span class="string">'brush-x:reset'</span>, <span class="string">'reset-button:hide'</span>] &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="三、踩坑方案"><a href="#三、踩坑方案" class="headerlink" title="三、踩坑方案"></a>三、踩坑方案</h2><h3 id="3-1-直接使用-brush-filter-导致的-scalex-上下文传递不一致问题"><a href="#3-1-直接使用-brush-filter-导致的-scalex-上下文传递不一致问题" class="headerlink" title="3.1 直接使用 brush-filter 导致的 scalex 上下文传递不一致问题"></a>3.1 直接使用 brush-filter 导致的 scalex 上下文传递不一致问题</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hack 原来的 getFilter() 方法，直接返回我们需要的数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param scale Scale</span></span><br><span class="line"><span class="comment"> * @param dim</span></span><br><span class="line"><span class="comment"> * @param point1 Point</span></span><br><span class="line"><span class="comment"> * @param point2</span></span><br><span class="line"><span class="comment"> * @returns &#123;null|&#123;minValue, maxValue&#125;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hackGetFilterReturnMinMax</span>(<span class="params">scale, dim, point1, point2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> min = <span class="built_in">Math</span>.min(point1[dim], point2[dim])</span><br><span class="line">  <span class="keyword">let</span> max = <span class="built_in">Math</span>.max(point1[dim], point2[dim])</span><br><span class="line">  <span class="keyword">const</span> [rangeMin, rangeMax] = scale.range</span><br><span class="line">  <span class="comment">// 约束值在 scale 的 range 之间</span></span><br><span class="line">  <span class="keyword">if</span> (min &lt; rangeMin) &#123;</span><br><span class="line">    min = rangeMin</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (max &gt; rangeMax) &#123;</span><br><span class="line">    max = rangeMax</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 范围大于整个 view 的范围，则返回 null</span></span><br><span class="line">  <span class="keyword">if</span> (min === rangeMax &amp;&amp; max === rangeMax) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> minValue = scale.invert(min)</span><br><span class="line">  <span class="keyword">const</span> maxValue = scale.invert(max)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// console.log('start', minValue, 'end', maxValue)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; minValue, maxValue &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-区分-view-的几个视角"><a href="#3-2-区分-view-的几个视角" class="headerlink" title="3.2 区分 view 的几个视角"></a>3.2 区分 view 的几个视角</h3><p><img src="/assets/image-20210127174110482.png" alt="image-20210127174110482"></p><h2 id="四、一些链接"><a href="#四、一些链接" class="headerlink" title="四、一些链接"></a>四、一些链接</h2><h3 id="4-1-tooltip-联动"><a href="#4-1-tooltip-联动" class="headerlink" title="4.1 tooltip 联动"></a>4.1 tooltip 联动</h3><p><a href="https://antv-g2.gitee.io/zh/examples/interaction/others#views-tooltip" target="_blank" rel="noopener">https://antv-g2.gitee.io/zh/examples/interaction/others#views-tooltip</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;G2-brush-时间轴，而不是筛选数据点&quot;&gt;&lt;a href=&quot;#G2-brush-时间轴，而不是筛选数据点&quot; class=&quot;headerlink&quot; title=&quot;G2 brush 时间轴，而不是筛选数据点&quot;&gt;&lt;/a&gt;G2 brush 时间轴，而不是筛选数据点&lt;/
      
    
    </summary>
    
      <category term="编程" scheme="https://rovast.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="antv" scheme="https://rovast.github.io/tags/antv/"/>
    
  </entry>
  
  <entry>
    <title>SkyWalking PHP 内核代码剖析</title>
    <link href="https://rovast.github.io/2021/01/29/skywalking-php-kernel-flow/"/>
    <id>https://rovast.github.io/2021/01/29/skywalking-php-kernel-flow/</id>
    <published>2021-01-29T09:04:15.000Z</published>
    <updated>2022-09-28T06:14:26.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、总体流程"><a href="#一、总体流程" class="headerlink" title="一、总体流程"></a>一、总体流程</h2><p>PHP 重要几个生命周期说明，先后顺序为 PHP_MI、PHP_RI、PHP_EXECUTE、PHP_RS、PHP_MS，每个模块的作用如下</p><ul><li>PHP_MI，模块初始化阶段，主要进行 PHP 框架、Zend 引擎的初始化工作。重要的几个工作如下：<ul><li>全局状态信息的初始化，如 SG、CG、EG等</li><li>启动 Zend 引擎，内存池启动、注册虚拟机的各项执行句柄</li><li>解析 php.ini 配置文件</li><li>注册拓展，包括静态编译拓展和动态编译拓展</li><li><strong>回调拓展定义的 MI 函数，即 <code>PHP_MINIT_FUNCTION</code> </strong></li></ul></li><li>PHP_RI，请求初始化阶段，CLI 模式下，该函数执行一次。如果是 php-fpm 模式下，会在 PHP_RI 和 PHP_RS 之间循环。该阶段需要关注的有如下事宜：<ul><li>激活 zend 引擎，包括：重置垃圾回收器、初始化编译器、初始化执行器、初始化词法扫描器</li><li><strong>回调各拓展定义的 RI 函数，即 <code>PHP_RINIT_FUNCTION</code></strong></li></ul></li><li>PHP_EXECUTE，脚本执行阶段。通过拦截 zend 引擎的 execute 函数，我们可以捕获用户执行的每一条语句，我们可以在此阶段，进行 MySQL、Redis、CURL等代码的捕获，从而生成对应的 span，进而构建 trace。</li><li>PHP_RS，请求关闭阶段。该阶段主要进行请求资源的释放动作，同时这个是 fpm 请求的最后一个阶段，我们可以在此阶段，把本次请求获取的 segment 信息上报至 sidecar</li><li>PHP_MS，模块关闭阶段。各项资源的释放</li></ul><p>SkyWalking PHP 内核的主要处理流程整理如下：</p><p><img src="/assets/image-20210118185219149.png" alt="image-20210118185219149"></p><h2 id="二、PHP-MI-阶段，自定义函数执行器替换Zend内核执行器"><a href="#二、PHP-MI-阶段，自定义函数执行器替换Zend内核执行器" class="headerlink" title="二、PHP_MI 阶段，自定义函数执行器替换Zend内核执行器"></a>二、PHP_MI 阶段，自定义函数执行器替换Zend内核执行器</h2><p><img src="/assets/image-20210118191216694.png" alt="image-20210118191216694"></p><p>该阶段的入口函数 <strong><code>PHP_MINIT_FUNCTION (skywalking)</code></strong></p><h3 id="2-1-代码命名约定"><a href="#2-1-代码命名约定" class="headerlink" title="2.1 代码命名约定"></a>2.1 代码命名约定</h3><p>该阶段主要是进行 Zend 执行器的 assign 动作，变量的命名有如下规则：</p><ul><li><code>ori_</code> 打头的，是 Zend 引擎的原函数，这里做备份，便于 hack 后，恢复原来的执行</li><li><code>zend_</code> 打头的，就是 Zend 引擎的内置函数</li><li><code>sky_</code> 打头的，是我们计划在对应阶段进行的自定义动作。一般在自定义动作的最后，都会使用 <code>ori_</code> 来交还函数控制权，恢复原来正常流程函数的执行动作</li></ul><p>部分代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PHP_MINIT_FUNCTION (skywalking) &#123;</span><br><span class="line">  <span class="comment">// .....</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 用户自定义函数执行器(php脚本定义的类、函数)</span></span><br><span class="line">  ori_execute_ex = zend_execute_ex;</span><br><span class="line">  zend_execute_ex = sky_execute_ex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 内部函数执行器(c语言定义的类、函数)</span></span><br><span class="line">  ori_execute_internal = zend_execute_internal;</span><br><span class="line">  zend_execute_internal = sky_execute_internal;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-拦截的函数分类和意义"><a href="#2-2-拦截的函数分类和意义" class="headerlink" title="2.2 拦截的函数分类和意义"></a>2.2 拦截的函数分类和意义</h3><p>其拦截的函数主要分三类：</p><ul><li>zend_execute_ex，拦截用户态函数，即我们平时写的 .php 文件里面的代码。这里可以捕获到 class name 类名、function name 函数名</li><li>zend_execute_internal，拦截 PHP 内置的函数和类等，比如 PDO、mysqli 等</li><li>CURL相关的函数句柄，这样我们就可以捕获函数的上下游 http 调用信息。其拦截的函数包括：curl_exec、curl_setopt、curl_setopt_array、curl_close</li></ul><h2 id="三、PHP-RI-阶段，请求初始化，注册-sky-agent，构造原始-segment"><a href="#三、PHP-RI-阶段，请求初始化，注册-sky-agent，构造原始-segment" class="headerlink" title="三、PHP_RI 阶段，请求初始化，注册 sky-agent，构造原始 segment"></a>三、PHP_RI 阶段，请求初始化，注册 sky-agent，构造原始 segment</h2><p>入口函数 <code>PHP_RINIT_FUNCTION(skywalking)</code></p><h3 id="3-1-主要流程"><a href="#3-1-主要流程" class="headerlink" title="3.1 主要流程"></a>3.1 主要流程</h3><p>PHP_RI 阶段在每一个 fpm 请求时都会触发一次，在此阶段，主要进行以下两件事</p><ul><li><code>static int sky_register()</code>，通过 unix sock 通信，注册 agent，同时根据返回的握手信息来确定 app、service、instance信息</li><li><code>static void request_init()</code> ，构造 segement 信息，这里包含了以下重要信息<ul><li>生成 traceId</li><li>根据 header 的 sw8 字段来解析上游信息，进而构造 span 信心，refs 信息</li></ul></li></ul><h3 id="3-2-traceId-生成规则，三段格式-instance-pid-second"><a href="#3-2-traceId-生成规则，三段格式-instance-pid-second" class="headerlink" title="3.2 traceId 生成规则，三段格式 instance.pid.second"></a>3.2 traceId 生成规则，三段格式 instance.pid.second</h3><p>其核心代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generate_context</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sys_pid = getpid();</span><br><span class="line">  <span class="keyword">long</span> second = get_second();</span><br><span class="line">  second = second * <span class="number">10000</span> + sky_increment_id; <span class="comment">//创建traceid的因子</span></span><br><span class="line">  <span class="keyword">char</span> *makeTraceId;</span><br><span class="line">  makeTraceId = (<span class="keyword">char</span> *) emalloc(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * <span class="number">180</span>); <span class="comment">//分配traceId所需要的内存</span></span><br><span class="line"></span><br><span class="line">  bzero(makeTraceId, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * <span class="number">180</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sprintf</span>(makeTraceId, <span class="string">"%d.%d.%ld"</span>, application_instance, sys_pid, second);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// .....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 sky_increment_id 是 0~9999。MSP 平台中显示的 TraceId 信息，类似如下：</p><p><img src="/assets/image-20210118194441556.png" alt="image-20210118194441556"></p><p>我们来简短分析下，按点「.」分割</p><ul><li><code>1</code>。因为在 sky_register 阶段，application_instance 固定为 1</li><li><code>393</code>，即 pid</li><li><code>16109522148050</code> 这个就是时间戳 + sky_increment_id 构成的了</li></ul><h3 id="3-3-header-里的-HTTP-SW8-数据含义"><a href="#3-3-header-里的-HTTP-SW8-数据含义" class="headerlink" title="3.3 header 里的 HTTP_SW8 数据含义"></a>3.3 header 里的 HTTP_SW8 数据含义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generate_context</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// .......</span></span><br><span class="line">  <span class="comment">// 获取 header HTTP_SW8 信息</span></span><br><span class="line">  sw = zend_hash_str_find(Z_ARRVAL_P(carrier), <span class="string">"HTTP_SW8"</span>, <span class="keyword">sizeof</span>(<span class="string">"HTTP_SW8"</span>) - <span class="number">1</span>); <span class="comment">//$SERVER['HTTP_SW8'];</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// .......</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 按中横线（-）分割为 sw8_N 数组</span></span><br><span class="line">  php_explode(zend_string_init(ZEND_STRL(<span class="string">"-"</span>), <span class="number">0</span>), Z_STR_P(sw), &amp;temp, <span class="number">10</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">  <span class="comment">// 对分割后的数组，进行解码，其 index 为 1,2,4,5,6,7</span></span><br><span class="line">  zval_b64_decode(&amp;sw8_1decode, Z_STRVAL_P(sw8_1));</span><br><span class="line">  zval_b64_decode(&amp;sw8_2decode, Z_STRVAL_P(sw8_2));</span><br><span class="line">  zval_b64_decode(&amp;sw8_4decode, Z_STRVAL_P(sw8_4));</span><br><span class="line">  zval_b64_decode(&amp;sw8_5decode, Z_STRVAL_P(sw8_5));</span><br><span class="line">  zval_b64_decode(&amp;sw8_6decode, Z_STRVAL_P(sw8_6));</span><br><span class="line">  zval_b64_decode(&amp;sw8_7decode, Z_STRVAL_P(sw8_7));</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// .......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们去网关日志里，取一个样本分析，得到的原始 header 信息如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1-QzBBODNDMzEtMTYxMDk1MzUyODM0MC0xMTc3OTctQS0xMjcw-QzBBODNDMzEtMTYxMDk1MzUyODM0MC0xMTc3OTctQS0xMjcw-1-xxxxxxxxxxxx-YjcyOWU0MzUtNjA5Zi00YzMwLWI4MjctNjZmMmUyYWZjNmM2-xxxxxxxxxx==-xxxxx.service</span><br></pre></td></tr></table></figure><p>我们按中横线(-)分割，得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">QzBBODNDMzEtMTYxMDk1MzUyODM0MC0xMTc3OTctQS0xMjcw // Trace Id base64</span><br><span class="line">QzBBODNDMzEtMTYxMDk1MzUyODM0MC0xMTc3OTctQS0xMjcw // Parent trace segment Id</span><br><span class="line">1                                                // Parent span Id</span><br><span class="line">xxxxxxxxxxxx                                     // Parent service</span><br><span class="line">YjcyOWU0MzUtNjA5Zi00YzMwLWI4MjctNjZmMmUyYWZjNmM2 // Parent service instance</span><br><span class="line">xxxxxxxxxx==                                     // Parent endpoint</span><br><span class="line">xxxxx.service                                    // Target address used at client side of this request</span><br></pre></td></tr></table></figure><p>我们对其中 1,2,4,5,6,7 进行 base64 解码，得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">C0A83C31-1610953528340-117797-A-1270 // Trace Id base64</span><br><span class="line">C0A83C31-1610953528340-117797-A-1270 // Parent trace segment Id</span><br><span class="line">1                                    // Parent span Id</span><br><span class="line">xxxxxxxxxxxxx                        // Parent service</span><br><span class="line">b729e435-609f-4c30-b827-66f2e2afc6c6 // Parent service instance</span><br><span class="line">xxxxxxxxxxxxxxxxxxxxxxxxx            // Parent endpoint</span><br><span class="line">xxxxxxxxxx.service                   // Target address used at client side of this request</span><br></pre></td></tr></table></figure><h3 id="3-4-RI-周期主要流程如下"><a href="#3-4-RI-周期主要流程如下" class="headerlink" title="3.4 RI 周期主要流程如下"></a>3.4 RI 周期主要流程如下</h3><p><img src="/assets/lifecycle.png" alt="lifecycle"></p><h2 id="四、PHP-EXECUTE-阶段，拦截代码执行语句，分析后恢复执行"><a href="#四、PHP-EXECUTE-阶段，拦截代码执行语句，分析后恢复执行" class="headerlink" title="四、PHP_EXECUTE 阶段，拦截代码执行语句，分析后恢复执行"></a>四、PHP_EXECUTE 阶段，拦截代码执行语句，分析后恢复执行</h2><p><img src="/assets/image-20210118193135548.png" alt="image-20210118193135548"></p><p>在 MI 阶段，我们替换了 zend 引擎的函数执行指向，所以所有语句的执行会被我们接管。我们在执行完自己需要的动作后，还原原来的执行即可。</p><p>需要注意的是，我们接管的函数会被多次触发，每执行一条 opline，就会被触发一次(存疑，待指正)。</p><h3 id="4-1-ZEND-API-void-sky-execute-ex-zend-execute-data-execute-data"><a href="#4-1-ZEND-API-void-sky-execute-ex-zend-execute-data-execute-data" class="headerlink" title="4.1 ZEND_API void sky_execute_ex(zend_execute_data *execute_data)"></a>4.1 ZEND_API void sky_execute_ex(zend_execute_data *execute_data)</h3><p>核心的流程如下</p><ol><li>获取当前代码执行的信息，包括：类名、函数名</li><li>对类名和函数名进行判断，看是否需要拦截。目前拦截的是 Predis SDK</li><li>如果需要拦截，根据拦截信息构造 span</li><li>把构造好的 span 插入到当前 segment 的 spans 数组里</li><li>恢复函数原来的执行，调用 <code>ori_</code> 即可</li></ol><p><img src="/assets/image-20210118200055531.png" alt="image-20210118200055531"></p><h3 id="4-2-ZEND-API-void-sky-execute-internal-zend-execute-data-execute-data-zval-return-value"><a href="#4-2-ZEND-API-void-sky-execute-internal-zend-execute-data-execute-data-zval-return-value" class="headerlink" title="4.2 ZEND_API void sky_execute_internal(zend_execute_data execute_data, zval return_value)"></a>4.2 ZEND_API void sky_execute_internal(zend_execute_data <em>execute_data, zval </em>return_value)</h3><p>其核心流程和上面 4.1 分析的类似，其不同就在于这里拦截的是 PHP 内置的一些类，即编译时就安装的类。流程主要包括</p><ol><li>获取类名和函数名</li><li>根据类名判断是否需要拦截，目前需要拦截：PDO、PDOStatement、mysqli、Yar_Client、Reids、Memecached</li><li>构造 span，插入到当前 segment 的 spans 数组里</li><li>恢复函数执行</li></ol><p><img src="/assets/image-20210118200231152.png" alt="image-20210118200231152"></p><h3 id="4-3-CURL-HOOK"><a href="#4-3-CURL-HOOK" class="headerlink" title="4.3 CURL HOOK"></a>4.3 CURL HOOK</h3><p>这里主要是调用链的传递，如果发现有 curl 请求，则根据规则生成当前的 sw8 信息，塞到 http header 的 sw8 字段里，传递给下游。</p><p>更多的流程，以后补充。</p><p><img src="/assets/image-20210118200521291.png" alt="image-20210118200521291"></p><h2 id="五、PHP-RS-请求结束阶段，发送-segment-信息至-sidecar"><a href="#五、PHP-RS-请求结束阶段，发送-segment-信息至-sidecar" class="headerlink" title="五、PHP_RS 请求结束阶段，发送 segment 信息至 sidecar"></a>五、PHP_RS 请求结束阶段，发送 segment 信息至 sidecar</h2><p>PHP_RS 阶段主要做两件事儿：</p><ol><li><p>通过 unix sock 发送本请求构建的 segment 信息至 sidecar</p></li><li><p>释放当前请求里的全局状态存储。由于其他的 int、char、boolean 类型的不涉及到内存管理，所以就是四个 zval 的释放</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ZEND_BEGIN_MODULE_GLOBALS(skywalking)</span><br><span class="line">    <span class="keyword">char</span> *sock_path;</span><br><span class="line">    <span class="keyword">char</span> *app_code; <span class="comment">//app_name eg:skywalking.app_code = MyProjectName</span></span><br><span class="line">    <span class="keyword">char</span> *app_code_env_key; <span class="comment">//app_name 环境变量地址：环境变量-&gt;默认KEY：APM_APP_CODE</span></span><br><span class="line">    zend_bool enable;</span><br><span class="line">    zval UpstreamSegment; <span class="comment">//全局上报数据段</span></span><br><span class="line">    zval context;</span><br><span class="line">    zval curl_header; <span class="comment">//curl header数据</span></span><br><span class="line">    zval curl_header_send; <span class="comment">//记录当前R周期 是否已经send过curl_header</span></span><br><span class="line">    <span class="keyword">int</span>  version;</span><br><span class="line">ZEND_END_MODULE_GLOBALS(skywalking)</span><br></pre></td></tr></table></figure></li></ol><p><img src="/assets/image-20210118200709516.png" alt="image-20210118200709516"></p><h2 id="六、PHP-MS-模块结束阶段"><a href="#六、PHP-MS-模块结束阶段" class="headerlink" title="六、PHP_MS 模块结束阶段"></a>六、PHP_MS 模块结束阶段</h2><p>这个阶段没啥好说的，没啥特殊操作</p><h2 id="七、全景，整个大脑图"><a href="#七、全景，整个大脑图" class="headerlink" title="七、全景，整个大脑图"></a>七、全景，整个大脑图</h2><p><img src="/assets/lifecycle2.png" alt="lifecycle2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、总体流程&quot;&gt;&lt;a href=&quot;#一、总体流程&quot; class=&quot;headerlink&quot; title=&quot;一、总体流程&quot;&gt;&lt;/a&gt;一、总体流程&lt;/h2&gt;&lt;p&gt;PHP 重要几个生命周期说明，先后顺序为 PHP_MI、PHP_RI、PHP_EXECUTE、PHP_RS、
      
    
    </summary>
    
      <category term="云原生" scheme="https://rovast.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
      <category term="APM" scheme="https://rovast.github.io/categories/APM/"/>
    
    
      <category term="APM" scheme="https://rovast.github.io/tags/APM/"/>
    
  </entry>
  
  <entry>
    <title>在 Mac 上使用 Clion 调试 PHP 源码</title>
    <link href="https://rovast.github.io/2020/12/27/debug-php-src-on-mac/"/>
    <id>https://rovast.github.io/2020/12/27/debug-php-src-on-mac/</id>
    <published>2020-12-27T03:39:39.000Z</published>
    <updated>2022-09-28T06:14:26.544Z</updated>
    
    <content type="html"><![CDATA[<p>参考 <a href="https://www.jianshu.com/p/f6af567b25a7" target="_blank" rel="noopener">https://www.jianshu.com/p/f6af567b25a7</a></p><h2 id="一、编译安装-debug-版本的-PHP"><a href="#一、编译安装-debug-版本的-PHP" class="headerlink" title="一、编译安装 debug 版本的 PHP"></a>一、编译安装 debug 版本的 PHP</h2><ol><li><p>configure php</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./configure --<span class="built_in">enable</span>-fpm --<span class="built_in">enable</span>-debug  --with-openssl=/usr/<span class="built_in">local</span>/Cellar/openssl@1.1/1.1.1i/ \</span><br><span class="line">--<span class="built_in">enable</span>-bcmath --with-curl  --<span class="built_in">enable</span>-exif --with-mysqli --with-pdo-mysql \</span><br><span class="line">--<span class="built_in">enable</span>-zip --with-zlib=/usr/<span class="built_in">local</span>/Cellar/zlib/1.2.11/ --<span class="built_in">enable</span>-intl --<span class="built_in">enable</span>-pcntl --<span class="built_in">enable</span>-mbstring --<span class="built_in">enable</span>-soap \</span><br><span class="line">--with-icu-dir=/usr/<span class="built_in">local</span>/Cellar/icu4c/67.1 \</span><br><span class="line">--with-iconv=/usr/<span class="built_in">local</span>/Cellar/libiconv/1.16 \</span><br><span class="line">--with-libxml-dir=/usr/<span class="built_in">local</span>/Cellar/libxml2/2.9.10_2</span><br></pre></td></tr></table></figure></li><li><p>修改 makefile</p></li></ol><p>查找关键字 <code>EXTRA_LIBS =</code> 我的在 line 108，删除所有的 <code>-liconv</code>，末尾加上 <code>/usr/local/opt/libiconv/lib/libiconv.dylib</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改前</span></span><br><span class="line">EXTRA_LIBS = -lcrypto -lssl -lcrypto -lz -lresolv -lstdc++ -liconv -liconv -lz -lcrypto -lssl -lcrypto -lm -lxml2 -lz -liconv -lm -lcurl -lxml2 -lz -liconv -lm -licui18n -licuuc -licudata -licuio -lxml2 -lz -liconv -lm -lxml2 -lz -liconv -lm -lxml2 -lz -liconv -lm -lxml2 -lz -liconv -lm -lxml2 -lz -liconv -lm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改后</span></span><br><span class="line">EXTRA_LIBS = -lcrypto -lssl -lcrypto -lz -lresolv -lstdc++ -lz -lcrypto -lssl -lcrypto -lm -lxml2 -lz -lm -lcurl -lxml2 -lz -lm -licui18n -licuuc -licudata -licuio -lxml2 -lz -lm -lxml2 -lz -lm -lxml2 -lz -lm -lxml2 -lz -lm -lxml2 -lz -lm /usr/<span class="built_in">local</span>/opt/libiconv/lib/libiconv.dylib</span><br></pre></td></tr></table></figure></p><ol start="3"><li><p>make</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></li><li><p>sudo make install</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure></li></ol><h2 id="二、设定一些目录的权限，不然-Clion-不能正常调试"><a href="#二、设定一些目录的权限，不然-Clion-不能正常调试" class="headerlink" title="二、设定一些目录的权限，不然 Clion 不能正常调试"></a>二、设定一些目录的权限，不然 Clion 不能正常调试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R rovast:wheel /usr/<span class="built_in">local</span>/lib/php/</span><br></pre></td></tr></table></figure><h2 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.13)</span><br><span class="line">project(php_7_2_27)</span><br><span class="line"></span><br><span class="line">set(CMAKE_CXX_STANDARD 14)</span><br><span class="line"></span><br><span class="line">set(PHP_SOURCE /Users/rovast/Software/tmp/php-7.2.27)</span><br><span class="line"></span><br><span class="line">include_directories($&#123;PHP_SOURCE&#125;/main)</span><br><span class="line"></span><br><span class="line">include_directories($&#123;PHP_SOURCE&#125;/Zend)</span><br><span class="line"></span><br><span class="line">include_directories($&#123;PHP_SOURCE&#125;/sapi)</span><br><span class="line"></span><br><span class="line">include_directories($&#123;PHP_SOURCE&#125;/pear)</span><br><span class="line"></span><br><span class="line">include_directories($&#123;PHP_SOURCE&#125;/TSRM)</span><br><span class="line"></span><br><span class="line">include_directories($&#123;PHP_SOURCE&#125;)</span><br><span class="line"></span><br><span class="line">add_custom_target(makefile COMMAND make &amp;&amp; make install WORKING_DIRECTORY $&#123;PROJECT_SOURCE_DIR&#125;)</span><br></pre></td></tr></table></figure><h1 id="debug-on-ubuntu"><a href="#debug-on-ubuntu" class="headerlink" title="debug on ubuntu"></a>debug on ubuntu</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libxml2-dev</span><br><span class="line">./configure --<span class="built_in">enable</span>-debug --<span class="built_in">enable</span>-fpm</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考 &lt;a href=&quot;https://www.jianshu.com/p/f6af567b25a7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/f6af567b25a7&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=
      
    
    </summary>
    
      <category term="杂项" scheme="https://rovast.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="mac" scheme="https://rovast.github.io/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>grafana iframe 接入备忘录</title>
    <link href="https://rovast.github.io/2020/12/23/grafana-iframe/"/>
    <id>https://rovast.github.io/2020/12/23/grafana-iframe/</id>
    <published>2020-12-23T02:46:30.000Z</published>
    <updated>2022-09-28T06:14:26.552Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iframe-引入"><a href="#iframe-引入" class="headerlink" title="iframe 引入"></a>iframe 引入</h1><p>部分配置修改后才能进行 iframe 嵌入，默认是不支持的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">allow_embedding: <span class="literal">true</span> <span class="comment"># 默认是 false， 为了防止 Clickjacking，如果不设置，浏览器会拒绝显示 iframe</span></span><br><span class="line">cookie_samesite: none <span class="comment"># 如果不设置，无法使用登录功能</span></span><br><span class="line">cookie_secure: <span class="literal">true</span> <span class="comment"># if you're using https and let us know how that works out.</span></span><br></pre></td></tr></table></figure><p>配置说明 <a href="https://grafana.com/docs/grafana/latest/administration/configuration/" target="_blank" rel="noopener">https://grafana.com/docs/grafana/latest/administration/configuration/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cookie_secure</span><br><span class="line">Set to true if you host Grafana behind HTTPS. Default is false.</span><br><span class="line"></span><br><span class="line">cookie_samesite</span><br><span class="line">Sets the SameSite cookie attribute and prevents the browser from sending this cookie along with cross-site requests. </span><br><span class="line">The main goal is to mitigate the risk of cross-origin information leakage. </span><br><span class="line">This setting also provides some protection against cross-site request forgery attacks (CSRF), read more about SameSite here. </span><br><span class="line">Valid values are lax, strict, none, and disabled. Default is lax. </span><br><span class="line">Using value disabled does not add any SameSite attribute to cookies.</span><br><span class="line"></span><br><span class="line">allow_embedding</span><br><span class="line">When false, the HTTP header X-Frame-Options: deny will be set in Grafana HTTP responses which will instruct browsers </span><br><span class="line">to not allow rendering Grafana in a &lt;frame&gt;, &lt;iframe&gt;, &lt;embed&gt; or &lt;object&gt;. </span><br><span class="line">The main goal is to mitigate the risk of Clickjacking. Default is false.</span><br></pre></td></tr></table></figure><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>隐藏左侧菜单和增加时间范围</p><ul><li><code>?kiosk=tv</code> 隐藏左侧的菜单</li><li><code>?from=now-1h&amp;to=now</code> 显示最近一小时的内容</li></ul><h1 id="免登陆访问-dashboard"><a href="#免登陆访问-dashboard" class="headerlink" title="免登陆访问 dashboard"></a>免登陆访问 dashboard</h1><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>暂时不支持设定指定的 dashboard 为 public，即：免认证访问。如果开启了只读权限，则所有人皆可以访问</p><h2 id="相关调研"><a href="#相关调研" class="headerlink" title="相关调研"></a>相关调研</h2><p>1、<a href="https://community.grafana.com/t/making-selected-dashboards-public/873" target="_blank" rel="noopener">《Making selected dashboards public》</a></p><blockquote><p>There is no way to do this and there is a big reason why.<br>If you make one dashboard public you will have to make your data source public<br>(ie anyone can query against it).<br>So any possible query for that data source can be issued not just the queries used in the dashboard you made public.</p></blockquote><p>根据初步的调研，得到的答复是不能指定 dashboard 开放 public 权限。同时，官方的 issue 里也有关于此问题的回复</p><p>2、<a href="https://github.com/grafana/grafana/issues/14473" target="_blank" rel="noopener">《[FeatureRequest] Dashboards: Add real time share instead of snapshot》</a></p><p>目前依旧是处于 Open 状态。</p><h2 id="折衷方案"><a href="#折衷方案" class="headerlink" title="折衷方案"></a>折衷方案</h2><p><a href="https://community.grafana.com/t/how-to-make-one-live-dashboard-public/12819" target="_blank" rel="noopener">《How to make one live dashboard public》</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iframe-引入&quot;&gt;&lt;a href=&quot;#iframe-引入&quot; class=&quot;headerlink&quot; title=&quot;iframe 引入&quot;&gt;&lt;/a&gt;iframe 引入&lt;/h1&gt;&lt;p&gt;部分配置修改后才能进行 iframe 嵌入，默认是不支持的&lt;/p&gt;
&lt;figure 
      
    
    </summary>
    
      <category term="编程" scheme="https://rovast.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="iframe" scheme="https://rovast.github.io/tags/iframe/"/>
    
  </entry>
  
  <entry>
    <title>makefile 简明教程</title>
    <link href="https://rovast.github.io/2020/11/28/makefile-tutorials/"/>
    <id>https://rovast.github.io/2020/11/28/makefile-tutorials/</id>
    <published>2020-11-28T21:39:18.000Z</published>
    <updated>2022-09-28T06:14:26.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Makefile-简明教程"><a href="#Makefile-简明教程" class="headerlink" title="Makefile 简明教程"></a>Makefile 简明教程</h1><blockquote><p> 英文原文地址：<a href="https://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/" target="_blank" rel="noopener">https://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/</a></p></blockquote><p>Makefiles 是组织代码编译的一种方式。通过这篇简明教程，虽然你不能完整学会 <code>make</code> 指令，但是你可以使用 makefile 来组织小到中型的项目啦。</p><h2 id="一个-简单的例子"><a href="#一个-简单的例子" class="headerlink" title="一个 简单的例子"></a>一个 简单的例子</h2><p>我们来从下面的三个文件开始吧：<code>hellomake.c</code>，<code>hellofunc.c</code>，<code>hellomake.h</code>。这是一个经典 C 语言程序，代码根据功能组织在不同的文件中。</p><p><em>hellomake.c</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hellomake.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 调用另一个文件里的函数</span></span><br><span class="line">  myPrintHelloMake();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>hellofunc.c</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hellomake.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintHelloMake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello makefiles!\n"</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>hellomake.h</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* example include file */</span><br><span class="line">void myPrintHelloMake(void);</span><br></pre></td></tr></table></figure><p>一般情况下，我们通过下面的指令来编译代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hellomake hellomake.c hellofunc.c -I.</span><br></pre></td></tr></table></figure><p>我们来说明下这个指令：</p><ol><li>我们编译两个 <code>.c</code> 文件</li><li>命名了编译后的可执行文件为 <code>hellomake</code></li><li><code>-I.</code> 告诉 gcc 在当前目录中寻找 <code>hellomake.h</code></li></ol><p>如果没有使用 makefile，我们在调试开发的时候，可以在终端上输入 <code>向上方向键</code> 来快速显示上次的指令（尤其是你有多个 <code>.c</code> 文件需要编译的时候）。</p><p>然而，通过上面的直接输入编译指令的方式存在两个弊端：</p><ul><li><strong>弊端一：</strong>不方便呀！当你换了电脑之后，你要重新再输入上面的指令。</li><li><strong>弊端二：</strong>编译效率低下！即使你只是修改了项目中的一个 <code>.c</code> 文件，每次编译时，还是需要编译所有的文件，这无疑是效率低下，浪费时间。</li></ul><p>所以接下来，请出本文的主角 —— makefile。</p><h2 id="Makefile1"><a href="#Makefile1" class="headerlink" title="Makefile1"></a>Makefile1</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hellomake: hellomake.c hellofunc.c</span></span><br><span class="line">gcc -o hellomake hellomake.c hellofunc.c -I.</span><br></pre></td></tr></table></figure><p>把上述的内容，放入到 <code>Makefile</code> 或者 <code>makefile</code> 文件，然后在命令行输入 <code>make</code> 命令，就能够直接执行编译了。有以下几点我们需要关注下：</p><ol><li>如果 <code>make</code> 后面没有跟任何参数，那么他就会执行 makefile 的第一条规则。</li><li>把命令依赖的文件放在第一行的 <code>:</code> 后面，这样 <code>make</code> 就能知道，当依赖文件变化时， <code>hellomake</code> 规则需要重新执行。</li><li>注意，第二行 <code>gcc</code> 前面，是一个 <code>tab</code> 制表符！不要使用空格！</li></ol><p>通过这样简单的 Makefile，我们已经解决了弊端一的问题，即：我们不需要每次都输入编译指令了。</p><p>然而，现在还不够高效，即使只修改了一个文件，还是需要全量编译（即编译所有的源文件）。为了使编译更加高效，让我们继续往下看。</p><h2 id="Makefile2"><a href="#Makefile2" class="headerlink" title="Makefile2"></a>Makefile2</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">CFLAGS=-I.</span><br><span class="line"></span><br><span class="line"><span class="section">hellomake: hellomake.o hellofunc.o</span></span><br><span class="line"><span class="variable">$(CC)</span> -o hellomake hellomake.o hellofunc.o</span><br></pre></td></tr></table></figure><p>我们定义了两个常量 <code>CC</code>、 <code>CFLAGS</code>，这两个常量告诉 <code>make</code> 怎么去编译 <code>hellomake.c</code> 和 <code>hellofunc.c</code>。其中 <code>CC</code> 告诉 make 使用哪个 C 编译器，<code>CFLAGS</code> 说明了编译指令的参数列表。通过把 <code>hellomake.o</code> 和 <code>hellofunc.o</code> 放到依赖列表中， <code>make</code> 指令就知道每次需要分别编译 <code>.c</code> 文件，然后再把他们编译为可行性文件 <code>hellomake</code>。</p><p>终端执行效果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  makefile-tourial git:(master) ✗ make</span><br><span class="line">gcc -I.   -c -o hellomake.o hellomake.c</span><br><span class="line">gcc -I.   -c -o hellofunc.o hellofunc.c</span><br><span class="line">gcc -o hellomake hellomake.o hellofunc.o</span><br><span class="line">➜  makefile-tourial git:(master) ✗</span><br></pre></td></tr></table></figure><p>这种形式的 makefile 对小型的项目还是比较方便的。然而，还是有个问题，那就是依赖文件的更新。设想下，即使你修改了<code>hellomake.h</code> 文件，<code>make</code> 指令不会重新编译文件。</p><p>为了解决这个问题，我们需要告诉 <code>make</code> 一件事情：即<code>.c</code> 文件和 <code>.h</code> 文件间的依赖关系。好，我们继续往下看。</p><h2 id="Makefile3"><a href="#Makefile3" class="headerlink" title="Makefile3"></a>Makefile3</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">CFLAGS=-I.</span><br><span class="line">DEPS = hellomake.h</span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c <span class="variable">$(DEPS)</span></span></span><br><span class="line"><span class="variable">$(CC)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span> <span class="variable">$(CFLAGS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">hellomake: hellomake.o hellofunc.o</span></span><br><span class="line"><span class="variable">$(CC)</span> -o hellomake hellomake.o hellofunc.o</span><br></pre></td></tr></table></figure><p>相较于上个版本，我们先是增加了一个 <code>DEPS</code>：这里列出了 <code>.c</code> 文件所依赖的 <code>.h</code> 文件集合。</p><p>接着，我们定义了一个了规则 <code>%.o: %.c $(DEPS)</code>：它说明了 <code>.o</code> 文件是取决于 <code>.c</code> 文件和 <code>DEPS</code> 里的 <code>.h</code> 文件。</p><p>接下来我们看下规则 <code>$(CC) -c -o $@ $&lt; $(CFLAGS)</code>，意思是说，为了生成这些 <code>.o</code> 文件，<code>make</code> 指令使用了 <code>CC</code> 定义的编译器来编译 <code>.c</code> 文件：</p><ul><li><code>-c</code> 说明了是为了生成目标文件（object files）</li><li><code>$@</code> 代表 <code>:</code> 左边的内容，即：<code>%.o</code></li><li><code>$&lt;</code> 是依赖列表里的第一项，即：<code>%.c</code></li><li><code>CFLAGS</code> 和之前的说明一样，就是编译的指令参数了(flag）</li></ul><p>执行效果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  makefile-tourial git:(master) ✗ make</span><br><span class="line">gcc -c -o hellomake.o hellomake.c -I.</span><br><span class="line">gcc -c -o hellofunc.o hellofunc.c -I.</span><br><span class="line">gcc -o hellomake hellomake.o hellofunc.o</span><br><span class="line">➜  makefile-tourial git:(master) ✗</span><br></pre></td></tr></table></figure><p>最后，我们再来做下简化，使编译更具通用性。我们使用 <code>$@</code> 和 <code>$^</code> 来分别表示 <code>:</code>  的左侧和右侧。在下面的例子里，所有 include 文件会作为 <code>DEPS</code> 的一部分，所有目标文件（object files）会作为 <code>OBJ</code> 的一部分。</p><h2 id="Makefile4"><a href="#Makefile4" class="headerlink" title="Makefile4"></a>Makefile4</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">CFLAGS=-I.</span><br><span class="line">DEPS = hellomake.h</span><br><span class="line">OBJ = hellomake.o hellofunc.o</span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c <span class="variable">$(DEPS)</span></span></span><br><span class="line"><span class="variable">$(CC)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span> <span class="variable">$(CFLAGS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">hellomake: <span class="variable">$(OBJ)</span></span></span><br><span class="line"><span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span> <span class="variable">$(CFLAGS)</span></span><br></pre></td></tr></table></figure><p>执行效果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  makefile-tourial git:(master) ✗ make</span><br><span class="line">gcc -c -o hellomake.o hellomake.c -I.</span><br><span class="line">gcc -c -o hellofunc.o hellofunc.c -I.</span><br><span class="line">gcc -o hellomake hellomake.o hellofunc.o -I.</span><br></pre></td></tr></table></figure><p>让我们来进一步思考下：</p><ul><li>我们能不能把 <code>.h</code> 的文件都放到一个专门的 <code>inlcude</code> 目录，把 <code>.c</code> 文件都放到一个专门的 <code>src</code>目录？</li><li>我们能不能把这些烦人的 <code>.o</code> 文件都隐藏起来？</li></ul><p>当然是可以的！我们会在下一个 makefile 中把对应的文件放到 <code>include</code> 和  <code>lib</code>文件夹中，并且把生成的目标文件都放到 <code>src</code> 的 <code>obj</code> 子目录中。除此之外，我们还可以定义任何我们想包含的库文件，比如常用的 math library <code>-lm</code>。这个 makefile 放在 <code>src</code> 目录里。</p><p>需要注意的是，我们还定义了一个 <code>clean</code> 规则，用来把生成的目标文件清除（使用 <code>make clean</code> 命令）。<code>.PHONY</code> 防止 <code>make</code> 清除名为 <code>clean</code> 的文件。</p><p>文件路径为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  src git:(master) ✗ tree          </span><br><span class="line">.</span><br><span class="line">├── hellofunc.c</span><br><span class="line">├── hellomake</span><br><span class="line">├── hellomake.c</span><br><span class="line">├── makefile</span><br><span class="line">└── obj</span><br><span class="line">    ├── hellofunc.o</span><br><span class="line">    └── hellomake.o</span><br><span class="line"></span><br><span class="line">1 directory, 6 files</span><br></pre></td></tr></table></figure><h2 id="Makefile5"><a href="#Makefile5" class="headerlink" title="Makefile5"></a>Makefile5</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">IDIR = ../<span class="keyword">include</span></span><br><span class="line">CC=gcc</span><br><span class="line">CFLAGS=-I<span class="variable">$(DIR)</span></span><br><span class="line"></span><br><span class="line">ODIR=obj</span><br><span class="line">LDIR=../lib</span><br><span class="line"></span><br><span class="line">LIBS=-lm</span><br><span class="line"></span><br><span class="line">_DEPS = hellomake.h</span><br><span class="line">DEPS=<span class="variable">$(<span class="built_in">patsubst</span> %,<span class="variable">$(IDIR)</span>/%,<span class="variable">$(_DEPS)</span>)</span></span><br><span class="line"></span><br><span class="line">_OBJ = hellomake.o hellofunc.o</span><br><span class="line">OBJ=<span class="variable">$(<span class="built_in">patsubst</span> %,<span class="variable">$(ODIR)</span>/%,<span class="variable">$(_OBJ)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(ODIR)</span>/%.o: %.c <span class="variable">$(DEPS)</span>(</span><br><span class="line"><span class="variable">$(CC)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span> <span class="variable">$(CFLAGS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">hellomake: <span class="variable">$(OBJ)</span></span></span><br><span class="line"><span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(LIBS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f <span class="variable">$(ODIR)</span>/*.o *~ core <span class="variable">$(INCDIR)</span>/*~</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  src git:(master) ✗ make</span><br><span class="line">gcc -c -o obj/hellomake.o hellomake.c -I../include</span><br><span class="line">gcc -c -o obj/hellofunc.o hellofunc.c -I../include</span><br><span class="line">gcc -o hellomake obj/hellomake.o obj/hellofunc.o -I../include</span><br></pre></td></tr></table></figure><blockquote><p>注意要在 <code>src</code> 目录下运行，并且要把 <code>.h</code> 文件放到 <code>include</code> 目录里</p></blockquote><p>好了，到目前为止，你已经有了一个不错的 makefile 了，现在你能 hold 住一个中型的项目了。你也可以增加更多的规则到 makefile 里，你甚至可以在一个规则中调用另一个规则。</p><p>想知道更多关于 makefile 和 make 的信息，就去查阅 <a href="https://www.gnu.org/software/make/manual/make.html" target="_blank" rel="noopener">GNU Make Manual</a> 吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Makefile-简明教程&quot;&gt;&lt;a href=&quot;#Makefile-简明教程&quot; class=&quot;headerlink&quot; title=&quot;Makefile 简明教程&quot;&gt;&lt;/a&gt;Makefile 简明教程&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; 英文原文地址：&lt;a hr
      
    
    </summary>
    
      <category term="编程" scheme="https://rovast.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="makefile" scheme="https://rovast.github.io/tags/makefile/"/>
    
  </entry>
  
  <entry>
    <title>借助 skywalking 搭建自己的 APM 数据展示平台</title>
    <link href="https://rovast.github.io/2020/11/28/build-your-own-ui-for-skywalking/"/>
    <id>https://rovast.github.io/2020/11/28/build-your-own-ui-for-skywalking/</id>
    <published>2020-11-28T17:27:41.000Z</published>
    <updated>2022-09-28T06:14:26.540Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/11/28/build-your-own-ui-for-skywalking/logo.jpeg" width="500" height="400"><blockquote><p>SkyWalking: an APM(application performance monitor) system, especially designed for microservices, cloud native and container-based (Docker, Kubernetes, Mesos) architectures.</p><footer><strong>README.md</strong><cite><a href="https://github.com/apache/skywalking" target="_blank" rel="noopener">github.com/apache/skywalking</a></cite></footer></blockquote><p>skywaking(本文后续简称 SW) 在如今的 APM 体系建设中逐渐展露头角，国内几乎所有的一线大厂都借助 skywaling 进行了自己的 APM 体系建设。<br>大厂的建设方案在诸多的大会中都有提及，尤其在刚过去的 《Apache SkyWalking DevCon 2020》，更是带来了诸多的精彩分享。</p><p>本文不会就 APM 架构或理论进行详细阐述，更多聚焦在实战环节，围绕下述几点展开：</p><ol><li>分析 SW 架构，确定接入方案</li><li>如何在本地调式官方的 UI 项目</li><li>快速了解 SW 查询协议 GraphQL </li></ol><h1 id="Skywalking-架构简介，寻找接入点"><a href="#Skywalking-架构简介，寻找接入点" class="headerlink" title="Skywalking 架构简介，寻找接入点"></a>Skywalking 架构简介，寻找接入点</h1><h2 id="几个官方库"><a href="#几个官方库" class="headerlink" title="几个官方库"></a>几个官方库</h2><p>在正式分析之前，我们来看下 SW 比较重要的三个官方项目</p><ul><li>主库 <a href="https://github.com/apache/skywalking" target="_blank" rel="noopener">https://github.com/apache/skywalking</a></li><li>UI 库 <a href="https://github.com/apache/skywalking-rocketbot-ui" target="_blank" rel="noopener">https://github.com/apache/skywalking-rocketbot-ui</a></li><li>查询协议库 <a href="https://github.com/apache/skywalking-query-protocol" target="_blank" rel="noopener">https://github.com/apache/skywalking-query-protocol</a></li></ul><h2 id="SW-查询协议-——-获取数据的桥梁"><a href="#SW-查询协议-——-获取数据的桥梁" class="headerlink" title="SW 查询协议 —— 获取数据的桥梁"></a>SW 查询协议 —— 获取数据的桥梁</h2><p>接下来，我们看下主库的架构图，即 SW 体系的整体架构图：</p><img src="/2020/11/28/build-your-own-ui-for-skywalking/jiagou.jpeg" width="500" height="400"><p>我们关注的 UI 接入部分，在图的左上角，其中 UI 和 CLI 通过查询协议来和 SW 的后端服务进行交互。正如查询协议库所说：</p><blockquote><p>Query Protocol defines the communication protocol in query stage.<br><strong>SkyWalking native UI</strong> and <strong>CLI</strong> use this protocol to <strong>fetch data from the backend</strong> consistently, don’t need to worry about the backend update.</p><footer><strong>README.md</strong><cite><a href="https://github.com/apache/skywalking-query-protocol" target="_blank" rel="noopener">github.com/apache/skywalking-query-protocol</a></cite></footer></blockquote><p>其中重点我们加粗表示了，即：SW 的官方 UI 和 CLI 工具都是通过查询协议和后端服务进行数据交互。</p><p>SW 的查询协议通俗简单的理解：定义了一系列 GraphQL 查询定义。甚至可以进一步粗暴的理解，就是一堆定义好的 HTTP API。所以只要了解官方的 API 定义，即可发挥 SW 的数据宝藏威力，<br>打造属于自己的 APM 展示平台。</p><p>快速搭建的第一步，就是参考官方的 UI 项目，一方面我们可以参考它的 UI 组件实现。另一方面，我们可以抓包，参考它的 GraphQL 请求。</p><h1 id="官网项目本地调试"><a href="#官网项目本地调试" class="headerlink" title="官网项目本地调试"></a>官网项目本地调试</h1><h2 id="本地运行一览"><a href="#本地运行一览" class="headerlink" title="本地运行一览"></a>本地运行一览</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置后端的请求地址为 SW 官方的北京机房演示地址</span></span><br><span class="line">➜  skywalking-rocketbot-ui git:(master) <span class="built_in">export</span> SW_PROXY_TARGET=http://122.112.182.72:8080/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务，之后访问 8080 端口</span></span><br><span class="line">➜  skywalking-rocketbot-ui git:(master) npm run serve</span><br></pre></td></tr></table></figure><p>访问 <a href="http://localhost:8080/topology" target="_blank" rel="noopener">http://localhost:8080/topology</a></p><img src="/2020/11/28/build-your-own-ui-for-skywalking/ui.jpg"><p>我们看到，服务已成功在本地运行，且可以通过 VueDev Tools 来查看对应的组件实现和传值。对我们自己去实现对应的显示组件，提供了极高的参考意义。</p><blockquote><p>关于如何这个环境变量的设置，大家可以顺着 packages.json 去捋一下 run server 的整个流程</p></blockquote><h2 id="服务抓包格式化"><a href="#服务抓包格式化" class="headerlink" title="服务抓包格式化"></a>服务抓包格式化</h2><p>我们还是以这个拓扑为例，抓一个包，简单看下 GraphQL 请求</p><figure class="highlight json"><figcaption><span>requestPayload</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: <span class="string">"query queryTopo($duration: Duration!) &#123;\n  topo: getGlobalTopology(duration: $duration) &#123;\n    nodes &#123;\n      id\n      name\n      type\n      isReal\n    &#125;\n    calls &#123;\n      id\n      source\n      detectPoints\n      target\n    &#125;\n  &#125;&#125;"</span>,</span><br><span class="line">  <span class="attr">"variables"</span>: &#123;</span><br><span class="line">    <span class="attr">"serviceId"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"duration"</span>: &#123;</span><br><span class="line">      <span class="attr">"start"</span>: <span class="string">"2020-11-27 0912"</span>,</span><br><span class="line">      <span class="attr">"end"</span>: <span class="string">"2020-11-27 0927"</span>,</span><br><span class="line">      <span class="attr">"step"</span>: <span class="string">"MINUTE"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们进一步格式化 graphQL 的 query 请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">query queryTopo($duration: Duration!) &#123;</span><br><span class="line">  topo: getGlobalTopology(duration: $duration) &#123;</span><br><span class="line">    nodes &#123;</span><br><span class="line">      id</span><br><span class="line">      name</span><br><span class="line">      type</span><br><span class="line">      isReal</span><br><span class="line">    &#125;</span><br><span class="line">    calls &#123;</span><br><span class="line">      id</span><br><span class="line">      source</span><br><span class="line">      detectPoints</span><br><span class="line">      target</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>格式化过后，更方便我们进行对应分析。</p><h1 id="分析查询协议"><a href="#分析查询协议" class="headerlink" title="分析查询协议"></a>分析查询协议</h1><h2 id="快速了解查询语句含义"><a href="#快速了解查询语句含义" class="headerlink" title="快速了解查询语句含义"></a>快速了解查询语句含义</h2><p>GraphQL 的更多用法，本文不提及。文本就上述抓到的协议进行简单说明，便于之前不了解 GraphQL 的同学能够快速了解 SW 查询协议。</p><ol><li>查看 Query，确定查询语句，其中 <code>$</code> 开头的就是形参，在 <code>variables</code> 里会具体传值</li><li>那上述例子，<code>$duration</code> 的具体值，就是 <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"start"</span>: <span class="string">"2020-11-27 0912"</span>,</span><br><span class="line">  <span class="attr">"end"</span>: <span class="string">"2020-11-27 0927"</span>,</span><br><span class="line">  <span class="attr">"step"</span>: <span class="string">"MINUTE"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>那问题来了，我怎么知道 <code>$duration</code> 是由 <code>start</code> <code>end</code> <code>step</code> 组成？他们的值类型是什么？在哪里定义？这就要看之前我们提到的 SW 查询协议。</p><h2 id="查询协议"><a href="#查询协议" class="headerlink" title="查询协议"></a>查询协议</h2><p>接着上面的分析，我们去查看 SW 的 Query Protocol.</p><blockquote><p>到这里大家看到，其实 Query Protocol 就是查询的定义，标准。就像我们平时开发中接触的后端标准接口一样。大家在接触这些看似<br>高大上的 Query Protocol 时，不要被唬到，其实就是相同技术在不同场合的不同叫法罢了。</p></blockquote><p>本例中的拓扑，我们可以查看 <a href="https://github.com/apache/skywalking-query-protocol/blob/master/topology.graphqls" target="_blank" rel="noopener">https://github.com/apache/skywalking-query-protocol/blob/master/topology.graphqls</a> 定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">extend type Query &#123;</span><br><span class="line">    # Query the global topology</span><br><span class="line">    getGlobalTopology(duration: Duration!): Topology</span><br><span class="line">    # Query the topology, based on the given service</span><br><span class="line">    getServiceTopology(serviceId: ID!, duration: Duration!): Topology</span><br><span class="line">    # Query the topology, based on the given services.</span><br><span class="line">    # `#getServiceTopology` could be replaced by this.</span><br><span class="line">    getServicesTopology(serviceIds: [ID!]!, duration: Duration!): Topology</span><br><span class="line">    # Query the instance topology, based on the given clientServiceId and serverServiceId</span><br><span class="line">    getServiceInstanceTopology(clientServiceId: ID!, serverServiceId: ID!, duration: Duration!): ServiceInstanceTopology</span><br><span class="line">    # Query the topology, based on the given endpoint</span><br><span class="line">    getEndpointTopology(endpointId: ID!, duration: Duration!): Topology</span><br><span class="line">    # v2 of getEndpointTopology</span><br><span class="line">    getEndpointDependencies(endpointId: ID!, duration: Duration!): EndpointTopology</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到其中就有 <code>getGlobalTopology</code>，再看看我们之前的抓包，我能看下第二行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">query queryTopo($duration: Duration!) &#123;</span><br><span class="line">  topo: getGlobalTopology(duration: $duration) &#123;</span><br><span class="line">    nodes &#123;</span><br><span class="line">      id</span><br><span class="line">      name</span><br><span class="line">      type</span><br><span class="line">      isReal</span><br><span class="line">    &#125;</span><br><span class="line">    calls &#123;</span><br><span class="line">      id</span><br><span class="line">      source</span><br><span class="line">      detectPoints</span><br><span class="line">      target</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二行内容 <code>topo: getGlobalTopology(duration: $duration) {</code></p><ul><li>topo 是查询结果的别名，查询到 response 会放到 topo 字段下</li><li>getGlobalTopology 的定义就是 <code>getGlobalTopology(duration: Duration!): Topology</code></li></ul><p>其中 <code>Duration</code> 定义，我们在 <a href="https://github.com/apache/skywalking-query-protocol/blob/master/common.graphqls" target="_blank" rel="noopener">https://github.com/apache/skywalking-query-protocol/blob/master/common.graphqls</a> 得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">input Duration &#123;</span><br><span class="line">    start: String!</span><br><span class="line">    end: String!</span><br><span class="line">    step: Step!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就像套娃一样，你也可以找到 <code>Step</code> 的定义</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文聊了我们如何找到自定义 UI 的切入点，同时就如何参考官方的一些开发细节进行了阐述。希望能给大家自定义数据展示平台一些参考。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2020/11/28/build-your-own-ui-for-skywalking/logo.jpeg&quot; width=&quot;500&quot; height=&quot;400&quot;&gt;
&lt;blockquote&gt;&lt;p&gt;SkyWalking: an APM(application pe
      
    
    </summary>
    
      <category term="云原生" scheme="https://rovast.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
      <category term="APM" scheme="https://rovast.github.io/categories/APM/"/>
    
    
      <category term="APM" scheme="https://rovast.github.io/tags/APM/"/>
    
  </entry>
  
</feed>
