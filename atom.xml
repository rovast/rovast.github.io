<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rovast</title>
  
  <subtitle>rovast&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://rovast.github.io/"/>
  <updated>2021-04-11T02:36:16.497Z</updated>
  <id>https://rovast.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初探 http-streaming</title>
    <link href="https://rovast.github.io/2021/04/07/http-straming-in-js/"/>
    <id>https://rovast.github.io/2021/04/07/http-straming-in-js/</id>
    <published>2021-04-07T02:22:37.000Z</published>
    <updated>2021-04-11T02:36:16.497Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>HTTP 流简单的理解为：服务端维持一个 HTTP 连接，通过这个 HTTP 连接源源不断、持续的输出内容至客户端。相较于我们常见的 HTTP 请求(一次返回)，流处理的特点在于持续返回。</p><p>我们举个简单的应用场景：股票网站的股价更新。你可以使用轮询的方式，前端设置定时器周期性的请求股价接口来刷新股价。除此之外，可以使用 HTTP Streaming 的方式，只需要维持一个 HTTP 链接，就可以由后端自行将最新的股价信息 Push 到客户端来完成实时刷新。</p><p>同时需要注意，为了实现这种持续返回的效果，服务端需要在客户端返回的 Header 中设置 <code>Transfer Encoding: chunked</code> [2]。</p><blockquote><p>To achieve an indefinite response, the server must respond to client requests by specifying Transfer Encoding: chunked in the header. This sets up a persistent connection from server to client and allows the server to send response data in chunks of newline-delimited strings. These chunks of data can then be received and processed on-the-fly by the client.</p></blockquote><h2 id="服务端初体验"><a href="#服务端初体验" class="headerlink" title="服务端初体验"></a>服务端初体验</h2><p>我们使用 php fpm + nginx，来完成服务端的 http 流输出。PHP 代码如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ob_get_level() == <span class="number">0</span>) ob_start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ($i = <span class="number">0</span>; $i&lt;<span class="number">10</span>; $i++)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;br&gt; Line to show. At"</span>.date(<span class="string">'Y-m-d H:i:s'</span>);</span><br><span class="line">    <span class="keyword">echo</span> str_pad(<span class="string">''</span>,<span class="number">4096</span>).<span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    ob_flush();</span><br><span class="line">    flush();</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Done."</span>;</span><br><span class="line"></span><br><span class="line">ob_end_flush();</span><br></pre></td></tr></table></figure><p>我们看到其中有 <code>str_pad(&#39;&#39;,4096)</code>，为填充输出缓冲区，进而保障每次 flush 都有数据能输出到客户端。因为我们的服务经过 Nginx，而 Nginx 的 proxy_buffer_size [3] 默认是 4k，所以我们需要填充完缓冲区后，才能保证每次的 Server 端输出可以直接打到客户端。（当然了，你也可以关闭 Nginx 的缓冲区设置）</p><p>其输出为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Line to show. At2021-04-11 01:54:52</span><br><span class="line">Line to show. At2021-04-11 01:54:54</span><br><span class="line">Line to show. At2021-04-11 01:54:56</span><br><span class="line">Line to show. At2021-04-11 01:54:58</span><br><span class="line">Line to show. At2021-04-11 01:55:00</span><br><span class="line">Line to show. At2021-04-11 01:55:02</span><br><span class="line">Line to show. At2021-04-11 01:55:04</span><br><span class="line">Line to show. At2021-04-11 01:55:06</span><br><span class="line">Line to show. At2021-04-11 01:55:08</span><br><span class="line">Line to show. At2021-04-11 01:55:10 Done.</span><br></pre></td></tr></table></figure></p><p>对于客户端，我们也有简单的代码验证，关注浏览器开发者工具即可<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watchResource</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">  xhr.open(<span class="string">"GET"</span>, url, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  xhr.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState &gt;= <span class="number">3</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">      callback(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  xhr.send();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> xhr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">watchResource(<span class="string">"/streaming.php"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>在这种情况下，每次后端有新的数据推送过来时，都会触发 <code>xhr.onreadystatechange</code> 事件，进而进入回调函数。</p><p>关于 xhr.onreadystatechange 的 readState 状态值含义如下[1]：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0The request is not initialized.</span><br><span class="line">1The request has been set up.</span><br><span class="line">2The request has been sent.</span><br><span class="line">3The request is in process.</span><br><span class="line">4The request is completed.</span><br></pre></td></tr></table></figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="HTTP-Streaming-VS-WebSocket"><a href="#HTTP-Streaming-VS-WebSocket" class="headerlink" title="HTTP Streaming VS WebSocket"></a>HTTP Streaming VS WebSocket</h3><p>两者的模式和使用场景不同，最明显的区别</p><ul><li>HTTP Streaming 是 Server Push，数据流向是单向的，由服务器推送给客户端。</li><li>WebSocket 是双向通信，客户端可以和服务端进行交互通信。</li></ul><h3 id="以容器云为例的应用场景"><a href="#以容器云为例的应用场景" class="headerlink" title="以容器云为例的应用场景"></a>以容器云为例的应用场景</h3><p>以容器云平台为例，我们需要在平台上对容器进行简单的管理，其管理包括：</p><ul><li>场景1：持续获取容器的运行日志，即容器终端持续输出的日志(view container logs)</li><li>场景2：远程登录至容器终端(exec container terminal)</li></ul><h4 id="场景1情况下，我们需要持续获取终端的日志输出，并且数据的流向是单向的：即服务端有新的日志输出就推送至客户端"><a href="#场景1情况下，我们需要持续获取终端的日志输出，并且数据的流向是单向的：即服务端有新的日志输出就推送至客户端" class="headerlink" title="场景1情况下，我们需要持续获取终端的日志输出，并且数据的流向是单向的：即服务端有新的日志输出就推送至客户端"></a>场景1情况下，我们需要持续获取终端的日志输出，并且数据的流向是单向的：即服务端有新的日志输出就推送至客户端</h4><p>在这种情况下，我们可以采用 HTTP Streaming 的方式来完成需求，其前端的代码简化如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听 url 的输出，每次触发后进入 callback 回调</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watchResource</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">  xhr.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">  xhr.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState &gt;= <span class="number">3</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">      callback(xhr.responseText)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  xhr.send()</span><br><span class="line">  <span class="keyword">return</span> xhr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 持续获取日志用于显示</span></span><br><span class="line"><span class="keyword">this</span>.logText = <span class="string">''</span></span><br><span class="line">watchResource(<span class="string">'/logs'</span>, res =&gt; &#123;</span><br><span class="line">  <span class="keyword">this</span>.logText += res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="场景2情况下，数据是双向交互的，我们选择使用-Websocket"><a href="#场景2情况下，数据是双向交互的，我们选择使用-Websocket" class="headerlink" title="场景2情况下，数据是双向交互的，我们选择使用 Websocket"></a>场景2情况下，数据是双向交互的，我们选择使用 Websocket</h4><p>此场景下，用户输入 command 后，服务端响应后返回至前端，是典型的双向通信场景，使用 websocket 来完成需求。</p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>在实际操作过程中，还是有些注意点需要提及。</p><ol><li>服务端的数据如果经过 Nginx 转发，需要注意 <code>proxy_buffer</code> 配置。不然会出现服务端服务有持续输出，经过 Nginx 后不一定有输出的情况。</li><li>客户端在处理完流数据后，记得在合适的析构时期断开连接。如在 <code>unmount</code> 组件时进行 <code>xhr.abort()</code></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] XMLHttpRequest WIKI <a href="https://www.wikiwand.com/en/XMLHttpRequest" target="_blank" rel="noopener">https://www.wikiwand.com/en/XMLHttpRequest</a></li><li>[2] What is HTTP Streaming? <a href="https://www.pubnub.com/learn/glossary/what-is-http-streaming/" target="_blank" rel="noopener">https://www.pubnub.com/learn/glossary/what-is-http-streaming/</a></li><li>[3] proxy_buffer_size <a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_buffer_size" target="_blank" rel="noopener">http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_buffer_size</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a&gt;基础概念&lt;/h2&gt;&lt;p&gt;HTTP 流简单的理解为：服务端维持一个 HTTP 连接，通过这个 HTTP 连接源源不断、持续的输出内容至客户端。相较于我
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用 github action 自动发布 hexo blog</title>
    <link href="https://rovast.github.io/2021/03/20/hexo-github-action/"/>
    <id>https://rovast.github.io/2021/03/20/hexo-github-action/</id>
    <published>2021-03-20T14:16:03.000Z</published>
    <updated>2021-04-11T02:36:16.497Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>用 Hexo 来生成 Github Pages 有一段时间了，之前一直是在本地写完 Blog 然后执行下述指令来发博客<br><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf public</span><br><span class="line">npx hexo deploy</span><br></pre></td></tr></table></figure></p><p>今天想想，不是有 github acion 嘛，能不能使用自动化 CI 流程来发布，当我的 Hexo Repo 发布时，自动进行 deply 动作，进而部署到 rovast.github.io。<br>当然是可以的！本文就其中的步骤进行记录，也算是 github action 的初体验了。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>首先我们要确认一个前提，就是 github pages 和 hexo 源码是两个东西，那我的来说，我有两个仓</p><ul><li>仓库1，hexo source 仓库，存放 hexo 博客源码。<a href="https://github.com/rovast/hexo-config" target="_blank" rel="noopener">https://github.com/rovast/hexo-config</a></li><li>仓库2，和自己用户名同样的仓库，你只要放了静态文件 index.html，github 自动帮你生成 github pages。<a href="https://github.com/rovast/rovast.github.io" target="_blank" rel="noopener">https://github.com/rovast/rovast.github.io</a></li></ul><p>整体的步骤如下</p><ol><li>正确配置 hexo-config 的配置文件 <code>_config.yaml</code></li><li>正确 <a href="https://github.com/rovast/hexo-config" target="_blank" rel="noopener">https://github.com/rovast/hexo-config</a> 仓库配置，尤其是 git 的 ssh 私钥和 github action</li><li>正确配置 <a href="https://github.com/rovast/rovast.github.io" target="_blank" rel="noopener">https://github.com/rovast/rovast.github.io</a> 的 deploy key</li></ol><p>接下来依次配置</p><h3 id="1、配置-hexo-config-项目的-config-yaml"><a href="#1、配置-hexo-config-项目的-config-yaml" class="headerlink" title="1、配置 hexo-config 项目的 _config.yaml"></a>1、配置 hexo-config 项目的 <code>_config.yaml</code></h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="string">git@github.com:rovast/rovast.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>注意其中的 repo 一定要是用 ssh 的协议，一因为后面我们要借助 ssh-key。</p><h3 id="2、配置-https-github-com-rovast-hexo-config-的-github-配置"><a href="#2、配置-https-github-com-rovast-hexo-config-的-github-配置" class="headerlink" title="2、配置 https://github.com/rovast/hexo-config 的 github 配置"></a>2、配置 <a href="https://github.com/rovast/hexo-config" target="_blank" rel="noopener">https://github.com/rovast/hexo-config</a> 的 github 配置</h3><p><strong>1. 配置 github action 的 yaml</strong></p><p>参考的 <a href="https://github.com/sma11black/hexo-action，我们新建文件" target="_blank" rel="noopener">https://github.com/sma11black/hexo-action，我们新建文件</a> <code>.github/workflows/deploy.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span> <span class="string">[push]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line"><span class="attr">  build:</span></span><br><span class="line"><span class="attr">    runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">A</span> <span class="string">job</span> <span class="string">to</span> <span class="string">deploy</span> <span class="string">blog.</span></span><br><span class="line"><span class="attr">    steps:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Checkout</span></span><br><span class="line"><span class="attr">      uses:</span> <span class="string">actions/checkout@v1</span></span><br><span class="line"><span class="attr">      with:</span></span><br><span class="line"><span class="attr">        submodules:</span> <span class="literal">true</span> <span class="comment"># Checkout private submodules(themes or something else).</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Caching dependencies to speed up workflows. (GitHub will remove any cache entries that have not been accessed in over 7 days.)</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Cache</span> <span class="string">node</span> <span class="string">modules</span></span><br><span class="line"><span class="attr">      uses:</span> <span class="string">actions/cache@v1</span></span><br><span class="line"><span class="attr">      id:</span> <span class="string">cache</span></span><br><span class="line"><span class="attr">      with:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">node_modules</span></span><br><span class="line"><span class="attr">        key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.os</span> <span class="string">&#125;&#125;-node-$&#123;&#123;</span> <span class="string">hashFiles('**/package-lock.json')</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">        restore-keys:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          $<span class="template-variable">&#123;&#123; runner.os &#125;&#125;</span>-node-</span></span><br><span class="line"><span class="string"></span><span class="attr">    - name:</span> <span class="string">Install</span> <span class="string">Dependencies</span></span><br><span class="line"><span class="attr">      if:</span> <span class="string">steps.cache.outputs.cache-hit</span> <span class="string">!=</span> <span class="string">'true'</span></span><br><span class="line"><span class="attr">      run:</span> <span class="string">npm</span> <span class="string">ci</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Deploy hexo blog website.</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Deploy</span></span><br><span class="line"><span class="attr">      id:</span> <span class="string">deploy</span></span><br><span class="line"><span class="attr">      uses:</span> <span class="string">sma11black/hexo-action@v1.0.3</span></span><br><span class="line"><span class="attr">      with:</span></span><br><span class="line"><span class="attr">        deploy_key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEPLOY_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">        commit_msg:</span> <span class="string">$&#123;&#123;</span> <span class="string">github.event.head_commit.message</span> <span class="string">&#125;&#125;</span>  <span class="comment"># (or delete this input setting to use hexo default settings)</span></span><br><span class="line">    <span class="comment"># Use the output from the `deploy` step(use for test action)</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Get</span> <span class="string">the</span> <span class="string">output</span></span><br><span class="line"><span class="attr">      run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        echo "$<span class="template-variable">&#123;&#123; steps.deploy.outputs.notify &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure><p><strong>2. 配置 secrect.DEPLOY_KEY</strong></p><p>我们看到 github action 里读取了 <code>$</code>，这个需要在 github 里正确配置。</p><p>注意这里应该填写的是私钥(<code>cat ~/.ssh/id_rsa</code>)，而不是 pub 公钥</p><p><img src="/assets/image-20210320222831807.png" alt="image-20210320222831807"></p><h3 id="3、在-https-github-com-rovast-rovast-github-io-配置-deploy-key"><a href="#3、在-https-github-com-rovast-rovast-github-io-配置-deploy-key" class="headerlink" title="3、在 https://github.com/rovast/rovast.github.io 配置 deploy key"></a>3、在 <a href="https://github.com/rovast/rovast.github.io" target="_blank" rel="noopener">https://github.com/rovast/rovast.github.io</a> 配置 deploy key</h3><p><code>cat ~/.ssh/id_rsa.pub</code>，配置到仓库的 deploy key 里面</p><p><img src="/assets/image-20210320223441248.png" alt="image-20210320223441248"></p><h3 id="4、结束"><a href="#4、结束" class="headerlink" title="4、结束"></a>4、结束</h3><p>正常保存 <a href="https://github.com/rovast/hexo-config" target="_blank" rel="noopener">https://github.com/rovast/hexo-config</a> 仓库，push 后自动触发 github action 进行发布。</p><p><img src="/assets/image-20210320223657343.png" alt="image-20210320223657343"></p><p><img src="/assets/image-20210320223734616.png" alt="image-20210320223734616"></p><h2 id="使用感受"><a href="#使用感受" class="headerlink" title="使用感受"></a>使用感受</h2><p>有以下几点在使用过程中不得不提</p><ol><li><p>丰富的 github action 模板，你甚至可以在编写的工程中在线搜索他的 Market Place！对新手而言可以快速入门，对于老手而言可以快速找到适合你的速成方案。</p><p><img src="/assets/image-20210320224530765.png" alt="image-20210320224530765"></p></li><li><p>自定义的 secrect.VAR，并且这个 secrect 编写后，居然是不可以查看的，只能更改，简直太赞！对于一些敏感内容而言，简直完美！</p><p><img src="/assets/image-20210320224658673.png" alt="image-20210320224658673"></p></li><li><p>执行 action 过程中的 UI 提示，很丝滑，执行到哪步，就显示哪个步骤。</p><p><img src="/assets/image-20210320224737049.png" alt="image-20210320224737049"></p></li><li><p>另外，通过查看 <a href="https://github.com/sma11black/hexo-action" target="_blank" rel="noopener">https://github.com/sma11black/hexo-action</a> 源码，我们知道，是可以对 Dockerfile 进行操作的，这个想象的空间就无限大了。</p></li></ol><p>让你感觉这个流程本该如此的操作，一定是好操作！</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li>《GitHub Actions 入门教程》<a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html</a></li><li><a href="https://github.com/sma11black/hexo-action" target="_blank" rel="noopener">https://github.com/sma11black/hexo-action</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;用 Hexo 来生成 Github Pages 有一段时间了，之前一直是在本地写完 Blog 然后执行下述指令来发博客&lt;br&gt;&lt;figure
      
    
    </summary>
    
      <category term="工具" scheme="https://rovast.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>【转】npx 使用教程</title>
    <link href="https://rovast.github.io/2021/03/17/use-npx/"/>
    <id>https://rovast.github.io/2021/03/17/use-npx/</id>
    <published>2021-03-17T18:32:46.000Z</published>
    <updated>2021-03-18T02:38:17.617Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文 <a href="https://www.ruanyifeng.com/blog/2019/02/npx.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2019/02/npx.html</a></p></blockquote><p>npm 从5.2版开始，增加了 npx 命令。它有很多用处，本文介绍该命令的主要使用场景。</p><p><img src="/assets/bg2019020901.jpg" alt="img"></p><p>Node 自带 npm 模块，所以可以直接使用 npx 命令。万一不能用，就要手动安装一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g npx</span><br></pre></td></tr></table></figure><h2 id="调用项目安装的模块"><a href="#调用项目安装的模块" class="headerlink" title="调用项目安装的模块"></a>调用项目安装的模块</h2><p>npx 想要解决的主要问题，就是调用项目内部安装的模块。比如，项目内部安装了测试工具 <a href="http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html" target="_blank" rel="noopener">Mocha</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -D mocha</span><br></pre></td></tr></table></figure><p>一般来说，调用 Mocha ，只能在项目脚本和 package.json 的<a href="http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html" target="_blank" rel="noopener"><code>scripts</code></a>字段里面， 如果想在命令行下调用，必须像下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 项目的根目录下执行</span></span><br><span class="line">$ node-modules/.bin/mocha --version</span><br></pre></td></tr></table></figure><p>npx 就是想解决这个问题，让项目内部安装的模块用起来更方便，只要像下面这样调用就行了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx mocha --version</span><br></pre></td></tr></table></figure><p>npx 的原理很简单，就是运行的时候，会到<code>node_modules/.bin</code>路径和环境变量<code>$PATH</code>里面，检查命令是否存在。</p><p>由于 npx 会检查环境变量<code>$PATH</code>，所以系统命令也可以调用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 等同于 ls</span></span><br><span class="line">$ npx ls</span><br></pre></td></tr></table></figure><p>注意，Bash 内置的命令不在<code>$PATH</code>里面，所以不能用。比如，<code>cd</code>是 Bash 命令，因此就不能用<code>npx cd</code>。</p><h2 id="避免全局安装模块"><a href="#避免全局安装模块" class="headerlink" title="避免全局安装模块"></a>避免全局安装模块</h2><p>除了调用项目内部模块，npx 还能避免全局安装的模块。比如，<code>create-react-app</code>这个模块是全局安装，npx 可以运行它，而且不进行全局安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx create-react-app my-react-app</span><br></pre></td></tr></table></figure><p>上面代码运行时，npx 将<code>create-react-app</code>下载到一个临时目录，使用以后再删除。所以，以后再次执行上面的命令，会重新下载<code>create-react-app</code>。</p><p>下载全局模块时，npx 允许指定版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx uglify-js@3.1.0 main.js -o ./dist/main.js</span><br></pre></td></tr></table></figure><p>上面代码指定使用 3.1.0 版本的<code>uglify-js</code>压缩脚本。</p><p>注意，只要 npx 后面的模块无法在本地发现，就会下载同名模块。比如，本地没有安装<code>http-server</code>模块，下面的命令会自动下载该模块，在当前目录启动一个 Web 服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx http-server</span><br></pre></td></tr></table></figure><h2 id="no-install-参数和-ignore-existing-参数"><a href="#no-install-参数和-ignore-existing-参数" class="headerlink" title="--no-install 参数和--ignore-existing 参数"></a><code>--no-install</code> 参数和<code>--ignore-existing</code> 参数</h2><p>如果想让 npx 强制使用本地模块，不下载远程模块，可以使用<code>--no-install</code>参数。如果本地不存在该模块，就会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx --no-install http-server</span><br></pre></td></tr></table></figure><p>反过来，如果忽略本地的同名模块，强制安装使用远程模块，可以使用<code>--ignore-existing</code>参数。比如，本地已经全局安装了<code>create-react-app</code>，但还是想使用远程模块，就用这个参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx --ignore-existing create-react-app my-react-app</span><br></pre></td></tr></table></figure><h2 id="使用不同版本的-node"><a href="#使用不同版本的-node" class="headerlink" title="使用不同版本的 node"></a>使用不同版本的 node</h2><p>利用 npx 可以下载模块这个特点，可以指定某个版本的 Node 运行脚本。它的窍门就是使用 npm 的 <a href="https://www.npmjs.com/package/node" target="_blank" rel="noopener">node 模块</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npx node@0.12.8 -v</span><br><span class="line">v0.12.8</span><br></pre></td></tr></table></figure><p>上面命令会使用 0.12.8 版本的 Node 执行脚本。原理是从 npm 下载这个版本的 node，使用后再删掉。</p><p>某些场景下，这个方法用来切换 Node 版本，要比 nvm 那样的版本管理器方便一些。</p><h2 id="p-参数"><a href="#p-参数" class="headerlink" title="-p 参数"></a><code>-p</code> 参数</h2><p><code>-p</code>参数用于指定 npx 所要安装的模块，所以上一节的命令可以写成下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npx -p node@0.12.8 node -v </span><br><span class="line">v0.12.8</span><br></pre></td></tr></table></figure><p>上面命令先指定安装<a href="mailto:`node@0.12.8" target="_blank" rel="noopener">`node@0.12.8</a><code>，然后再执行</code>node -v`命令。</p><p><code>-p</code>参数对于需要安装多个模块的场景很有用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx -p lolcatjs -p cowsay [<span class="built_in">command</span>]</span><br></pre></td></tr></table></figure><h2 id="c-参数"><a href="#c-参数" class="headerlink" title="-c 参数"></a>-c 参数</h2><p>如果 npx 安装多个模块，默认情况下，所执行的命令之中，只有第一个可执行项会使用 npx 安装的模块，后面的可执行项还是会交给 Shell 解释。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npx -p lolcatjs -p cowsay <span class="string">'cowsay hello | lolcatjs'</span></span><br><span class="line"><span class="comment"># 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>cowsay hello | lolcatjs</code>执行时会报错，原因是第一项<code>cowsay</code>由 npx 解释，而第二项命令<code>localcatjs</code>由 Shell 解释，但是<code>lolcatjs</code>并没有全局安装，所以报错。</p><p><code>-c</code>参数可以将所有命令都用 npx 解释。有了它，下面代码就可以正常执行了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx -p lolcatjs -p cowsay -c <span class="string">'cowsay hello | lolcatjs'</span></span><br></pre></td></tr></table></figure><p><code>-c</code>参数的另一个作用，是将环境变量带入所要执行的命令。举例来说，npm 提供当前项目的一些环境变量，可以用下面的命令查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run env | grep npm_</span><br></pre></td></tr></table></figure><p><code>-c</code>参数可以把这些 npm 的环境变量带入 npx 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx -c <span class="string">'echo "$npm_package_name"'</span></span><br></pre></td></tr></table></figure><p>上面代码会输出当前项目的项目名。</p><h2 id="执行-GitHub-源码"><a href="#执行-GitHub-源码" class="headerlink" title="执行 GitHub 源码"></a>执行 GitHub 源码</h2><p>npx 还可以执行 GitHub 上面的模块源码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行 Gist 代码</span></span><br><span class="line">$ npx https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行仓库代码</span></span><br><span class="line">$ npx github:piuccio/cowsay hello</span><br></pre></td></tr></table></figure><p>注意，远程代码必须是一个模块，即必须包含<code>package.json</code>和入口脚本。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.npmjs.com/package/npx" target="_blank" rel="noopener">npx</a></li><li><a href="https://alligator.io/workflow/npx/" target="_blank" rel="noopener">Speed Up Your npm Workflow With npx</a></li><li><a href="https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b" target="_blank" rel="noopener">Introducing npx: an npm package runner</a></li></ul><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文 &lt;a href=&quot;https://www.ruanyifeng.com/blog/2019/02/npx.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.ruanyifeng.com/blog
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux客户端设置 socks5+kcptun</title>
    <link href="https://rovast.github.io/2021/03/13/server-set-proxy-use-socks5/"/>
    <id>https://rovast.github.io/2021/03/13/server-set-proxy-use-socks5/</id>
    <published>2021-03-13T07:08:40.000Z</published>
    <updated>2021-03-13T15:22:19.881Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/ss-kcp.jpg" alt="ss-kcp"></p><p><img src="/assets/kcptun.jpg" alt="kcptun"></p><p>之前更多使用 Linux 服务器作为服务器来提供代理服务，这里使用 Linux 机器作为客户端，链接远端代理服务器，使用纯终端来设置代理，加速访问。</p><p>同时，参考 《pm2 简明使用教程》来配合进行守护进程使用</p><h2 id="安软件"><a href="#安软件" class="headerlink" title="安软件"></a>安软件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> shadowsocks</span></span><br><span class="line">pip3 install shadowsocks</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> kcptun</span></span><br><span class="line">wget https://github.com/xtaci/kcptun/releases/download/v20210103/kcptun-linux-amd64-20210103.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> cow，用于转换 socks5 协议至 http 和 https</span></span><br><span class="line">wget https://github.com/cyfdecyf/cow/releases/download/0.9.8/cow-linux64-0.9.8.gz</span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ol><li><p>kcptun.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"localaddr"</span>: <span class="string">":1080"</span>,</span><br><span class="line">    <span class="attr">"remoteaddr"</span>: <span class="string">"REMOTE_SERVER:29900"</span>,</span><br><span class="line">    <span class="attr">"key"</span>: <span class="string">"111111"</span>,</span><br><span class="line">    <span class="attr">"crypt"</span>: <span class="string">"aes"</span>,</span><br><span class="line">    <span class="attr">"mode"</span>: <span class="string">"fast"</span>,</span><br><span class="line">    <span class="attr">"conn"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"autoexpire"</span>: <span class="number">60</span>,</span><br><span class="line">    <span class="attr">"mtu"</span>: <span class="number">1350</span>,</span><br><span class="line">    <span class="attr">"sndwnd"</span>: <span class="number">512</span>,</span><br><span class="line">    <span class="attr">"rcvwnd"</span>: <span class="number">512</span>,</span><br><span class="line">    <span class="attr">"datashard"</span>: <span class="number">70</span>,</span><br><span class="line">    <span class="attr">"parityshard"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"dscp"</span>: <span class="number">46</span>,</span><br><span class="line">    <span class="attr">"nocomp"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"acknodelay"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"nodelay"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"interval"</span>: <span class="number">40</span>,</span><br><span class="line">    <span class="attr">"resend"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"nc"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"sockbuf"</span>: <span class="number">4194304</span>,</span><br><span class="line">    <span class="attr">"keepalive"</span>: <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ss.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"server"</span>:<span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="attr">"server_port"</span>:<span class="number">1080</span>,</span><br><span class="line">    <span class="attr">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="attr">"local_port"</span>:<span class="number">1087</span>,</span><br><span class="line">    <span class="attr">"password"</span>:<span class="string">"9SehN7C3GQ9h9Cyt"</span>,</span><br><span class="line">    <span class="attr">"timeout"</span>:<span class="number">300</span>,</span><br><span class="line">    <span class="attr">"method"</span>:<span class="string">"chacha20"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>~/.cow/rc</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">listen = http://127.0.0.1:4411</span><br><span class="line">proxy = socks5://127.0.0.1:1087</span><br></pre></td></tr></table></figure></li></ol><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> socks5 协议转为 http 和 https</span></span><br><span class="line">/home/rovast/applications/cow-linux64-0.9.8</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启 kcptun</span></span><br><span class="line">/home/rovast/applications/kcptun/client_linux_amd64 -c /home/rovast/applications/kcptun/kcptun.json</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启 ss</span></span><br><span class="line">/usr/bin/ss-local -c /home/rovast/applications/shadowsocks/ss.json</span><br></pre></td></tr></table></figure><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ul><li><a href="https://github.com/xtaci/kcptun" target="_blank" rel="noopener">https://github.com/xtaci/kcptun</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/assets/ss-kcp.jpg&quot; alt=&quot;ss-kcp&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/kcptun.jpg&quot; alt=&quot;kcptun&quot;&gt;&lt;/p&gt;
&lt;p&gt;之前更多使用 Linux 服务器作为服务器来提供代理服务，这里使用 L
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>pm2 简明使用教程</title>
    <link href="https://rovast.github.io/2021/03/13/pm2-usage/"/>
    <id>https://rovast.github.io/2021/03/13/pm2-usage/</id>
    <published>2021-03-13T07:04:30.000Z</published>
    <updated>2021-03-20T07:20:13.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>npm install pm2@latest -g</p><h2 id="书写配置文件"><a href="#书写配置文件" class="headerlink" title="书写配置文件"></a>书写配置文件</h2><p>使用配置文件来启动，便于统一管理</p><p><code>~/.config/pm2/ecosystem.config.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apps:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">script</span>     <span class="string">:</span> <span class="string">/home/luohao/applications/code-server-3.9.1-linux-amd64/bin/code-server</span></span><br><span class="line"><span class="attr">    interpreter:</span> <span class="string">none</span></span><br><span class="line"><span class="attr">    max_memory_restart:</span> <span class="number">500</span><span class="string">M</span></span><br><span class="line">    <span class="string">name</span>       <span class="string">:</span> <span class="string">'code-server'</span></span><br><span class="line">    <span class="string">instances</span>  <span class="string">:</span> <span class="number">1</span></span><br><span class="line">    <span class="string">exec_mode</span>  <span class="string">:</span> <span class="string">fork</span></span><br><span class="line"><span class="attr">    env:</span></span><br><span class="line">      <span class="string">http_proxy</span> <span class="string">:</span> <span class="attr">http://127.0.0.1:4411</span></span><br><span class="line"><span class="attr">      https_proxy:</span> <span class="attr">http://127.0.0.1:4411</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">script</span>     <span class="string">:</span> <span class="string">/home/luohao/applications/cow-linux64-0.9.8</span></span><br><span class="line"><span class="attr">    interpreter:</span> <span class="string">none</span></span><br><span class="line">    <span class="string">name</span>       <span class="string">:</span> <span class="string">'cow'</span></span><br><span class="line">    <span class="string">instances</span>  <span class="string">:</span> <span class="number">1</span></span><br><span class="line">    <span class="string">exec_mode</span>  <span class="string">:</span> <span class="string">fork</span></span><br><span class="line"><span class="attr">    env:</span></span><br><span class="line"><span class="attr">      version:</span> <span class="number">0.9</span><span class="number">.8</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">script</span>     <span class="string">:</span> <span class="string">/home/luohao/applications/kcptun/client_linux_amd64</span> <span class="bullet">-c</span> <span class="string">/home/luohao/applications/kcptun/kcptun.json</span></span><br><span class="line"><span class="attr">    interpreter:</span> <span class="string">none</span></span><br><span class="line">    <span class="string">name</span>       <span class="string">:</span> <span class="string">'kcptun-client'</span></span><br><span class="line">    <span class="string">instances</span>  <span class="string">:</span> <span class="number">1</span></span><br><span class="line">    <span class="string">exec_mode</span>  <span class="string">:</span> <span class="string">fork</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">script</span>     <span class="string">:</span> <span class="string">/usr/bin/ss-local</span> <span class="bullet">-c</span> <span class="string">/home/luohao/applications/shadowsocks/ss.json</span></span><br><span class="line"><span class="attr">    interpreter:</span> <span class="string">none</span></span><br><span class="line">    <span class="string">name</span>       <span class="string">:</span> <span class="string">'shadowsocks-client'</span></span><br><span class="line">    <span class="string">instances</span>  <span class="string">:</span> <span class="number">1</span></span><br><span class="line">    <span class="string">exec_mode</span>  <span class="string">:</span> <span class="string">fork</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">script</span>     <span class="string">:</span> <span class="string">/home/luohao/.local/bin/projector</span> <span class="string">run</span> <span class="string">Goland</span></span><br><span class="line"><span class="attr">    interpreter:</span> <span class="string">none</span></span><br><span class="line">    <span class="string">name</span>       <span class="string">:</span> <span class="string">'Goland-server'</span></span><br><span class="line">    <span class="string">instances</span>  <span class="string">:</span> <span class="number">1</span></span><br><span class="line">    <span class="string">exec_mode</span>  <span class="string">:</span> <span class="string">fork</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">script</span>     <span class="string">:</span> <span class="string">/home/luohao/.local/bin/projector</span> <span class="string">run</span> <span class="string">Webstorm</span></span><br><span class="line"><span class="attr">    interpreter:</span> <span class="string">none</span></span><br><span class="line">    <span class="string">name</span>       <span class="string">:</span> <span class="string">'Webstorm-server'</span></span><br><span class="line">    <span class="string">instances</span>  <span class="string">:</span> <span class="number">1</span></span><br><span class="line">    <span class="string">exec_mode</span>  <span class="string">:</span> <span class="string">fork</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">script</span>     <span class="string">:</span> <span class="string">/home/luohao/.local/bin/projector</span> <span class="string">run</span> <span class="string">Clion</span></span><br><span class="line"><span class="attr">    interpreter:</span> <span class="string">none</span></span><br><span class="line">    <span class="string">name</span>       <span class="string">:</span> <span class="string">'Clion-server'</span></span><br><span class="line">    <span class="string">instances</span>  <span class="string">:</span> <span class="number">1</span></span><br><span class="line">    <span class="string">exec_mode</span>  <span class="string">:</span> <span class="string">fork</span></span><br></pre></td></tr></table></figure><blockquote><p>interpreter 设置为 none，用默认行为启动二进制文件。以上是服务器设置客户端代理的脚本，供参考</p></blockquote><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start ~/.config/pm2/ecosystem.config.yaml</span><br></pre></td></tr></table></figure><p>常用的操作还有下面的系列操作，可以在后面加上 jobId(通过 <code>pm2 list</code>查看)，或者加上 echosystem 文件<br><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pm2 delete JOBID_OR_FILE</span><br><span class="line">pm2 stop JOBID_OR_FILE</span><br><span class="line">pm2 reload JOBID_OR_FILE</span><br><span class="line">pm2 restart JOBID_OR_FILE</span><br><span class="line">pm2 descibe JOBID_OR_FILE</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 监控类</span></span><br><span class="line">pm2 monit</span><br><span class="line">pm2 list</span><br></pre></td></tr></table></figure></p><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p><a href="https://app.pm2.io/" target="_blank" rel="noopener">https://app.pm2.io/</a></p><h2 id="设置为开机自启动"><a href="#设置为开机自启动" class="headerlink" title="设置为开机自启动"></a>设置为开机自启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pm2 startup</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入完 之后有如下提示</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo env PATH=<span class="variable">$PATH</span>:/home/luohao/.nvm/versions/node/v15.11.0/bin /home/luohao/.nvm/versions/node/v15.11.0/lib/node_modules/pm2/bin/pm2 startup systemd -u luohao --hp /home/luohao</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更改完配置后更新最新配置</span></span><br><span class="line">pm2 save</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;npm install pm2@latest -g&lt;/p&gt;
&lt;h2 id=&quot;书写配置文件&quot;&gt;&lt;a href=&quot;#书写配置文件&quot; class=
      
    
    </summary>
    
      <category term="工具" scheme="https://rovast.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>【转】人人都有认知障</title>
    <link href="https://rovast.github.io/2021/02/19/renrendouyourenzhizhangai/"/>
    <id>https://rovast.github.io/2021/02/19/renrendouyourenzhizhangai/</id>
    <published>2021-02-19T21:16:50.000Z</published>
    <updated>2021-02-20T05:21:49.235Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://mp.weixin.qq.com/s/eO7mVliAl8CwYnGV1FwtJg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/eO7mVliAl8CwYnGV1FwtJg</a></p></blockquote><blockquote><p>原文标题：《人人都有认知障》</p></blockquote><blockquote><p>原文公众号：caoz的梦呓</p></blockquote><p>以前记得看过这么一个段子，当然我是没办法求证真伪的，说大清后期有个皇上，有一天跟大臣聊天，问大臣，你早上上朝之前吃的什么啊，大臣如实回复，早上吃了俩鸡子（也就是鸡蛋），皇上就很惊讶，这么奢侈啊，你的俸禄够花么，为什么皇上很惊讶呢，因为内务府的太监跟皇上报账一个鸡蛋要好几两银子，而实际上一个鸡蛋也就几文钱。大臣心知肚明但也不便点破，就说我们吃的是寻常鸡蛋，比不上皇家特供的高级，所以没那么贵。</p><p>故事真假不知，但我觉得这比各种清宫戏反而真实一些，其实这种情况并不罕见，正如晋惠帝那句流传千古的话，何不食肉糜。生在深宫大院，帝王人家，不知柴米油盐，是很寻常的，一个太监就能蒙蔽圣听。其实当今社会，对于富裕的年轻一代或者富裕国家的国民，去理解挣扎在温饱线的时代或者贫困国家的人民生活，何不食肉糜这种认知还真不是段子，一直一直一直都有，只是换个说法而已。包括现在很多年轻人开始怀念几十年前所谓没有内卷的年代，真是都没挨饿过。</p><p>类似的故事还有，说辛亥革命后，旗人贵族没落了，需要出来自己讨生计，有个贵族遗少也出来自己想办法赚钱养活自己，走在街上饿了，花几个钱买了街边现烤的烧饼，一吃之下大惊，原来新出炉的烧饼这么脆这么好吃，以前都是让仆人出去买，每次吃到的都是冷冰冰硬梆梆的。深宫大院说起来要啥有啥，吃穿不愁，但恰恰远离了烟火气。一些寻常百姓唾手可得的东西，他们反而是难以理解。</p><p>贵族不懂百姓，当然百姓也不懂贵族，这才有相声里提到的吕剧唱词，”东宫的娘娘烙大饼，西宫的娘娘卷大葱。” 旧社会普通百姓对富贵人家的想象，也就局限于此了。</p><p>说的这些，其实不同阶层，不同社会地位，不同地域，乃至不同行业的人，对彼此的认知都会有很大的误区，不同地域也是，一个地区约定俗成的东西，在另一个地区可能就是闻所未闻。</p><p>经常有一种观点，认为高认知碾压低认知，说你如果达到某个阶层，掌握某个认知，就可以碾压那些阶层之下的人，可以任意收割或者利用他们。</p><p>但我发现，其实并不是，高学历，高智商人群被低学历，低背景人群诈骗收割的案例也很多。最近爆出来的阿里女员工被诈骗的新闻，其实真的不是孤例。很多人认为这些人认知不够，但扪心自问，我们自己又高明到哪里去，在投资领域我犯过的错误也数不胜数，认知不足交过的学费算下来也是挺大的数字了。</p><p>现在业内都知道，所谓下沉市场价值巨大，我在星球里说过，对如何挖掘下沉市场，我是没任何感知的。因为我从小就没在农村住过一天，虽然小时候家里也很穷，但属于城市平民，所以对所谓乡村生活，乡村人际，乡村的过年气氛，就完全无感，我看到有读者说，现在年味越来越淡，只有小时候乡下过年那才叫过年，这话我就不爱听，我城里长大的就不配过年是怎么的。</p><p>另外，我还说过一点，我没有故乡的概念，我虽然是天津出生的，但是随着父亲工作单位调动，6岁之前在山东德州，是出扒鸡的德州，不是出牛仔的德州。那么6岁之前是没任何印象的，6岁后父母迁回天津，事业单位，属于水利部下的勘测设计院，当时还叫水电部，那么住的小区是单位家属区，整个设计院的人分别来自山东德州和河南三门峡，换句话说，家属院里就没有本土的天津人。当然，我们家祖籍也不是天津，是河北，解放前我爷爷迁居到天津的，可是河北老家我也一次都没去过。所以不好意思，我小时候在天津的时候，就没觉得自己是天津人，天津人也没拿我当本地人，但我也没觉得自己是河北人，是山东人。所以所谓叶落归根，荣归故里，很惭愧，我也是完全没感觉的。</p><p>没有故土概念，也没有乡村生活经历，城里亲戚关系也没那么深厚，对很多这方面的感知基本没有，所以我知道很多人会用这样的认知感来做营销，做市场运营，做低成本获客，但这种我就不会碰，因为我的认知跟不上。</p><p>以前草根创业者，很多是本色的认知感，比如李兴平，做的非常成功；后来精英们做下沉，靠数据反馈迭代，我是很佩服张一鸣和黄峥这种，我是做不来。但确实，跨越阶层，跨越群体的认知，是产生很多商业机会，以及个人价值增长的所在。 这句话我加粗一下，希望读者仔细想想。</p><p>比如说，为什么我常说，技术人员懂一点商业，会非常有价值，看看中国和美国的福布斯榜单，多少大佬是程序员出身。懂草根的精英，和懂精英的草根，也都是非常容易创建商业奇迹的人。</p><p>比如说，出海企业，能够理解海外市场，并掌握中国研发资源的人，就会非常有优势。</p><p>跨越不同族群，不同阶层的时候，你会发现，A群体中非常渴望的诉求，认为非常难以实现的事情，在B群体里其实是非常简单，容易获取的资源，但B群体并不知道A群体存在这样的诉求，如果有一个人，比如他是A群体的人，突然有机会接触了B群体，掌握了B群体的认知，发现存在非常简单，容易获取这样的资源，他拿到资源转过头来，回到A群体贩售，这就是很多商业成功案例的本质逻辑。</p><p>我看到包括生财有术，包括我自己星球里很多读者分享的赚钱案例，相当高的比例都可以用这个逻辑来套用，几乎都能符合。</p><p>很多草根创业者小有成就后，都愿意花钱读个emba，试图让自己融入另一个阶层，也是存在这样的一种理念。</p><p>但这里存在一个问题，最近我发现很多创业者，或者一些还不错的草根创业者，存在这样一个问题，他们脱胎于A群体，开始接触B群体，靠B群体的认知，转过头来，在A群体解决了一些关键诉求，实现了很好的商业转化，这不挺成功的么，然后他们就开始觉得，A群体太low了，什么都不懂，自己要怎样，脱胎换骨，成为B群体中的一员，但是这里问题来了，彻底脱离了A群体后，他们其实就失去了自己的价值了。</p><p>这就是今天要说的主题，能够纵横跨越阶层，跨越族群的认知，充分利用起来，可以具有极大的商业价值，但如果你彻底放弃了某个群体和阶层的认知，你以为你脱胎换骨，其实你是自废武功。你说增进认知，学习更多难道有错么？当然没错。但究竟什么才是你的价值，既懂A，又懂B才是你的价值。放弃A，追求B，你什么都不是。</p><p>底层逆袭的人，往往会忽视底层认知的价值，当你脱离了所谓低级趣味的时候，你可能已经失去了很重要的价值资源。而这样的人，还真挺多的。</p><p>类似的案例还有很多，中国改革开放，第一批睁眼看世界的人，既懂中国，又懂西方，就很容易抓住时代的机遇，抓住很多稀缺的机会，成就一番事业，这些人慢慢成为中年人，觉得自己孩子早点接受西方教育，不是比自己更有优势么？结果问题来了，下一代人确实很懂西方，但不懂中国，反而失去了独特的价值。</p><p>认知障无处不在，所谓高阶人士，其实也存在很多认知障，就好比说，一路开挂的学霸是教不了学渣的，因为他们无法理解学渣的困境和苦恼，反而是从学渣逆袭诚学霸的，拥有跨越阶层的思维，才能更有针对性的辅导学渣。就好比说，纯粹大公司成长起来的技术高手很难去早期创业公司带团队，因为他们很难理解资源极为苛刻，人力极为平庸的情况下，如何做好产品，但反而是那些从巨头草创早期就加入，一路成长的高手，更能理解从创业到成长为巨头的挑战，这些都可以认为是跨越阶层的认知，具有独特的价值。</p><p>但切记，同时拥有多个阶层的认知才是你的价值所在，不要顾此失彼，为了追求所谓阶层上升，阶层融入，轻易放弃曾经的认知能力。最近发现有不少创业者，在做这样自废武功的事情，遂有感慨成此文。</p><p>一定要找到自己的独特价值，无论面对什么阶层，什么样的人，你总会在某个细分领域的认知具有优势，你找到这个点，然后再通过学习和领悟对方阶层的认知，从中挖掘匹配的需求点，就是你的独特价值。</p><p>我的知识星球，年终免费福利课，复盘人生关键决策，有效期只剩不到10天，最后提醒，3月1日凌晨准时下架。</p><p>懒得发链接了，星球用户去看置顶帖，其他读者忽略即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/eO7mVliAl8CwYnGV1FwtJg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/e
      
    
    </summary>
    
      <category term="随想" scheme="https://rovast.github.io/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>理解 shell 脚本中的常见用法2&gt;&amp;1</title>
    <link href="https://rovast.github.io/2021/02/08/understanding-shell-script-idiom-redirect/"/>
    <id>https://rovast.github.io/2021/02/08/understanding-shell-script-idiom-redirect/</id>
    <published>2021-02-08T01:39:02.000Z</published>
    <updated>2021-02-08T09:50:07.143Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://www.brianstorti.com/understanding-shell-script-idiom-redirect/" target="_blank" rel="noopener">https://www.brianstorti.com/understanding-shell-script-idiom-redirect/</a></p><p>在我们接触的 shell 脚本中，对 <code>2&gt;&amp;1</code> 一定不陌生，比如 <code>ls foo &gt; /dev/null 2&gt;&amp;1</code>。</p><p>本文就来解释下 <code>2&gt;&amp;1</code> 究竟做了什么，并且是如何起作用的。</p><h2 id="一、I-O-重定向简介"><a href="#一、I-O-重定向简介" class="headerlink" title="一、I/O 重定向简介"></a>一、I/O 重定向简介</h2><p>「重定向」是计算机用来把命令的输出从一个地方，输出到另一个地方。举个例子，默认情况下，我们使用 <code>cat</code> 指令可以把一个文件的内容打印到终端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat foo.txt</span><br><span class="line">foo</span><br><span class="line">bar</span><br><span class="line">baz</span><br></pre></td></tr></table></figure><p>但是，我们可以把输出重定向到另外地方。此例中，我们可以把输出重定向到 <code>output.txt</code> 中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat foo.txt &gt; output.txt</span><br><span class="line"></span><br><span class="line">$ cat output.txt</span><br><span class="line">foo</span><br><span class="line">bar</span><br><span class="line">baz</span><br></pre></td></tr></table></figure><p>注意，在执行第一行命令 <code>cat foo.txt &gt; output.txt</code> 时，我们在屏幕上看不到任何输出。我们把原来应该打印到屏幕的内容，重定向到 <code>output.txt</code> 了，所以屏幕上不会有任何输出了。</p><p>这里，「本来应该打印到屏幕的内容」，就是<strong>标准输出</strong>，即 <strong>stdout(standard output)</strong>。</p><p>除了<strong>标准输出</strong>可以接收程序的输出之外，还有一个地方可以，叫 <strong>标准错误输出</strong>，即 <strong>stderr(standard error)</strong>。stderr 用来接收程序的错误消息。例如，我们 <code>cat</code> 了一个不存在的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat nop.txt &gt; output.txt</span><br><span class="line">cat: nop.txt: No such file or directory</span><br></pre></td></tr></table></figure><p>我们看到，虽然我们要求程序把输出重定向到 <code>output.txt</code>，但是我们还是在屏幕上看到了错误消息输出。这是因为我们只是重定向了 standard output，而不是 standard error。</p><h2 id="二、文件描述符-fd-简介"><a href="#二、文件描述符-fd-简介" class="headerlink" title="二、文件描述符(fd)简介"></a>二、文件描述符(fd)简介</h2><p>文件描述符（file descriptor）简单来说，就是一个正整数，用来代表一个打开的文件。比如当前我们有 100 各打开的文件，那么就有 100 个文件描述符。</p><p>唯一需要补充的是，在 Unix 系统中，「一切皆文件」。</p><p>同时我们还应该知道，对于标准输出(stdout)和标准错误输出(stderr)，也有对应的文件描述符。我们使用 1 和 2 来分别表示 stdout 和 stderr 所在的位置。</p><h2 id="三、融合上述知识"><a href="#三、融合上述知识" class="headerlink" title="三、融合上述知识"></a>三、融合上述知识</h2><p>回到我们的第一个示例，我们还可以有另外一种写法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写法一</span></span><br><span class="line">$ cat foo.txt &gt; output.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价写法二</span></span><br><span class="line">$ cat foo.txt 1&gt; output.txt</span><br></pre></td></tr></table></figure><p>这里的 1 就是用来代表 stdout 的文件描述符。语法是 <code>[FILE_DESCRIPTOR]&gt;</code>。我们看到把 1 省略的写法 <code>&gt;</code>只是 <code>1&gt;</code> 的快捷写法而已。</p><p>对于重定向到 stderr 的场景，我们只需要在右边的文件前面加上文件描述符即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat nop.txt 2&gt; error.txt</span><br><span class="line"></span><br><span class="line">$ cat error.txt</span><br><span class="line">cat: nop.txt: No such file or directory</span><br></pre></td></tr></table></figure><p>你看，这样就生效了。这会儿，你大概知道 <code>2&gt;&amp;1</code> 是怎样工作的，让我们来总结总结。</p><p>我们使用 <code>&amp;1</code> 来表示文件描述符1(stdout)的地址。当你使用 <code>2&gt;&amp;1</code> 时，其实就是在说：把 stderr 的输出重定向到 stdout 的地方。这样，我们就可以把程序的标准输出和错误输出都输出到同一个地方了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cat foo.txt &gt; output.txt 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">$ cat output.txt</span><br><span class="line">foo</span><br><span class="line">bar</span><br><span class="line">baz</span><br><span class="line"></span><br><span class="line">$ cat nop.txt &gt; output.txt 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">$ cat output.txt</span><br><span class="line">cat: nop.txt: No such file or directory</span><br></pre></td></tr></table></figure><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><ul><li>程序可以把输出发送到两个地方：标准输出(stdout，standard output)和标准错误输出(stderr，standard error)。</li><li>你可以把输出重定向到另一个地方（比如文件）</li><li>文件描述符1和2 可以分别用来表示 stdout 和 stderr</li><li><code>command &gt; output</code> 是 <code>command 1&gt; output</code> 的缩写</li><li>可以使用 <code>&amp;[FILE_DESCRIPTOR]</code> 来引用文件描述符的值（或者叫指向文件描述符的地址）</li><li>使用 <code>2&gt;&amp;1</code> 来重定向 stderr 的输出至 stdout 的地方（你可以用 <code>1&gt;&amp;2</code> 来进行反向操作）</li></ul><p>另，在 Linux 系统中 0、1、2 分别表示不同的设备类型，其中</p><p>0 标准输入设备，指键盘<br>1 标准正确输出设备<br>2 标准错误输出设备</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://www.brianstorti.com/understanding-shell-script-idiom-redirect/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.brianstort
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MacOS非安全模式打开Chrome</title>
    <link href="https://rovast.github.io/2021/02/01/cors-on-mac/"/>
    <id>https://rovast.github.io/2021/02/01/cors-on-mac/</id>
    <published>2021-02-01T00:02:18.000Z</published>
    <updated>2021-02-01T08:04:07.298Z</updated>
    
    <content type="html"><![CDATA[<p>使用允许跨域（不安全）模式打开，便于调试，设定一个 Alias 即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> openChromeNoCORS=<span class="string">"open -na Google\ Chrome --args --user-data-dir=/tmp/temporary-chrome-profile-dir --disable-web-security --disable-site-isolation-trials"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用允许跨域（不安全）模式打开，便于调试，设定一个 Alias 即可&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Antv G2 修改 Brush 默认行为为返回时间戳范围</title>
    <link href="https://rovast.github.io/2021/01/29/ant-g2-brush-timerange/"/>
    <id>https://rovast.github.io/2021/01/29/ant-g2-brush-timerange/</id>
    <published>2021-01-29T01:12:46.000Z</published>
    <updated>2021-01-29T09:20:39.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="G2-brush-时间轴，而不是筛选数据点"><a href="#G2-brush-时间轴，而不是筛选数据点" class="headerlink" title="G2 brush 时间轴，而不是筛选数据点"></a>G2 brush 时间轴，而不是筛选数据点</h1><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>目前 G2 使用 brush-x 筛选后的是对应的点，而不是 X 轴的时间范围。在实际使用过程中，我们需要场景如下</p><ol><li>鼠标筛选一个区域</li><li>获取这个区域的开始时间和结束时间</li><li>以第2步获取到的时间范围作为结果来重新获取数据</li></ol><h2 id="二、核心代码一览"><a href="#二、核心代码一览" class="headerlink" title="二、核心代码一览"></a>二、核心代码一览</h2><h3 id="2-1-注册-Action"><a href="#2-1-注册-Action" class="headerlink" title="2.1 注册 Action"></a>2.1 注册 Action</h3><ul><li><code>src/index.ts</code>，中枚举出了可以使用的 Action</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">registerAction(<span class="string">'brush'</span>, DataRangeFilter);</span><br><span class="line">registerAction(<span class="string">'brush-x'</span>, DataRangeFilter, &#123; dims: [<span class="string">'x'</span>] &#125;);</span><br><span class="line">registerAction(<span class="string">'brush-y'</span>, DataRangeFilter, &#123; dims: [<span class="string">'y'</span>] &#125;);</span><br></pre></td></tr></table></figure><h3 id="2-2-filter-处理逻辑"><a href="#2-2-filter-处理逻辑" class="headerlink" title="2.2 filter 处理逻辑"></a>2.2 filter 处理逻辑</h3><ul><li>看下 filter 流程<code>src/interaction/action/data/range-filter.ts</code><ul><li>获取到用户当前选择的视觉点</li><li>转换视觉点，获取到实际选择的 min value 和 max value，并且生成 filter</li><li>根据 filter 进行数据筛选</li></ul></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> filter() &#123;</span><br><span class="line">  <span class="keyword">let</span> startPoint;</span><br><span class="line">  <span class="keyword">let</span> currentPoint;</span><br><span class="line">  <span class="comment">// ... codes</span></span><br><span class="line">  <span class="comment">// 进行一些列处理，得到 startPoint 和 currentPoint 的值</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> view = <span class="keyword">this</span>.context.view;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取到归一化坐标</span></span><br><span class="line">  <span class="keyword">const</span> coord = view.getCoordinate();</span><br><span class="line">  <span class="keyword">const</span> normalCurrent = coord.invert(currentPoint);</span><br><span class="line">  <span class="keyword">const</span> normalStart = coord.invert(startPoint);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 设置 x 方向的 filter</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.hasDim(<span class="string">'x'</span>)) &#123;</span><br><span class="line">    <span class="keyword">const</span> xScale = view.getXScale();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// filter 其实就是一个函数  (value: any, datum: Datum, idx?: number) =&gt; boolean;</span></span><br><span class="line">    <span class="keyword">const</span> filter = getFilter(xScale, <span class="string">'x'</span>, normalCurrent, normalStart);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 核心！根据 filter 进行筛选</span></span><br><span class="line">    <span class="keyword">this</span>.filterView(view, xScale.field, filter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置 y 方向的 filter</span></span><br><span class="line">  <span class="comment">// ... codes</span></span><br><span class="line">  <span class="keyword">this</span>.reRender(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>看下如何获取到 min value 和 max value <code>src/interaction/action/data/range-filter.ts</code><ul><li>获取到的 minValue 和 maxValue 取整后就是时间戳了</li></ul></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFilter</span>(<span class="params">scale: Scale, dim: <span class="built_in">string</span>, point1: Point, point2: Point</span>): <span class="title">FilterCondition</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> min = <span class="built_in">Math</span>.min(point1[dim], point2[dim]);</span><br><span class="line">  <span class="keyword">let</span> max = <span class="built_in">Math</span>.max(point1[dim], point2[dim]);</span><br><span class="line">  <span class="keyword">const</span> [rangeMin, rangeMax] = scale.range;</span><br><span class="line">  <span class="comment">// 约束值在 scale 的 range 之间</span></span><br><span class="line">  <span class="keyword">if</span> (min &lt; rangeMin) &#123;</span><br><span class="line">    min = rangeMin;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (max &gt; rangeMax) &#123;</span><br><span class="line">    max = rangeMax;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 范围大于整个 view 的范围，则返回 null</span></span><br><span class="line">  <span class="keyword">if</span> (min === rangeMax &amp;&amp; max === rangeMax) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> minValue = scale.invert(min);</span><br><span class="line">  <span class="keyword">const</span> maxValue = scale.invert(max);</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 这里获取到的 minValue 和 maxValue，就是对应的 x 轴选择的时间范围</span></span><br><span class="line"><span class="comment">   * 类似 minValue 1611724258188.5186 Wed Jan 27 2021 13:10:58 GMT+0800</span></span><br><span class="line"><span class="comment">   *  maxValue 1611724586405.7407 Wed Jan 27 2021 13:16:26 GMT+0800</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (scale.isCategory) &#123;</span><br><span class="line">    <span class="keyword">const</span> minIndex = scale.values.indexOf(minValue);</span><br><span class="line">    <span class="keyword">const</span> maxIndex = scale.values.indexOf(maxValue);</span><br><span class="line">    <span class="keyword">const</span> arr = scale.values.slice(minIndex, maxIndex + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> arr.includes(value);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> value &gt;= minValue &amp;&amp; value &lt;= maxValue;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在用户定义的 action 上下文里拿到对应的 rangefilter 实例</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.actions.find(<span class="function"><span class="params">v</span> =&gt;</span> v.name === <span class="string">'brush-x'</span>)</span><br></pre></td></tr></table></figure><p>但同时我们也看到，我们需要的 minValue 和 maxValue 都是作为临时计算的产物，并没有挂在对象实例上，所以我们有以下三条路</p><ol><li>获取到 ctx 后，自己重新计算</li><li>修改源码，把这个临时状态挂在对象上。不过需要重新发包，或者把代码纳入版本库？侵入性强，不便于后期升级，还是算了吧</li><li>再去看看其他方案吧</li></ol><p>不需要在选择上浪费太多时间，干就完了。我们先选择方案一，要是后面有更好的，再更换嘛。</p><h3 id="2-3-根据获取到的-ctx-来计算-Min-和-Max"><a href="#2-3-根据获取到的-ctx-来计算-Min-和-Max" class="headerlink" title="2.3 根据获取到的 ctx 来计算 Min 和 Max"></a>2.3 根据获取到的 ctx 来计算 Min 和 Max</h3><p><img src="/assets/image-20210127174119210.png" alt="image-20210127174119210"></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、获取到可视区域 view 的宽度</span></span><br><span class="line"><span class="comment"> * 2、获取到可视区域的时间戳分布</span></span><br><span class="line"><span class="comment"> * 3、算出 brush 的起始点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param ctx</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getBrushedTimeRange</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// action 本身实例</span></span><br><span class="line">  <span class="keyword">const</span> self = ctx.actions.find(<span class="function"><span class="params">v</span> =&gt;</span> v.name === <span class="string">'brush-x'</span>)</span><br><span class="line">  <span class="keyword">const</span> view = self.context.view</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取到两个选择的点</span></span><br><span class="line">  <span class="keyword">const</span> startPoint = self.startPoint</span><br><span class="line">  <span class="keyword">const</span> currentPoint = ctx.getCurrentPoint()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 画布两侧的 padding</span></span><br><span class="line">  <span class="keyword">const</span> paddingLeft = view.padding[<span class="number">3</span>]</span><br><span class="line">  <span class="comment">// 获取主体的实际宽度</span></span><br><span class="line">  <span class="keyword">const</span> totalWith = view.width - view.padding[<span class="number">1</span>] - view.padding[<span class="number">3</span>]</span><br><span class="line">  <span class="comment">// 获取选择点的开始结束坐标</span></span><br><span class="line">  <span class="keyword">const</span> startX = startPoint.x - paddingLeft</span><br><span class="line">  <span class="keyword">const</span> endX = currentPoint.x - paddingLeft</span><br><span class="line"></span><br><span class="line">  <span class="comment">// range 范围的才会落点</span></span><br><span class="line">  <span class="keyword">const</span> timestampsCount = (view.getXScale().max - view.getXScale().min) / (view.getXScale().range[<span class="number">1</span>] - view.getXScale().range[<span class="number">0</span>])</span><br><span class="line">  <span class="comment">// 获取到每一个时间占用的宽度</span></span><br><span class="line">  <span class="keyword">const</span> perTimestampWidth = timestampsCount / totalWith</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始需要补偿的时间范围</span></span><br><span class="line">  <span class="keyword">const</span> startXTimestamp = view.getXScale().min - view.getXScale().range[<span class="number">0</span>] * totalWith * perTimestampWidth</span><br><span class="line">  <span class="keyword">const</span> startTime = startXTimestamp + startX * perTimestampWidth</span><br><span class="line">  <span class="keyword">const</span> endTime = startXTimestamp + endX * perTimestampWidth</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> startTime &lt; endTime ? [startTime, endTime] : [endTime, startTime]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在brush回调的地方，执行下面的动作即可，着重关注 <code>callback</code> 地方</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">registerInteraction(<span class="string">'brushX'</span>, &#123;</span><br><span class="line">  showEnable: [</span><br><span class="line">    &#123; trigger: <span class="string">'plot:mouseenter'</span>, action: <span class="string">'cursor:crosshair'</span> &#125;,</span><br><span class="line">    &#123; trigger: <span class="string">'plot:mouseleave'</span>, action: <span class="string">'cursor:default'</span> &#125;</span><br><span class="line">  ],</span><br><span class="line">  start: [</span><br><span class="line">    &#123;</span><br><span class="line">      trigger: <span class="string">'mousedown'</span>,</span><br><span class="line">      action: [<span class="string">'brush-x:start'</span>, <span class="string">'x-rect-mask:start'</span>, <span class="string">'x-rect-mask:show'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  processing: [</span><br><span class="line">    &#123;</span><br><span class="line">      trigger: <span class="string">'mousemove'</span>,</span><br><span class="line">      action: [<span class="string">'x-rect-mask:resize'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  end: [</span><br><span class="line">    &#123;</span><br><span class="line">      trigger: <span class="string">'mouseup'</span>,</span><br><span class="line">      action: [<span class="string">'brush-x:end'</span>, <span class="string">'x-rect-mask:end'</span>, <span class="string">'x-rect-mask:hide'</span>],</span><br><span class="line">      callback: <span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 重点再这里</span></span><br><span class="line">        <span class="keyword">const</span> [startTime, endTime] = getBrushedTimeRange(ctx)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.$emit(<span class="string">'on-brushed'</span>, [startTime, endTime])</span><br><span class="line">        <span class="keyword">this</span>.resetBrushAction = ctx.actions.find(<span class="function"><span class="params">v</span> =&gt;</span> v.name === <span class="string">'brush-x'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  rollback: [</span><br><span class="line">    &#123; trigger: <span class="string">'dblclick'</span>, action: [<span class="string">'brush-x:reset'</span>, <span class="string">'reset-button:hide'</span>] &#125;,</span><br><span class="line">    &#123; trigger: <span class="string">'reset-button:click'</span>, action: [<span class="string">'brush-x:reset'</span>, <span class="string">'reset-button:hide'</span>] &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="三、踩坑方案"><a href="#三、踩坑方案" class="headerlink" title="三、踩坑方案"></a>三、踩坑方案</h2><h3 id="3-1-直接使用-brush-filter-导致的-scalex-上下文传递不一致问题"><a href="#3-1-直接使用-brush-filter-导致的-scalex-上下文传递不一致问题" class="headerlink" title="3.1 直接使用 brush-filter 导致的 scalex 上下文传递不一致问题"></a>3.1 直接使用 brush-filter 导致的 scalex 上下文传递不一致问题</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hack 原来的 getFilter() 方法，直接返回我们需要的数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param scale Scale</span></span><br><span class="line"><span class="comment"> * @param dim</span></span><br><span class="line"><span class="comment"> * @param point1 Point</span></span><br><span class="line"><span class="comment"> * @param point2</span></span><br><span class="line"><span class="comment"> * @returns &#123;null|&#123;minValue, maxValue&#125;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hackGetFilterReturnMinMax</span>(<span class="params">scale, dim, point1, point2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> min = <span class="built_in">Math</span>.min(point1[dim], point2[dim])</span><br><span class="line">  <span class="keyword">let</span> max = <span class="built_in">Math</span>.max(point1[dim], point2[dim])</span><br><span class="line">  <span class="keyword">const</span> [rangeMin, rangeMax] = scale.range</span><br><span class="line">  <span class="comment">// 约束值在 scale 的 range 之间</span></span><br><span class="line">  <span class="keyword">if</span> (min &lt; rangeMin) &#123;</span><br><span class="line">    min = rangeMin</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (max &gt; rangeMax) &#123;</span><br><span class="line">    max = rangeMax</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 范围大于整个 view 的范围，则返回 null</span></span><br><span class="line">  <span class="keyword">if</span> (min === rangeMax &amp;&amp; max === rangeMax) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> minValue = scale.invert(min)</span><br><span class="line">  <span class="keyword">const</span> maxValue = scale.invert(max)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// console.log('start', minValue, 'end', maxValue)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; minValue, maxValue &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-区分-view-的几个视角"><a href="#3-2-区分-view-的几个视角" class="headerlink" title="3.2 区分 view 的几个视角"></a>3.2 区分 view 的几个视角</h3><p><img src="/assets/image-20210127174110482.png" alt="image-20210127174110482"></p><h2 id="四、一些链接"><a href="#四、一些链接" class="headerlink" title="四、一些链接"></a>四、一些链接</h2><h3 id="4-1-tooltip-联动"><a href="#4-1-tooltip-联动" class="headerlink" title="4.1 tooltip 联动"></a>4.1 tooltip 联动</h3><p><a href="https://antv-g2.gitee.io/zh/examples/interaction/others#views-tooltip" target="_blank" rel="noopener">https://antv-g2.gitee.io/zh/examples/interaction/others#views-tooltip</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;G2-brush-时间轴，而不是筛选数据点&quot;&gt;&lt;a href=&quot;#G2-brush-时间轴，而不是筛选数据点&quot; class=&quot;headerlink&quot; title=&quot;G2 brush 时间轴，而不是筛选数据点&quot;&gt;&lt;/a&gt;G2 brush 时间轴，而不是筛选数据点&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking PHP 内核代码剖析</title>
    <link href="https://rovast.github.io/2021/01/29/skywalking-php-kernel-flow/"/>
    <id>https://rovast.github.io/2021/01/29/skywalking-php-kernel-flow/</id>
    <published>2021-01-29T01:04:15.000Z</published>
    <updated>2021-01-29T09:11:23.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、总体流程"><a href="#一、总体流程" class="headerlink" title="一、总体流程"></a>一、总体流程</h2><p>PHP 重要几个生命周期说明，先后顺序为 PHP_MI、PHP_RI、PHP_EXECUTE、PHP_RS、PHP_MS，每个模块的作用如下</p><ul><li>PHP_MI，模块初始化阶段，主要进行 PHP 框架、Zend 引擎的初始化工作。重要的几个工作如下：<ul><li>全局状态信息的初始化，如 SG、CG、EG等</li><li>启动 Zend 引擎，内存池启动、注册虚拟机的各项执行句柄</li><li>解析 php.ini 配置文件</li><li>注册拓展，包括静态编译拓展和动态编译拓展</li><li><strong>回调拓展定义的 MI 函数，即 <code>PHP_MINIT_FUNCTION</code> </strong></li></ul></li><li>PHP_RI，请求初始化阶段，CLI 模式下，该函数执行一次。如果是 php-fpm 模式下，会在 PHP_RI 和 PHP_RS 之间循环。该阶段需要关注的有如下事宜：<ul><li>激活 zend 引擎，包括：重置垃圾回收器、初始化编译器、初始化执行器、初始化词法扫描器</li><li><strong>回调各拓展定义的 RI 函数，即 <code>PHP_RINIT_FUNCTION</code></strong></li></ul></li><li>PHP_EXECUTE，脚本执行阶段。通过拦截 zend 引擎的 execute 函数，我们可以捕获用户执行的每一条语句，我们可以在此阶段，进行 MySQL、Redis、CURL等代码的捕获，从而生成对应的 span，进而构建 trace。</li><li>PHP_RS，请求关闭阶段。该阶段主要进行请求资源的释放动作，同时这个是 fpm 请求的最后一个阶段，我们可以在此阶段，把本次请求获取的 segment 信息上报至 sidecar</li><li>PHP_MS，模块关闭阶段。各项资源的释放</li></ul><p>SkyWalking PHP 内核的主要处理流程整理如下：</p><p><img src="/assets/image-20210118185219149.png" alt="image-20210118185219149"></p><h2 id="二、PHP-MI-阶段，自定义函数执行器替换Zend内核执行器"><a href="#二、PHP-MI-阶段，自定义函数执行器替换Zend内核执行器" class="headerlink" title="二、PHP_MI 阶段，自定义函数执行器替换Zend内核执行器"></a>二、PHP_MI 阶段，自定义函数执行器替换Zend内核执行器</h2><p><img src="/assets/image-20210118191216694.png" alt="image-20210118191216694"></p><p>该阶段的入口函数 <strong><code>PHP_MINIT_FUNCTION (skywalking)</code></strong></p><h3 id="2-1-代码命名约定"><a href="#2-1-代码命名约定" class="headerlink" title="2.1 代码命名约定"></a>2.1 代码命名约定</h3><p>该阶段主要是进行 Zend 执行器的 assign 动作，变量的命名有如下规则：</p><ul><li><code>ori_</code> 打头的，是 Zend 引擎的原函数，这里做备份，便于 hack 后，恢复原来的执行</li><li><code>zend_</code> 打头的，就是 Zend 引擎的内置函数</li><li><code>sky_</code> 打头的，是我们计划在对应阶段进行的自定义动作。一般在自定义动作的最后，都会使用 <code>ori_</code> 来交还函数控制权，恢复原来正常流程函数的执行动作</li></ul><p>部分代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PHP_MINIT_FUNCTION (skywalking) &#123;</span><br><span class="line">  <span class="comment">// .....</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 用户自定义函数执行器(php脚本定义的类、函数)</span></span><br><span class="line">  ori_execute_ex = zend_execute_ex;</span><br><span class="line">  zend_execute_ex = sky_execute_ex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 内部函数执行器(c语言定义的类、函数)</span></span><br><span class="line">  ori_execute_internal = zend_execute_internal;</span><br><span class="line">  zend_execute_internal = sky_execute_internal;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-拦截的函数分类和意义"><a href="#2-2-拦截的函数分类和意义" class="headerlink" title="2.2 拦截的函数分类和意义"></a>2.2 拦截的函数分类和意义</h3><p>其拦截的函数主要分三类：</p><ul><li>zend_execute_ex，拦截用户态函数，即我们平时写的 .php 文件里面的代码。这里可以捕获到 class name 类名、function name 函数名</li><li>zend_execute_internal，拦截 PHP 内置的函数和类等，比如 PDO、mysqli 等</li><li>CURL相关的函数句柄，这样我们就可以捕获函数的上下游 http 调用信息。其拦截的函数包括：curl_exec、curl_setopt、curl_setopt_array、curl_close</li></ul><h2 id="三、PHP-RI-阶段，请求初始化，注册-sky-agent，构造原始-segment"><a href="#三、PHP-RI-阶段，请求初始化，注册-sky-agent，构造原始-segment" class="headerlink" title="三、PHP_RI 阶段，请求初始化，注册 sky-agent，构造原始 segment"></a>三、PHP_RI 阶段，请求初始化，注册 sky-agent，构造原始 segment</h2><p>入口函数 <code>PHP_RINIT_FUNCTION(skywalking)</code></p><h3 id="3-1-主要流程"><a href="#3-1-主要流程" class="headerlink" title="3.1 主要流程"></a>3.1 主要流程</h3><p>PHP_RI 阶段在每一个 fpm 请求时都会触发一次，在此阶段，主要进行以下两件事</p><ul><li><code>static int sky_register()</code>，通过 unix sock 通信，注册 agent，同时根据返回的握手信息来确定 app、service、instance信息</li><li><code>static void request_init()</code> ，构造 segement 信息，这里包含了以下重要信息<ul><li>生成 traceId</li><li>根据 header 的 sw8 字段来解析上游信息，进而构造 span 信心，refs 信息</li></ul></li></ul><h3 id="3-2-traceId-生成规则，三段格式-instance-pid-second"><a href="#3-2-traceId-生成规则，三段格式-instance-pid-second" class="headerlink" title="3.2 traceId 生成规则，三段格式 instance.pid.second"></a>3.2 traceId 生成规则，三段格式 instance.pid.second</h3><p>其核心代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generate_context</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sys_pid = getpid();</span><br><span class="line">  <span class="keyword">long</span> second = get_second();</span><br><span class="line">  second = second * <span class="number">10000</span> + sky_increment_id; <span class="comment">//创建traceid的因子</span></span><br><span class="line">  <span class="keyword">char</span> *makeTraceId;</span><br><span class="line">  makeTraceId = (<span class="keyword">char</span> *) emalloc(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * <span class="number">180</span>); <span class="comment">//分配traceId所需要的内存</span></span><br><span class="line"></span><br><span class="line">  bzero(makeTraceId, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * <span class="number">180</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sprintf</span>(makeTraceId, <span class="string">"%d.%d.%ld"</span>, application_instance, sys_pid, second);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// .....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 sky_increment_id 是 0~9999。MSP 平台中显示的 TraceId 信息，类似如下：</p><p><img src="/assets/image-20210118194441556.png" alt="image-20210118194441556"></p><p>我们来简短分析下，按点「.」分割</p><ul><li><code>1</code>。因为在 sky_register 阶段，application_instance 固定为 1</li><li><code>393</code>，即 pid</li><li><code>16109522148050</code> 这个就是时间戳 + sky_increment_id 构成的了</li></ul><h3 id="3-3-header-里的-HTTP-SW8-数据含义"><a href="#3-3-header-里的-HTTP-SW8-数据含义" class="headerlink" title="3.3 header 里的 HTTP_SW8 数据含义"></a>3.3 header 里的 HTTP_SW8 数据含义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generate_context</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// .......</span></span><br><span class="line">  <span class="comment">// 获取 header HTTP_SW8 信息</span></span><br><span class="line">  sw = zend_hash_str_find(Z_ARRVAL_P(carrier), <span class="string">"HTTP_SW8"</span>, <span class="keyword">sizeof</span>(<span class="string">"HTTP_SW8"</span>) - <span class="number">1</span>); <span class="comment">//$SERVER['HTTP_SW8'];</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// .......</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 按中横线（-）分割为 sw8_N 数组</span></span><br><span class="line">  php_explode(zend_string_init(ZEND_STRL(<span class="string">"-"</span>), <span class="number">0</span>), Z_STR_P(sw), &amp;temp, <span class="number">10</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">  <span class="comment">// 对分割后的数组，进行解码，其 index 为 1,2,4,5,6,7</span></span><br><span class="line">  zval_b64_decode(&amp;sw8_1decode, Z_STRVAL_P(sw8_1));</span><br><span class="line">  zval_b64_decode(&amp;sw8_2decode, Z_STRVAL_P(sw8_2));</span><br><span class="line">  zval_b64_decode(&amp;sw8_4decode, Z_STRVAL_P(sw8_4));</span><br><span class="line">  zval_b64_decode(&amp;sw8_5decode, Z_STRVAL_P(sw8_5));</span><br><span class="line">  zval_b64_decode(&amp;sw8_6decode, Z_STRVAL_P(sw8_6));</span><br><span class="line">  zval_b64_decode(&amp;sw8_7decode, Z_STRVAL_P(sw8_7));</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// .......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们去网关日志里，取一个样本分析，得到的原始 header 信息如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1-QzBBODNDMzEtMTYxMDk1MzUyODM0MC0xMTc3OTctQS0xMjcw-QzBBODNDMzEtMTYxMDk1MzUyODM0MC0xMTc3OTctQS0xMjcw-1-xxxxxxxxxxxx-YjcyOWU0MzUtNjA5Zi00YzMwLWI4MjctNjZmMmUyYWZjNmM2-xxxxxxxxxx==-xxxxx.service</span><br></pre></td></tr></table></figure><p>我们按中横线(-)分割，得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">QzBBODNDMzEtMTYxMDk1MzUyODM0MC0xMTc3OTctQS0xMjcw // Trace Id base64</span><br><span class="line">QzBBODNDMzEtMTYxMDk1MzUyODM0MC0xMTc3OTctQS0xMjcw // Parent trace segment Id</span><br><span class="line">1                                                // Parent span Id</span><br><span class="line">xxxxxxxxxxxx                                     // Parent service</span><br><span class="line">YjcyOWU0MzUtNjA5Zi00YzMwLWI4MjctNjZmMmUyYWZjNmM2 // Parent service instance</span><br><span class="line">xxxxxxxxxx==                                     // Parent endpoint</span><br><span class="line">xxxxx.service                                    // Target address used at client side of this request</span><br></pre></td></tr></table></figure><p>我们对其中 1,2,4,5,6,7 进行 base64 解码，得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">C0A83C31-1610953528340-117797-A-1270 // Trace Id base64</span><br><span class="line">C0A83C31-1610953528340-117797-A-1270 // Parent trace segment Id</span><br><span class="line">1                                    // Parent span Id</span><br><span class="line">xxxxxxxxxxxxx                        // Parent service</span><br><span class="line">b729e435-609f-4c30-b827-66f2e2afc6c6 // Parent service instance</span><br><span class="line">xxxxxxxxxxxxxxxxxxxxxxxxx            // Parent endpoint</span><br><span class="line">xxxxxxxxxx.service                   // Target address used at client side of this request</span><br></pre></td></tr></table></figure><h3 id="3-4-RI-周期主要流程如下"><a href="#3-4-RI-周期主要流程如下" class="headerlink" title="3.4 RI 周期主要流程如下"></a>3.4 RI 周期主要流程如下</h3><p><img src="/assets/lifecycle.png" alt="lifecycle"></p><h2 id="四、PHP-EXECUTE-阶段，拦截代码执行语句，分析后恢复执行"><a href="#四、PHP-EXECUTE-阶段，拦截代码执行语句，分析后恢复执行" class="headerlink" title="四、PHP_EXECUTE 阶段，拦截代码执行语句，分析后恢复执行"></a>四、PHP_EXECUTE 阶段，拦截代码执行语句，分析后恢复执行</h2><p><img src="/assets/image-20210118193135548.png" alt="image-20210118193135548"></p><p>在 MI 阶段，我们替换了 zend 引擎的函数执行指向，所以所有语句的执行会被我们接管。我们在执行完自己需要的动作后，还原原来的执行即可。</p><p>需要注意的是，我们接管的函数会被多次触发，每执行一条 opline，就会被触发一次(存疑，待指正)。</p><h3 id="4-1-ZEND-API-void-sky-execute-ex-zend-execute-data-execute-data"><a href="#4-1-ZEND-API-void-sky-execute-ex-zend-execute-data-execute-data" class="headerlink" title="4.1 ZEND_API void sky_execute_ex(zend_execute_data *execute_data)"></a>4.1 ZEND_API void sky_execute_ex(zend_execute_data *execute_data)</h3><p>核心的流程如下</p><ol><li>获取当前代码执行的信息，包括：类名、函数名</li><li>对类名和函数名进行判断，看是否需要拦截。目前拦截的是 Predis SDK</li><li>如果需要拦截，根据拦截信息构造 span</li><li>把构造好的 span 插入到当前 segment 的 spans 数组里</li><li>恢复函数原来的执行，调用 <code>ori_</code> 即可</li></ol><p><img src="/assets/image-20210118200055531.png" alt="image-20210118200055531"></p><h3 id="4-2-ZEND-API-void-sky-execute-internal-zend-execute-data-execute-data-zval-return-value"><a href="#4-2-ZEND-API-void-sky-execute-internal-zend-execute-data-execute-data-zval-return-value" class="headerlink" title="4.2 ZEND_API void sky_execute_internal(zend_execute_data execute_data, zval return_value)"></a>4.2 ZEND_API void sky_execute_internal(zend_execute_data <em>execute_data, zval </em>return_value)</h3><p>其核心流程和上面 4.1 分析的类似，其不同就在于这里拦截的是 PHP 内置的一些类，即编译时就安装的类。流程主要包括</p><ol><li>获取类名和函数名</li><li>根据类名判断是否需要拦截，目前需要拦截：PDO、PDOStatement、mysqli、Yar_Client、Reids、Memecached</li><li>构造 span，插入到当前 segment 的 spans 数组里</li><li>恢复函数执行</li></ol><p><img src="/assets/image-20210118200231152.png" alt="image-20210118200231152"></p><h3 id="4-3-CURL-HOOK"><a href="#4-3-CURL-HOOK" class="headerlink" title="4.3 CURL HOOK"></a>4.3 CURL HOOK</h3><p>这里主要是调用链的传递，如果发现有 curl 请求，则根据规则生成当前的 sw8 信息，塞到 http header 的 sw8 字段里，传递给下游。</p><p>更多的流程，以后补充。</p><p><img src="/assets/image-20210118200521291.png" alt="image-20210118200521291"></p><h2 id="五、PHP-RS-请求结束阶段，发送-segment-信息至-sidecar"><a href="#五、PHP-RS-请求结束阶段，发送-segment-信息至-sidecar" class="headerlink" title="五、PHP_RS 请求结束阶段，发送 segment 信息至 sidecar"></a>五、PHP_RS 请求结束阶段，发送 segment 信息至 sidecar</h2><p>PHP_RS 阶段主要做两件事儿：</p><ol><li><p>通过 unix sock 发送本请求构建的 segment 信息至 sidecar</p></li><li><p>释放当前请求里的全局状态存储。由于其他的 int、char、boolean 类型的不涉及到内存管理，所以就是四个 zval 的释放</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ZEND_BEGIN_MODULE_GLOBALS(skywalking)</span><br><span class="line">    <span class="keyword">char</span> *sock_path;</span><br><span class="line">    <span class="keyword">char</span> *app_code; <span class="comment">//app_name eg:skywalking.app_code = MyProjectName</span></span><br><span class="line">    <span class="keyword">char</span> *app_code_env_key; <span class="comment">//app_name 环境变量地址：环境变量-&gt;默认KEY：APM_APP_CODE</span></span><br><span class="line">    zend_bool enable;</span><br><span class="line">    zval UpstreamSegment; <span class="comment">//全局上报数据段</span></span><br><span class="line">    zval context;</span><br><span class="line">    zval curl_header; <span class="comment">//curl header数据</span></span><br><span class="line">    zval curl_header_send; <span class="comment">//记录当前R周期 是否已经send过curl_header</span></span><br><span class="line">    <span class="keyword">int</span>  version;</span><br><span class="line">ZEND_END_MODULE_GLOBALS(skywalking)</span><br></pre></td></tr></table></figure></li></ol><p><img src="/assets/image-20210118200709516.png" alt="image-20210118200709516"></p><h2 id="六、PHP-MS-模块结束阶段"><a href="#六、PHP-MS-模块结束阶段" class="headerlink" title="六、PHP_MS 模块结束阶段"></a>六、PHP_MS 模块结束阶段</h2><p>这个阶段没啥好说的，没啥特殊操作</p><h2 id="七、全景，整个大脑图"><a href="#七、全景，整个大脑图" class="headerlink" title="七、全景，整个大脑图"></a>七、全景，整个大脑图</h2><p><img src="/assets/lifecycle2.png" alt="lifecycle2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、总体流程&quot;&gt;&lt;a href=&quot;#一、总体流程&quot; class=&quot;headerlink&quot; title=&quot;一、总体流程&quot;&gt;&lt;/a&gt;一、总体流程&lt;/h2&gt;&lt;p&gt;PHP 重要几个生命周期说明，先后顺序为 PHP_MI、PHP_RI、PHP_EXECUTE、PHP_RS、
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>在 Mac 上使用 Clion 调试 PHP 源码</title>
    <link href="https://rovast.github.io/2020/12/26/debug-php-src-on-mac/"/>
    <id>https://rovast.github.io/2020/12/26/debug-php-src-on-mac/</id>
    <published>2020-12-26T19:39:39.000Z</published>
    <updated>2020-12-27T07:04:34.038Z</updated>
    
    <content type="html"><![CDATA[<p>参考 <a href="https://www.jianshu.com/p/f6af567b25a7" target="_blank" rel="noopener">https://www.jianshu.com/p/f6af567b25a7</a></p><h2 id="一、编译安装-debug-版本的-PHP"><a href="#一、编译安装-debug-版本的-PHP" class="headerlink" title="一、编译安装 debug 版本的 PHP"></a>一、编译安装 debug 版本的 PHP</h2><ol><li><p>configure php</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./configure --<span class="built_in">enable</span>-fpm --<span class="built_in">enable</span>-debug  --with-openssl=/usr/<span class="built_in">local</span>/Cellar/openssl@1.1/1.1.1i/ \</span><br><span class="line">--<span class="built_in">enable</span>-bcmath --with-curl  --<span class="built_in">enable</span>-exif --with-mysqli --with-pdo-mysql \</span><br><span class="line">--<span class="built_in">enable</span>-zip --with-zlib=/usr/<span class="built_in">local</span>/Cellar/zlib/1.2.11/ --<span class="built_in">enable</span>-intl --<span class="built_in">enable</span>-pcntl --<span class="built_in">enable</span>-mbstring --<span class="built_in">enable</span>-soap \</span><br><span class="line">--with-icu-dir=/usr/<span class="built_in">local</span>/Cellar/icu4c/67.1 \</span><br><span class="line">--with-iconv=/usr/<span class="built_in">local</span>/Cellar/libiconv/1.16 \</span><br><span class="line">--with-libxml-dir=/usr/<span class="built_in">local</span>/Cellar/libxml2/2.9.10_2</span><br></pre></td></tr></table></figure></li><li><p>修改 makefile</p></li></ol><p>查找关键字 <code>EXTRA_LIBS =</code> 我的在 line 108，删除所有的 <code>-liconv</code>，末尾加上 <code>/usr/local/opt/libiconv/lib/libiconv.dylib</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改前</span></span><br><span class="line">EXTRA_LIBS = -lcrypto -lssl -lcrypto -lz -lresolv -lstdc++ -liconv -liconv -lz -lcrypto -lssl -lcrypto -lm -lxml2 -lz -liconv -lm -lcurl -lxml2 -lz -liconv -lm -licui18n -licuuc -licudata -licuio -lxml2 -lz -liconv -lm -lxml2 -lz -liconv -lm -lxml2 -lz -liconv -lm -lxml2 -lz -liconv -lm -lxml2 -lz -liconv -lm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改后</span></span><br><span class="line">EXTRA_LIBS = -lcrypto -lssl -lcrypto -lz -lresolv -lstdc++ -lz -lcrypto -lssl -lcrypto -lm -lxml2 -lz -lm -lcurl -lxml2 -lz -lm -licui18n -licuuc -licudata -licuio -lxml2 -lz -lm -lxml2 -lz -lm -lxml2 -lz -lm -lxml2 -lz -lm -lxml2 -lz -lm /usr/<span class="built_in">local</span>/opt/libiconv/lib/libiconv.dylib</span><br></pre></td></tr></table></figure></p><ol start="3"><li><p>make</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></li><li><p>sudo make install</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure></li></ol><h2 id="二、设定一些目录的权限，不然-Clion-不能正常调试"><a href="#二、设定一些目录的权限，不然-Clion-不能正常调试" class="headerlink" title="二、设定一些目录的权限，不然 Clion 不能正常调试"></a>二、设定一些目录的权限，不然 Clion 不能正常调试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R rovast:wheel /usr/<span class="built_in">local</span>/lib/php/</span><br></pre></td></tr></table></figure><h2 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.13)</span><br><span class="line">project(php_7_2_27)</span><br><span class="line"></span><br><span class="line">set(CMAKE_CXX_STANDARD 14)</span><br><span class="line"></span><br><span class="line">set(PHP_SOURCE /Users/rovast/Software/tmp/php-7.2.27)</span><br><span class="line"></span><br><span class="line">include_directories($&#123;PHP_SOURCE&#125;/main)</span><br><span class="line"></span><br><span class="line">include_directories($&#123;PHP_SOURCE&#125;/Zend)</span><br><span class="line"></span><br><span class="line">include_directories($&#123;PHP_SOURCE&#125;/sapi)</span><br><span class="line"></span><br><span class="line">include_directories($&#123;PHP_SOURCE&#125;/pear)</span><br><span class="line"></span><br><span class="line">include_directories($&#123;PHP_SOURCE&#125;/TSRM)</span><br><span class="line"></span><br><span class="line">include_directories($&#123;PHP_SOURCE&#125;)</span><br><span class="line"></span><br><span class="line">add_custom_target(makefile COMMAND make &amp;&amp; make install WORKING_DIRECTORY $&#123;PROJECT_SOURCE_DIR&#125;)</span><br></pre></td></tr></table></figure><h1 id="debug-on-ubuntu"><a href="#debug-on-ubuntu" class="headerlink" title="debug on ubuntu"></a>debug on ubuntu</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libxml2-dev</span><br><span class="line">./configure --<span class="built_in">enable</span>-debug --<span class="built_in">enable</span>-fpm</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考 &lt;a href=&quot;https://www.jianshu.com/p/f6af567b25a7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/f6af567b25a7&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>grafana iframe 接入备忘录</title>
    <link href="https://rovast.github.io/2020/12/22/grafana-iframe/"/>
    <id>https://rovast.github.io/2020/12/22/grafana-iframe/</id>
    <published>2020-12-22T18:46:30.000Z</published>
    <updated>2020-12-23T03:05:02.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iframe-引入"><a href="#iframe-引入" class="headerlink" title="iframe 引入"></a>iframe 引入</h1><p>部分配置修改后才能进行 iframe 嵌入，默认是不支持的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">allow_embedding: <span class="literal">true</span> <span class="comment"># 默认是 false， 为了防止 Clickjacking，如果不设置，浏览器会拒绝显示 iframe</span></span><br><span class="line">cookie_samesite: none <span class="comment"># 如果不设置，无法使用登录功能</span></span><br><span class="line">cookie_secure: <span class="literal">true</span> <span class="comment"># if you're using https and let us know how that works out.</span></span><br></pre></td></tr></table></figure><p>配置说明 <a href="https://grafana.com/docs/grafana/latest/administration/configuration/" target="_blank" rel="noopener">https://grafana.com/docs/grafana/latest/administration/configuration/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cookie_secure</span><br><span class="line">Set to true if you host Grafana behind HTTPS. Default is false.</span><br><span class="line"></span><br><span class="line">cookie_samesite</span><br><span class="line">Sets the SameSite cookie attribute and prevents the browser from sending this cookie along with cross-site requests. </span><br><span class="line">The main goal is to mitigate the risk of cross-origin information leakage. </span><br><span class="line">This setting also provides some protection against cross-site request forgery attacks (CSRF), read more about SameSite here. </span><br><span class="line">Valid values are lax, strict, none, and disabled. Default is lax. </span><br><span class="line">Using value disabled does not add any SameSite attribute to cookies.</span><br><span class="line"></span><br><span class="line">allow_embedding</span><br><span class="line">When false, the HTTP header X-Frame-Options: deny will be set in Grafana HTTP responses which will instruct browsers </span><br><span class="line">to not allow rendering Grafana in a &lt;frame&gt;, &lt;iframe&gt;, &lt;embed&gt; or &lt;object&gt;. </span><br><span class="line">The main goal is to mitigate the risk of Clickjacking. Default is false.</span><br></pre></td></tr></table></figure><h1 id="免登陆访问-dashboard"><a href="#免登陆访问-dashboard" class="headerlink" title="免登陆访问 dashboard"></a>免登陆访问 dashboard</h1><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>暂时不支持设定指定的 dashboard 为 public，即：免认证访问。如果开启了只读权限，则所有人皆可以访问</p><h2 id="相关调研"><a href="#相关调研" class="headerlink" title="相关调研"></a>相关调研</h2><p>1、<a href="https://community.grafana.com/t/making-selected-dashboards-public/873" target="_blank" rel="noopener">《Making selected dashboards public》</a></p><blockquote><p>There is no way to do this and there is a big reason why.<br>If you make one dashboard public you will have to make your data source public<br>(ie anyone can query against it).<br>So any possible query for that data source can be issued not just the queries used in the dashboard you made public.</p></blockquote><p>根据初步的调研，得到的答复是不能指定 dashboard 开放 public 权限。同时，官方的 issue 里也有关于此问题的回复</p><p>2、<a href="https://github.com/grafana/grafana/issues/14473" target="_blank" rel="noopener">《[FeatureRequest] Dashboards: Add real time share instead of snapshot》</a></p><p>目前依旧是处于 Open 状态。</p><h2 id="折衷方案"><a href="#折衷方案" class="headerlink" title="折衷方案"></a>折衷方案</h2><p><a href="https://community.grafana.com/t/how-to-make-one-live-dashboard-public/12819" target="_blank" rel="noopener">《How to make one live dashboard public》</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iframe-引入&quot;&gt;&lt;a href=&quot;#iframe-引入&quot; class=&quot;headerlink&quot; title=&quot;iframe 引入&quot;&gt;&lt;/a&gt;iframe 引入&lt;/h1&gt;&lt;p&gt;部分配置修改后才能进行 iframe 嵌入，默认是不支持的&lt;/p&gt;
&lt;figure 
      
    
    </summary>
    
      <category term="工具" scheme="https://rovast.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>makefile 简明教程</title>
    <link href="https://rovast.github.io/2020/11/28/makefile-tutorials/"/>
    <id>https://rovast.github.io/2020/11/28/makefile-tutorials/</id>
    <published>2020-11-28T13:39:18.000Z</published>
    <updated>2020-11-28T13:41:13.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Makefile-简明教程"><a href="#Makefile-简明教程" class="headerlink" title="Makefile 简明教程"></a>Makefile 简明教程</h1><blockquote><p> 英文原文地址：<a href="https://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/" target="_blank" rel="noopener">https://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/</a></p></blockquote><p>Makefiles 是组织代码编译的一种方式。通过这篇简明教程，虽然你不能完整学会 <code>make</code> 指令，但是你可以使用 makefile 来组织小到中型的项目啦。</p><h2 id="一个-简单的例子"><a href="#一个-简单的例子" class="headerlink" title="一个 简单的例子"></a>一个 简单的例子</h2><p>我们来从下面的三个文件开始吧：<code>hellomake.c</code>，<code>hellofunc.c</code>，<code>hellomake.h</code>。这是一个经典 C 语言程序，代码根据功能组织在不同的文件中。</p><p><em>hellomake.c</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hellomake.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 调用另一个文件里的函数</span></span><br><span class="line">  myPrintHelloMake();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>hellofunc.c</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hellomake.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintHelloMake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello makefiles!\n"</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>hellomake.h</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* example include file */</span><br><span class="line">void myPrintHelloMake(void);</span><br></pre></td></tr></table></figure><p>一般情况下，我们通过下面的指令来编译代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hellomake hellomake.c hellofunc.c -I.</span><br></pre></td></tr></table></figure><p>我们来说明下这个指令：</p><ol><li>我们编译两个 <code>.c</code> 文件</li><li>命名了编译后的可执行文件为 <code>hellomake</code></li><li><code>-I.</code> 告诉 gcc 在当前目录中寻找 <code>hellomake.h</code></li></ol><p>如果没有使用 makefile，我们在调试开发的时候，可以在终端上输入 <code>向上方向键</code> 来快速显示上次的指令（尤其是你有多个 <code>.c</code> 文件需要编译的时候）。</p><p>然而，通过上面的直接输入编译指令的方式存在两个弊端：</p><ul><li><strong>弊端一：</strong>不方便呀！当你换了电脑之后，你要重新再输入上面的指令。</li><li><strong>弊端二：</strong>编译效率低下！即使你只是修改了项目中的一个 <code>.c</code> 文件，每次编译时，还是需要编译所有的文件，这无疑是效率低下，浪费时间。</li></ul><p>所以接下来，请出本文的主角 —— makefile。</p><h2 id="Makefile1"><a href="#Makefile1" class="headerlink" title="Makefile1"></a>Makefile1</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hellomake: hellomake.c hellofunc.c</span></span><br><span class="line">gcc -o hellomake hellomake.c hellofunc.c -I.</span><br></pre></td></tr></table></figure><p>把上述的内容，放入到 <code>Makefile</code> 或者 <code>makefile</code> 文件，然后在命令行输入 <code>make</code> 命令，就能够直接执行编译了。有以下几点我们需要关注下：</p><ol><li>如果 <code>make</code> 后面没有跟任何参数，那么他就会执行 makefile 的第一条规则。</li><li>把命令依赖的文件放在第一行的 <code>:</code> 后面，这样 <code>make</code> 就能知道，当依赖文件变化时， <code>hellomake</code> 规则需要重新执行。</li><li>注意，第二行 <code>gcc</code> 前面，是一个 <code>tab</code> 制表符！不要使用空格！</li></ol><p>通过这样简单的 Makefile，我们已经解决了弊端一的问题，即：我们不需要每次都输入编译指令了。</p><p>然而，现在还不够高效，即使只修改了一个文件，还是需要全量编译（即编译所有的源文件）。为了使编译更加高效，让我们继续往下看。</p><h2 id="Makefile2"><a href="#Makefile2" class="headerlink" title="Makefile2"></a>Makefile2</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">CFLAGS=-I.</span><br><span class="line"></span><br><span class="line"><span class="section">hellomake: hellomake.o hellofunc.o</span></span><br><span class="line"><span class="variable">$(CC)</span> -o hellomake hellomake.o hellofunc.o</span><br></pre></td></tr></table></figure><p>我们定义了两个常量 <code>CC</code>、 <code>CFLAGS</code>，这两个常量告诉 <code>make</code> 怎么去编译 <code>hellomake.c</code> 和 <code>hellofunc.c</code>。其中 <code>CC</code> 告诉 make 使用哪个 C 编译器，<code>CFLAGS</code> 说明了编译指令的参数列表。通过把 <code>hellomake.o</code> 和 <code>hellofunc.o</code> 放到依赖列表中， <code>make</code> 指令就知道每次需要分别编译 <code>.c</code> 文件，然后再把他们编译为可行性文件 <code>hellomake</code>。</p><p>终端执行效果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  makefile-tourial git:(master) ✗ make</span><br><span class="line">gcc -I.   -c -o hellomake.o hellomake.c</span><br><span class="line">gcc -I.   -c -o hellofunc.o hellofunc.c</span><br><span class="line">gcc -o hellomake hellomake.o hellofunc.o</span><br><span class="line">➜  makefile-tourial git:(master) ✗</span><br></pre></td></tr></table></figure><p>这种形式的 makefile 对小型的项目还是比较方便的。然而，还是有个问题，那就是依赖文件的更新。设想下，即使你修改了<code>hellomake.h</code> 文件，<code>make</code> 指令不会重新编译文件。</p><p>为了解决这个问题，我们需要告诉 <code>make</code> 一件事情：即<code>.c</code> 文件和 <code>.h</code> 文件间的依赖关系。好，我们继续往下看。</p><h2 id="Makefile3"><a href="#Makefile3" class="headerlink" title="Makefile3"></a>Makefile3</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">CFLAGS=-I.</span><br><span class="line">DEPS = hellomake.h</span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c <span class="variable">$(DEPS)</span></span></span><br><span class="line"><span class="variable">$(CC)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span> <span class="variable">$(CFLAGS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">hellomake: hellomake.o hellofunc.o</span></span><br><span class="line"><span class="variable">$(CC)</span> -o hellomake hellomake.o hellofunc.o</span><br></pre></td></tr></table></figure><p>相较于上个版本，我们先是增加了一个 <code>DEPS</code>：这里列出了 <code>.c</code> 文件所依赖的 <code>.h</code> 文件集合。</p><p>接着，我们定义了一个了规则 <code>%.o: %.c $(DEPS)</code>：它说明了 <code>.o</code> 文件是取决于 <code>.c</code> 文件和 <code>DEPS</code> 里的 <code>.h</code> 文件。</p><p>接下来我们看下规则 <code>$(CC) -c -o $@ $&lt; $(CFLAGS)</code>，意思是说，为了生成这些 <code>.o</code> 文件，<code>make</code> 指令使用了 <code>CC</code> 定义的编译器来编译 <code>.c</code> 文件：</p><ul><li><code>-c</code> 说明了是为了生成目标文件（object files）</li><li><code>$@</code> 代表 <code>:</code> 左边的内容，即：<code>%.o</code></li><li><code>$&lt;</code> 是依赖列表里的第一项，即：<code>%.c</code></li><li><code>CFLAGS</code> 和之前的说明一样，就是编译的指令参数了(flag）</li></ul><p>执行效果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  makefile-tourial git:(master) ✗ make</span><br><span class="line">gcc -c -o hellomake.o hellomake.c -I.</span><br><span class="line">gcc -c -o hellofunc.o hellofunc.c -I.</span><br><span class="line">gcc -o hellomake hellomake.o hellofunc.o</span><br><span class="line">➜  makefile-tourial git:(master) ✗</span><br></pre></td></tr></table></figure><p>最后，我们再来做下简化，使编译更具通用性。我们使用 <code>$@</code> 和 <code>$^</code> 来分别表示 <code>:</code>  的左侧和右侧。在下面的例子里，所有 include 文件会作为 <code>DEPS</code> 的一部分，所有目标文件（object files）会作为 <code>OBJ</code> 的一部分。</p><h2 id="Makefile4"><a href="#Makefile4" class="headerlink" title="Makefile4"></a>Makefile4</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">CFLAGS=-I.</span><br><span class="line">DEPS = hellomake.h</span><br><span class="line">OBJ = hellomake.o hellofunc.o</span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c <span class="variable">$(DEPS)</span></span></span><br><span class="line"><span class="variable">$(CC)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span> <span class="variable">$(CFLAGS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">hellomake: <span class="variable">$(OBJ)</span></span></span><br><span class="line"><span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span> <span class="variable">$(CFLAGS)</span></span><br></pre></td></tr></table></figure><p>执行效果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  makefile-tourial git:(master) ✗ make</span><br><span class="line">gcc -c -o hellomake.o hellomake.c -I.</span><br><span class="line">gcc -c -o hellofunc.o hellofunc.c -I.</span><br><span class="line">gcc -o hellomake hellomake.o hellofunc.o -I.</span><br></pre></td></tr></table></figure><p>让我们来进一步思考下：</p><ul><li>我们能不能把 <code>.h</code> 的文件都放到一个专门的 <code>inlcude</code> 目录，把 <code>.c</code> 文件都放到一个专门的 <code>src</code>目录？</li><li>我们能不能把这些烦人的 <code>.o</code> 文件都隐藏起来？</li></ul><p>当然是可以的！我们会在下一个 makefile 中把对应的文件放到 <code>include</code> 和  <code>lib</code>文件夹中，并且把生成的目标文件都放到 <code>src</code> 的 <code>obj</code> 子目录中。除此之外，我们还可以定义任何我们想包含的库文件，比如常用的 math library <code>-lm</code>。这个 makefile 放在 <code>src</code> 目录里。</p><p>需要注意的是，我们还定义了一个 <code>clean</code> 规则，用来把生成的目标文件清除（使用 <code>make clean</code> 命令）。<code>.PHONY</code> 防止 <code>make</code> 清除名为 <code>clean</code> 的文件。</p><p>文件路径为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  src git:(master) ✗ tree          </span><br><span class="line">.</span><br><span class="line">├── hellofunc.c</span><br><span class="line">├── hellomake</span><br><span class="line">├── hellomake.c</span><br><span class="line">├── makefile</span><br><span class="line">└── obj</span><br><span class="line">    ├── hellofunc.o</span><br><span class="line">    └── hellomake.o</span><br><span class="line"></span><br><span class="line">1 directory, 6 files</span><br></pre></td></tr></table></figure><h2 id="Makefile5"><a href="#Makefile5" class="headerlink" title="Makefile5"></a>Makefile5</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">IDIR = ../<span class="keyword">include</span></span><br><span class="line">CC=gcc</span><br><span class="line">CFLAGS=-I<span class="variable">$(DIR)</span></span><br><span class="line"></span><br><span class="line">ODIR=obj</span><br><span class="line">LDIR=../lib</span><br><span class="line"></span><br><span class="line">LIBS=-lm</span><br><span class="line"></span><br><span class="line">_DEPS = hellomake.h</span><br><span class="line">DEPS=<span class="variable">$(<span class="built_in">patsubst</span> %,<span class="variable">$(IDIR)</span>/%,<span class="variable">$(_DEPS)</span>)</span></span><br><span class="line"></span><br><span class="line">_OBJ = hellomake.o hellofunc.o</span><br><span class="line">OBJ=<span class="variable">$(<span class="built_in">patsubst</span> %,<span class="variable">$(ODIR)</span>/%,<span class="variable">$(_OBJ)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(ODIR)</span>/%.o: %.c <span class="variable">$(DEPS)</span>(</span><br><span class="line"><span class="variable">$(CC)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span> <span class="variable">$(CFLAGS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">hellomake: <span class="variable">$(OBJ)</span></span></span><br><span class="line"><span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(LIBS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f <span class="variable">$(ODIR)</span>/*.o *~ core <span class="variable">$(INCDIR)</span>/*~</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  src git:(master) ✗ make</span><br><span class="line">gcc -c -o obj/hellomake.o hellomake.c -I../include</span><br><span class="line">gcc -c -o obj/hellofunc.o hellofunc.c -I../include</span><br><span class="line">gcc -o hellomake obj/hellomake.o obj/hellofunc.o -I../include</span><br></pre></td></tr></table></figure><blockquote><p>注意要在 <code>src</code> 目录下运行，并且要把 <code>.h</code> 文件放到 <code>include</code> 目录里</p></blockquote><p>好了，到目前为止，你已经有了一个不错的 makefile 了，现在你能 hold 住一个中型的项目了。你也可以增加更多的规则到 makefile 里，你甚至可以在一个规则中调用另一个规则。</p><p>想知道更多关于 makefile 和 make 的信息，就去查阅 <a href="https://www.gnu.org/software/make/manual/make.html" target="_blank" rel="noopener">GNU Make Manual</a> 吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Makefile-简明教程&quot;&gt;&lt;a href=&quot;#Makefile-简明教程&quot; class=&quot;headerlink&quot; title=&quot;Makefile 简明教程&quot;&gt;&lt;/a&gt;Makefile 简明教程&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; 英文原文地址：&lt;a hr
      
    
    </summary>
    
      <category term="编程" scheme="https://rovast.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>借助 skywalking 搭建自己的 APM 数据展示平台</title>
    <link href="https://rovast.github.io/2020/11/28/build-your-own-ui-for-skywalking/"/>
    <id>https://rovast.github.io/2020/11/28/build-your-own-ui-for-skywalking/</id>
    <published>2020-11-28T09:27:41.000Z</published>
    <updated>2020-11-28T11:10:56.931Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/11/28/build-your-own-ui-for-skywalking/logo.jpeg" width="500" height="400"><blockquote><p>SkyWalking: an APM(application performance monitor) system, especially designed for microservices, cloud native and container-based (Docker, Kubernetes, Mesos) architectures.</p><footer><strong>README.md</strong><cite><a href="https://github.com/apache/skywalking" target="_blank" rel="noopener">github.com/apache/skywalking</a></cite></footer></blockquote><p>skywaking(本文后续简称 SW) 在如今的 APM 体系建设中逐渐展露头角，国内几乎所有的一线大厂都借助 skywaling 进行了自己的 APM 体系建设。<br>大厂的建设方案在诸多的大会中都有提及，尤其在刚过去的 《Apache SkyWalking DevCon 2020》，更是带来了诸多的精彩分享。</p><p>本文不会就 APM 架构或理论进行详细阐述，更多聚焦在实战环节，围绕下述几点展开：</p><ol><li>分析 SW 架构，确定接入方案</li><li>如何在本地调式官方的 UI 项目</li><li>快速了解 SW 查询协议 GraphQL </li></ol><h1 id="Skywalking-架构简介，寻找接入点"><a href="#Skywalking-架构简介，寻找接入点" class="headerlink" title="Skywalking 架构简介，寻找接入点"></a>Skywalking 架构简介，寻找接入点</h1><h2 id="几个官方库"><a href="#几个官方库" class="headerlink" title="几个官方库"></a>几个官方库</h2><p>在正式分析之前，我们来看下 SW 比较重要的三个官方项目</p><ul><li>主库 <a href="https://github.com/apache/skywalking" target="_blank" rel="noopener">https://github.com/apache/skywalking</a></li><li>UI 库 <a href="https://github.com/apache/skywalking-rocketbot-ui" target="_blank" rel="noopener">https://github.com/apache/skywalking-rocketbot-ui</a></li><li>查询协议库 <a href="https://github.com/apache/skywalking-query-protocol" target="_blank" rel="noopener">https://github.com/apache/skywalking-query-protocol</a></li></ul><h2 id="SW-查询协议-——-获取数据的桥梁"><a href="#SW-查询协议-——-获取数据的桥梁" class="headerlink" title="SW 查询协议 —— 获取数据的桥梁"></a>SW 查询协议 —— 获取数据的桥梁</h2><p>接下来，我们看下主库的架构图，即 SW 体系的整体架构图：</p><img src="/2020/11/28/build-your-own-ui-for-skywalking/jiagou.jpeg" width="500" height="400"><p>我们关注的 UI 接入部分，在图的左上角，其中 UI 和 CLI 通过查询协议来和 SW 的后端服务进行交互。正如查询协议库所说：</p><blockquote><p>Query Protocol defines the communication protocol in query stage.<br><strong>SkyWalking native UI</strong> and <strong>CLI</strong> use this protocol to <strong>fetch data from the backend</strong> consistently, don’t need to worry about the backend update.</p><footer><strong>README.md</strong><cite><a href="https://github.com/apache/skywalking-query-protocol" target="_blank" rel="noopener">github.com/apache/skywalking-query-protocol</a></cite></footer></blockquote><p>其中重点我们加粗表示了，即：SW 的官方 UI 和 CLI 工具都是通过查询协议和后端服务进行数据交互。</p><p>SW 的查询协议通俗简单的理解：定义了一系列 GraphQL 查询定义。甚至可以进一步粗暴的理解，就是一堆定义好的 HTTP API。所以只要了解官方的 API 定义，即可发挥 SW 的数据宝藏威力，<br>打造属于自己的 APM 展示平台。</p><p>快速搭建的第一步，就是参考官方的 UI 项目，一方面我们可以参考它的 UI 组件实现。另一方面，我们可以抓包，参考它的 GraphQL 请求。</p><h1 id="官网项目本地调试"><a href="#官网项目本地调试" class="headerlink" title="官网项目本地调试"></a>官网项目本地调试</h1><h2 id="本地运行一览"><a href="#本地运行一览" class="headerlink" title="本地运行一览"></a>本地运行一览</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置后端的请求地址为 SW 官方的北京机房演示地址</span></span><br><span class="line">➜  skywalking-rocketbot-ui git:(master) <span class="built_in">export</span> SW_PROXY_TARGET=http://122.112.182.72:8080/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务，之后访问 8080 端口</span></span><br><span class="line">➜  skywalking-rocketbot-ui git:(master) npm run serve</span><br></pre></td></tr></table></figure><p>访问 <a href="http://localhost:8080/topology" target="_blank" rel="noopener">http://localhost:8080/topology</a></p><img src="/2020/11/28/build-your-own-ui-for-skywalking/ui.jpg"><p>我们看到，服务已成功在本地运行，且可以通过 VueDev Tools 来查看对应的组件实现和传值。对我们自己去实现对应的显示组件，提供了极高的参考意义。</p><blockquote><p>关于如何这个环境变量的设置，大家可以顺着 packages.json 去捋一下 run server 的整个流程</p></blockquote><h2 id="服务抓包格式化"><a href="#服务抓包格式化" class="headerlink" title="服务抓包格式化"></a>服务抓包格式化</h2><p>我们还是以这个拓扑为例，抓一个包，简单看下 GraphQL 请求</p><figure class="highlight json"><figcaption><span>requestPayload</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: <span class="string">"query queryTopo($duration: Duration!) &#123;\n  topo: getGlobalTopology(duration: $duration) &#123;\n    nodes &#123;\n      id\n      name\n      type\n      isReal\n    &#125;\n    calls &#123;\n      id\n      source\n      detectPoints\n      target\n    &#125;\n  &#125;&#125;"</span>,</span><br><span class="line">  <span class="attr">"variables"</span>: &#123;</span><br><span class="line">    <span class="attr">"serviceId"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"duration"</span>: &#123;</span><br><span class="line">      <span class="attr">"start"</span>: <span class="string">"2020-11-27 0912"</span>,</span><br><span class="line">      <span class="attr">"end"</span>: <span class="string">"2020-11-27 0927"</span>,</span><br><span class="line">      <span class="attr">"step"</span>: <span class="string">"MINUTE"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们进一步格式化 graphQL 的 query 请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">query queryTopo($duration: Duration!) &#123;</span><br><span class="line">  topo: getGlobalTopology(duration: $duration) &#123;</span><br><span class="line">    nodes &#123;</span><br><span class="line">      id</span><br><span class="line">      name</span><br><span class="line">      type</span><br><span class="line">      isReal</span><br><span class="line">    &#125;</span><br><span class="line">    calls &#123;</span><br><span class="line">      id</span><br><span class="line">      source</span><br><span class="line">      detectPoints</span><br><span class="line">      target</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>格式化过后，更方便我们进行对应分析。</p><h1 id="分析查询协议"><a href="#分析查询协议" class="headerlink" title="分析查询协议"></a>分析查询协议</h1><h2 id="快速了解查询语句含义"><a href="#快速了解查询语句含义" class="headerlink" title="快速了解查询语句含义"></a>快速了解查询语句含义</h2><p>GraphQL 的更多用法，本文不提及。文本就上述抓到的协议进行简单说明，便于之前不了解 GraphQL 的同学能够快速了解 SW 查询协议。</p><ol><li>查看 Query，确定查询语句，其中 <code>$</code> 开头的就是形参，在 <code>variables</code> 里会具体传值</li><li>那上述例子，<code>$duration</code> 的具体值，就是 <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"start"</span>: <span class="string">"2020-11-27 0912"</span>,</span><br><span class="line">  <span class="attr">"end"</span>: <span class="string">"2020-11-27 0927"</span>,</span><br><span class="line">  <span class="attr">"step"</span>: <span class="string">"MINUTE"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>那问题来了，我怎么知道 <code>$duration</code> 是由 <code>start</code> <code>end</code> <code>step</code> 组成？他们的值类型是什么？在哪里定义？这就要看之前我们提到的 SW 查询协议。</p><h2 id="查询协议"><a href="#查询协议" class="headerlink" title="查询协议"></a>查询协议</h2><p>接着上面的分析，我们去查看 SW 的 Query Protocol.</p><blockquote><p>到这里大家看到，其实 Query Protocol 就是查询的定义，标准。就像我们平时开发中接触的后端标准接口一样。大家在接触这些看似<br>高大上的 Query Protocol 时，不要被唬到，其实就是相同技术在不同场合的不同叫法罢了。</p></blockquote><p>本例中的拓扑，我们可以查看 <a href="https://github.com/apache/skywalking-query-protocol/blob/master/topology.graphqls" target="_blank" rel="noopener">https://github.com/apache/skywalking-query-protocol/blob/master/topology.graphqls</a> 定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">extend type Query &#123;</span><br><span class="line">    # Query the global topology</span><br><span class="line">    getGlobalTopology(duration: Duration!): Topology</span><br><span class="line">    # Query the topology, based on the given service</span><br><span class="line">    getServiceTopology(serviceId: ID!, duration: Duration!): Topology</span><br><span class="line">    # Query the topology, based on the given services.</span><br><span class="line">    # `#getServiceTopology` could be replaced by this.</span><br><span class="line">    getServicesTopology(serviceIds: [ID!]!, duration: Duration!): Topology</span><br><span class="line">    # Query the instance topology, based on the given clientServiceId and serverServiceId</span><br><span class="line">    getServiceInstanceTopology(clientServiceId: ID!, serverServiceId: ID!, duration: Duration!): ServiceInstanceTopology</span><br><span class="line">    # Query the topology, based on the given endpoint</span><br><span class="line">    getEndpointTopology(endpointId: ID!, duration: Duration!): Topology</span><br><span class="line">    # v2 of getEndpointTopology</span><br><span class="line">    getEndpointDependencies(endpointId: ID!, duration: Duration!): EndpointTopology</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到其中就有 <code>getGlobalTopology</code>，再看看我们之前的抓包，我能看下第二行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">query queryTopo($duration: Duration!) &#123;</span><br><span class="line">  topo: getGlobalTopology(duration: $duration) &#123;</span><br><span class="line">    nodes &#123;</span><br><span class="line">      id</span><br><span class="line">      name</span><br><span class="line">      type</span><br><span class="line">      isReal</span><br><span class="line">    &#125;</span><br><span class="line">    calls &#123;</span><br><span class="line">      id</span><br><span class="line">      source</span><br><span class="line">      detectPoints</span><br><span class="line">      target</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二行内容 <code>topo: getGlobalTopology(duration: $duration) {</code></p><ul><li>topo 是查询结果的别名，查询到 response 会放到 topo 字段下</li><li>getGlobalTopology 的定义就是 <code>getGlobalTopology(duration: Duration!): Topology</code></li></ul><p>其中 <code>Duration</code> 定义，我们在 <a href="https://github.com/apache/skywalking-query-protocol/blob/master/common.graphqls" target="_blank" rel="noopener">https://github.com/apache/skywalking-query-protocol/blob/master/common.graphqls</a> 得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">input Duration &#123;</span><br><span class="line">    start: String!</span><br><span class="line">    end: String!</span><br><span class="line">    step: Step!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就像套娃一样，你也可以找到 <code>Step</code> 的定义</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文聊了我们如何找到自定义 UI 的切入点，同时就如何参考官方的一些开发细节进行了阐述。希望能给大家自定义数据展示平台一些参考。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2020/11/28/build-your-own-ui-for-skywalking/logo.jpeg&quot; width=&quot;500&quot; height=&quot;400&quot;&gt;
&lt;blockquote&gt;&lt;p&gt;SkyWalking: an APM(application pe
      
    
    </summary>
    
      <category term="云原生" scheme="https://rovast.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://rovast.github.io/2020/11/28/hello-world/"/>
    <id>https://rovast.github.io/2020/11/28/hello-world/</id>
    <published>2020-11-28T08:49:18.064Z</published>
    <updated>2020-11-28T08:49:18.064Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Install php7.2 on Ubuntu 18.04 LTS</title>
    <link href="https://rovast.github.io/2019/12/02/install-php72-ubuntu/"/>
    <id>https://rovast.github.io/2019/12/02/install-php72-ubuntu/</id>
    <published>2019-12-02T01:54:24.000Z</published>
    <updated>2020-11-28T08:49:18.065Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 php7.2</span></span><br><span class="line">sudo apt-get install php7.2 php7.2-fpm \</span><br><span class="line">php7.2-mysql php7.2-curl php7.2-mbstring php7.2-gd php7.2-xml php7.2-soap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 mcrypt</span></span><br><span class="line">sudo apt install php-dev libmcrypt-dev php-pear</span><br><span class="line">sudo pecl channel-update pecl.php.net</span><br><span class="line">sudo pecl install mcrypt-1.0.1</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/php/7.2/cli/php.ini</span><br><span class="line">sudo vi /etc/php/7.2/fpm/php.ini</span><br><span class="line"><span class="comment"># 最后加上 `extension=mcrypt.so`</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/php/7.2/fpm/pool.d/www.conf</span><br><span class="line"><span class="comment"># 修改 listen 为 127.0.0.1:9000</span></span><br></pre></td></tr></table></figure><h1 id="测试-nginx-是否可用"><a href="#测试-nginx-是否可用" class="headerlink" title="测试 nginx 是否可用"></a>测试 nginx 是否可用</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -c /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="杂项" scheme="https://rovast.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="Linux" scheme="https://rovast.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>docker 安装</title>
    <link href="https://rovast.github.io/2019/11/28/install-docker/"/>
    <id>https://rovast.github.io/2019/11/28/install-docker/</id>
    <published>2019-11-28T09:06:18.000Z</published>
    <updated>2020-11-28T08:49:18.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 安装 docker</span><br><span class="line">curl -sSL https://get.daocloud.io/docker | sh</span><br><span class="line"></span><br><span class="line">// 注意更改所属用户组</span><br><span class="line">sudo usermod -aG docker YOUR_GROUP</span><br></pre></td></tr></table></figure><p>注销用户后重新登录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 启动　docker</span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 安装 docker-compose</span><br><span class="line">sudo pip install -U docker-compose</span><br><span class="line"></span><br><span class="line">// 如果没有 pip</span><br><span class="line">sudo apt-get install python-pi</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c
      
    
    </summary>
    
      <category term="杂项" scheme="https://rovast.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="docker" scheme="https://rovast.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>时间复杂度</title>
    <link href="https://rovast.github.io/2019/11/06/time-complexity/"/>
    <id>https://rovast.github.io/2019/11/06/time-complexity/</id>
    <published>2019-11-06T01:35:45.000Z</published>
    <updated>2020-11-28T08:49:18.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>技术人员的内功修炼：操作系统、计算机网络、编译原理、数据结构与算法。</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度分下面几个维度：</p><ul><li>最好时间复杂度（Best Case Time Complexity）</li><li>最坏时间复杂度（Worst Case Time Complexity）</li><li>平均时间复杂度（Average Case Time Complexity）</li><li>均摊时间复杂度（Amortized Time Complexity）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;技术人员的内功修炼：操作系统、计算机网络、编译原理、数据结构与算法。&lt;/p&gt;
&lt;h2 id=&quot;时间复杂度&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="基础" scheme="https://rovast.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="数据结构与算法" scheme="https://rovast.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>使用 www-data 用户运行定时任务（cron）</title>
    <link href="https://rovast.github.io/2019/11/04/run-cron-with-www-data/"/>
    <id>https://rovast.github.io/2019/11/04/run-cron-with-www-data/</id>
    <published>2019-11-04T07:03:07.000Z</published>
    <updated>2020-11-28T08:49:18.081Z</updated>
    
    <content type="html"><![CDATA[<p>其实这个没啥好说的，就是记录下解决的过程（说得好像跟一篇水文似的…）。或者给遇到这类问题的小伙伴提供个思路。</p><h2 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h2><p>我们在部署 web 服务时，经常用到定时任务。正常的流程就是直接执行下面的指令来配置定时任务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure><p>问题来了，正常情况下，这个指令在哪个用户下面执行，这个权限就是谁的（如果你听不懂我在说啥，那基本就是属于 root的）。</p><blockquote><p>定时任务本身的配置也是个精细活，你可以阅读下 <a href="https://learnku.com/articles/25177" target="_blank" rel="noopener">https://learnku.com/articles/25177</a> 看看你之前用的姿势是不是还能优化。</p></blockquote><p><strong>常见问题之日志权限</strong></p><p>这怕是最常见的问题了。定时任务出错了，记录日志到 <code>storage/logs</code> 里了，一般就是 <code>laravel.log</code> 文件。</p><p>此时 <code>laravel.log</code> 所属者就是 root 了。</p><p>用户通过浏览器访问我们网站，如果出错，以 www-data 身份尝试记录到 <code>storage/logs/laravel.log</code>，然后<strong>写不进去</strong>，一直报错，真香！</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>打开谷歌搜索 <code>run cron job as www-data</code>。找到了文章 <a href="https://askubuntu.com/questions/189189/how-to-run-crontab-as-userwww-data" target="_blank" rel="noopener">https://askubuntu.com/questions/189189/how-to-run-crontab-as-userwww-data</a></p><p>谷歌真香！</p><p>具体的意思，就是直接在 <code>/etc/crontab</code> 中编辑定时任务即可，加上用户名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/crontab: system-wide crontab</span></span><br><span class="line"><span class="comment"># Unlike any other crontab you don't have to run the `crontab'</span></span><br><span class="line"><span class="comment"># command to install the new version when you edit this file</span></span><br><span class="line"><span class="comment"># and files in /etc/cron.d. These files also have username fields,</span></span><br><span class="line"><span class="comment"># that none of the other crontabs do.</span></span><br><span class="line"></span><br><span class="line">SHELL=/bin/sh</span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example of job definition:</span></span><br><span class="line"><span class="comment"># .---------------- minute (0 - 59)</span></span><br><span class="line"><span class="comment"># |  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="comment"># |  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="comment"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="comment"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="comment"># |  |  |  |  |</span></span><br><span class="line"><span class="comment"># *  *  *  *  * user-name command to be executed</span></span><br><span class="line">17 *    * * *   root    <span class="built_in">cd</span> / &amp;&amp; run-parts --report /etc/cron.hourly</span><br><span class="line">25 6    * * *   root    <span class="built_in">test</span> -x /usr/sbin/anacron || ( <span class="built_in">cd</span> / &amp;&amp; run-parts --report /etc/cron.daily )</span><br><span class="line">47 6    * * 7   root    <span class="built_in">test</span> -x /usr/sbin/anacron || ( <span class="built_in">cd</span> / &amp;&amp; run-parts --report /etc/cron.weekly )</span><br><span class="line">52 6    1 * *   root    <span class="built_in">test</span> -x /usr/sbin/anacron || ( <span class="built_in">cd</span> / &amp;&amp; run-parts --report /etc/cron.monthly )</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># cron</span></span><br><span class="line">* * * * *  www-data flock /tmp/flock1.lock -c <span class="string">'timeout 200 /usr/local/bin/php /var/www/html/laravel/artisan command &gt;&gt; /home/log/laravel.log 2&gt;&amp;1'</span></span><br></pre></td></tr></table></figure><p>啰嗦下：</p><ul><li>flock 用来防止重复执行，起到原子锁作用</li><li>timeout 表示这个脚本执行过长，咱就干死它，可以有效避免各种循环或长时间占用问题</li><li><code>&gt;&gt;</code> 表示向文件中追加内容</li><li><code>2&gt;&amp;1</code> 表示将标准错误输出重定向到正确输出（这样你万一有程序出错，也能记录下）</li></ul><h2 id="真香后传（更新于-2019年11月06日19-38-27）"><a href="#真香后传（更新于-2019年11月06日19-38-27）" class="headerlink" title="真香后传（更新于 2019年11月06日19:38:27）"></a>真香后传（更新于 2019年11月06日19:38:27）</h2><p>如果你按照上述的进行，你会发现还是执行不了定时任务。因为 <code>www-data</code> 默认是不能执行 bash 相关操作的。</p><p>使用真香的谷歌搜索 <code>www-data run cron error</code>，我们发现了宝藏  <a href="https://ubuntuforums.org/showthread.php?t=2334330" target="_blank" rel="noopener">https://ubuntuforums.org/showthread.php?t=2334330</a></p><blockquote><p>The www-data user is not able to invoke a shell by default. In /etc/passwd you’ll see<br>  Code:<br>  www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin<br>  If you want to be able to run scripts as that user, you’ll need to change “/usr/sbin/nologin” to “/bin/bash”.</p></blockquote><p>好了，咱们把 <code>/etc/passwd</code> 里面 <code>www-data</code> 对应的那一行改下就可以了。</p><p><strong>另外</strong></p><p>其实你还可以用 <code>crontab -u www-data CRON_FILE</code> 来指定用户运行指定的定时任务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;其实这个没啥好说的，就是记录下解决的过程（说得好像跟一篇水文似的…）。或者给遇到这类问题的小伙伴提供个思路。&lt;/p&gt;
&lt;h2 id=&quot;痛点&quot;&gt;&lt;a href=&quot;#痛点&quot; class=&quot;headerlink&quot; title=&quot;痛点&quot;&gt;&lt;/a&gt;痛点&lt;/h2&gt;&lt;p&gt;我们在部署 we
      
    
    </summary>
    
      <category term="Linux" scheme="https://rovast.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rovast.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>macos 莫名失去焦点</title>
    <link href="https://rovast.github.io/2019/10/15/macos-lost-focus/"/>
    <id>https://rovast.github.io/2019/10/15/macos-lost-focus/</id>
    <published>2019-10-15T15:05:22.000Z</published>
    <updated>2020-11-28T08:49:18.067Z</updated>
    
    <content type="html"><![CDATA[<p>执行下述 python 代码，观测除了当前应用程序外，还有谁占用了焦点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> AppKit <span class="keyword">import</span> NSWorkspace</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">t = range(<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> t:</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    activeAppName = NSWorkspace.sharedWorkspace().activeApplication()[<span class="string">'NSApplicationName'</span>]</span><br><span class="line">    <span class="keyword">print</span> activeAppName</span><br></pre></td></tr></table></figure><p>查看输出即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;执行下述 python 代码，观测除了当前应用程序外，还有谁占用了焦点&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;b
      
    
    </summary>
    
    
  </entry>
  
</feed>
